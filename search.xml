<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>「数据结构与算法」B 树 与 B+ 树</title>
      <link href="/2022/08/15/data-structure-b-tree.html"/>
      <url>/2022/08/15/data-structure-b-tree.html</url>
      
        <content type="html"><![CDATA[<p>一般情况，我们可以把整个数据结构存储到计算机的主存中；可如果数据更多装不下主存，那么意味着必须把数据结构放到磁盘上。<br>此时“大<code>O</code>模型”不再适用，因为大<code>O</code>分析假设所有操作耗时都是相同的，所以涉及到<strong>磁盘I&#x2F;O</strong>就不再适用了。与内存相比，磁盘必须花成倍的时间来存取一个数据元素，这是因为磁盘的机械部件读写数据的速度远远赶不上纯电子媒体的内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【CPU】 &lt;---&gt; 【内存】 &lt;--I/O--&gt; 【磁盘】</span><br></pre></td></tr></table></figure><p>当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的节点。造成大量磁盘<code>I/O</code>操作（最坏情况下为树的高度）。<br>平衡二叉树由于树深度过大而造成磁盘I&#x2F;O读写过于频繁，进而导致效率低下。<br>为了减少磁盘<code>I/O</code>操作的次数，就你必须降低树的深度，将“瘦高”的树变得“矮胖”。<br>所以，就引入了<code>B 树</code>。<code>B 树</code>利用多个分支（称为子树）的节点，减少获取记录时所经历的节点数，从而达到节省存取时间的目的。</p><span id="more"></span><h3 id="1-B-树（B-Tree）"><a href="#1-B-树（B-Tree）" class="headerlink" title="1. B 树（B Tree）"></a>1. B 树（B Tree）</h3><p><code>B 树</code>（B-Tree），是一种<strong>平衡的多路查找树</strong>，主要面向于动态查找，常用于文件系统中。<br><code>B 树</code>中，节点的子树最大数目称为 <strong>B 树的阶</strong>。</p><ul><li>一颗<strong>m 阶</strong><code>B 树</code>（m叉树）或为空树，或满足：<ul><li>叶子节点都出现在同一层，且不带信息。</li><li>树中每个节点最多有<code>m</code>棵子树。</li><li>叶子节点的父节点称为<strong>终端节点</strong>，若根节点不是终端节点，则至少有两棵子树。</li><li>除根节点外的所有非终端节点至少有<code>m/2</code>棵子树。</li><li>非终端节点都包括数据：<code>&#123;n,A0, K1,A1, K2,A2..., Kn,An&#125;</code>，其中<code>n</code>为关键字个数(取值范围是<code>[(m/2)-1,m-1]</code>,向上取整)，<code>Ki</code>为关键字，<code>Ai</code>为指向子树根节点的指针，且指针<code>Ai</code>所指子树中所有节点的关键字均大于<code>Ki</code>且小于 <code>K&#123;i+1&#125;</code>（即关键字有序）。</li></ul></li></ul><p>节点的结构：<br><img src="/2022/08/15/data-structure-b-tree/04_01.png"></p><p>一般情况下，<code>B 树</code>的叶子节点可以看做外部节点，即查找失败的点，实际上这些节点并不存在，指向这些节点的指针都为<code>NULL</code>；<br><code>B 树</code>是树高平衡的，此外，<code>B 树</code>中每个节点中关键字的个数为<code>子树个数-1</code>。</p><h4 id="1-1-构建-B-树（插入）"><a href="#1-1-构建-B-树（插入）" class="headerlink" title="1.1 构建 B 树（插入）"></a>1.1 构建 B 树（插入）</h4><p><code>B 树</code>也是从空树开始，但是在插入新的关键字时并不是每次都向树中插入新的节点。</p><ul><li>对于<code>m</code>阶的<code>B 树</code>来说，节点中包含关键字的个数<code>n</code>的范围是<code>[(m/2)-1,m-1]</code>，在插入新的关键字时，首先向最底层的某个终端节点中添加:<ul><li>若节点中关键字个数<code>n</code>小于<code>m-1</code>，则直接插入成功；</li><li>若节点中关键字个数<code>n</code>等于<code>m-1</code>，插入后<code>n&gt;m-1</code>引起节点分裂；以该节点中间关键字为分界，取中间关键字（偶数个数，中间两个随机选取）插入到父节点中；</li><li>重复上面动作，直到所有节点符合B 树的规则<code>[(m/2)-1,m-1]</code>；最坏的情况一直分裂到根节点，生成新的根节点，高度增加<code>1</code>；</li></ul></li></ul><p>如图，有一颗<code>3</code>阶 <code>B 树</code>（深度为<code>4</code>）：<br><img src="/2022/08/15/data-structure-b-tree/04_02.png"><br>分别插入关键字 <code>30</code>、<code>26</code>、<code>85</code>、<code>7</code>。<br>（<code>3</code>阶 <code>B 树</code>节点中关键字个数<code>n</code>的范围是<code>[(m/2)-1,m-1]</code>向上取整，即<code>[1,2]</code>，插入后<code>n&gt;2</code>就分裂）。</p><ul><li>插入关键字<code>30</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_04.gif"></li></ul><p>插入关键字<code>30</code>的过程：【45】–&gt;【24】–&gt;【37】直接插入变成【30,37】</p><ul><li>插入关键字<code>26</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_05.gif"></li></ul><p>插入关键字<code>26</code>的过程：【45】–&gt;【24】–&gt;【30,37】；<br><code>26</code>插入【30,37】节点后变成【26,30,37】其关键字个数<code>n&gt;2</code>分裂：①<code>37</code>存储到新的节点【37】，②<code>30</code>存储到父节点变成【24,30】，同时<code>30</code>的右侧的指针指向新节点【37】。</p><ul><li>插入关键字<code>85</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_06.gif"></li></ul><p>插入关键字<code>85</code>的过程：【45】–&gt;【53,90】–&gt;【61,70】；<br><code>85</code>插入【61,70】节点后变成【61,70,85】其关键字个数<code>n&gt;2</code>分裂：①<code>85</code>存储到新的节点【85】，②<code>70</code>存储到父节点变成【53,70,90】，同时<code>70</code>的右侧的指针指向新节点【85】。<br>节点【53,70,90】分裂：①<code>90</code>存储到新的节点【90】，②<code>70</code>存储到父节点变成【45,70】，同时<code>70</code>的右侧的指针指向新节点【90】。</p><ul><li>插入关键字<code>7</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_07.gif"></li></ul><p>插入关键字<code>7</code>的过程：【45,70】–&gt;【24,30】–&gt;【3,12】该节点关键字为<code>2</code>等于<code>m-1</code>；<br><code>7</code>插入【3,12】节点后变成【3,7,12】其关键字个数<code>n&gt;2</code>分裂：①<code>12</code>存储到新的节点【12】，②<code>7</code>存储到父节点变成【7,24,30】，同时<code>7</code>的右侧的指针指向新节点【12】。<br>节点【7,24,30】分裂：①<code>30</code>存储到新的节点【30】，②<code>24</code>存储到根节点变成【24,45,70】，同时<code>24</code>的右侧的指针指向新节点【30】。<br>根节点【24,45,70】分裂：①<code>70</code>存储到新的节点【70】，②【45】变成新的根节点，同时【45】的右侧的指针指向新节点【70】；【45】的左侧的指针指向【24】。</p><h4 id="1-2-B-树的删除"><a href="#1-2-B-树的删除" class="headerlink" title="1.2 B 树的删除"></a>1.2 B 树的删除</h4><p>在<code>B 树</code>中删除关键字时，首先找到该关键字所在节点，然后在节点中对关键字进行删除；首先判断该关键字是否有子节点，如果没有，直接删除；如果有，删除后则上移子节点中的某相近关键字(“左子节点最右关键字”或“右子节点最左关键字”)到此节点中。<br>然后是移动之后的情况：</p><ul><li>某节点中关键字个数<code>n</code>小于<code>m/2-1</code>（向上取整），则需要看其左右相邻兄弟节点是否丰满：<ul><li>①如果有一个丰满（节点中关键字个数<code>n</code>大于<code>m/2-1</code>），则向父节点借一个关键字来满足条件，上移该丰满节点最后或最前一个关键字到父节点中；</li><li>②如果其相邻兄弟都不丰满，则该节点与其相邻的某一兄弟节点进行“合并”成一个节点；</li></ul></li></ul><p>如图，有一颗<code>5</code>阶 <code>B 树</code>（深度为<code>4</code>）：<br><img src="/2022/08/15/data-structure-b-tree/04_03.png"></p><p>依次删除依次删除<code>8</code>、<code>20</code>、<code>18</code>、<code>5</code>。<br>（<code>5</code>阶 <code>B 树</code>节点中关键字个数<code>n</code>的范围是<code>[(m/2)-1,m-1]</code>向上取整，即<code>[2,4]</code>，关键要领：关键字个数小于<code>2</code>就合并，大于<code>4</code>就分裂）。</p><ul><li>删除关键字<code>8</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_08.gif"></li></ul><p>删除<code>8</code>，首先查找<code>8</code>，<code>8</code>在一个终端节点【8,11,12】中，删除后该节点关键字个数<code>n=2</code>，符合<code>B 树</code>规则<code>[2,4]</code>，操作很简单，节点中删除关键字后面的关键字向前移动，也就是只需要移动<code>11</code>至原来<code>8</code>的位置，移动<code>12</code>至<code>11</code>的位置。</p><ul><li>删除关键字<code>20</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_09.gif"></li></ul><p>删除<code>20</code>,因为<code>20</code>在节点【17，20】中不是终端节点，上移其孩子节点中的某相近关键字(<code>19</code>或<code>23</code>)，若上移<code>19</code>该子节点关键字个数<code>n&lt;2</code>则还需额外操作，所以<code>23</code>上移到<code>20</code>的位置，该子节点关键字个数为<code>3</code>，无需进行合并操作。</p><ul><li>删除关键字<code>18</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_10.gif"></li></ul><p>删除<code>18</code>，<code>18</code>在一个终端节点【18,19】中，但是该节点中关键字个数<code>n=2</code>，删除后就小于<code>2</code>，没达标，而相邻右兄弟节点比较丰满，则先向父节点借一个关键字<code>23</code>下移到该删除节点中，代替原来<code>19</code>的位置，<code>19</code>前移；然后将丰满兄弟节点的<code>24</code>上移到父节点中。</p><ul><li>删除关键字<code>5</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_11.gif"></li></ul><p>删除<code>5</code>，<code>5</code>在一个终端节点中且关键字个数<code>n=2</code>，删除后就小于<code>2</code>，没达标，而相邻右兄弟节点都不丰满，所以需要该节点与某相邻兄弟节点进行<strong>合并操作</strong>：子节点【1,3】【6】，父节点【4,7】；首先将父节点的关键字<code>4</code>下移到删除的节点中变成【4,6】,然后合并【1,3】与【4,6】变成一个节点【1,3,4,6】。<br>此时，你会发现父节点只包含一个关键字<code>7</code>，<code>n=1</code>没达标<code>[2,4]</code>，而相邻右兄弟节点都不丰满，只能进行合并，而根节点中的唯一关键字<code>13</code>下移到子节点，这样，<strong>树的高度减少一层</strong>，根节点变成【7,13,17,24】。</p><h3 id="2-磁盘I-x2F-O-与-预读"><a href="#2-磁盘I-x2F-O-与-预读" class="headerlink" title="2. 磁盘I&#x2F;O 与 预读"></a>2. 磁盘I&#x2F;O 与 预读</h3><p>计算机存储设备一般分为：<strong>内存储器</strong>(main memory)和<strong>外存储器</strong>(external memory)。 </p><ul><li>内存储器为<strong>内存</strong>，内存存取速度快，但容量小，价格昂贵，且数据不能长期保存(数据断电就没了)。</li><li>外存储器为<strong>磁盘读取</strong>，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<strong>寻道时间</strong>、<strong>旋转延迟</strong>、<strong>传输时间</strong>三个部分：<ul><li>寻道时间指磁臂移动到指定磁道所需要的时间，主流磁盘一般在<code>5ms</code>以下；</li><li>旋转延迟指的是磁盘转速，比如一个磁盘<code>7200</code>转，表示每分钟能转<code>7200</code>次，也就是说<code>1</code>秒钟能转<code>120</code>次，旋转延迟就是<code>1/120/2 = 4.17ms</code>；</li><li>传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</li></ul></li></ul><p>那么粗略计算一次磁盘I&#x2F;O的时间约<code>5+4.17 = 9ms</code>左右，但要知道一台<code>500-MIPS</code>的机器每秒可以执行<code>5亿</code>条指令，因为指令依靠的是电的性质，换句话说执行一次I&#x2F;O的时间可以执行<code>40万</code>条指令，数据库动辄十万百万乃至千万级数据，每次<code>9</code>毫秒的时间，显然是个灾难。</p><p>由于磁盘IO的高耗时操作，计算机系统做了很多优化，当一次磁盘I&#x2F;O时，不仅会读取当前磁盘地址的数据，还会把相邻的数据也一起读到内存中，因为一般情况下，其相邻的数据很快也会被访问到，这就是局部预读性原理。<br>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，<strong>预读可以提高I&#x2F;O效率</strong>。<br>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为<code>4k</code>或<code>8k</code>），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>内存(<code>ns</code>级别) &lt;&lt; 磁盘(<code>ms</code>级别)，相差<code>100000</code>倍；为了避免1次外存访问，宁愿访问内存100+次，所以将最常用的数据存储在最快的存储器中。</p><p>索引查询的数据主要受限于磁盘的I&#x2F;O速度，查询I&#x2F;O次数越少，速度越快，所以<code>B 树</code>的结构才应需求而生；<code>B 树</code>的每个节点的关键字可以视为一次I&#x2F;O读取，树的高度表示最多的I&#x2F;O次数，在相同数量的总关键字个数下，每个节点的关键字个数越多，高度越低，查询所需的I&#x2F;O次数越少；<br>假设，一次磁盘一次I&#x2F;O数据为8K，索引用int(4字节)类型数据建立，理论上一个节点最多可以为2000个关键字，2000<em>2000</em>2000&#x3D;8000000000，80亿条的数据只需3次I&#x2F;O（理论值），可想而知，<code>B 树</code>做为索引的查询效率有多高；</p><h3 id="3-B-树（B-Tree）"><a href="#3-B-树（B-Tree）" class="headerlink" title="3. B+ 树（B+ Tree）"></a>3. B+ 树（B+ Tree）</h3><p><code>B+ 树</code>是应文件系统所需而产生的<code>B 树</code>的变形树，严格意义上来讲，其已经不是一棵树了。<br>由于 <code>B+ 树</code>的非叶节点不含有实际数据，因此磁盘页中可以容纳更多节点关键字，也就是说同样数据情况下，<code>B+ 树</code>会 <code>B 树</code>更加“矮胖”，因此查询效率更快，磁盘读写代价更低。<br><code>B+ 树</code>的叶子节点包含了全部的数据，任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；所以查询效率是稳定的。<br><code>B 树</code>在提高了I&#x2F;O性能的同时并没有解决关键字遍历效率低下的问题，范围查找时<code>B 树</code>只能挨个中序遍历比较大小。由于 <code>B+ 树</code>的叶子节点是一个有序链表，只需在叶子节点上遍历即可。</p><p>各种资料上<code>B+ 树</code>的定义各有不同，一种定义是关键字个数与子树个数相同。这里我们采取维基百科上所定义的方式，即关键字个数比子树个数小<code>1</code>，即对于<code>m</code>阶的<code>B+ 树</code>来说，最多有<code>m-1</code>个关键字，最多<code>m</code>个子树。<br>除此之外<code>B+ 树</code>还有以下要求：<strong>非叶子节点不存数据仅用作索引</strong>，非叶子节点的关键字都在它的下一级子树中同样存在，最后<strong>所有数据都存储在叶子节点中</strong>，每个叶子节点都<strong>存有相邻叶子节点的指针</strong>，叶子节点本身依关键字的大小自小而大顺序链接。根节点的关键字个数最少可以只有<code>1</code>个。</p><p><img src="/2022/08/15/data-structure-b-tree/04_12.png"></p><ul><li><code>B+ 树</code>的特性：<ul><li>所有关键字都出现在叶子节点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子节点命中；</li><li>非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ul></li></ul><h4 id="3-1-构建-B-树（插入）"><a href="#3-1-构建-B-树（插入）" class="headerlink" title="3.1 构建 B+ 树（插入）"></a>3.1 构建 B+ 树（插入）</h4><p><code>B+ 树</code>的插入操作全部都在<strong>叶子节点</strong>上进行，且不能破坏关键字自小而大的顺序；</p><ul><li>对于<code>m</code>阶的<code>B+ 树</code>来说，根据维基百科上的定义节点中包含关键字的个数<code>n</code>的范围是<code>[(m/2)-1,m-1]</code>（根节点的关键字个数最少可以只有<code>1</code>个），在插入新的关键字时：<ul><li>若节点中关键字个数<code>n</code>小于<code>m-1</code>，则直接插入成功；</li><li>若节点中关键字个数<code>n</code>等于<code>m-1</code>，插入后<code>n&gt;m-1</code>引起节点分裂；以该节点中间关键字为分界，取中间关键字（偶数个数，中间两个随机选取）上移至父节点中；</li><li>重复上面动作，直到所有节点符合<code>B+ 树</code>关键字个数的规则；</li></ul></li></ul><p>如图，构建一颗<code>3</code>阶 <code>B+ 树</code>：<code>10</code>、<code>56</code>、<code>90</code>、<code>5</code>、<code>20</code>、<code>80</code>。</p><p><img src="/2022/08/15/data-structure-b-tree/04_13.gif"></p><ul><li>插入<code>10</code>、<code>56</code>，直接插入成功节点变成【10,56】；</li><li>插入<code>90</code>:<br><img src="/2022/08/15/data-structure-b-tree/04_14.gif"></li></ul><p><code>90</code>插入后节点后变成【10,56,90】其关键字个数<code>n&gt;2</code>分裂成【10】【56,90】，<code>56</code>上移至父节点中变成【56】，同时<code>56</code>的左指针指向【10】，<code>56</code>的右指针指向【56,90】；</p><ul><li>插入<code>5</code>，找到节点【10】，直接插入变成【5,10】；</li><li>插入<code>20</code>:<br><img src="/2022/08/15/data-structure-b-tree/04_15.gif"></li></ul><p>插入<code>20</code>，找到节点【5,10】，插入后变成【5,10,20】分裂成【5】【10,20】，<code>10</code>上移至父节点中变成【10,56】，同时<code>10</code>的左指针指向【5】，<code>10</code>的右指针指向【10,20】；</p><ul><li>插入<code>80</code>:<br><img src="/2022/08/15/data-structure-b-tree/04_16.gif"></li></ul><p>插入<code>80</code>，找到节点【56,90】，插入后变成【56,80,90】分裂成【56】【80,90】，<code>80</code>上移至父节点中变成【10,56,80】，同时<code>80</code>的左指针指向【56】，<code>80</code>的右指针指向【80,90】；此时节点【10,56,80】继续分裂成【10】【80】，<code>56</code>上移至父节点中变成【56】，同时<code>56</code>的左指针指向【10】，<code>56</code>的右指针指向【80】；</p><h4 id="3-2-B-树的删除"><a href="#3-2-B-树的删除" class="headerlink" title="3.2 B+ 树的删除"></a>3.2 B+ 树的删除</h4><p><code>B+ 树</code>的删除操作也仅在<strong>叶子节点</strong>上进行；<br>删除时，如果不破坏<code>B+ 树</code>本身的性质，直接完成操作；<br>删除时还要注意有时需要更改其父节点中的索引值；<br>在删除关键字后，如果导致其节点中关键字个数不足，有两种方法：一种是向兄弟节点去借，另外一种是同兄弟节点合并（与<code>B 树</code>类似）。</p><p>如图，有一颗<code>5</code>阶 <code>B+ 树</code>：<br><img src="/2022/08/15/data-structure-b-tree/04_17.png"></p><ul><li>删除<code>53</code>:<br><img src="/2022/08/15/data-structure-b-tree/04_18.gif"></li></ul><p>删除<code>53</code>后，节点【50】关键字不足，向兄弟节点借一个最相近的<code>68</code>后变成【50,68】，兄弟节点变成【69,70,71】，父节点索引由原来的<code>68</code>变成<code>69</code>；</p><ul><li>删除<code>69</code>:<br><img src="/2022/08/15/data-structure-b-tree/04_19.gif"></li></ul><p>删除<code>69</code>后，节点【70,71】不破坏<code>B+ 树</code>本身的性质，只需更改父节点索引为<code>70</code>即可；</p><ul><li>删除<code>70</code>:<br><img src="/2022/08/15/data-structure-b-tree/04_20.gif"></li></ul><p>删除<code>70</code>后，节点【71】关键字不足，兄弟节点也不丰满，与兄弟节点合并为【50,68,71】，合并后只有一个叶子节点，树的高度减一；</p><h3 id="4-B-树（B-Tree）"><a href="#4-B-树（B-Tree）" class="headerlink" title="4. B* 树（B* Tree）"></a>4. B* 树（B* Tree）</h3><p><code>B* 树</code>是<code>B+ 树</code>的变形树，其也非严格意义上的树。<br><code>B* 树</code>在<code>B+ 树</code>的基础上进行了改进，<strong>在<code>B+ 树</code>的非根和非叶子节点上行增加了指向兄弟的指针</strong>，且规定<code>m</code>阶树非叶节点关键字个数至少为<code>(2/3)m</code>，即块的最低使用率为<code>2/3</code>，可以看出，<code>B* 树</code>空间利用率更高。</p><h3 id="5-InnoDB-存储引擎"><a href="#5-InnoDB-存储引擎" class="headerlink" title="5. InnoDB 存储引擎"></a>5. InnoDB 存储引擎</h3><p><code>InnoDB</code>是<code>MySQL</code>的默认事务引擎，也是目前最重要、使用最广泛的存储引擎。</p><ul><li>在<code>InnoDB</code>中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。</li><li><code>InnoDB</code>使用了<code>B+树</code>索引模型，所以数据都是存储在<code>B+树</code>中的。</li><li>每一个索引在<code>InnoDB</code>里面对应一棵<code>B+树</code>，每一张表其实就是多个 <code>B+树</code>，即一个主键索引树和多个非主键索引树。<ul><li>主键索引的叶子节点存的是整行数据。主键索引也被称为聚簇索引（clustered index）。</li><li>非主键索引的叶子节点内容是主键索引的引用。非主键索引也被称为二级索引（secondary index）。</li></ul></li></ul><p>执行查询的效率，使用主键索引 &gt; 使用非主键索引 &gt; 不使用索引（从主索引 <code>B+树</code>的叶子节点进行遍历）。<br>使用非主键索引查询会触发回表，因为非主键索引只存储主键索引的引用，我们需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><blockquote><p>参考资料：<br><a href="https://www.cs.helsinki.fi/u/mluukkai/tirak2010/B-tree.pdf">B+ 树 外文文档</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」常见算法思想</title>
      <link href="/2022/07/25/data-structure-algorithm-method.html"/>
      <url>/2022/07/25/data-structure-algorithm-method.html</url>
      
        <content type="html"><![CDATA[<p>数据结构可以看作是算法实现的容器，通过一系列特殊结构的数据集合，能够将算法更为高效而可靠的执行起来。<br>算法（Algorithm）是为了解决一个特定的问题而精心设计的一套数学模型以及在这套数学模型上的一系列操作步骤，这些操作步骤是将描述的输入数据逐步处理、转换，并最后得到一个确定的结果。<br>一般来说，算法设计没有什么固定的方法可循。但是通过大量的实践，也总结出算法某些共性的规律，包括枚举(Enumeration)、递归(Recursion)、分支法(Divide and Conquer)、贪心法(Greedy)、回溯法(Backtracking)、动态规划法(Dynamic Programming)等。</p><span id="more"></span><h3 id="1-枚举"><a href="#1-枚举" class="headerlink" title="1. 枚举"></a>1. 枚举</h3><p>枚举（Enumeration）又称暴力枚举，顾名思义，就是穷尽列举。基本思想是：按问题本身的性质，一一列举出该问题所有可能的解，并在逐一列举的过程中，检验每个可能的解是否真正的解，若是，就采纳，否则就放弃。</p><ul><li>枚举思想的本质就是从所有候选答案中去搜索正确的解，使用枚举需要满足两个条件：<ol><li>可预先确定候选答案的数量；</li><li>候选答案的范围在求解之前必须有一个确定的集合。</li></ol></li></ul><p>枚举简单粗暴，因为暴力的枚举所有可能，尽可能地尝试所有的方法；因此<strong>比较直观，易于理解</strong>，得到的结果总是正确的。<br>枚举的效率取决于枚举状态的数量以及单个状态枚举的代价，因此<strong>效率比较低</strong>。</p><h3 id="2-递归"><a href="#2-递归" class="headerlink" title="2. 递归"></a>2. 递归</h3><p>程序调用自身的编程技巧称为<strong>递归（Recursion）</strong>。递归思想往往用函数的形式来体现，所以需要预先编写功能函数。这些函数是独立的功能，能够实现解决某个问题的具体功能，当需要时直接调用这个函数即可。<br>「递归」，先有「递」再有「归」。<br>「递」的意思是将问题拆解成子问题来解决，子问题再拆解成子子问题，…，直到无法被拆解（找到终止条件，即可以求解）；<br>「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了。</p><ul><li>实际上，递归有两个显著的特征：<strong>自身调用</strong>和<strong>终止条件</strong>；<ul><li>自身调用：原问题可以分解为子问题，子问题和原问题的求解方法是一致的，即都是调用自身的同一个函数。</li><li>终止条件：递归必须有一个终止的条件，即不能无限循环地调用本身。</li></ul></li></ul><p>编写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><ul><li>例如递归实现 斐波那契数列数列(1、1、2、3、5、8、13、21、34、…)<ul><li>递推公式：<code>f(n)=f(n-1)+f(n-2)</code>；</li><li>终止条件：当n&#x3D;1或者n&#x3D;2时，<code>f(1)=f(2)=1</code>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;= <span class="number">2</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n-<span class="number">1</span>) + fibonacci(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归代码虽然表达力很强，写起来非常简洁，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等。<ol><li>堆栈溢出：函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</li><li>重复计算：比如想要计算<code>f(5)</code>，需要先计算<code>f(4)</code>和<code>f(3)</code>，而计算<code>f(4)</code>还需要计算<code>f(3)</code>，因此<code>f(3)</code>就被重复计算了多次。为了避免重复计算，可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。</li><li>函数调用耗时多：递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</li><li>空间复杂度高：因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</li></ol></li></ul><p>所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p><h3 id="3-分治算法"><a href="#3-分治算法" class="headerlink" title="3. 分治算法"></a>3. 分治算法</h3><p><strong>分治算法</strong>（Divide and Conquer）的核心思想其实就是四个字，<strong>分而治之</strong> ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。<br><strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。实际上，分治算法一般都比较适合用递归来实现。</p><ul><li>分治算法的递归实现中，每一层递归都会涉及这样三个操作：<ol><li><strong>分解</strong>：将原问题分解成一系列子问题；</li><li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li><strong>合并</strong>：将子问题的结果合并成原问题。</li></ol></li><li>分治算法的典型的应用场景：<ol><li>用来指导编码，降低问题求解的时间复杂度。</li><li>应用在海量数据处理的场景中。<br>比如 大规模计算框架MapReduce 本质上就是利用了分治思想。实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</li></ol></li></ul><h3 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4. 贪心算法"></a>4. 贪心算法</h3><p><strong>贪心算法</strong>（Greedy）是指，在对问题求解时，总是做出在<strong>当前看来是最好的选择</strong>（只顾眼前）。也就是说，不从整体最优上加以考虑，得到的是在<strong>某种意义上的局部最优解</strong>。<br>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。即问题能够分解成子问题，子问题最优解能够递推到整体最优解。所以选择的贪心策略必须具备<strong>无后效性</strong>（即某个状态以后的过程不会影响以前的状态，只与当前状态有关）。<br>贪心策略一旦经过证明成立后，它就是一种高效的算法。比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。</p><h4 id="4-1-贪心算法实现霍夫曼编码"><a href="#4-1-贪心算法实现霍夫曼编码" class="headerlink" title="4.1 贪心算法实现霍夫曼编码"></a>4.1 贪心算法实现霍夫曼编码</h4><p>通常的编码方式有固定长度编码和不定长度编码两种。哈夫曼编码就是不定长度的编码，它利用字符的使用频率来编码，经常使用的字符编码较短，不常使用的字符编码较长。目的是为了总的编码长度最短，空间效率最高，它是由数学家Huffman在1952年提出的。霍夫曼编码广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。</p><ul><li>不定长编码需要解决两个关键问题：<ol><li>编码尽可能短：让使用频率高的字符编码较短，使用频率低的编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度。</li><li>不能有二义性：任何一个字符的编码不能是另一个字符的前缀，即前缀码特性，例如不能有“10”和“101”这样的编码。</li></ol></li></ul><p>哈夫曼编码的基本思想：以字符的<strong>使用频率作为权值</strong>构建一颗哈夫曼树，然后利用哈夫曼树对字符进行编码。</p><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。</p><table><thead><tr><th align="center">字符</th><th align="center">a</th><th align="center">b</th><th align="center">c</th><th align="center">d</th><th align="center">e</th><th align="center">f</th></tr></thead><tbody><tr><td align="center">出现频率</td><td align="center">32</td><td align="center">25</td><td align="center">18</td><td align="center">13</td><td align="center">7</td><td align="center">5</td></tr></tbody></table><p>构造一棵哈夫曼树：将要编码的字符作为叶子节点，它们对应的频率作为其权值，初始每个字符都是一个单独的树，以自底向上的方式合并，直到只剩一棵树为止。</p><p><img src="/2022/07/25/data-structure-algorithm-method/03_01.png"></p><p>采取的贪心策略：每次从树的集合中取出没有父节点且权值最小的两棵树作为左右子树，构造一棵新树，新树根节点的权值为其左右孩子节点权值之和，将新树插入到树的集合中，继续使用贪心策略进行选择，直到树的集合中只剩一棵树时结束。</p><p><img src="/2022/07/25/data-structure-algorithm-method/03_02.png"><br><img src="/2022/07/25/data-structure-algorithm-method/03_03.png"><br><img src="/2022/07/25/data-structure-algorithm-method/03_04.png"><br><img src="/2022/07/25/data-structure-algorithm-method/03_05.png"><br><img src="/2022/07/25/data-structure-algorithm-method/03_06.png"></p><p>哈夫曼树构建成功后，约定左分支(的边)编码为0，右分支(的边)编码为1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p><img src="/2022/07/25/data-structure-algorithm-method/03_07.png"></p><h3 id="5-回溯算法"><a href="#5-回溯算法" class="headerlink" title="5. 回溯算法"></a>5. 回溯算法</h3><p><strong>回溯算法</strong>（Back Tracking）也叫试探法，解决问题时，每进行一步，都是抱着试试看的态度，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。深度优先搜索算法利用的是回溯算法思想。</p><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p><blockquote><p>剪枝：在不符合条件的情况下尽早结束该路劲的遍历。</p></blockquote><p>回溯算法思想下，需要清晰的找出三个要素：选择 (Options)，限制 (Restraints)，结束条件 (Termination)。</p><ul><li>回溯算法的一般步骤：<ol><li>针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。</li><li>确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间。</li><li>以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。</li></ol></li></ul><p>代码模板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 路径：已经做出的选择</span></span><br><span class="line"><span class="comment"> * 选择列表：当前可以做的选择</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(路径，选择列表)</span> =&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span> (满足结束条件) &#123;</span><br><span class="line">        存放路径;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：路径，选择列表) &#123;</span><br><span class="line">        做出选择;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销选择;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-回溯算法的经典应用：0-1-背包问题"><a href="#5-1-回溯算法的经典应用：0-1-背包问题" class="headerlink" title="5.1 回溯算法的经典应用：0-1 背包问题"></a>5.1 回溯算法的经典应用：0-1 背包问题</h4><p>问题：我们有一个背包，背包总的承载重量是<code>w</code>kg。现在我们有n个物品，每个物品不同重量，并且不可分割。在满足背包背包承重的前提下，背包中物品总重量的最大值是多少呢？<br>解析：n个物品，对于每个物品有装或者不装两种选择，所以是2<em>2</em>2…2&#x3D;<code>2^n</code>种装法，去掉总重量超过<code>w</code>kg的，从剩下的装法中选择总重量最接近<code>w</code>kg的。<br>这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * maxW 存储背包中物品总重量的(2^n种装法)最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">maxW</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i 表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment"> * sum 表示当前已经装进去的物品的重量和；</span></span><br><span class="line"><span class="comment"> * items 表示每个物品的重量；</span></span><br><span class="line"><span class="comment"> * n 表示物品个数；w 表示背包承重；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span>[] items, <span class="type">int</span> n, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">  <span class="comment">// sum==w 表示背包满了; i==n 表示已经考察完所有的物品</span></span><br><span class="line">  <span class="keyword">if</span> (sum == w || i == n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; maxW) &#123;</span><br><span class="line">      <span class="comment">// 计算总重量的最大值</span></span><br><span class="line">      maxW = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 两种选择:①不装第i个物品</span></span><br><span class="line">  f(i+<span class="number">1</span>, sum, items, n, w);</span><br><span class="line">  <span class="comment">// 两种选择:②装第i个物品（剪枝技巧，超过背包承重就不装了）</span></span><br><span class="line">  <span class="keyword">if</span> (sum + items[i] &lt;= w) &#123;</span><br><span class="line">    f(i+<span class="number">1</span>, sum + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 假设背包承重100，物品10个，物品重量存储在数组items中，</span></span><br><span class="line"><span class="comment">// 那可以这样调用函数：f(0, 0, items, 10, 100)</span></span><br></pre></td></tr></table></figure><h3 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h3><p><strong>动态规划</strong>（Dynamic Programming，简称DP）常用于求解最优性质的问题（这类问题可能有许多解，希望找到最优值的解）。</p><p>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。不同的是，动态规划避免了重复计算相同子问题，用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p><p>动态规划适合解决的问题的模型定义为<strong>多阶段决策最优解模型</strong>：<br>解决问题的过程，需要经历多个决策阶段。每个决策阶段依赖于当前状态（每个子问题的解叫做一个状态）。当各个阶段决策确定后，就组成一个决策序列。经过这组决策序列，能够产生最终期望求解的最优值。</p><ul><li>动态规划的<strong>三个特征</strong>分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>：<ol><li>最优子结构：问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。即后面阶段的状态可以通过前面阶段的状态推导出来。</li><li>无后效性：某阶段状态一旦确定，就不受之后阶段的决策影响。即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</li><li>重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。即重复子问题可能会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，从而获得较高的效率。</li></ol></li></ul><h4 id="6-1-0-1-背包问题升级版"><a href="#6-1-0-1-背包问题升级版" class="headerlink" title="6.1 0-1 背包问题升级版"></a>6.1 0-1 背包问题升级版</h4><p>问题：我们有一个背包，背包总的承载重量是<code>w</code>kg。现在我们有n个物品，每个物品不同重量、不同价值、并且不可分割。在满足背包背包承重的前提下，背包中可装入物品的总价值最大是多少呢？<br>解析：引入物品价值这一变量，这个问题依旧可以用回溯算法来解决，代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * maxW 存储背包中物品总价值的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxV</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * i 表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment"> * sumW 表示当前已经装进去的物品的重量和；</span></span><br><span class="line"><span class="comment"> * sumV 表示当前已经装进去的物品的总价值；</span></span><br><span class="line"><span class="comment"> * weight 表示物品的重量；value 表示物品的价值；</span></span><br><span class="line"><span class="comment"> * n 表示物品个数；w 表示背包承重；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] weight = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] value = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> sumW, <span class="type">int</span> sumV)</span> &#123;</span><br><span class="line">  <span class="comment">// sumW==w 表示装满了，i==n 表示物品都考察完了</span></span><br><span class="line">  <span class="keyword">if</span> (sumW == w || i == n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sumV &gt; maxV) maxV = sumV;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 两种选择:①不装第i个物品</span></span><br><span class="line">  f(i+<span class="number">1</span>, sumW, sumV); <span class="comment">// 选择不装第i个物品</span></span><br><span class="line">  <span class="keyword">if</span> (sumW + weight[i] &lt;= w) &#123;</span><br><span class="line">    <span class="comment">// 两种选择:②装第i个物品（剪枝技巧，超过背包承重就不装了）  </span></span><br><span class="line">    f(i+<span class="number">1</span>, sumW+weight[i], sumV+value[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用f(0, 0, 0)</span></span><br></pre></td></tr></table></figure><p>针对上面的代码，我们画出递归树。在递归树中，每个节点表示一个状态。现在我们需要<code>3</code>个变量（<code>i</code>, <code>sumW</code>, <code>sumV</code>）来表示一个状态。其中，<code>i</code>表示即将要决策第<code>i</code>个物品是否装入背包，<code>sumW</code>表示当前背包中物品的总重量，<code>sumV</code>表示当前背包中物品的总价值。<br><img src="/2022/07/25/data-structure-algorithm-method/03_08.webp"><br>我们发现，在递归树中，有几个节点的<code>i</code>和<code>sumW</code>是完全相同的，比如<code>f(2,2,4)</code>和<code>f(2,2,3)</code>。在背包中物品总重量一样的情况下，<code>f(2,2,4)</code>这种状态对应的物品总价值更大，我们可以舍弃<code>f(2,2,3)</code> 这种状态，只需要沿着<code>f(2,2,4)</code>这条决策路线继续往下决策就可以。<br>也就是说，对于<code>(i, sumW)</code>相同的不同状态，那我们只需要保留<code>sumV</code>值最大的那个，继续递归处理，其他状态不予考虑。<br>我们把状态设置为背包中的价值，用一个二维数组 <code>dp[n][w+1]</code>来记录。我们把每一层中<code>(i, sumW)</code>重复的状态（节点）合并，只记录<code>sumV</code>值最大的那个状态，然后基于这些状态来推导下一层的状态。<br><img src="/2022/07/25/data-structure-algorithm-method/03_09.png"><br>重量相同时保留值最大的状态填入表格，最优解即是<code>dp[4][9]=18</code>：<br><img src="/2022/07/25/data-structure-algorithm-method/03_10.png"></p><p>我们把这个动态规划的过程翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * weight 表示物品的重量；value 表示物品的价值；</span></span><br><span class="line"><span class="comment"> * n 表示物品个数；w 表示背包承重；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> n, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不选第一个物品</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 选择第一个物品</span></span><br><span class="line">    <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 动态规划，状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 不选择第i个物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择第i个物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> dp[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span> (v &gt; dp[i][j+weight[i]]) &#123;</span><br><span class="line">                    <span class="comment">// 只保留对应的物品总价值最大的状态</span></span><br><span class="line">                    dp[i][j+weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxV</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n-<span class="number">1</span>][j] &gt; maxV) &#123;</span><br><span class="line">            maxV = dp[n - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-动态规划解题思路"><a href="#6-2-动态规划解题思路" class="headerlink" title="6.2 动态规划解题思路"></a>6.2 动态规划解题思路</h4><p>解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法。</p><h5 id="6-2-1-状态转移表法"><a href="#6-2-1-状态转移表法" class="headerlink" title="6.2.1 状态转移表法"></a>6.2.1 状态转移表法</h5><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。</p><p><strong>状态转移表法</strong>的工作思路：先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。<br>状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。</p><h5 id="6-2-2-状态转移方程法"><a href="#6-2-2-状态转移方程法" class="headerlink" title="6.2.2 状态转移方程法"></a>6.2.2 状态转移方程法</h5><p><strong>状态转移方程法</strong>有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p><p><strong>状态转移方程是解决动态规划的关键</strong>。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。<br>状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p><h3 id="7-经典算法思想比较分析"><a href="#7-经典算法思想比较分析" class="headerlink" title="7. 经典算法思想比较分析"></a>7. 经典算法思想比较分析</h3><p>实际上<strong>枚举</strong>思想是最接近人的思维方式，在更多的时候是用来帮助我们去「理解问题」，而不是「解决问题」。</p><p><strong>递归</strong>思想其实就是一个「套娃」过程。使用时要明确终止条件，及时止损。多数算法的编码实现都要用到递归，但递归代码也有很多弊端，要根据实际情况来选择是否需要用递归的方式来实现。</p><p>贪心、回溯、动态规划可以抽象成「多阶段决策最优解」模型，而<strong>分治算法</strong>解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。分治算法通过层层粒度上的划分，将原问题划分为最小的子问题，然后再向上依次得到更高粒度的解。先从上而下，再从下而上。「先分解，再求解，再合并」。</p><p><strong>回溯算法</strong>是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。</p><p><strong>动态规划</strong>比回溯算法高效，但是需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p><strong>贪心算法</strong>实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」Trie 树 与 AC 自动机</title>
      <link href="/2022/07/06/data-structure-trie-ac.html"/>
      <url>/2022/07/06/data-structure-trie-ac.html</url>
      
        <content type="html"><![CDATA[<p><code>Trie 树</code>，也叫“字典树”、“前缀树”。它是一种有序树形结构。是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。<br><code>AC 自动机</code>以**<code>Trie 树</code>的结构<strong>为基础，结合</strong><code>KMP</code>的思想**建立的，是一种用于解决多模式匹配问题的经典算法。</p><span id="more"></span><h3 id="1-Trie-树"><a href="#1-Trie-树" class="headerlink" title="1. Trie 树"></a>1. Trie 树</h3><p><code>Trie 树</code>的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起。</p><p>举例说明一下。我们有<code>6</code>个字符串：<code>how，hi，her，hello，so，see</code>。构造出来<code>Trie 树</code>的结构就是下面这个图中的样子。</p><p><img src="/2022/07/06/data-structure-trie-ac/02_01.webp"></p><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点表示一个单词的结尾，红色节点并不都是叶子节点）。</p><p><code>Trie 树</code>构造的分解过程：</p><p><img src="/2022/07/06/data-structure-trie-ac/02_02.webp"><br><img src="/2022/07/06/data-structure-trie-ac/02_03.webp"></p><p>当我们在 <code>Trie 树</code>中查找一个字符串的时候，比如查找字符串“her”，从 <code>Trie 树</code>的根节点开始匹配。如图所示，绿色的路径就是在 <code>Trie 树</code>中匹配的路径。</p><p><img src="/2022/07/06/data-structure-trie-ac/02_04.webp"></p><h4 id="1-1-Trie-树-的实现"><a href="#1-1-Trie-树-的实现" class="headerlink" title="1.1 Trie 树 的实现"></a>1.1 Trie 树 的实现</h4><p><code>Trie 树</code>是一个多叉树。假如这个字典只包括<code>26</code>个英文字母（暂且都定为小写），那么这个树的深度会由具体单词不一样而定。但是它的广度范围是可以提前确定好的。对于每个节点，广度最大为<code>26</code>。（因为每个节点的下一个字母（即后缀点）只可能是<code>26</code>个字母。）<br>每个节点存储为<code>26</code>个元素(<code>a-z</code>)的数组，下标<code>0-25</code>存储子节点数组的位置，子节点数组仍然为<code>26</code>个元素的数组。我们在数组中下标为<code>0</code>的位置，存储指向子节点<code>a</code>的指针，下标为<code>1</code>的位置存储指向子节点<code>b</code>的指针，以此类推，下标为<code>25</code>的位置，存储的是指向的子节点<code>z</code>的指针。如果某个字符的子节点不存在，我们就在对应的下标的位置存储<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">  <span class="type">char</span> data;</span><br><span class="line">  TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在 <code>Trie 树</code>中查找字符串的时候，我们就可以通过字符的<code>ASCII</code>码减去<code>a</code>的<code>ASCII</code>码，迅速找到匹配的子节点的指针。<br>比如，<code>d</code>的<code>ASCII</code>码减去<code>a</code>的<code>ASCII</code>码就是<code>3</code>，那子节点<code>d</code>的指针就存储在数组中下标为<code>3</code>的位置中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">  <span class="comment">// 根节点存储无意义字符</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">TrieNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieNode</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  <span class="comment">// 往Trie树中插入一个字符串</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">char</span>[] text)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text.length; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> text[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrieNode</span>(text[i]);</span><br><span class="line">        p.children[index] = newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在Trie树中查找一个字符串</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span>[] pattern)</span> &#123;</span><br><span class="line">    <span class="type">TrieNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pattern[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="comment">// 不存在pattern</span></span><br><span class="line">      <span class="keyword">if</span> (p.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">    <span class="keyword">if</span> (p.isEndingChar == <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 找到pattern</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">isEndingChar</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Trie-树-的复杂度"><a href="#1-2-Trie-树-的复杂度" class="headerlink" title="1.2 Trie 树 的复杂度"></a>1.2 Trie 树 的复杂度</h4><p>构建<code>Trie 树</code>的过程，需要扫描所有的字符串，时间复杂度是 <code>O(n)</code>（<code>n</code> 表示所有字符串的长度和）。<br>但是一旦构建成功之后，后续的查询操作会非常高效，时间复杂度是 <code>O(k)</code>（<code>k</code>表示要查找的字符串的长度）。<br>所以<code>Trie 树</code>的查找时间复杂度<code>O(k)</code>是可以忽略不计的。</p><p><code>Trie 树</code>用的是一种空间换时间的思路，用数组来存储一个节点的子节点的指针。如果字符串中包含从<code>a-z</code>这<code>26</code>个字符，那每个节点都要存储一个长度为<code>26</code>的数组，如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，<code>Trie 树</code>不一定会节省存储空间。在重复的前缀并不多的情况下，<code>Trie 树</code>不但不能节省内存，还有可能会浪费更多的内存。<br><code>Trie 树</code>尽管有可能很浪费内存，但是确实非常高效。那为了解决这个内存问题，我们可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。比如有序数组、跳表、散列表、红黑树等。</p><p><code>Trie 树</code>可以应用于 搜索引擎的搜索关键词提示、输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p><h3 id="2-AC-自动机"><a href="#2-AC-自动机" class="headerlink" title="2. AC 自动机"></a>2. AC 自动机</h3><p><code>AC 自动机</code>（Aho-Corasick Automaton）算法，是一种用于解决多模式匹配问题的经典算法。自动机是一个数学模型，自动机的结构就是一张<strong>有向图</strong>。通过将模式串预处理为确定有限状态自动机，扫描文本一遍就能结束。其复杂度为O(n)，即与模式串的数量和长度无关。<br><code>AC 自动机</code>以**<code>Trie 树</code>的结构<strong>为基础，结合</strong><code>KMP</code>的思想**建立的。<br>简单来说，建立一个<code>AC 自动机</code>有两个步骤：</p><ol><li>基础的<code>Trie 树</code>结构：将所有的模式串构成一棵<code>Trie 树</code>。</li><li><code>KMP</code> 的思想：对<code>Trie 树</code>上所有的结点构造失配指针（相当于<code>KMP</code>中的失效函数<code>next</code>数组）。<br>然后就可以利用它进行<strong>多模式匹配</strong>了。</li></ol><blockquote><ul><li>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。</li><li>多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，<strong>在一个主串中查找多个模式串</strong>。</li></ul></blockquote><p>举个<code>AC自动机</code>的构建的例子：假设文本串是<code>shisherhis</code>，模式串有<code>4</code>个，分别为<code>&#123;he,her,his,she&#125;</code>，我们用模式串建一颗<code>Trie 树</code>。如下图：</p><p><img src="/2022/07/06/data-structure-trie-ac/02_05.png"></p><p>紫色虚线表示<strong>失配指针</strong>，失配指针的作用是在这个模式串失配后快速跳到下一个有可能成功匹配的模式串来匹配，即利用已知信息来加速匹配。如下图：</p><p><img src="/2022/07/06/data-structure-trie-ac/02_06.png"></p><p>其实，构建<strong>失配指针</strong>其实就是在找<strong>最长的与当前失配模式串后缀(已匹配后缀)相同的与下一个模式串的前缀</strong>，其实最长的话就可以保证每个有可能匹配的模式串都匹配到，假设当前节点模式串失配了，就跳最大的前缀，如果又失配，就又到最大前缀的最大前缀，直到没有为止，这样就可以保证全部考虑到。<br>画个图来理解：<br><img src="/2022/07/06/data-structure-trie-ac/02_07.png"></p><p>计算每个节点的失败指针这个过程看起来有些复杂。其实，如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上层。<br>可以像<code>KMP 算法</code>那样，当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说，我们可以逐层依次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历的过程（广度优先搜索(BFS)）。</p><blockquote><ul><li><code>广度优先搜索（Breadth-First-Search）</code>，简称 <code>BFS</code>。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</li><li><code>深度优先搜索（Depth-First-Search）</code>，简称 <code>DFS</code>。它会尽可能深地搜索分支，最直观的例子就是“走迷宫”，即走迷宫发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。</li></ul></blockquote><h3 id="3-AC-自动机的-Java-实现"><a href="#3-AC-自动机的-Java-实现" class="headerlink" title="3. AC 自动机的 Java 实现"></a>3. AC 自动机的 Java 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AC 自动机的 Java 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AC</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本示例中的AC自动机只处理 英文类型的字符串；</span></span><br><span class="line"><span class="comment">     * ASCII码到目前为止共定义了128个字符；</span></span><br><span class="line"><span class="comment">     * 包括大小写字母、数字0-9、标点符号，以及在英文中使用的特殊控制字符。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ASCII</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根结点不存储任何字符信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配结果集合，key表示模式串，value表示模式串在文本串出现的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部静态类，用于表示AC自动机的每个结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="comment">/** 该结点对应的字符 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> data;</span><br><span class="line">        <span class="comment">/** 深度：根节点到这个节点所经历的路径（边数）*/</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/** ASCII == 128, 所以这里相当于128叉树 */</span></span><br><span class="line">        <span class="keyword">public</span> Node[] children = <span class="keyword">new</span> <span class="title class_">Node</span>[ASCII];</span><br><span class="line">        <span class="comment">/** 失配指针 */</span></span><br><span class="line">        Node fail;</span><br><span class="line">        <span class="comment">/** 是否结尾字符 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="variable">isWord</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/** 构造函数 */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过模式串构建 Trie树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildTrieTree</span><span class="params">(String[] patterns)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String pattern : patterns) &#123;</span><br><span class="line">            <span class="comment">// 初始化匹配结果集合</span></span><br><span class="line">            result.put(pattern, <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">            <span class="comment">// 通过模式串构建 Trie树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pattern.length(); ++i) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> pattern.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (p.children[ch] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.children[ch] = <span class="keyword">new</span> <span class="title class_">Node</span>(pattern.charAt(i));</span><br><span class="line">                    p.children[ch].depth = p.depth + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p.children[ch];</span><br><span class="line">            &#125;</span><br><span class="line">            p.isWord = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 Trie树 上所有的结点构造失配指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildFailurePointer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// LinkedList 实现了 Queue 接口，可作为队列使用(先进先出)</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 单独处理根结点下的第一层子结点</span></span><br><span class="line">        <span class="keyword">for</span> (Node x : root.children)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 根结点的所有孩子结点的fail都指向根结点</span></span><br><span class="line">                x.fail = root;</span><br><span class="line">                <span class="comment">// 所有根结点的孩子结点入队列</span></span><br><span class="line">                queue.add(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 出队列结点的孩子结点的fail指向</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> queue.remove();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p.children.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.children[i] != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 孩子结点入队列</span></span><br><span class="line">                    queue.add(p.children[i]);</span><br><span class="line">                    <span class="comment">// 从p.fail开始找起</span></span><br><span class="line">                    <span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> p.fail;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                        <span class="comment">// 向上找到了根结点还没有找到(没有公共前缀)</span></span><br><span class="line">                        <span class="keyword">if</span>(f == <span class="literal">null</span>)&#123;</span><br><span class="line">                            p.children[i].fail = root;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 有公共前缀</span></span><br><span class="line">                        <span class="keyword">if</span>(f.children[i] != <span class="literal">null</span>)&#123;</span><br><span class="line">                            p.children[i].fail = f.children[i];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 继续向上寻找</span></span><br><span class="line">                            f = f.fail;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造AC自动机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> patterns 多模式串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AC</span><span class="params">(String[] patterns)</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        buildTrieTree(patterns);</span><br><span class="line">        buildFailurePointer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配所有的模式串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 文本串（主串）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;String, List&lt;Integer&gt;&gt; <span class="title function_">match</span><span class="params">(String text)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; text.length())&#123;</span><br><span class="line">            <span class="comment">// 文本串中的字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> text.charAt(i);</span><br><span class="line">            <span class="comment">// 在AC自动机中找文本串中的字符ch</span></span><br><span class="line">            <span class="keyword">if</span>(p.children[ch] != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 找到了，自动机进入下一状态</span></span><br><span class="line">                p = p.children[ch];</span><br><span class="line">                <span class="keyword">if</span>(p.isWord)&#123;</span><br><span class="line">                    <span class="comment">// 模式串匹配成功，存入结果集result</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> text.substring(i - p.depth + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                    result.get(pattern).add(i - p.depth + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 模式串的中间某部分字符可能正好包含另一个模式串</span></span><br><span class="line">                <span class="keyword">if</span>(p.fail != <span class="literal">null</span> &amp;&amp; p.fail.isWord)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">pattern</span> <span class="operator">=</span> text.substring(i - p.fail.depth + <span class="number">1</span>, i + <span class="number">1</span>);</span><br><span class="line">                    result.get(pattern).add(i - p.fail.depth + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 文本串索引自增，指向下一个文本串中的字符</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 没找到（p.children[ch] == null）,</span></span><br><span class="line">                <span class="comment">// 失配指针发挥作用的地</span></span><br><span class="line">                p = p.fail;</span><br><span class="line">                <span class="comment">// 到根结点还未找到，说明文本串中以ch作为结束的字符片段不是任何目标字符串的前缀，</span></span><br><span class="line">                <span class="comment">// 状态机重置(从root开始重新匹配)，比较下一个字符</span></span><br><span class="line">                <span class="keyword">if</span>(p == <span class="literal">null</span>)&#123;</span><br><span class="line">                    p = root;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 文本串扫描完毕，返回结果集</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC自动机 测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAC</span><span class="params">()</span> &#123;</span><br><span class="line">    String[] patterns = &#123;<span class="string">&quot;he&quot;</span>,<span class="string">&quot;her&quot;</span>,<span class="string">&quot;his&quot;</span>,<span class="string">&quot;she&quot;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;shisherhis&quot;</span>;</span><br><span class="line">    <span class="comment">// 构造AC自动机</span></span><br><span class="line">    <span class="type">AC</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AC</span>(patterns);</span><br><span class="line">    <span class="comment">// AC自动机匹配文本串</span></span><br><span class="line">    HashMap&lt;String, List&lt;Integer&gt;&gt; result = ac.match(text);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;文本串“&quot;</span>+ text + <span class="string">&quot;”的匹配结果：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Integer&gt;&gt; entry : result.entrySet())&#123;</span><br><span class="line">        System.out.println(entry.getKey()+<span class="string">&quot; : &quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本串“shisherhis”的匹配结果：</span><br><span class="line">she : [3]</span><br><span class="line">his : [1, 7]</span><br><span class="line">her : [4]</span><br><span class="line">he : [4]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」单模式字符串匹配算法（BF、RK、KMP、BM）</title>
      <link href="/2022/06/25/data-structure-text-pattern-algorithm.html"/>
      <url>/2022/06/25/data-structure-text-pattern-algorithm.html</url>
      
        <content type="html"><![CDATA[<p>介绍字符串匹配算法之前，先定义几个概念：</p><ul><li><strong>主串</strong><code>Text</code>: 长度记作 <code>n</code>；</li><li><strong>模式串</strong><code>Pattern</code>: 长度记作 <code>m</code>，并且 <code>m&lt;=n</code>。</li><li>有效位移<code>s</code>（Valid Shift）：即模式串在主串中出现，并且位置移动 <code>s</code> 次。<br><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_01.png"></li></ul><span id="more"></span><h3 id="1-BF-算法"><a href="#1-BF-算法" class="headerlink" title="1. BF 算法"></a>1. BF 算法</h3><p>BF（Brute Force）算法，中文叫作暴力匹配算法，也叫朴素匹配算法。</p><p>从主串的首或尾开始逐个匹配字母（比较顺序没有限制）。<br><code>BF 算法</code>的思想可以用一句话来概括：在主串中，检查从起始位置 <code>0</code> 开始到 <code>n-m</code> 位置且长度为 <code>m</code> 的 <code>n-m+1</code> 个子串，看有没有跟模式串匹配的。如下图：</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_02.png"></p><p><code>BF 算法</code>从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。<br>我们每次都比对 <code>m</code> 个字符，要比对 <code>n-m+1</code> 次，所以，这种算法的最坏情况时间复杂度是 <code>O(n*m)</code>。</p><p>尽管理论上，<code>BF 算法</code>的时间复杂度很高，是 <code>O(n*m)</code>，但在实际的开发中，它却是一个比较常用的字符串匹配算法。原因有两点。</p><ul><li>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 <code>m</code> 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 <code>O(n*m)</code>，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</li><li>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的<a href="https://zh.wikipedia.org/wiki/KISS%E5%8E%9F%E5%88%99">KISS（Keep it Simple and Stupid）设计原则</a>。</li></ul><h4 id="1-1-BF-算法总结"><a href="#1-1-BF-算法总结" class="headerlink" title="1.1 BF 算法总结"></a>1.1 BF 算法总结</h4><p><code>BF 算法</code>（Brute Force）是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。<br>尽管理论上的最坏情况时间复杂度很高，是 <code>O(n*m)</code>（<code>n</code>、<code>m</code> 表示主串和模式串的长度）。<br>但在实际的开发中，它却是一个比较常用的字符串匹配算法。因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><h4 id="1-2-Java代码实现"><a href="#1-2-Java代码实现" class="headerlink" title="1.2 Java代码实现"></a>1.2 Java代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串暴力匹配算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bf</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m-<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i+j) != pattern.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// j为已匹配的字符串下一个字符的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-RK-算法"><a href="#2-RK-算法" class="headerlink" title="2. RK 算法"></a>2. RK 算法</h3><p>RK（Rabin-Karp）算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。这个算法算是 <code>BF 算法</code>的升级版。</p><p><code>BF 算法</code>中，如果主串长度为 <code>n</code>，模式串长度为 <code>m</code>，那在主串中，就会有 <code>n-m+1</code> 个长度为 <code>m</code> 的子串与模式串匹配。但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 <code>BF 算法</code>的时间复杂度就比较高，是 <code>O(n*m)</code>。</p><p><code>RK 算法</code>的思路：通过哈希算法对主串中的 <code>n-m+1</code> 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p><p>整个<code>RK 算法</code>包含两部分：<br>第一部分，计算子串哈希值；通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 <code>O(n)</code>。<br>第二部分，模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 <code>O(1)</code>，总共需要比较 <code>n-m+1</code> 个子串的哈希值，所以，这部分的时间复杂度也是 <code>O(n)</code>。<br>所以，<code>RK 算法</code>整体的时间复杂度就是 <code>O(n)</code>。<br>但是，当存在哈希冲突的时候，有可能存在子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 <code>O(n*m)</code>。但也不要太悲观，一般情况下，冲突不会很多，<code>RK 算法</code>的效率还是比 <code>BF 算法</code>高的。</p><h4 id="2-1-RK-算法总结"><a href="#2-1-RK-算法总结" class="headerlink" title="2.1 RK 算法总结"></a>2.1 RK 算法总结</h4><p><code>RK 算法</code>（Rabin-Karp）是对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。<br>理想情况下，<code>RK 算法</code>的时间复杂度是 <code>O(n)</code>。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 <code>O(n*m)</code>。</p><h4 id="2-2-Java代码实现"><a href="#2-2-Java代码实现" class="headerlink" title="2.2 Java代码实现"></a>2.2 Java代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rabin-Karp算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> text 主串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rk</span><span class="params">(String text, String pattern)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 对模式串与第一个字串求哈希值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">patternCode</span> <span class="operator">=</span> pattern.hashCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> text.substring(<span class="number">0</span>, m);</span><br><span class="line">    <span class="type">int</span> <span class="variable">subCode</span> <span class="operator">=</span> sub.hashCode();</span><br><span class="line">    <span class="comment">// 对主串中的n-m+1个子串分别求哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - m + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 哈希值相同，才进一步确认</span></span><br><span class="line">        <span class="keyword">if</span> (patternCode.equals(subCode) &amp;&amp; sub.equals(pattern)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续下一个子串</span></span><br><span class="line">        i++;</span><br><span class="line">        sub = text.substring(i, i + m);</span><br><span class="line">        subCode = sub.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-KMP-算法"><a href="#3-KMP-算法" class="headerlink" title="3. KMP 算法"></a>3. KMP 算法</h3><p>KMP（Knuth Morris Pratt）算法，是最常用的之一。它以三个发明者命名，很多时候，提到字符串匹配，我们首先想到的就是<code>KMP 算法</code>。</p><p><code>KMP 算法</code>的核心思想：<br>在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><p>先了解几个概念：</p><ul><li><strong>前缀</strong>：指除了最后一个字符以外，一个字符串的全部头部组合；</li><li><strong>后缀</strong>：指除了第一个字符以外，一个字符串的全部尾部组合；</li><li><strong>部分匹配值</strong>：”前缀”和”后缀”的最长的共有元素的长度。</li></ul><p>以模式串”ABCDABD”为例：</p><table><thead><tr><th align="left">子串</th><th align="left">前缀</th><th align="left">后缀</th><th align="left">共有</th><th align="left">长度</th></tr></thead><tbody><tr><td align="left">A</td><td align="left">空</td><td align="left">空</td><td align="left">-</td><td align="left">0</td></tr><tr><td align="left">AB</td><td align="left">[A]</td><td align="left">[B]</td><td align="left">-</td><td align="left">0</td></tr><tr><td align="left">ABC</td><td align="left">[A, AB]</td><td align="left">[BC, C]</td><td align="left">-</td><td align="left">0</td></tr><tr><td align="left">ABCD</td><td align="left">[A, AB, ABC]</td><td align="left">[BCD, CD, D]</td><td align="left">-</td><td align="left">0</td></tr><tr><td align="left">ABCDA</td><td align="left">[A, AB, ABC, ABCD]</td><td align="left">[BCDA, CDA, DA, A]</td><td align="left">A</td><td align="left">1</td></tr><tr><td align="left">ABCDAB</td><td align="left">[A, AB, ABC, ABCD, ABCDA]</td><td align="left">[BCDAB, CDAB, DAB, AB, B]</td><td align="left">AB</td><td align="left">2</td></tr><tr><td align="left">ABCDABD</td><td align="left">[A, AB, ABC, ABCD, ABCDA, ABCDAB]</td><td align="left">[BCDABD, CDABD, DABD, ABD, BD, D]</td><td align="left">-</td><td align="left">0</td></tr></tbody></table><p>所以模式串”ABCDABD”的《部分匹配表》是：</p><table><thead><tr><th align="left">模式串</th><th align="left">A</th><th align="left">B</th><th align="left">C</th><th align="left">D</th><th align="left">A</th><th align="left">B</th><th align="left">D</th></tr></thead><tbody><tr><td align="left">部分匹配表</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">0</td></tr></tbody></table><p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是<code>2</code>（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动<code>4</code>位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。<br>所以<code>KMP 算法</code>的后移规律：</p><blockquote><p>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</p></blockquote><p>根据这个规律，我们以模式串”ABCDABD”来匹配字符串”BBC ABCDAB ABCDABCDABDE”。<code>KMP 算法</code>的匹配顺序是按照模式串下标从小到大。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_07.png"></p><p>逐位比较，不匹配就移一位；直到主串有一个字符与模式串的第一个字符相同为止。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_08.png"></p><p>已知空格与”D”不匹配时，前面<code>6</code>个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符”B”对应的”部分匹配值”为<code>2</code>，因此按照规律<code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code>算出向后移动的位数：<code>6 - 2</code> 等于<code>4</code>，所以将搜索词向后移动<code>4</code>位。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_09.png"></p><p>因为空格与”C”不匹配，搜索词还要继续往后移。这时，已匹配的字符数为<code>2</code>（”AB”），对应的”部分匹配值”为<code>0</code>。所以，<code>移动位数 = 2 - 0</code>，于是将搜索词向后移<code>2</code>位。<br>按照规律<code>移动位数 = 已匹配的字符数 - 对应的部分匹配值</code>算出向后移动的位数：<code>2 - 0</code> 等于<code>2</code>，所以将搜索词向后移动<code>2</code>位。<br>继续逐位比较，因为空格与”A”不匹配，继续后移<code>1</code>位。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_10.png"></p><p>逐位比较，直到发现”C”与”D”不匹配。于是，<code>移动位数 = 6 - 2</code>，继续将搜索词向后移动<code>4</code>位。<br>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。</p><h4 id="3-1-KMP-算法总结"><a href="#3-1-KMP-算法总结" class="headerlink" title="3.1 KMP 算法总结"></a>3.1 KMP 算法总结</h4><p><code>KMP 算法</code>（Knuth Morris Pratt）的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个<code>next()</code>函数实现，函数本身包含了模式串的局部匹配信息。<code>KMP 算法</code>的时间复杂度<code>O(m+n)</code>。</p><h4 id="3-2-KMP-算法的JAVA-代码实现"><a href="#3-2-KMP-算法的JAVA-代码实现" class="headerlink" title="3.2 KMP 算法的JAVA 代码实现"></a>3.2 KMP 算法的JAVA 代码实现</h4><p><strong>部分匹配值</strong>是模式串中子串”前缀”和”后缀”的<strong>最长</strong>的共有元素的长度。<br>《部分匹配表》在代码中定义为 <strong>next 数组</strong>，很多书中也叫<strong>失效函数</strong>（failure function）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现next()函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] kmpNext(String pattern)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="comment">// 声明部分匹配表数组 next，用于存储部分匹配值</span></span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">// 第一个字符没有前后缀，最长匹配值为 0</span></span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环模式串，计算部分匹配表，i初始化为 1</span></span><br><span class="line">    <span class="comment">// j用于记录部分匹配值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>,j = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="comment">// ④ 在0~i中，j&gt;0 并且 pattern.charAt(j) != pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示上一轮比较，前后缀部分匹配值为j。</span></span><br><span class="line">        <span class="comment">//   上一轮比较时，下标[0~j-1]是前后缀最长相同字符串。</span></span><br><span class="line">        <span class="comment">//   下标[j-1]的部分匹配值表示为next[j-1]，即j=next[j-1];</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; pattern.charAt(j) != pattern.charAt(i))&#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ① 在0~i中，j=0 并且 pattern.charAt(j) != pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示前后缀字符串集合中没有相同字符串，next[i]=j（同next[i]=0）</span></span><br><span class="line">        <span class="comment">// ② 在0~i中，j=0 并且 pattern.charAt(j) == pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示前后缀字符串集合中有 1 个相同字符串，j++;next[i]=j;（同next[i]=1）</span></span><br><span class="line">        <span class="comment">// ③ 在0~i中，j&gt;0 并且 pattern.charAt(j) == pattern.charAt(i)时，</span></span><br><span class="line">        <span class="comment">//   表示上一轮比较，前后缀部分匹配值为j。这轮为j+1。因此j++;next[i]=j;</span></span><br><span class="line">        <span class="keyword">if</span>(pattern.charAt(i) == pattern.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>KMP 算法</code>的框架代码，比较模式串和主串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">kmp</span><span class="params">(String text, String pattern)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 计算出部分匹配表</span></span><br><span class="line">    <span class="type">int</span>[] next = kmpNext(pattern);</span><br><span class="line">    <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= m-<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i+j) != pattern.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// j为已匹配的字符串下一个字符的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 后移位数 = 已匹配的字符数j - 对应的部分匹配值next[j-1]</span></span><br><span class="line">            s = j - next[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        i += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-BM-算法"><a href="#4-BM-算法" class="headerlink" title="4. BM 算法"></a>4. BM 算法</h3><p>BM（Boyer-Moore）算法，也是以两位发明者名字命名的字符串匹配算法。<code>BM 算法</code>不仅效率高，而且构思巧妙，容易理解。</p><p><code>BM 算法</code>的核心思想：<br>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p><p>BM 算法包含两部分，分别是<strong>坏字符</strong>规则（bad character rule）和<strong>好后缀</strong>规则（good suffix shift）。</p><h4 id="4-1-坏字符规则"><a href="#4-1-坏字符规则" class="headerlink" title="4.1 坏字符规则"></a>4.1 坏字符规则</h4><p><code>BM 算法</code>的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。<br>当发现某个字符没法匹配的时候，我们把这个没有匹配的字符叫作”<strong>坏字符</strong>“（bad character）。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_03.png"><br>如上图，从尾部开始比较，发现”S”与”E”不匹配，所以”S”就是”坏字符”。<br>并且，”S”不包含在模式串”EXAMPLE”之中，也就是说，可以把模式串直接移到”S”的后一位。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_04.png"><br>如上图，依然从尾部开始比较，发现”P”与”E”不匹配，所以”P”是”坏字符”。<br>但是，”P”包含在模式串”EXAMPLE”之中。所以，将模式串后移两位，两个”P”对齐。</p><p>由此我们总结出<strong>坏字符规则</strong>：</p><blockquote><p>后移位数 &#x3D; 坏字符(对应模式串)的位置 - 模式串中的上一次出现位置</p><p>（如果”坏字符”不包含在模式串中，则上一次出现位置为 <code>-1</code>）</p></blockquote><p>如上图，”P”作为”坏字符”为例，出现在模式串的第6位（从0开始编号），在模式串中的上一次出现位置为4，所以后移<code>6 - 4 = 2</code> 位。<br>再以前面”坏字符”的”S”为例，它出现在第6位，上一次出现位置是 -1（即未出现），则整个模式串后移 <code>6 - (-1) = 7</code> 位。</p><h4 id="4-2-好后缀规则"><a href="#4-2-好后缀规则" class="headerlink" title="4.2 好后缀规则"></a>4.2 好后缀规则</h4><p>好后缀规则实际上跟坏字符规则的思路很类似。<br>从尾部开始比较，我们把所有尾部匹配的字符串称为”<strong>好后缀</strong>“（good suffix）。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_05.png"><br>如上图，从尾部开始比较，”E”与”E”匹配；”LE”与”LE”匹配；”PLE”与”PLE”匹配；”MPLE”与”MPLE”匹配。<br>所以，”MPLE”、”PLE”、”LE”、”E”都是好后缀。<br>比较前一位，发现”I”与”A”不匹配。所以，”I”是”坏字符”。</p><p><strong>好后缀规则</strong>：</p><blockquote><p>后移位数 &#x3D; 好后缀的位置 - 模式串中的上一次出现位置</p></blockquote><p>举例来说，<br>如果模式串”ABCDAB”的后一个”AB”是”好后缀”。那么<em>好后缀的位置</em>是 <code>5</code>（取最后的”B”的值），<em>模式串中的上一次出现位置</em>是 <code>1</code>（第一个”B”的位置），所以后移<code>5 - 1 = 4</code>位。<br>如果模式串”ABCDEF”的”EF”是好后缀，则<em>好后缀的位置</em>是<code>5</code> ，<em>上一次出现的位置</em>是<code>-1</code>（即未出现），所以后移<code>5 - (-1) = 6</code>位。</p><ul><li>好后缀规则三个注意点：<ol><li>“好后缀”的位置以最后一个字符为准。<ul><li>假定”ABCDEF”的”EF”是好后缀，则它的位置以”F”为准，即5。</li></ul></li><li>如果”好后缀”在搜索词中只出现一次，则它的上一次出现位置为 -1。<ul><li>比如，”EF”在”ABCDEF”之中只出现一次，则它的上一次出现位置为-1（即未出现）。</li></ul></li><li>如果”好后缀”有多个，则除了最长的那个”好后缀”，其他”好后缀”的上一次出现位置必须在头部。<ul><li>比如，假定”BABCDAB”的”好后缀”是”DAB”、”AB”、”B”，此时计算上一次出现位置是第0位，采用好后缀”B”计算。这个规则也可以这样表达：如果最长的那个”好后缀”只出现一次，则可以把搜索词改写成如下形式进行位置计算”(DA)BABCDAB”，即虚拟加入最前面的”DA”。</li></ul></li></ol></li></ul><p>回到上图的例子。此时，所有的”好后缀”（MPLE、PLE、LE、E）之中，只有”E”在”EXAMPLE”还出现在头部，所以好后缀规则是后移<code>6 - 0 = 6</code>位。<br>而”I”是”坏字符”，坏字符规则后移<code>2 - (-1) = 3</code>位。<br>可以看到，”坏字符规则”只能移3位，”好后缀规则”可以移6位。所以，<code>BM 算法</code>的基本思想是，<strong>每次后移这两个规则之中的较大值</strong>。</p><p>更巧妙的是，这两个规则的移动位数，只与搜索词有关，与原字符串无关。因此，可以预先计算生成《坏字符规则表》和《好后缀规则表》。使用时，只要查表比较一下就可以了。</p><p><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_06.png"><br>继续从尾部开始比较，”P”与”E”不匹配，因此”P”是”坏字符”。根据”坏字符规则”，后移 <code>6 - 4 = 2</code>位；<br>从尾部开始逐位比较，发现全部匹配，于是搜索结束。</p><h4 id="4-3-BM-算法总结"><a href="#4-3-BM-算法总结" class="headerlink" title="4.3 BM 算法总结"></a>4.3 BM 算法总结</h4><p><code>BM 算法</code>（Boyer-Moore）核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。<code>BM 算法</code>构建的规则有两类，坏字符规则和好后缀规则。</p><h4 id="4-4-BM-算法的JAVA-代码实现"><a href="#4-4-BM-算法的JAVA-代码实现" class="headerlink" title="4.4 BM 算法的JAVA 代码实现"></a>4.4 BM 算法的JAVA 代码实现</h4><p><code>BM 算法</code>的框架代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bm</span><span class="params">(String text, String pattern)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) &#123; <span class="keyword">return</span> -<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 计算 坏字符规则表，记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    Map&lt;Character, Integer&gt; badCharRules = generateBadCharRules(pattern);</span><br><span class="line">    <span class="comment">// 计算 好后缀规则表，记录好后缀位置对应后移的位数</span></span><br><span class="line">    <span class="type">int</span>[] goodSuffixRules = generateGoodSuffix(pattern.toCharArray());</span><br><span class="line">    <span class="comment">// i表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text.charAt(i+j) != pattern.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后移位数 = 坏字符(对应模式串)的位置 - 坏字符在模式串中最后出现位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> j - getBadCharPosition(badCharRules, text.charAt(i + j));</span><br><span class="line">        <span class="comment">// 好后缀后移位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> goodSuffixRules[j];</span><br><span class="line">        <span class="comment">//后移这两个规则之中的较大值</span></span><br><span class="line">        i += Math.max(s1, s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-1-坏字符规则表"><a href="#4-4-1-坏字符规则表" class="headerlink" title="4.4.1 坏字符规则表"></a>4.4.1 坏字符规则表</h5><p>计算模式串中每个字符最后出现的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坏字符规则表</span></span><br><span class="line"><span class="comment"> * 记录模式串中每个字符最后出现的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Character, Integer&gt; <span class="title function_">generateBadCharRules</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; bmBc = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(pattern.length());</span><br><span class="line">    <span class="comment">// 选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; pattern.length(); j++) &#123;</span><br><span class="line">        bmBc.put(pattern.charAt(j), j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bmBc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取坏字符在模式串中最后出现位置</span></span><br><span class="line"><span class="comment"> * 未出现返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBadCharPosition</span><span class="params">(Map&lt;Character, Integer&gt; badChar, Character c)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> badChar.get(c);</span><br><span class="line">    <span class="keyword">return</span> a == <span class="literal">null</span> ? -<span class="number">1</span> : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-4-2-好后缀规则表"><a href="#4-4-2-好后缀规则表" class="headerlink" title="4.4.2 好后缀规则表"></a>4.4.2 好后缀规则表</h5><p>好后缀规则表，用来记录好后缀位置对应后移的位数。<br>为了实现好后缀规则，需要定义一个<code>suffix</code>数组，用来记录模式串中匹配上好后缀的子串长度。<br>其中，<code>suffix[i] = s</code>满足<code>pattern[i-s,i] == pattern[m-1-s,m-1]</code>，<code>m</code>是模式串的长度。如下图：<code>pattern[i-4,i]</code>和<code>pattern[m-5,m-1]</code>字符相同。<br><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_11.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算后缀长度数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getSuffix(<span class="type">char</span>[] pattern)&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">    <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">// 计算</span></span><br><span class="line">    suffix[m-<span class="number">1</span>] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span> (q &gt;= <span class="number">0</span> &amp;&amp; pattern[q] == pattern[q+m-<span class="number">1</span>-i])&#123;</span><br><span class="line">            q--;</span><br><span class="line">        &#125;</span><br><span class="line">        suffix[i] = i-q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回后缀长度数组</span></span><br><span class="line">    <span class="keyword">return</span> suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了<code>suffix</code>数组，就可以定义好后缀忽略映射<code>bmgs</code>数组。<br><code>suffix[i]</code>表示模式串中匹配上好后缀的子串长度（<code>i</code>表示子串的末位置）；<br><code>bmgs[j]</code>表示好后缀位置对应后移的位数（<code>j</code>表示好后缀前一个字符的位置，即坏字符的位置）。<br>根据<strong>好后缀规则</strong>：<code>后移位数 = 好后缀的位置 - 模式串中的上一次出现位置</code>，构建<code>bmgs</code>数组分为三种情况：</p><ul><li>①模式串没有子串匹配上好后缀，也没有最大前缀。<ul><li>后移位数为<code>m-1-(-1)</code>，即<code>bmgs[j]=m</code>。</li></ul></li><li>②模式串没有子串匹配上好后缀，但有最大前缀。<ul><li>后移位数为<code>m-1-i</code>，即<code>bmgs[j] = m-1-i</code>。<br><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_13.png"></li></ul></li><li>③模式串有子串匹配上好后缀。<ul><li>后移位数为<code>m-1-i</code>，即<code>bmgs[j] = m-1-i; j=m-1-suffix[i]</code>。<br><img src="/2022/06/25/data-structure-text-pattern-algorithm/01_12.png"></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 好后缀忽略映射（后移位数数组）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pattern 模式串字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] generateGoodSuffix(<span class="type">char</span>[] pattern)&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> pattern.length;</span><br><span class="line">    <span class="type">int</span>[] bmgs = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">// 获取后缀长度数组</span></span><br><span class="line">    <span class="type">int</span>[] suffix = getSuffix(pattern);</span><br><span class="line">    <span class="comment">// 赋值默认值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        bmgs[j] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模式串没有没有子串匹配上好后缀，但有最大前缀</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m-<span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (suffix[i] == i+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m-<span class="number">1</span>-i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(bmgs[j] == m)&#123;</span><br><span class="line">                    bmgs[j] = m-<span class="number">1</span>-i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 模式串有子串匹配上好后缀（多个取最左）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m-<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        bmgs[m-<span class="number">1</span>-suffix[i]] = m-<span class="number">1</span>-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回忽略数组</span></span><br><span class="line">    <span class="keyword">return</span> bmgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」二分查找</title>
      <link href="/2022/06/02/data-structure-binary-search.html"/>
      <url>/2022/06/02/data-structure-binary-search.html</url>
      
        <content type="html"><![CDATA[<p>二分查找（Binary Search）又称折半查找、二分搜索、折半搜索等，查找思想有点类似<strong>分治思想</strong>，对应的时间复杂度为<code>O(logn)</code>。<br>二分查找算法仅适用于<strong>有序</strong>且使用<strong>顺序存储结构</strong>的序列（比如有序数组）。<br>核心思想是：不断地缩小搜索区域，降低查找目标元素的难度。（每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。）</p><ul><li>以在升序序列中查找目标元素为例，二分查找算法的<strong>实现思路</strong>是：<ol><li>初始状态下，将整个序列作为搜索区域（假设为 [B, E]）；</li><li>找到搜索区域内的中间元素（假设所在位置为 M），和目标元素进行比对。如果相等，则搜索成功；如果中间元素大于目标元素，将左侧 [B, M-1] 作为新的搜素区域；反之，若中间元素小于目标元素，将右侧 [M+1, E] 作为新的搜素区域；</li><li>重复执行第二步，直至找到目标元素。如果搜索区域无法再缩小，且区域内不包含任何元素，表明整个序列中没有目标元素，查找失败。<span id="more"></span></li></ol></li></ul><h3 id="1-标准二分查找"><a href="#1-标准二分查找" class="headerlink" title="1. 标准二分查找"></a>1. 标准二分查找</h3><p>二分查找递归实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 如果存在，返回其索引，否则返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> searchRecursion(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 递归实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">searchRecursion</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// mid = left + (right - left) / 2;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRecursion(nums, mid+<span class="number">1</span>, right, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchRecursion(nums, left, mid-<span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找循环实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找循环实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找虽然性能比较优秀，但应用场景也比较有限。<br>底层必须依赖<strong>数组</strong>，并且还要求数据是<strong>有序</strong>的。<br>对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。<br>二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><h3 id="2-二分查找左边界"><a href="#2-二分查找左边界" class="headerlink" title="2. 二分查找左边界"></a>2. 二分查找左边界</h3><p>查找第一个值等于给定值的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftSearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (nums[mid - <span class="number">1</span>] != target)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 即使我们找到了nums[mid] == target, 这个mid的位置也不一定就是最左侧的那个边界，</span></span><br><span class="line">            <span class="comment">// nums[mid - 1] == target，继续收缩右边界</span></span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二分查找右边界"><a href="#3-二分查找右边界" class="headerlink" title="3. 二分查找右边界"></a>3. 二分查找右边界</h3><p>查找最后一个值等于给定值的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightSearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == nums.length - <span class="number">1</span>) || (nums[mid + <span class="number">1</span>] != target)) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 即使我们找到了nums[mid] == target, 这个mid的位置也不一定就是最右侧的那个边界，</span></span><br><span class="line">            <span class="comment">// nums[mid + 1] == target，继续收缩左边界</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」排序算法</title>
      <link href="/2022/05/25/data-structure-sort.html"/>
      <url>/2022/05/25/data-structure-sort.html</url>
      
        <content type="html"><![CDATA[<p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><span id="more"></span><p>用一张图概括：</p><p><img src="/2022/05/25/data-structure-sort/12_01.png"></p><p>名词解释：</p><ul><li><code>n</code>：数据规模</li><li><code>k</code>：”桶”的个数</li><li><code>In-place</code>：占用常数内存，不占用额外内存</li><li><code>Out-place</code>：占用额外内存</li><li><code>稳定性</code>：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><table><thead><tr><th align="left">内部排序</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">冒泡排序</td><td align="left">（无序区，有序区）<br> 从无序区通过交换找出最大元素放到有序区最前端。</td></tr><tr><td align="left">选择排序</td><td align="left">（无序区，有序区）<br> 从无序区选择一个最小的元素放到有序区的末尾。比较多，交换少</td></tr><tr><td align="left">插入排序</td><td align="left">（无序区，有序区）<br> 把无序区的第一个元素插入到有序区合适的位置。比较少，交换多</td></tr><tr><td align="left">希尔排序</td><td align="left">通过比较相距一定间隔的元素来进行（每一定间隔取一个元素组成子序列），各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</td></tr><tr><td align="left">归并排序</td><td align="left">把数组从中间分成前后两部分，分别排序，再将排好序的两部分合并。</td></tr><tr><td align="left">快速排序</td><td align="left">（小数，基准，大数）<br> 随机一个元素作为基准数，将小于基准的元素放在基准之前，大于基准的放在基准之后，再分别对小数区与大数区进行排序。</td></tr><tr><td align="left">堆排序</td><td align="left">（大顶堆，有序区）<br> 取出堆顶元素放在有序区，再恢复堆。</td></tr><tr><td align="left">计数排序</td><td align="left">统计小于等于该元素值的元素个数i,于是该元素就放在目标数组的索引i位（i&gt;&#x3D;0）。</td></tr><tr><td align="left">桶排序</td><td align="left">将值为i的元素放在i号桶，最后依次把桶里元素倒出来。</td></tr><tr><td align="left">基数排序</td><td align="left">一种多关键字的排序算法，可用桶排序实现。</td></tr></tbody></table><h3 id="1-冒泡排序（Bubble-Sort）"><a href="#1-冒泡排序（Bubble-Sort）" class="headerlink" title="1. 冒泡排序（Bubble Sort）"></a>1. 冒泡排序（Bubble Sort）</h3><p><code>冒泡排序（Bubble Sort）</code>是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><ul><li>冒泡排序步骤：<ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_bubble.gif"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 若已有序，提前退出标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">// 发生交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            <span class="comment">// 若已有序,未发生交换，提前退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-选择排序（Selection-sort）"><a href="#2-选择排序（Selection-sort）" class="headerlink" title="2. 选择排序（Selection sort）"></a>2. 选择排序（Selection sort）</h3><p><code>选择排序（Selection sort）</code>是一种简单直观的排序算法。 它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。 以此类推，直到全部待排序的数据元素的个数为零。 选择排序是不稳定的排序方法。</p><ul><li>冒泡排序步骤：<ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_selection.gif"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> min=i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != min)&#123;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            arr[i] = arr[min];</span><br><span class="line">            arr[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-插入排序（Insertion-Sort）"><a href="#3-插入排序（Insertion-Sort）" class="headerlink" title="3. 插入排序（Insertion Sort）"></a>3. 插入排序（Insertion Sort）</h3><p><code>插入排序（Insertion Sort）</code>是一种最简单直观的排序算法，一般也被称为直接插入排序。<br>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><ul><li>插入排序步骤：<ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_insertion.gif"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; temp)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-希尔排序（Shell-Sort）"><a href="#4-希尔排序（Shell-Sort）" class="headerlink" title="4. 希尔排序（Shell Sort）"></a>4. 希尔排序（Shell Sort）</h3><p><code>希尔排序（Shell Sort）</code>是插入排序的一种更高效的改进版本；又称缩小增量排序，因 DL.Shell 于 1959 年提出而得名。<br>通过比较相距一定间隔的元素来进行（每一定间隔取一个元素组成子序列），各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。</p><ul><li>希尔排序步骤：<ol><li>将 len 个元素的数组序列 分割为间隔 gap (gap &#x3D; len&#x2F;2) 的子序列（每间隔 gap 取一个元素）</li><li>在每一个子序列中分别采用直接插入排序。</li><li>然后缩小间隔 gap，将 gap &#x3D; gap&#x2F;2。</li><li>重复上述的子序列划分和排序工作，随着序列减少最后变为一个，也就完成了整个排序。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_shell.png"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i-gap;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;=<span class="number">0</span>; j = j-gap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; temp)&#123;</span><br><span class="line">                    arr[j+gap] = arr[j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-归并排序（Merge-sort）"><a href="#5-归并排序（Merge-sort）" class="headerlink" title="5. 归并排序（Merge sort）"></a>5. 归并排序（Merge sort）</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效、稳定的排序算法，该算法是采用分治法(Divide and Conquer）的一个非常典型的应用。<br>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并排序使用的就是分治思想。分治算法一般都是用递归来实现的。分治是一种解决问题的处理思想，递归是一种编程技巧，这两者并不冲突。</p><ul><li>归并排序步骤：<ol><li>先把数组从中间分成前后两部分子序列，然后对前后两部分分别排序，然后再合并。</li><li>前后两部分子序列递归重复上述步骤。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_merge.png"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序（稳定的排序算法）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    mergeSortRecursion(arr, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序递归调用函数</span></span><br><span class="line"><span class="comment"> * 给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，</span></span><br><span class="line"><span class="comment"> * 分割点下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSortRecursion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 分割点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> p + (r-p)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 递归左边排序</span></span><br><span class="line">    mergeSortRecursion(arr, p, q);</span><br><span class="line">    <span class="comment">// 递归右边排序</span></span><br><span class="line">    mergeSortRecursion(arr, q+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 合并左右</span></span><br><span class="line">    mergeResult(arr, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并</span></span><br><span class="line"><span class="comment"> * 将已经有序的 A[p...q]和 A[q+1....r]合并成一个有序的数组，并且放入 A[p....r]。</span></span><br><span class="line"><span class="comment"> * 具体我们申请一个临时数组 tmp，大小与 A[p...r]相同。我们用两个游标 i 和 j，分别指向 A[p...q]和 A[q+1...r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。</span></span><br><span class="line"><span class="comment"> * 继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中剩余的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p...r]中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeResult</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// i是arr前半部分下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p;</span><br><span class="line">    <span class="comment">// j是arr后半部分下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> q +<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// k是临时新数组temp下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当arr数组两边都还有数时,依次从小到大拷贝到临时新数组temp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">            temp[k] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i, end = q;</span><br><span class="line">    <span class="keyword">if</span> (j &lt;= r) &#123;</span><br><span class="line">        <span class="comment">// arr后半部分还有剩余(初始化时默认前半部分还有剩余)</span></span><br><span class="line">        start = j;</span><br><span class="line">        end = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组temp</span></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        temp[k++] = arr[start++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将排好序的temp数组拷贝回arr[p...r]</span></span><br><span class="line">    System.arraycopy(temp, <span class="number">0</span>, arr, p, temp.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-快速排序（Quick-Sort）"><a href="#6-快速排序（Quick-Sort）" class="headerlink" title="6. 快速排序（Quick Sort）"></a>6. 快速排序（Quick Sort）</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数。把小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p><ul><li>快速排序步骤：<ol><li>从数列中挑出一个元素，称为 “基准”（pivot）。</li><li>将小于基准的元素放在基准之前，大于基准的放在基准之后，再分别对小数区与大数区进行快速排序。</li><li>小数区与大数区子序列递归地重复上述步骤（直到分区子序列的大小是0或1）。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_quick.png"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quickSortRecursion(arr, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序递归函数，p,r为下标</span></span><br><span class="line"><span class="comment"> * 根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSortRecursion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 获取分区点下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> getPartitionIndex(arr, p, r);</span><br><span class="line">    System.out.println(<span class="string">&quot;pivotIndex=: &quot;</span> + q + <span class="string">&quot;,pivot=&quot;</span> + arr[q]);</span><br><span class="line">    System.out.println(Arrays.toString(Arrays.copyOfRange(arr, p, r+<span class="number">1</span>)));</span><br><span class="line">    <span class="comment">// 用递归排序下标从 p 到 q-1 之间的数据</span></span><br><span class="line">    quickSortRecursion(arr, p, q-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 用递归排序下标从 q+1 到 r 之间的数据</span></span><br><span class="line">    quickSortRecursion(arr, q+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取分区点</span></span><br><span class="line"><span class="comment"> * 随机选择一个元素作为分区点 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p...r]分区，返回 pivot 的下标。</span></span><br><span class="line"><span class="comment"> * 遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPartitionIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> p, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[r];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> p; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            swapArr(arr, i, j);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swapArr(arr, i, r);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapArr</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-堆排序（Heap-Sort）"><a href="#7-堆排序（Heap-Sort）" class="headerlink" title="7. 堆排序（Heap Sort）"></a>7. 堆排序（Heap Sort）</h3><p>堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。<br>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li><li><p>堆排序步骤：</p><ol><li>创建一个堆（建堆后数组中的第一个元素就是堆顶，大顶堆的堆顶也就是最大的元素）。</li><li>堆顶（最大值）和堆尾互换（最大元素就放到了下标为 <code>n</code> 的位置）。</li><li>剩下 <code>n-1</code> 个元素重复这个过程(堆化-&gt;取堆顶)。</li><li>直到最后堆中只剩下标为 1 的一个元素，排序完成。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_heap.png"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  堆排序</span></span><br><span class="line"><span class="comment"> *  len 表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    buildHeap(arr, len);</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> len;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        swapArr(arr, <span class="number">1</span>, k);</span><br><span class="line">        --k;</span><br><span class="line">        heapify(arr, k, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        heapify(arr, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPos</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= len &amp;&amp; arr[i] &lt; arr[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= len &amp;&amp; arr[maxPos] &lt; arr[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">        swapArr(arr, i, maxPos);</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swapArr</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[a];</span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-计数排序（Counting-Sort）"><a href="#8-计数排序（Counting-Sort）" class="headerlink" title="8. 计数排序（Counting Sort）"></a>8. 计数排序（Counting Sort）</h3><p>计数排序（Counting Sort）是一种牺牲内存空间来换取低时间复杂度的排序算法，同时它也是一种不基于比较的算法。<br>它的优势在于在对一定范围内的整数排序时，它的复杂度为<code>Ο(n+k)</code>（其中k是整数的范围），快于任何比较排序算法。<br>它适合于最大值和最小值的差值不是不是很大的排序。</p><p>基本思想：就是把数组元素作为数组的下标，然后用一个临时数组统计该元素出现的次数，例如 temp[i] &#x3D; m, 表示元素 i 一共出现了 m 次。最后再把临时数组统计的数据从小到大汇总起来，此时汇总起来是数据是有序的。</p><ul><li>计数排序步骤：<ol><li>找出待排序数组中最大值 <code>max</code> 和最小值 <code>min</code>；</li><li>创建临时数组，大小为 <code>(max - min + 1)</code>；</li><li>统计待排序数组中每个值为<code>i</code>的元素出现的次数，存入临时数组的第<code>i</code>项；</li><li>反向填充目标数组：依次从临时数组中取出放入新数组。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_counting.gif"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 寻找数组的最大值与最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line">    <span class="comment">// 创建大小为(max - min + 1)的临时数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[range];</span><br><span class="line">    <span class="comment">// 统计元素i出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        temp[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把临时数组统计好的数据汇总到原数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> temp[i]; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            arr[k++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找数组的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; value) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找数组的最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; value) &#123;</span><br><span class="line">            min = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-桶排序（Bucket-Sort）"><a href="#9-桶排序（Bucket-Sort）" class="headerlink" title="9. 桶排序（Bucket Sort）"></a>9. 桶排序（Bucket Sort）</h3><p>桶排序（Bucket sort）是计数排序的升级版。核心思想是将要排序的数据分到几个有序的“桶”里，每个桶里的数据再单独进行排序。<br>桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br>桶排序的表现取决于数据的分布。当数据在各个桶之间的分布是比较均匀的，排序效率非常高；在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><p><img src="/2022/05/25/data-structure-sort/12_bucket.png"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桶排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 寻找数组的最大值与最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> getMin(arr);</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(arr);</span><br><span class="line">    <span class="comment">// 创建 (max - min) / 5 + 1 个桶，第 i 桶存放  5*i ~ 5*i+5-1范围的数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> max - min;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> range / <span class="number">5</span> + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketNum);</span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历原数组，将每个元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : arr) &#123;</span><br><span class="line">        bucketList.get((a - min) / range).add(a - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对桶内的元素进行排序，我这里采用系统自带的排序工具</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        Collections.sort(bucketList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把每个桶排序好的数据进行合并汇总放回原数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer t : bucketList.get(i)) &#123;</span><br><span class="line">            arr[k++] = t + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-基数排序（Radix-Sort）"><a href="#10-基数排序（Radix-Sort）" class="headerlink" title="10. 基数排序（Radix Sort）"></a>10. 基数排序（Radix Sort）</h3><p>基数排序（Radix Sort）要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。<br>而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。<br>基数排序的方式可以采用最低位优先LSD（Least sgnificant digital）法或最高位优先MSD（Most sgnificant digital）法，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><ul><li>基数排序步骤：<ol><li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。</li><li>然后，从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li></ol></li></ul><p><img src="/2022/05/25/data-structure-sort/12_radix.gif"></p><p>Java代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span> ) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算最大值是几位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> getMaxNum(arr);</span><br><span class="line">    <span class="comment">// 创建10个桶</span></span><br><span class="line">    ArrayList&lt;LinkedList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 初始化桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行每一趟的排序，从个位数开始排</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取每个数最后第 i 位是数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">radio</span> <span class="operator">=</span> (arr[j] / (<span class="type">int</span>)Math.pow(<span class="number">10</span>,i-<span class="number">1</span>)) % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">// 放进对应的桶里</span></span><br><span class="line">            bucketList.get(radio).add(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合并放回原数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer t : bucketList.get(j)) &#123;</span><br><span class="line">                arr[k++] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出来合并了之后把桶清光数据</span></span><br><span class="line">            bucketList.get(j).clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算最大值是几位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxNum</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 寻找数组的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; value) &#123;</span><br><span class="line">            max = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最大值是几位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (max / <span class="number">10</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        max = max / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」图（Graph）</title>
      <link href="/2022/05/10/data-structure-graph.html"/>
      <url>/2022/05/10/data-structure-graph.html</url>
      
        <content type="html"><![CDATA[<p><strong>图（Graph）</strong>。和树比起来，这是一种<strong>更加复杂的非线性表结构</strong>，由顶点和连接每对顶点的边所构成的抽象网络就是图。</p><p>图的定义：图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：<code>G(V,E)</code>，其中，<code>G</code>表示一个图，<code>V</code>是顶点的集合，<code>E</code>是边的集合。</p><p>图中的元素叫做<code>顶点（vertex）</code>。顶点与其他顶点建立的连接关系叫做<code>边（edge）</code>。跟顶点相连接的边的条数叫做顶点的<code>度（degree）</code>。</p><p>如果图中任意两个顶点之间的边都是无向边（边没有方向），则称该图为<code>无向图（Undirected graphs）</code>。<br>以此类推，把边有方向的图称为<code>有向图（Directed graphs）</code>。</p><ul><li>完全图：<ul><li>①无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</li><li>②有向完全图：在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。</li></ul></li><li>当一个图接近完全图时，则称它为<code>稠密图（Dense Graph）</code>，而当一个图含有较少的边时，则称它为<code>稀疏图（Spare Graph）</code>。<span id="more"></span></li></ul><h3 id="1-图的存储方式"><a href="#1-图的存储方式" class="headerlink" title="1. 图的存储方式"></a>1. 图的存储方式</h3><p>图的两个主要的存储方式：<strong>邻接矩阵</strong>和<strong>邻接表</strong>。<br>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。<br>邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p><h4 id="邻接矩阵（Adjacency-Matrix）"><a href="#邻接矩阵（Adjacency-Matrix）" class="headerlink" title="邻接矩阵（Adjacency Matrix）"></a>邻接矩阵（Adjacency Matrix）</h4><p>邻接矩阵的底层依赖一个二维数组。<br>对于无向图来说，如果顶点 <code>i</code> 与顶点 <code>j</code> 之间有边，我们就将 <code>A[i][j]</code>和 <code>A[j][i]</code>标记为 <code>1</code>；<br>对于有向图来说，如果顶点 <code>i</code> 到顶点 <code>j</code> 之间，有一条箭头从顶点 <code>i</code> 指向顶点 <code>j</code> 的边，那我们就将 <code>A[i][j]</code>标记为 <code>1</code>；<br>对于带权图，数组中就存储相应的权重。</p><p><img src="/2022/05/10/data-structure-graph/11_01.webp"><br>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。</p><h4 id="邻接表（Adjacency-List）"><a href="#邻接表（Adjacency-List）" class="headerlink" title="邻接表（Adjacency List）"></a>邻接表（Adjacency List）</h4><p>图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。<br>对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点。</p><p><img src="/2022/05/10/data-structure-graph/11_02.webp"><br>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p><p>可以将邻接表中的链表改成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表、有序动态数组等。</p><h3 id="2-深度和广度优先搜索"><a href="#2-深度和广度优先搜索" class="headerlink" title="2. 深度和广度优先搜索"></a>2. 深度和广度优先搜索</h3><p>算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。<br>这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p><h4 id="2-1-广度优先搜索（BFS）"><a href="#2-1-广度优先搜索（BFS）" class="headerlink" title="2.1 广度优先搜索（BFS）"></a>2.1 广度优先搜索（BFS）</h4><p><code>广度优先搜索（Breadth-First-Search）</code>，我们平常都简称 <code>BFS</code>。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。</p><p><img src="/2022/05/10/data-structure-graph/11_03.webp"></p><p>尽管广度优先搜索的原理挺简单，但代码实现还是稍微有点复杂度。</p><p>代码里面，<code>bfs()</code> 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 <code>s</code> 表示起始顶点，<code>t</code> 表示终止顶点。我们搜索一条从 <code>s</code> 到 <code>t</code> 的路径。实际上，这样求得的路径就是从 <code>s</code> 到 <code>t</code> 的最短路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先搜索</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int s 起始顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int t 终止顶点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// visited 是用来记录已经被访问的顶点，用来避免顶点被重复访问。</span></span><br><span class="line">  <span class="comment">// 如果顶点 q 被访问，那相应的 visited[q]会被设置为 true</span></span><br><span class="line">  <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// queue 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。</span></span><br><span class="line">  <span class="comment">// 因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。</span></span><br><span class="line">  <span class="comment">// 当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。</span></span><br><span class="line">  <span class="comment">// 所以，我们用这个队列来实现记录的功能。</span></span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="comment">// prev 用来记录搜索路径。</span></span><br><span class="line">  <span class="comment">// 当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。</span></span><br><span class="line">  <span class="comment">// 不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。</span></span><br><span class="line">  <span class="comment">// 比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。</span></span><br><span class="line">  <span class="comment">// 为了正向打印出路径，我们需要递归地来打印。</span></span><br><span class="line">  <span class="type">int</span>[] prev = <span class="keyword">new</span> <span class="title class_">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="literal">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归打印s-&gt;t的路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] prev, <span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广度优先搜索的分解图：</p><p><img src="/2022/05/10/data-structure-graph/11_04.webp"><br><img src="/2022/05/10/data-structure-graph/11_05.webp"><br><img src="/2022/05/10/data-structure-graph/11_06.webp"></p><p>最坏情况下，终止顶点 <code>t</code> 离起始顶点 <code>s</code> 很远，需要遍历完整个图才能找到。<br>这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 <code>O(V+E)</code>，其中，<code>V</code> 表示顶点的个数，<code>E</code> 表示边的个数。<br>当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，<code>E</code> 肯定要大于等于 <code>V-1</code>，所以，广度优先搜索的<strong>时间复杂度</strong>也可以简写为 <code>O(E)</code>。</p><p>广度优先搜索的空间消耗主要在几个辅助变量 <code>visited</code> 数组、<code>queue</code> 队列、<code>prev</code> 数组上。这三个存储空间的大小都不会超过顶点的个数，所以<strong>空间复杂度</strong>是 <code>O(V)</code>。</p><h4 id="2-2-深度优先搜索（DFS）"><a href="#2-2-深度优先搜索（DFS）" class="headerlink" title="2.2 深度优先搜索（DFS）"></a>2.2 深度优先搜索（DFS）</h4><p><code>深度优先搜索（Depth-First-Search）</code>，简称 <code>DFS</code>。它会尽可能深地搜索分支，最直观的例子就是“走迷宫”。<br>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>如下图。用深度递归算法搜索一条从 <code>s</code> 到 <code>t</code> 的路径，实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点 <code>s</code> 到顶点 <code>t</code> 的最短路径。</p><p><img src="/2022/05/10/data-structure-graph/11_07.webp"></p><p>深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。</p><p>深度优先搜索代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">  <span class="comment">// found，的作用是，当我们已经找到终止顶点 t 之后，我们就不再递归地继续查找了。</span></span><br><span class="line">  found = <span class="literal">false</span>;</span><br><span class="line">  <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[v];</span><br><span class="line">  <span class="type">int</span>[] prev = <span class="keyword">new</span> <span class="title class_">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recurDfs</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> t, <span class="type">boolean</span>[] visited, <span class="type">int</span>[] prev)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的<strong>时间复杂度</strong>是 <code>O(E)</code>，<code>E</code> 表示边的个数。<br>深度优先搜索算法的消耗内存主要是 <code>visited</code>、<code>prev</code> 数组和递归调用栈。<code>visited</code>、<code>prev</code> 数组的大小跟顶点的个数 <code>V</code> 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的<strong>空间复杂度</strong>就是 <code>O(V)</code>。</p><h4 id="2-3-深度和广度优先搜索总结"><a href="#2-3-深度和广度优先搜索总结" class="headerlink" title="2.3 深度和广度优先搜索总结"></a>2.3 深度和广度优先搜索总结</h4><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法。广度优先搜索（BFS）和 深度优先搜索（DFS）搜索统称<strong>暴力搜索算法</strong>，适用于<strong>图不大的搜索</strong>。<br>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。<br>深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。<br>在执行效率方面，深度优先和广度优先搜索的**时间复杂度都是 O(E)，空间复杂度是 O(V)**。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」堆（Heap）</title>
      <link href="/2022/05/02/data-structure-heap.html"/>
      <url>/2022/05/02/data-structure-heap.html</url>
      
        <content type="html"><![CDATA[<p>堆的两点要求：</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。<ul><li>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做<strong>大顶堆</strong>。</li><li>对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做<strong>小顶堆</strong>。<span id="more"></span></li></ul></li></ul><blockquote><ul><li><strong>完全二叉树</strong>：除最后一层外，其他层的节点都满；并且最后一层的节点从左到右是连续排列，中间没有断开，空位都在右边。</li><li>在构建完全二叉树的时候，新加入的节点在最后一层从左往右依次排列，直到排满为止。</li></ul></blockquote><p>有两种方法存储一棵二叉树，一种是基于指针或者引用的<strong>二叉链式存储法</strong>，一种是基于<code>数组</code>的<strong>顺序存储法</strong>。<br><strong>堆</strong>是一种<strong>完全二叉树</strong>，最常用的存储方式就是基于<strong>数组</strong>的顺序存储法。</p><h3 id="1-基于数组的顺序存储法。"><a href="#1-基于数组的顺序存储法。" class="headerlink" title="1. 基于数组的顺序存储法。"></a>1. 基于数组的顺序存储法。</h3><p>如下图，我们把根节点存储在数组下标 <code>i=1</code> 的位置，那左子节点存储在下标 <code>2*i = 2</code> 的位置，右子节点存储在 <code>2*i+1 = 3</code> 的位置。以此类推，<code>B</code>节点的左子节点存储在 <code>2*i = 2*2 = 4</code> 的位置，右子节点存储在 <code>2*i+1 = 2*2+1 = 5</code> 的位置。</p><p><img src="/2022/05/02/data-structure-heap/10_01.webp"></p><p>如果节点<code>X</code>存储在数组中下标为 <code>i</code> 的位置，下标为 <code>2*i</code> 的位置存储的就是左子节点，下标为<code> 2*i+1</code> 的位置存储的就是右子节点。<br>反过来，下标为 <code>i/2</code> 的位置存储就是它的父节点。<br>通过这种方式，我们只要知道根节点存储的位置（通常根节点会存储在下标为<code>1</code>的位置），这样就可以通过下标计算，把整棵树都串起来。</p><h3 id="2-堆化（heapify）"><a href="#2-堆化（heapify）" class="headerlink" title="2. 堆化（heapify）"></a>2. 堆化（heapify）</h3><p>往堆中插入或者删除一个元素后，需要继续满足堆的两个特性，而这个<strong>重新维持堆特性的过程</strong>称为<code>堆化（heapify）</code>。</p><p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，比较，然后交换。<br>堆化实际上有两种：从下往上、从上往下。</p><ul><li>插入元素时涉及的是<code>从下往上</code>的堆化方法。</li><li>删除堆顶元素涉及的是<code>从上往下</code>的堆化方法。</li></ul><h3 id="3-往堆中插入一个元素"><a href="#3-往堆中插入一个元素" class="headerlink" title="3. 往堆中插入一个元素"></a>3. 往堆中插入一个元素</h3><p>把新插入的元素放到堆的最后，需要继续满足堆的两个特性。</p><p><img src="/2022/05/02/data-structure-heap/10_02.webp"></p><p>从下往上的堆化：<br>让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。<br>一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p><p><img src="/2022/05/02/data-structure-heap/10_03.webp"></p><p>往堆中插入数据的过程，翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span>[] a; <span class="comment">// 数组，从下标1开始存储数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;  <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">    n = capacity;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= n) <span class="keyword">return</span>; <span class="comment">// 堆满了</span></span><br><span class="line">    ++count;</span><br><span class="line">    a[count] = data;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count;</span><br><span class="line">    <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) &#123; <span class="comment">// 自下往上堆化</span></span><br><span class="line">      swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap()函数作用：交换下标为i和i/2的两个元素</span></span><br><span class="line">      i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-删除堆顶元素"><a href="#4-删除堆顶元素" class="headerlink" title="4. 删除堆顶元素"></a>4. 删除堆顶元素</h3><p>从堆的特性可以看出，堆顶元素存储的就是堆中数据的最大值或者最小值。<br>从上往下的堆化：<br>当我们删除堆顶元素之后，把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。</p><p><img src="/2022/05/02/data-structure-heap/10_04.webp"></p><p>堆顶元素删除的过程，翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMax</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 堆中没有数据</span></span><br><span class="line">  a[<span class="number">1</span>] = a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123; <span class="comment">// 自上往下堆化</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPos</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-堆化的时间复杂度"><a href="#2-堆化的时间复杂度" class="headerlink" title="2. 堆化的时间复杂度"></a>2. 堆化的时间复杂度</h3><p>一个包含 <code>n</code> 个节点的完全二叉树，树的高度不会超过 <code>log2​n</code>。<br>堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <code>O(logn)</code>。<br>插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <code>O(logn)</code>。</p><h3 id="3-堆排序（heap-sort）"><a href="#3-堆排序（heap-sort）" class="headerlink" title="3. 堆排序（heap sort）"></a>3. 堆排序（heap sort）</h3><p><code>堆排序（heap sort）</code>是基于堆的一种排序，堆排序的过程大致分为两大步骤：<strong>建堆</strong>和<strong>排序</strong>。</p><p><strong>大顶堆</strong>：每个节点的值都大于等于子树中每个节点值。<br><strong>小顶堆</strong>：每个节点的值都小于等于子树中每个节点值。<br>求升序用大顶堆，求降序用小顶堆。</p><h4 id="3-1-堆的构建"><a href="#3-1-堆的构建" class="headerlink" title="3.1 堆的构建"></a>3.1 堆的构建</h4><p>这里提供一种构建思路：从最后一个非叶子节点开始从后往前处理数组，并且每个数据都是从上往下堆化。</p><p>包含 <code>n</code> 个节点的完全二叉树来说，下标从 <code>2/n​+1</code> 到 <code>n</code> 的节点都是叶子节点；我们对下标从 <code>2/n​</code> 开始到 <code>1</code> 的节点（非叶子节点）开始处理数组。</p><p>如下图，9个节点，从数组下标4开始处理数组，构建大顶堆。</p><p><img src="/2022/05/02/data-structure-heap/10_05.png"></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxPos</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) maxPos = i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxPos == i) <span class="keyword">break</span>;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i = maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序的建堆过程的时间复杂度是 <code>O(n)</code>。</p><p>每个节点堆化的时间复杂度是 <code>O(logn)</code>，因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。<br>每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度成正比。通过将每个非叶子节点的高度求和，最终求得建堆的时间复杂度就是 <code>O(n)</code>。</p><h4 id="3-2-排序"><a href="#3-2-排序" class="headerlink" title="3.2 排序"></a>3.2 排序</h4><p>建堆结束之后，数组中的第一个元素就是堆顶，大顶堆的堆顶也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 <code>n</code> 的位置。剩下 <code>n-1</code> 个元素重复这个过程(堆化-&gt;取堆顶)。一直重复，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p><p><img src="/2022/05/02/data-structure-heap/10_06.png"></p><p>堆排序的过程代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n表示数据的个数，数组a中的数据从下标1到n的位置。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">  <span class="keyword">while</span> (k &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    swap(a, <span class="number">1</span>, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。<br>堆排序包括建堆和排序两个操作，<br>建堆过程的时间复杂度是 <code>O(n)</code>，<br>排序过程的时间复杂度是 <code>O(nlogn)</code>，<br>所以，堆排序整体的时间复杂度是 <code>O(nlogn)</code>。<br>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><blockquote><p>在实际开发中，为什么快速排序要比堆排序性能好？</p><ol><li>第一点，堆排序数据访问的方式没有快速排序友好。<ul><li>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的（堆化）。 CPU对于顺序访问的数据更加友好，可以做缓存。</li></ul></li><li>第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。<ul><li>堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。</li></ul></li></ol></blockquote><h3 id="4-堆的应用"><a href="#4-堆的应用" class="headerlink" title="4. 堆的应用"></a>4. 堆的应用</h3><h4 id="4-1-优先级队列"><a href="#4-1-优先级队列" class="headerlink" title="4.1 优先级队列"></a>4.1 优先级队列</h4><p>在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>用堆来实现是最直接、最高效的。<br>这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。<br>很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><p>优先级队列的应用广泛，如赫夫曼编码，图的最短路径，做小生成树的算法等。</p><h4 id="4-2-利用堆求Top-K"><a href="#4-2-利用堆求Top-K" class="headerlink" title="4.2 利用堆求Top K"></a>4.2 利用堆求Top K</h4><ol><li>针对静态数据：<ul><li>可以维护一个大小为k的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果堆顶元素大，就将堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前k大数据了。</li><li>遍历数据需要<code>O(n)</code>的时间复杂度，一次堆化操作需要<code>O(logk)</code>的时间复杂度，最坏情况下，<code>n</code>个元素都入堆一次，时间复杂度就是<code>O(nlogk)</code>。</li></ul></li><li>针对动态数据：求得Topk就是实时Topk。<ul><li>一个数据集合有两个操作，一个是添加数据，另一个询问当前的前k大数据。</li><li>可以维护一直都维护一个k大小的小顶堆，当有数据被添加到集合时，就那它与堆顶的元素对对比。如果比堆顶元素大，就把堆顶元素删除，并将这个元素插入到堆中，如果比堆顶元素小，这不处理。这样，无论任何时候需要查询当前的前k大数据，就都可以 立刻返回给他。</li></ul></li></ol><h4 id="4-2-利用堆求中位数"><a href="#4-2-利用堆求中位数" class="headerlink" title="4.2 利用堆求中位数"></a>4.2 利用堆求中位数</h4><ol><li>对于一组静态数据，中位数是固定的，可以先排序，第<code>n/2</code>个数据就是中位数。</li><li>对于动态数据集合，就无法先排序了，需要借助堆这种数据结构，我们不用排序，就可以非常高效的实现求中位数操作。</li></ol><ul><li>实现思路：<ol><li>需要维护两个堆，大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</li><li>如果新加入的数据小于等于大顶堆的堆顶元素，就将这个数据插入到大顶堆；否则就插入小顶堆。</li><li>当两个堆中的数据量不服和中位数的约定时，就从一个堆中不停的将堆顶的元素移动到另一个堆，重新让两个堆中数据满足上面的约定。</li></ol></li></ul><p>可以利用两个堆实现动态数据集合中求中位数的操作，插入数据因为涉及堆化，所以时间复杂度变成了<code>O(logn)</code>，但求中位数只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是<code>O(1)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」红黑树（Red-Black Tree）</title>
      <link href="/2022/04/25/data-structure-redblacktree.html"/>
      <url>/2022/04/25/data-structure-redblacktree.html</url>
      
        <content type="html"><![CDATA[<p>平衡二叉查找树其实有很多，比如，红黑树（Red-Black Tree，简称 R-B Tree）、伸展树（Splay Tree）、树堆（Treap）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树，它是一种不严格的平衡二叉查找树。<br>红黑树是一种含有红黑节点并能自平衡的二叉查找树。它必须满足下面性质：</p><ol><li>每个节点要么是红色，要么是黑色；</li><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>任意一节点到每个叶子节点的路径，都包含相同数目的黑色节点；<span id="more"></span></li></ol><h3 id="1-红黑树的平衡特征"><a href="#1-红黑树的平衡特征" class="headerlink" title="1. 红黑树的平衡特征"></a>1. 红黑树的平衡特征</h3><p>红黑树与<code>AVL</code>树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。</p><p><strong>红黑树牺牲了部分平衡性</strong>，以换取插入&#x2F;删除操作时较少的旋转操作，整体来说性能要优于<code>AVL</code>树。</p><p>红黑树的黑色属性（即性质第五点）：任意一节点到每个叶子节点的路径，都包含相同数目的黑色节点。<br>黑色属性，可以理解为<strong>平衡特征</strong>， 如果满足不了平衡特征，就要进行平衡操作（变色、左旋、右旋）。</p><p>红黑树的平衡条件，是以<strong>黑色节点的高度</strong>来约束的，所以称红黑树这种平衡为<strong>黑色完美平衡</strong>。</p><p>如下图，去掉红色节点，会得到一个四叉树， 从根节点到每一个叶子节点高度相同，就是红黑树的根节点到叶子的黑色路径长度。<br><img src="/2022/04/25/data-structure-redblacktree/09_01.png"></p><h3 id="2-红黑树的平衡调整"><a href="#2-红黑树的平衡调整" class="headerlink" title="2. 红黑树的平衡调整"></a>2. 红黑树的平衡调整</h3><p>三种操作：左旋（rotate left）、右旋（rotate right）和 变色。</p><ul><li><p>左旋，即是<strong>逆时针</strong>旋转，以某个节点作为旋转点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变；<br><img src="/2022/04/25/data-structure-redblacktree/rotate_left.gif"></p></li><li><p>右旋，即是<strong>顺时针</strong>旋转，以某个节点作为旋转点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。<br><img src="/2022/04/25/data-structure-redblacktree/rotate_right.gif"></p></li><li><p>变色，节点的颜色由红变黑或由黑变红；</p></li></ul><h3 id="3-插入操作的平衡调整"><a href="#3-插入操作的平衡调整" class="headerlink" title="3. 插入操作的平衡调整"></a>3. 插入操作的平衡调整</h3><p>红黑树规定，<strong>插入的节点一定是红色的</strong>。而且，<strong>二叉查找树中新插入的节点都是放在叶子节点上</strong>。</p><p>红黑树的平衡调整过程是一个迭代的过程。<br>我们把正在处理的节点叫做<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。<strong>最开始的关注节点就是新插入的节点</strong>。</p><ol><li><p>新插入节点的父节点是黑色的，红黑树不需要调整。</p></li><li><p>新插入节点是根节点，<strong>根节点变黑</strong>即可。</p></li><li><p>新插入节点的父节点和它的叔叔都是红色，红黑树只需要<strong>变色</strong>，不需要旋转。<br><img src="/2022/04/25/data-structure-redblacktree/09_02.png"></p></li><li><p>新插入节点的父节点是红色，但它叔叔是黑色（可能为null的黑色空节点），红黑树需要<strong>变色+旋转</strong>。</p></li></ol><p>需要红黑树<strong>变色+旋转</strong>（父节点红色，叔节点黑色）的四种情形：</p><ul><li><p>一、<strong>LL型</strong>（左左插），即父节点和插入的节点都是左节点：</p><ul><li>①父节点变黑色，爷节点变红色</li><li>②爷节点右旋<br><img src="/2022/04/25/data-structure-redblacktree/09_03.png"></li></ul></li><li><p>二、<strong>LR型</strong>（左右插），即父节点是左节点，插入节点是右节点：</p><ul><li>①父节点左旋，父子交换变成了【情形一·LL】</li><li>②跳到【LL型】的调整<br><img src="/2022/04/25/data-structure-redblacktree/09_04.png"></li></ul></li><li><p>三、<strong>RR型</strong>（右右插），即父节点和插入的节点都是右节点：</p><ul><li>①父节点变黑色，爷节点变红色</li><li>②爷节点左旋<br><img src="/2022/04/25/data-structure-redblacktree/09_05.png"></li></ul></li><li><p>二、<strong>RL型</strong>（右左插），即父节点是右节点，插入的节点是左节点：</p><ul><li>①父节点右旋，父子交换变成了【情形三·RR】</li><li>②跳到【RR型】的调整<br><img src="/2022/04/25/data-structure-redblacktree/09_06.png"></li></ul></li></ul><h3 id="4-删除操作的平衡调整"><a href="#4-删除操作的平衡调整" class="headerlink" title="4. 删除操作的平衡调整"></a>4. 删除操作的平衡调整</h3><p>红黑树的删除情况相对插入会复杂一些，不过原理都是类似的。</p><h4 id="4-1-二叉查找树的删除操作"><a href="#4-1-二叉查找树的删除操作" class="headerlink" title="4.1 二叉查找树的删除操作"></a>4.1 二叉查找树的删除操作</h4><ol><li>待删除节点没有子节点，将父节点中，指向要删除节点的指针置为<code>null</code>。</li><li>待删除节点只有一个子节点，更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点。</li><li>待删除节点有两个子节点，用后继节点或者前继节点替换删除节点，然后再删除掉替换节点。<blockquote><ul><li>后继节点：删除节点的右子树中的最小节点，即右子树中最左节点。</li><li>前继节点：删除节点的左子树中最大节点，即左子树中最右节点。</li></ul></blockquote></li></ol><h4 id="4-2-红黑树的删除动作"><a href="#4-2-红黑树的删除动作" class="headerlink" title="4.2 红黑树的删除动作"></a>4.2 红黑树的删除动作</h4><p>红黑树和二叉查找树的删除类似，只不过加上颜色属性（这里的子节点均指<strong>非黑色叶子NULL节点</strong>）：</p><ol><li><p>无子节点时，删除节点可能为红色或者黑色；</p><ul><li>1.1 如果为红色，直接删除即可，不会影响黑色节点的数量；</li><li>1.2 如果为黑色，则需要进行删除平衡的操作（如果是根节点，无需平衡操作）；<br><img src="/2022/04/25/data-structure-redblacktree/09_07.png"></li></ul></li><li><p>只有一个子节点时，删除节点只能是黑色，其子节点是红色（否则无法满足红黑树的性质）。 此时用删除节点的子节点接到父节点，且将子节点颜色涂黑，保证黑色数量。<br><img src="/2022/04/25/data-structure-redblacktree/09_08.png"></p></li><li><p>有两个子节点时，与二叉搜索树一样，使用后继节点作为替换的删除节点，情形转至为【1】或【2】处理。<br><img src="/2022/04/25/data-structure-redblacktree/09_09.png"></p></li></ol><p>删除情形【3】总是会转换为情形【1】或【2】的，<br>而情形【1.2】（删除节点无子节点且是黑色）还需要额外的平衡调整；<br>因为一旦该节点被拿掉，红黑树中通过该节点的路径黑色节点数量将会减1，而且无法像情形【2】那样将子节点涂黑来达到平衡。此时只能自底向上进行平衡操作。</p><h4 id="4-3-红黑树删除后的平衡操作"><a href="#4-3-红黑树删除后的平衡操作" class="headerlink" title="4.3 红黑树删除后的平衡操作"></a>4.3 红黑树删除后的平衡操作</h4><p>为了简化描述，先约定关注节点及相关节点的名称：<br><img src="/2022/04/25/data-structure-redblacktree/09_10.png"></p><h5 id="【情形-1-1】：-兄黑（S-黑），兄子全黑（L-和-R-全黑），父红（P-红）；"><a href="#【情形-1-1】：-兄黑（S-黑），兄子全黑（L-和-R-全黑），父红（P-红）；" class="headerlink" title="【情形 1.1】： 兄黑（S 黑），兄子全黑（L 和 R 全黑），父红（P 红）；"></a>【情形 1.1】： 兄黑（S 黑），兄子全黑（L 和 R 全黑），父红（P 红）；</h5><p>即 兄弟节点为黑色，兄弟节点的子节点全部黑色，父节点为红色。<br><img src="/2022/04/25/data-structure-redblacktree/09_12.png"></p><h5 id="【情形-1-2】：-兄黑（S-黑），兄子全黑（L-和-R-全黑），父黑（P-黑）；"><a href="#【情形-1-2】：-兄黑（S-黑），兄子全黑（L-和-R-全黑），父黑（P-黑）；" class="headerlink" title="【情形 1.2】： 兄黑（S 黑），兄子全黑（L 和 R 全黑），父黑（P 黑）；"></a>【情形 1.2】： 兄黑（S 黑），兄子全黑（L 和 R 全黑），父黑（P 黑）；</h5><p>即 兄弟节点为黑色，兄弟节点的子节点全部黑色，父节点为黑色。<br><img src="/2022/04/25/data-structure-redblacktree/09_13.png"></p><h5 id="【情形-2-1】：-兄黑（S-黑），兄在左（S-左），兄左子红（L-红）；"><a href="#【情形-2-1】：-兄黑（S-黑），兄在左（S-左），兄左子红（L-红）；" class="headerlink" title="【情形 2.1】： 兄黑（S 黑），兄在左（S 左），兄左子红（L 红）；"></a>【情形 2.1】： 兄黑（S 黑），兄在左（S 左），兄左子红（L 红）；</h5><p>即 兄弟节点为黑色，且兄弟节点在左边，兄弟节点的左子节点为红色。<br><img src="/2022/04/25/data-structure-redblacktree/09_14.png"></p><h5 id="【情形-2-2】：-兄黑（S-黑），兄在左（S-左），兄左子黑（L-黑）；"><a href="#【情形-2-2】：-兄黑（S-黑），兄在左（S-左），兄左子黑（L-黑）；" class="headerlink" title="【情形 2.2】： 兄黑（S 黑），兄在左（S 左），兄左子黑（L 黑）；"></a>【情形 2.2】： 兄黑（S 黑），兄在左（S 左），兄左子黑（L 黑）；</h5><p>即 兄弟节点为黑色，且兄弟节点在左边，兄弟节点的左子节点为黑色。<br><img src="/2022/04/25/data-structure-redblacktree/09_15.png"></p><h5 id="【情形-2-3】：-兄黑（S-黑），兄在右（S-右），兄右子红（R-红）；"><a href="#【情形-2-3】：-兄黑（S-黑），兄在右（S-右），兄右子红（R-红）；" class="headerlink" title="【情形 2.3】： 兄黑（S 黑），兄在右（S 右），兄右子红（R 红）；"></a>【情形 2.3】： 兄黑（S 黑），兄在右（S 右），兄右子红（R 红）；</h5><p>即 兄弟节点为黑色，且兄弟节点在右边，兄弟节点的右子节点为红色。<br><img src="/2022/04/25/data-structure-redblacktree/09_16.png"></p><h5 id="【情形-2-4】：-兄黑（S-黑），兄在右（S-右），兄右子黑（R-黑）；"><a href="#【情形-2-4】：-兄黑（S-黑），兄在右（S-右），兄右子黑（R-黑）；" class="headerlink" title="【情形 2.4】： 兄黑（S 黑），兄在右（S 右），兄右子黑（R 黑）；"></a>【情形 2.4】： 兄黑（S 黑），兄在右（S 右），兄右子黑（R 黑）；</h5><p>即 兄弟节点为黑色，且兄弟节点在右边，兄弟节点的右子节点为黑色。<br><img src="/2022/04/25/data-structure-redblacktree/09_17.png"></p><h5 id="【情形-3-1】：-兄红（S-红），兄在左（S-左）；"><a href="#【情形-3-1】：-兄红（S-红），兄在左（S-左）；" class="headerlink" title="【情形 3.1】： 兄红（S 红），兄在左（S 左）；"></a>【情形 3.1】： 兄红（S 红），兄在左（S 左）；</h5><p>即 兄弟节点为红色，且兄弟节点在左边。<br><img src="/2022/04/25/data-structure-redblacktree/09_18.png"></p><h5 id="【情形-3-2】：-兄红（S-红），兄在右（S-右）；"><a href="#【情形-3-2】：-兄红（S-红），兄在右（S-右）；" class="headerlink" title="【情形 3.2】： 兄红（S 红），兄在右（S 右）；"></a>【情形 3.2】： 兄红（S 红），兄在右（S 右）；</h5><p>即 兄弟节点为红色，且兄弟节点在右边。<br><img src="/2022/04/25/data-structure-redblacktree/09_19.png"></p><h4 id="4-4-红黑树删除总结"><a href="#4-4-红黑树删除总结" class="headerlink" title="4.4 红黑树删除总结"></a>4.4 红黑树删除总结</h4><p>删除动作（移除节点）之后，若待平衡节点是黑色的叶子节点：<br>平衡调整情形，主要根据 [兄节点的位置&#x2F;颜色]、[兄的子节点的颜色]、[父节点颜色] 进行分类：<br><img src="/2022/04/25/data-structure-redblacktree/09_11.png"></p><h3 id="5-红黑树的应用场景"><a href="#5-红黑树的应用场景" class="headerlink" title="5. 红黑树的应用场景"></a>5. 红黑树的应用场景</h3><p>二叉查找树的时间复杂度会受到其树深度的影响，而红黑树可以保证在最坏情况下的时间复杂度仍为O(lgn)。<br>当数据量多到一定程度时，使用红黑树比二叉查找树的效率要高。</p><blockquote><p>平衡二叉树的时间复杂度是O(logn)，红黑树的时间复杂度为O(lgn)，两者都表示的都是时间复杂度为对数关系（lg 函数为底是 10 的对数）。</p></blockquote><p>同平衡二叉树相比较，红黑树没有像平衡二叉树对平衡性要求的那么苛刻，虽然两者的时间复杂度相同，但是红黑树在实际测算中的速度要更胜一筹！</p><p>红黑树的使用非常广泛，</p><ul><li>如<code>Java</code>的<code>TreeMap</code>和<code>TreeSet</code>都是基于红黑树实现的（相对与<code>HashMap</code>优势，内部<code>key</code>保持有序，且支持自定义排序比较器）；</li><li>而<code>JDK8</code>中<code>HashMap</code>当链表长度大于<code>8</code>时也会转化为红黑树（时间复杂度从<code>O(n)--&gt;O(lgn)</code> ，且自旋开销比其他树低）。</li><li>其他：如epoll在内核中的实现，用红黑树管理事件块（文件描述符）；linux进程调度Completely Fair Scheduler，用红黑树管理进程控制块；nginx中，用红黑树管理timer等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」AVL树</title>
      <link href="/2022/04/15/data-structure-avltree.html"/>
      <url>/2022/04/15/data-structure-avltree.html</url>
      
        <content type="html"><![CDATA[<p><code>AVL</code>树（得名于发明者G. M. Adelson-Velsky 和 E. M. Landis）本质上是一棵带有平衡条件的二叉搜索树。<br><code>AVL</code>树具有以下<code>2</code>个性质：</p><ol><li>左子树和右子树的深度之差的绝对值不超过<code>1</code>；</li><li>左子树和右子树全都是 <code>AVL</code>树。<span id="more"></span></li></ol><p>其中为了度量左右子树的深度之差，我们引入<code>平衡因子(BF)</code>的概念。</p><blockquote><p>平衡因子： 某个节点的左子树的高度减去右子树的高度得到的差值。</p></blockquote><p>对于一棵 <code>AVL</code>树，里面的所有节点的平衡因子只能取值于<code>-1、0、1</code>，否则，<code>AVL</code>树将是不平衡的并且需要平衡调整。</p><h3 id="1-AVL-树平衡调整"><a href="#1-AVL-树平衡调整" class="headerlink" title="1. AVL 树平衡调整"></a>1. AVL 树平衡调整</h3><p>二叉树的平衡化有两大基础操作： 左旋（rotate left）和右旋（rotate right）。</p><ul><li><p>左旋，即是<strong>逆时针</strong>旋转，以某个节点作为旋转点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变；<br><img src="/2022/04/15/data-structure-avltree/rotate_left.gif"></p></li><li><p>右旋，即是<strong>顺时针</strong>旋转，以某个节点作为旋转点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。<br><img src="/2022/04/15/data-structure-avltree/rotate_right.gif"></p></li></ul><p>这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是从失去平衡的最小子树根节点开始的(即离插入节点最近且平衡因子超过1的祖节点)。</p><p>造成失衡一共有 <code>4</code> 种情况：LL型、LR型、RL型、RR型，如下图所示。</p><ul><li><p><code>LL型</code>平衡调整：对节点<code>C</code>右旋即可。<br><img src="/2022/04/15/data-structure-avltree/08_ll.jpg"></p></li><li><p><code>LR型</code>平衡调整：先对<code>A</code>进行一次左旋再对<code>C</code>进行一次右旋。<br><img src="/2022/04/15/data-structure-avltree/08_lr.jpg"></p></li><li><p><code>RL型</code>平衡调整：先对<code>C</code>进行一次右旋再对<code>A</code>进行一次左旋。<br><img src="/2022/04/15/data-structure-avltree/08_rl.jpg"></p></li><li><p><code>RR型</code>平衡调整：对节点<code>A</code>左旋即可。<br><img src="/2022/04/15/data-structure-avltree/08_rr.jpg"></p></li></ul><h3 id="2-模拟建-AVL-树"><a href="#2-模拟建-AVL-树" class="headerlink" title="2. 模拟建 AVL 树"></a>2. 模拟建 AVL 树</h3><p>按照整数序列 {4,5,7,2,1,3,6} 依次插入<code>AVL</code>树。<br><img src="/2022/04/15/data-structure-avltree/08_demo.png"></p><p>由于<code>AVL</code>树必须保证左右子树平衡(左子树和右子树的深度之差的绝对值不超过<code>1</code>)，</p><p>所以在插入的时候很容易出现不平衡的情况，一旦这样，就需要进行旋转以求达到平衡。</p><p>正是由于这种严格的平衡条件，导致<code>AVL</code>需要花大量时间在调整上，故<code>AVL</code>树一般适用于<strong>查询</strong>场景， 而<strong>不</strong>适用于<strong>增删频繁</strong>的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」二叉树</title>
      <link href="/2022/04/08/data-structure-binarytree.html"/>
      <url>/2022/04/08/data-structure-binarytree.html</url>
      
        <content type="html"><![CDATA[<p>树：树是一种非线性的数据结构，一棵树是<code>n</code>（<code>n&gt;=0</code>）个节点的集合。<br>用来连接相邻节点之间的关系，我们叫做“父子关系”。<br>我们把没有父节点的节点叫做<strong>根节点</strong>，节点的上一层节点是其<strong>父节点</strong>，下一层节点是其<strong>子节点</strong>，拥有相同父节点的子节点之间互称为<strong>兄弟节点</strong>。</p><span id="more"></span><ul><li>树的三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。<ul><li>节点的高度：节点到叶子节点的最长路径（边数）</li><li>节点的深度：根节点到这个节点所经历的路径（边数）</li><li>节点的层数：节点的深度 <code>+1</code></li></ul></li><li>树的高度：根节点的高度。</li></ul><p><img src="/2022/04/08/data-structure-binarytree/07_01.webp"></p><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h3><p>二叉树：每个节点<strong>最多</strong>有两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。<br>二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。</p><ul><li>两个比较特殊的二叉树：<ul><li>满二叉树：树中每个分支节点（非叶节点）都有两棵非空子树，并且所有的叶节点都在同一层。</li><li>完全二叉树：除最后一层外，其他层的节点都满；并且最后一层的节点从左到右是连续排列，中间没有断开，空位都在右边。<br><img src="/2022/04/08/data-structure-binarytree/07_02.webp"></li></ul></li></ul><p>有两种方法存储一棵二叉树，一种是基于指针或者引用的<strong>二叉链式存储法</strong>，一种是基于数组的<strong>顺序存储法</strong>。</p><h3 id="2-存储二叉树"><a href="#2-存储二叉树" class="headerlink" title="2. 存储二叉树"></a>2. 存储二叉树</h3><p>基于基于指针的链式存储法。<br>每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。<br>从根节点开始，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。<br><img src="/2022/04/08/data-structure-binarytree/07_03.webp"></p><p>基于数组的顺序存储法。<br>如下图，我们把根节点存储在数组下标 <code>i=1</code> 的位置，那左子节点存储在下标 <code>2*i = 2</code> 的位置，右子节点存储在 <code>2*i+1 = 3</code> 的位置。以此类推，<code>B</code>节点的左子节点存储在 <code>2*i = 2*2 = 4</code> 的位置，右子节点存储在 <code>2*i+1 = 2*2+1 = 5</code> 的位置。<br><img src="/2022/04/08/data-structure-binarytree/07_04.webp"></p><p>如果节点<code>X</code>存储在数组中下标为 <code>i</code> 的位置，下标为 <code>2*i</code> 的位置存储的就是左子节点，下标为<code> 2*i+1</code> 的位置存储的就是右子节点。<br>反过来，下标为 <code>i/2</code> 的位置存储就是它的父节点。<br>通过这种方式，我们只要知道根节点存储的位置（通常根节点会存储在下标为<code>1</code>的位置），这样就可以通过下标计算，把整棵树都串起来。</p><p><strong>堆</strong>其实就是一种<strong>完全二叉树</strong>，最常用的存储方式就是<strong>数组</strong>。</p><h3 id="3-遍历二叉树"><a href="#3-遍历二叉树" class="headerlink" title="3. 遍历二叉树"></a>3. 遍历二叉树</h3><p>经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。</p><ul><li>前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</li><li>中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</li><li>后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。<br><img src="/2022/04/08/data-structure-binarytree/07_05.webp"></li></ul><p>实际上，二叉树的前、中、后序遍历就是一个<strong>递归的过程</strong>。<br>比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><h3 id="4-二叉查找树（Binary-Search-Tree）"><a href="#4-二叉查找树（Binary-Search-Tree）" class="headerlink" title="4. 二叉查找树（Binary Search Tree）"></a>4. 二叉查找树（Binary Search Tree）</h3><p>二叉查找树，也叫二叉搜索树。<br>顾名思义，二叉查找树是为了实现<strong>快速查找</strong>而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。</p><p>二叉查找树要求，在树中的<strong>任意一个节点，其左子树中的每个节点的值都比该节点的值小，而右子树节点的值都比该节点的值大</strong>。</p><h4 id="4-1-二叉查找树的查找操作"><a href="#4-1-二叉查找树的查找操作" class="headerlink" title="4.1 二叉查找树的查找操作"></a>4.1 二叉查找树的查找操作</h4><p>先取根节点，如果它等于我们要查找的数据，那就返回。<br>如果要查找的数据比根节点的值小，那就在左子树中递归查找；<br>如果要查找的数据比根节点的值大，那就在右子树中递归查找。<br><img src="/2022/04/08/data-structure-binarytree/07_06.webp"></p><h4 id="4-2-二叉查找树的插入操作"><a href="#4-2-二叉查找树的插入操作" class="headerlink" title="4.2 二叉查找树的插入操作"></a>4.2 二叉查找树的插入操作</h4><p>二叉查找树的插入操作二叉查找树的插入过程有点类似查找操作。<br>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。<br><img src="/2022/04/08/data-structure-binarytree/07_07.webp"></p><h4 id="4-3-二叉查找树的删除操作"><a href="#4-3-二叉查找树的删除操作" class="headerlink" title="4.3 二叉查找树的删除操作"></a>4.3 二叉查找树的删除操作</h4><p>分三种情况来处理。</p><ol><li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为<code>null</code>。(比如图中的删除节点<code>55</code>。)</li><li>如果要删除的节点只有一个子节点，我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。(比如图中的删除节点<code>13</code>。)</li><li>如果要删除的节点有两个子节点，可以用后继节点或者前继节点替换删除节点，然后再删除掉替换节点。（比如图中的删除节点<code>18</code>。)<blockquote><ul><li>后继节点：删除节点的右子树中的最小节点，即右子树中最左节点。</li><li>前继节点：删除节点的左子树中最大节点，即左子树中最右节点。</li></ul></blockquote></li></ol><p><img src="/2022/04/08/data-structure-binarytree/07_08.webp"></p><h4 id="4-2-二叉查找树的其他操作"><a href="#4-2-二叉查找树的其他操作" class="headerlink" title="4.2 二叉查找树的其他操作"></a>4.2 二叉查找树的其他操作</h4><ul><li>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。</li><li><strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 <code>O(n)</code>，非常高效</strong>。因此，二叉查找树也叫作<strong>二叉排序树</strong>。</li><li>支持重复数据的二叉查找树<ol><li>通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</li><li>每个节点仍然只存储一个数据。新插入值相同的数据当作大于这个节点的值来处理。查找时，遇到值相同的节点不停止，而是继续在右子树中查找，直到遇到叶子节点才停止。这样就可以把键值等于要查找值的所有节点都找出来。删除时，也需要先查找到每个要删除的节点，依次删除。</li></ol></li></ul><h3 id="5-平衡二叉树"><a href="#5-平衡二叉树" class="headerlink" title="5. 平衡二叉树"></a>5. 平衡二叉树</h3><p>二叉查找树支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，也就是<code>O(height)</code>，完全二叉树的高度<code>height&lt;=log2n</code>；理想情况下，时间复杂度是<code>O(logn)</code>。<br>不过，二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于<code>log2n</code>的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到<code>O(n)</code>。</p><p>为了解决二叉查找树因为动态更新导致的性能退化问题，发明了<strong>平衡二叉查找树</strong>这类数据结构。<br>平衡二叉查找树的高度接近<code>logn</code>，所以插入、删除、查找操作的时间复杂度也比较稳定，是<code>O(logn)</code>。<br>在工程中，很多用到平衡二叉查找树的地方都会用红黑树。红黑树是一种特殊的平衡二叉查找树。</p><p>平衡二叉树的<strong>严格定义</strong>：**二叉树中任意一个节点的左右子树的高度相差不能大于<code>1</code>**。</p><p>从这个定义来看，完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p>但是很多平衡二叉查找树其实并没有符合严格的定义，比如红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>所以，平衡二叉查找树中“平衡”的意思，其实就是<strong>让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」哈希算法</title>
      <link href="/2022/03/25/data-structure-hashalgorithm.html"/>
      <url>/2022/03/25/data-structure-hashalgorithm.html</url>
      
        <content type="html"><![CDATA[<p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p><p>哈希算法最重要的特点就是：相同的输入一定得到相同的输出；不同的输入大概率得到不同的输出。</p><span id="more"></span><p>哈希算法的目的就是为了验证原始数据是否被篡改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java字符串的hashCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数：</span></span><br><span class="line"><span class="string">&quot;hello&quot;</span>.hashCode(); <span class="comment">// 0x5e918d2</span></span><br><span class="line"><span class="string">&quot;hello, java&quot;</span>.hashCode(); <span class="comment">// 0x7a9d88e8</span></span><br><span class="line"><span class="string">&quot;hello, bob&quot;</span>.hashCode(); <span class="comment">// 0xa0dbae2f</span></span><br></pre></td></tr></table></figure><p>哈希碰撞是指，两个不同的输入得到了相同的输出。一个安全的哈希算法必须满足：碰撞概率低，不能猜测输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;AaAaAa&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br><span class="line"><span class="string">&quot;BBAaBB&quot;</span>.hashCode(); <span class="comment">// 0x7460e8c0</span></span><br></pre></td></tr></table></figure><h3 id="1-常用的哈希算法"><a href="#1-常用的哈希算法" class="headerlink" title="1. 常用的哈希算法"></a>1. 常用的哈希算法</h3><table><thead><tr><th align="left">算法</th><th align="left">输出长度（位）</th><th align="left">输出长度（字节）</th></tr></thead><tbody><tr><td align="left">MD5</td><td align="left">128 bits</td><td align="left">16 bytes</td></tr><tr><td align="left">SHA-1</td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left">RipeMD-160</td><td align="left">160 bits</td><td align="left">20 bytes</td></tr><tr><td align="left">SHA-256</td><td align="left">256 bits</td><td align="left">32 bytes</td></tr><tr><td align="left">SHA-512</td><td align="left">512 bits</td><td align="left">64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p><h3 id="2-哈希算法的应用"><a href="#2-哈希算法的应用" class="headerlink" title="2. 哈希算法的应用"></a>2. 哈希算法的应用</h3><p>哈希算法的应用非常非常多，这里介绍最常见的七个，分别是安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。</p><h4 id="2-1-安全加密"><a href="#2-1-安全加密" class="headerlink" title="2.1 安全加密"></a>2.1 安全加密</h4><p>最常用于加密的哈希算法是 <code>MD5</code>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 <code>SHA</code>（Secure Hash Algorithm，安全散列算法）。<br>除了这两个之外，当然还有很多其他加密算法，比如计算机网络的<code>SSL/TLS</code>协议里面的对称加密（<code>AES</code>）、非对称加密（<code>RSA</code>）。</p><p>安全加密的关键点：①很难根据哈希值反向推导出原始数据；②散列冲突的概率要很小。</p><p>不管是什么哈希算法，只能尽量减少碰撞冲突的概率，理论上是无法做到完全不冲突的。<br>一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p><p>没有绝对安全的加密。任何哈希算法都会出现散列冲突，但是这个冲突概率非常小。越是复杂哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。</p><h4 id="2-2-唯一标识"><a href="#2-2-唯一标识" class="headerlink" title="2.2 唯一标识"></a>2.2 唯一标识</h4><p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</p><p>比如<code>URL</code>字段或者图片字段要求不能重复，这个时候就可以通过哈希算法对这个数据取唯一标识，或者说信息摘要（比如<code>MD5</code>处理）。<br>此外，还可以对文件之类的二进制数据做<code>MD5</code>处理，作为唯一标识，这样判定重复文件的时候更快捷。</p><h4 id="2-3-数据校验"><a href="#2-3-数据校验" class="headerlink" title="2.3 数据校验"></a>2.3 数据校验</h4><p>网络传输数据不安全，传输数据的过程中，数据可能被宿主机篡改，或数据丢失，所以需要校验文件的安全，正确，完整性。</p><p>因为哈希算法对数据很敏感，只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同；所以在文件块下载完后，使用相同的哈希算法，对于文件计算，判断是否相同。</p><h4 id="2-4-散列函数"><a href="#2-4-散列函数" class="headerlink" title="2.4 散列函数"></a>2.4 散列函数</h4><p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p><p>散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h4 id="2-5-负载均衡"><a href="#2-5-负载均衡" class="headerlink" title="2.5 负载均衡"></a>2.5 负载均衡</h4><p>负载均衡算法有很多，比如轮询、随机、加权轮询等。利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。</p><p>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p><h4 id="2-6-数据分片"><a href="#2-6-数据分片" class="headerlink" title="2.6 数据分片"></a>2.6 数据分片</h4><p>针对海量数据的处理问题，通过哈希算法对处理的海量数据进行分片，多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。</p><h4 id="2-7-分布式存储"><a href="#2-7-分布式存储" class="headerlink" title="2.7 分布式存储"></a>2.7 分布式存储</h4><p>在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p><h5 id="2-7-1-一致性哈希算法"><a href="#2-7-1-一致性哈希算法" class="headerlink" title="2.7.1 一致性哈希算法"></a>2.7.1 一致性哈希算法</h5><p>一致性哈希算法是对<code>2^32</code>进行取模运算，是一个固定的值。即<code>0~(2^32)-1</code>的数字空间中。现在我们可以将这些数字头尾相连，想象成一个闭合的环形。如下图：<br><img src="/2022/03/25/data-structure-hashalgorithm/06_01.png"></p><p>一致性哈希要进行的两步哈希：</p><ol><li>对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li><li>当对数据进行存储或访问时，对数据进行哈希映射；</li><li>所以，<strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</li></ol><p>如下图，已经有3个节点经过哈希计算，映射到了哈希环上相应的位置，有三个数据进行哈希映射到节点上；<br>①首先，对 <code>key</code> 进行哈希计算，确定此 <code>key</code> 在环上的位置；<br>②然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 <code>key</code> 的节点。<br><img src="/2022/03/25/data-structure-hashalgorithm/06_02.png"></p><p>假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置；<br>可以看到，key-1、key-3 都不受影响，只有 key-2 需要被迁移节点 D。<br><img src="/2022/03/25/data-structure-hashalgorithm/06_03.png"></p><p>假设节点数量从 3 减少到了 2，比如将节点 A 移除；<br>你可以看到，key-2 和 key-3 不会受到影响，只有 key-1 需要被迁移节点 B。<br><img src="/2022/03/25/data-structure-hashalgorithm/06_04.png"></p><p>在一致性哈希算法中，如果增加或者移除一个节点，<strong>仅影响该节点在哈希环上顺时针相邻的后继节点</strong>，其它数据也不会受到影响。</p><h5 id="2-7-2-虚拟节点"><a href="#2-7-2-虚拟节点" class="headerlink" title="2.7.2 虚拟节点"></a>2.7.2 虚拟节点</h5><p><strong>一致性哈希算法虽然减少了数据迁移量，但是并不保证节点能够在哈希环上分布均匀</strong>，这样就会带来一个问题，会有大量的请求集中在一个节点上。在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。<br>如下图中 3 个节点的映射位置都在哈希环的右半边：<br><img src="/2022/03/25/data-structure-hashalgorithm/06_05.png"></p><p>要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。<br>这个时候我们就加入<strong>虚拟节点</strong>，也就是对一个真实节点做多个副本。<br>具体做法是，不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有<strong>「两层」映射关系</strong>。</p><p>比如对每个节点分别设置 3 个虚拟节点，引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。<br>节点数量多了后，节点在哈希环上的分布就相对均匀了。<br><img src="/2022/03/25/data-structure-hashalgorithm/06_06.png"><br>这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。</p><p>虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高。</p><p>有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。</p><p>因此，<strong>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</strong>。</p><h5 id="2-7-3-分布式存储的哈希算法总结"><a href="#2-7-3-分布式存储的哈希算法总结" class="headerlink" title="2.7.3 分布式存储的哈希算法总结"></a>2.7.3 分布式存储的哈希算法总结</h5><p>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。</p><p>但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。</p><p>为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</p><p>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」散列表（Hash Table）</title>
      <link href="/2022/03/18/data-structure-hashtable.html"/>
      <url>/2022/03/18/data-structure-hashtable.html</url>
      
        <content type="html"><![CDATA[<p>散列表（<code>Hash Table</code>），也叫“哈希表”或者“Hash表”。是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。</p><p>通常，我们把这个关键字称为 <code>Key</code>，把对应的记录称为 <code>Value</code>，所以也可以说是通过 <code>Key</code> 访问一个映射表来得到 <code>Value</code> 的地址。而这个映射表，也叫作散列函数或者哈希函数，存放记录的数组叫作散列表。</p><p>散列表用的是<strong>数组支持按照下标随机访问数据</strong>的特性，所以散列表其实就是<strong>数组的一种扩展</strong>，由数组演化而来。</p><span id="more"></span><p><code>Hash</code>，一般翻译做“散列”&#x2F;“哈希”，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。<br>(这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，这种现象叫作碰撞（Collision）。)<br>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>对散列表中的键(<code>key</code>)进行<code>Hash</code>的函数就是散列函数（<code>Hash(key)</code>）。函数的计算结果就是散列值,就是<code>Hash(key)</code>的值。</p><h3 id="1-几种常见哈希函数："><a href="#1-几种常见哈希函数：" class="headerlink" title="1. 几种常见哈希函数："></a>1. 几种常见哈希函数：</h3><ul><li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址；如<code>Hash(key)=key</code>或者<code>Hash(key)=a*key+b</code>，<code>a</code>和<code>b</code>都为常数。</li><li>数字分析法：如果关键字由多位字符或者数字组成，就可以考虑抽取其中的<code>2</code>位或者多位作为该关键字对应的散列地址，在取法上尽量选择变化较多的位，避免冲突发生。</li><li>平方取中法：对关键字做平方操作，取平方值的中间几位作为散列地址。此方法也是比较常用的构造哈希函数的方法。计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li><li>折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。此方法适合关键字位数较多的情况。</li><li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li><li>除留余数法：若已知整个哈希表的最大长度<code>m</code>，可以取一个不大于<code>m</code>的数<code>p</code>，然后对该关键字<code>key</code>做取余运算，即：<code>Hash(key)=key%p</code>。</li><li>随机数法：取关键字的一个随机函数值作为它的哈希地址，即：<code>Hash(key)=random(key)</code>，此方法适用于关键字长度不等的情况。</li></ul><p>构建哈希函数，需要根据实际的查找表的情况采取适当的方法。通常考虑的因素有以下几方面：</p><ol><li>关键字的长度。如果长度不等，就选用随机数法。如果关键字位数较多，就选用折叠法或者数字分析法；反之如果位数较短，可以考虑平方取中法；</li><li>哈希表的大小。如果大小已知，可以选用除留余数法；</li><li>关键字的分布情况；</li><li>查找表的查找频率；</li><li>计算哈希函数所需的时间（包括硬件指令的因素）</li></ol><h3 id="２-几种哈希冲突的处理方式："><a href="#２-几种哈希冲突的处理方式：" class="headerlink" title="２. 几种哈希冲突的处理方式："></a>２. 几种哈希冲突的处理方式：</h3><ul><li>开放寻址法：<code>Hash(key) = (Hash(key) + d) MOD m</code>；（其中<code>m</code>为哈希表的表长，<code>d</code>为一个增量）。当得出的哈希地址产生冲突时，选取一种探测方法获取<code>d</code>的值，然后继续计算，直到计算出的哈希地址不在冲突为止。三种探测方法：<ul><li>线性探测法：d&#x3D;1，2，3，…，m-1 （每次 +1，向右探测，直到有空闲的位置为止）</li><li>二次探测法：d&#x3D;12，-12，22，-22，32，… （按照 +12，-12，+22，…如此探测，直到有空闲的位置）</li><li>伪随机数探测法：d&#x3D;伪随机数 （每次加上一个随机数，直到探测到空闲位置结束）</li></ul></li><li>再哈希法：当通过哈希函数求得的哈希地址同其他关键字产生冲突时，使用另一个哈希函数计算，直到冲突不再发生。</li><li>链地址法：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。</li><li>建立一个公共溢出区：建立两张表，一张为基本表，另一张为溢出表。基本表存储没有发生冲突的数据，当关键字由哈希函数生成的哈希地址产生冲突时，就将数据填入溢出表。</li></ul><h3 id="３-散列表的特点"><a href="#３-散列表的特点" class="headerlink" title="３. 散列表的特点"></a>３. 散列表的特点</h3><ol><li>访问速度很快<ul><li>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</li></ul></li><li>需要额外的空间<ul><li>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</li><li>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</li></ul></li><li>无序<ul><li>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</li></ul></li><li>可能会产生碰撞<ul><li>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」跳表（Skip List）</title>
      <link href="/2022/03/12/data-structure-skiplist.html"/>
      <url>/2022/03/12/data-structure-skiplist.html</url>
      
        <content type="html"><![CDATA[<p>跳表（Skip List）是一个动态数据结构（链表加多级索引），可以支持快速地插入、删除、查找操作的有序链表。<br>跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。</p><span id="more"></span><h3 id="1-跳表的演化"><a href="#1-跳表的演化" class="headerlink" title="1. 跳表的演化"></a>1. 跳表的演化</h3><p>跳表的原始链表是一个有序单链表，如果要想在其中查找某个数据，只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。<br><img src="/2022/03/12/data-structure-skiplist/04_01.webp"></p><p>从链表中每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<strong>索引</strong>或<strong>索引层</strong>。如下图。图中的 down 表示 down 指针，指向下一级结点。<br><img src="/2022/03/12/data-structure-skiplist/04_02.webp"></p><p>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。<br>跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。查找一个结点需要遍历的结点数量又减少了。<br>这就是跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。<br><img src="/2022/03/12/data-structure-skiplist/04_03.webp"></p><p>当元素数量较多时，建立多级索引，索引提高的效率比较大，近似于二分查找。<br><img src="/2022/03/12/data-structure-skiplist/04_04.webp"></p><h3 id="2-跳表查找的时间复杂度"><a href="#2-跳表查找的时间复杂度" class="headerlink" title="2. 跳表查找的时间复杂度"></a>2. 跳表查找的时间复杂度</h3><p>跳表查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。所以，<code>时间复杂度 = 索引的高度 * 每层索引遍历元素的个数</code>。</p><p>如果每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是<code>n/2</code>，第二级索引的结点个数大约就是<code>n/4</code>，第三级索引的结点个数大约就是<code>n/8</code>，依次类推，那第<code>k</code>级索引结点的个数就是<code>n/(2^k)</code>。</p><p>最高级索引一般有<code>2</code>个元素，即：最高级索引<code>h</code>满足<code>2=n/(2^h)</code>，从而求得<code>h=log2n-1</code>，如果包含原始链表这一层，整个跳表的高度就是<code>log2n</code>。</p><p>按照前面这种索引结构，我们每一级索引都最多只需要遍历<code>3</code>个结点，根据<code>时间复杂度 = 索引的高度 * 每层索引遍历元素的个数</code>，即跳表中查找一个元素的时间复杂度为<code>O(3*log2n)</code>，省略常数即：<code>O(logn)</code>。</p><h3 id="3-跳表的空间复杂度"><a href="#3-跳表的空间复杂度" class="headerlink" title="3. 跳表的空间复杂度"></a>3. 跳表的空间复杂度</h3><p>跳表通过建立索引，来提高查找元素的效率，就是典型的“空间换时间”的思想，所以在空间上做了一些牺牲。</p><p>前面提到，如果每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是<code>n/2</code>，第二级索引的结点个数大约就是<code>n/4</code>，以此类推，每上升一级就减少一半，直到剩下<code>2</code>个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n/2, n/4, n/8, ..., 8, 4, 2</span><br></pre></td></tr></table></figure><p>这几级索引的结点总和就是<code>n/2+n/4+n/8…+8+4+2=n-2</code>。所以，跳表的空间复杂度是<code>O(n)</code>。也就是说，如果将包含<code>n</code>个结点的单链表构造成跳表，我们需要额外再用接近<code>n</code>个结点的存储空间。</p><p>我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，第一级索引需要大约<code>n/3</code>个结点，第二级索引需要大约<code>n/9</code>个结点，以此类推，每往上一级，索引结点个数都除以<code>3</code>。通过等比数列求和公式，总的索引结点大约就是<code>n/3+n/9+n/27+...+9+3+1=n/2</code>。尽管空间复杂度还是<code>O(n)</code>，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p><p><strong>在软件工程中，对象数据所占的空间要远大于指针，指针大小可以忽略。</strong></p><h3 id="4-跳表的插入和删除"><a href="#4-跳表的插入和删除" class="headerlink" title="4. 跳表的插入和删除"></a>4. 跳表的插入和删除</h3><p>跳表这个动态数据结构，插入、删除操作的时间复杂度也是<code>O(logn)</code>。</p><h4 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4.1 插入数据"></a>4.1 插入数据</h4><p>跳表的插入首先查找某个数据应该插入的位置（时间复杂度是<code>O(logn)</code>），当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p><p>需要某种手段来维护索引与原始链表大小之间的平衡。<br>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。<br>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第K级索引中。<br>随机函数简化跳跃链表建立层级索引的复杂度，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</p><p>如下图所示，插入数据<code>6</code>到跳表中，随机函数生成<code>K=2</code>:<br><img src="/2022/03/12/data-structure-skiplist/04_05.webp"></p><h4 id="4-2-删除数据"><a href="#4-2-删除数据" class="headerlink" title="4.2 删除数据"></a>4.2 删除数据</h4><p>跳表删除数据时，要把索引中对应节点也要删掉。<br>删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素<code>x</code>，则执行删除操作。</p><p>如下图所示，如果要删除元素<code>9</code>，需要把原始链表中的<code>9</code>和第一级索引的<code>9</code>都删除掉。<br><img src="/2022/03/12/data-structure-skiplist/04_06.webp"></p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>跳表是查询效率近似于二分查找的有序链表；<br>每个元素插入时随机生成它的索引层级level；<br>最底层原始链表包含所有的元素；<br>如果一个元素出现在<code>x</code>层索引，那么它肯定出现在<code>x</code>以下的索引层中；<br>跳表查询、插入、删除的时间复杂度为<code>O(logn)</code>，与平衡二叉树接近；</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」栈（Stack）与 队列（Queue）</title>
      <link href="/2022/03/05/data-structure-stack-queue.html"/>
      <url>/2022/03/05/data-structure-stack-queue.html</url>
      
        <content type="html"><![CDATA[<p>栈（Stack）和队列（Queue），严格意义上来说，也属于线性表，是一种<strong>操作受限的线性表数据结构</strong>。<br>使用栈结构存储数据，讲究“先进后出”，即最先进栈的数据，最后出栈；<br>使用队列存储数据，讲究“先进先出”，即最先进队列的数据，也最先出队列。</p><span id="more"></span><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1. 栈"></a>1. 栈</h3><p>栈（<code>Stack</code>）是一种只能从一端存取数据且遵循“<strong>先进后出</strong>”原则（First In Last Out，简称FILO）的线性存储结构。<br>通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。<br>栈只支持两个基本操作：<strong>入栈</strong><code>push()</code>和<strong>出栈</strong><code>pop()</code>。</p><h4 id="1-1-栈的实现"><a href="#1-1-栈的实现" class="headerlink" title="1.1 栈的实现"></a>1.1 栈的实现</h4><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。</p><h4 id="1-2-栈的应用"><a href="#1-2-栈的应用" class="headerlink" title="1.2 栈的应用"></a>1.2 栈的应用</h4><ol><li>栈在函数调用中的应用<ul><li>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将其中的临时变量作为栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</li></ul></li><li>栈在表达式求值中的应用（比如：<code>34+13*9+44-12/3</code>）<ul><li>利用两个栈，其中一个用来保存操作数，另一个用来保存运算符。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较，若比运算符栈顶元素优先级高，就将当前运算符压入栈，若比运算符栈顶元素的优先级低或者相同，从运算符栈中取出栈顶运算符，从操作数栈顶取出2个操作数，然后进行计算，把计算完的结果压入操作数栈，继续比较。</li></ul></li><li>栈在括号匹配中的应用（比如：<code>&#123;&#125;&#123;[()]()&#125;</code>）<ul><li>用栈保存为匹配的左括号，从左到右一次扫描字符串，当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号，如果能匹配上，则继续扫描剩下的字符串。如果扫描过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</li><li>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明未匹配的左括号为非法格式。</li></ul></li><li>实现浏览器的前进后退功能<ul><li>我们使用两个栈<code>X</code>和<code>Y</code>，我们把首次浏览的页面依次压如栈<code>X</code>，当点击后退按钮时，再依次从栈<code>X</code>中出栈，并将出栈的数据一次放入<code>Y</code>栈。当点击前进按钮时，我们依次从栈<code>Y</code>中取出数据，放入栈<code>X</code>中。当栈<code>X</code>中没有数据时，说明没有页面可以继续后退浏览了。当<code>Y</code>栈没有数据，那就说明没有页面可以点击前进浏览了。</li></ul></li></ol><h4 id="1-3-为什么函数调用要用“栈”来保存临时变量？"><a href="#1-3-为什么函数调用要用“栈”来保存临时变量？" class="headerlink" title="1.3 为什么函数调用要用“栈”来保存临时变量？"></a>1.3 为什么函数调用要用“栈”来保存临时变量？</h4><ul><li>因为函数调用的执行顺序符合后进者先出，先进者后出的特点。比如函数中的局部变量的生命周期的长短是先定义的生命周期长，后定义的生命周期短；还有函数中调用函数也是这样，先开始执行的函数只有等到内部调用的其他函数执行完毕，该函数才能执行结束。</li><li>正是由于函数调用的这些特点，根据数据结构是特定应用场景的抽象的原则，我们优先考虑栈结构。</li></ul><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2. 队列"></a>2. 队列</h3><p>队列（<code>queue</code>）是一种遵循“<strong>先进先出</strong>”原则（First In First Out，简称FIFO）的线性存储结构。<br>与栈结构不同的是，队列的两端都“开口”，要求数据只能从一端进，从另一端出；通常，称进数据的一端为“队尾”，出数据的一端为“队头”。<br>最基本的操作也是两个：<strong>入队</strong><code>enqueue()</code>，放一个数据到队列尾部；<strong>出队</strong><code>dequeue()</code>，从队列头部取一个元素。<br>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p><h4 id="2-1-队列的实现"><a href="#2-1-队列的实现" class="headerlink" title="2.1 队列的实现"></a>2.1 队列的实现</h4><ul><li>队列存储结构的实现有以下两种方式：<ul><li>顺序队列：在顺序表的基础上实现的队列结构。</li><li>链队列：在链表的基础上实现的队列结构。</li></ul></li><li>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。</li><li>基于链表的实现方式，可以实现一个支持无限排队的<strong>无界队列</strong>（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li><li>而基于数组实现的<strong>有界队列</strong>（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</li></ul><h4 id="2-2-队列的应用"><a href="#2-2-队列的应用" class="headerlink" title="2.2 队列的应用"></a>2.2 队列的应用</h4><ol><li>循环队列<ul><li>循环队列还是基于数组实现的。原本数组是有头有尾的，是一条直线。我们把首尾相连，扳成了一个环，形成逻辑上的环状空间。</li></ul></li><li>阻塞队列<ul><li>在队列的基础上增加阻塞操作，就成了阻塞队列。</li><li>阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。</li><li>从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。</li></ul></li><li>并发队列<ul><li>在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。</li><li>并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。</li><li>实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</li></ul></li><li>线程池资源枯竭是的处理<ul><li>在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」数组与链表</title>
      <link href="/2022/02/28/data-structure-array-linked-list.html"/>
      <url>/2022/02/28/data-structure-array-linked-list.html</url>
      
        <content type="html"><![CDATA[<p>线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。比如数组，链表、队列、栈等也是线性表结构。<br>而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><span id="more"></span><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p>数组（<code>Array</code>）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p><p>数组寻址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>以长度为10的int数组（<code>int[] a = new int[10]</code>）为例：分配了一块连续内存空间 <code>1000～1039</code>，其中，内存块的首地址为 <code>base_address = 1000</code>，<code>int</code>类型的<code>data_type_size</code>为<code>4</code>个字节，即<code>a[0]</code>地址为<code>1000</code>，<code>a[1]</code>地址为<code>1004</code>…</p><p><img src="/2022/02/28/data-structure-array-linked-list/array_address.webp"></p><p>容器是否完全替代数组？</p><ul><li>容器的优势：对于Java语言，容器封装了数组插入、删除等操作的细节，并且支持动态扩容。</li><li>对于Java，一些更适合用数组的场景：<ol><li>Java的<code>ArrayList</code>无法存储基本类型，需要进行装箱操作，而装箱与拆箱操作都会有一定的性能消耗，如果特别注意性能，或者希望使用基本类型，就可以选用数组。</li><li>若数组大小事先已知，并且对数组只有非常简单的操作，不需要使用到<code>ArrayList</code>提供的大部分方法，则可以直接使用数组。</li><li>多维数组时，使用数组会更加直观。</li></ol></li></ul><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><p>链表（<code>Linked list</code>）也是一种线性表数据结构。它的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储。<br>链表中每一个内存块称为节点（<code>Node</code>），节点除了存储数据外，还需存储下一个节点的地址。</p><ol><li>单链表：每个节点只包含一个指针，即后继指针（<code>next</code>）；首节点地址表示整条链表，尾节点的后继指针指向空地址null。</li><li>循环链表：尾节点的后继指针指向首节点，其他与单链表一致。</li><li>双向链表：每个节点包含两个指针，前驱指针（<code>prev</code>）和后继指针（<code>next</code>），首节点的前驱指针和尾节点后继指针都指向空地址null。</li><li>双向循环链表：首节点前驱指针指向尾节点，尾节点后继指针指向首节点，其他与双链表一致。</li></ol><h3 id="3-数组vs链表"><a href="#3-数组vs链表" class="headerlink" title="3. 数组vs链表"></a>3. 数组vs链表</h3><ol><li>数组中的元素存在一个连续的内存空间中，若数组申请空间足够但不连续也会失败；而链表中的元素可以存在于不连续的内存空间，不过需要额外的内存空间存储指针信息。</li><li>数组支持随机访问，根据下标随机访问的时间复杂度是<code>O(1)</code>；链表随机访问的时间复杂度是<code>O(n)</code>。</li><li>链表适合插入、删除操作，时间复杂度为<code>O(1)</code>；数组插入、删除操作，时间复杂度为<code>O(n)</code>。</li><li>数组大小固定，若存储空间不足，需要进行扩容，扩容就需要数据复制，这非常耗时；链表进行频繁的插入删除操作会导致内存频繁的内存申请和释放，容易造成内存碎片，Java环境还可能造成频繁的<code>GC</code>(自动垃圾回收)操作。</li><li>数组在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。</li></ol><h3 id="附：双向链表的Java实现"><a href="#附：双向链表的Java实现" class="headerlink" title="附：双向链表的Java实现"></a>附：双向链表的Java实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; first;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾节点指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; last;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结点类（私有静态内部类）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素（默认尾部添加）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加为头元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引获取元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引设置元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldVal</span> <span class="operator">=</span> x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * e元素链接为尾部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * e元素链接为头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">        first = newNode;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">            last = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f.prev = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消非空节点 x 的链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x.item = <span class="literal">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定索引检查非空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkElementIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span>+index+<span class="string">&quot;, Size: &quot;</span>+size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定索引的（非空）节点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构与算法」复杂度分析</title>
      <link href="/2022/02/26/data-structure-complexity.html"/>
      <url>/2022/02/26/data-structure-complexity.html</url>
      
        <content type="html"><![CDATA[<p>数据结构与算法解决的是：如何让计算机更快时间、更省空间的解决问题。<br>因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能，二者统称为复杂度。<br>复杂度描述的是算法执行时间或占用系统空间与数据规模的增长关系。</p><span id="more"></span><p>和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。</p><h3 id="1-时间复杂度与空间复杂度"><a href="#1-时间复杂度与空间复杂度" class="headerlink" title="1. 时间复杂度与空间复杂度"></a>1. 时间复杂度与空间复杂度</h3><p>大O表示法：所有代码的执行时间<code>T(n)</code>与每行代码的执行次数<code>f(n)</code>成正比，用<code>T(n) = O(f(n))</code>表示，其中<code>n</code>表示数据规模的大小</p><ul><li><code>T(n) = O(f(n))</code>表示<em>算法的执行时间与数据规模之间的增长关系</em>，所以也叫<em>渐进时间复杂度</em>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</li><li>类比一下，S(n)&#x3D;O(f(n))表示<strong>空间复杂度</strong>全称就是<em>渐进空间复杂度</em>（asymptotic space complexity），表示<em>算法的存储空间与数据规模之间的增长关系</em>。</li></ul><h3 id="2-复杂度量级"><a href="#2-复杂度量级" class="headerlink" title="2. 复杂度量级"></a>2. 复杂度量级</h3><ul><li>多项式量级：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。这类有：<ul><li>常量阶<code>O(1)</code></li><li>对数阶<code>O(logn)</code></li><li>线性阶<code>O(n)</code></li><li>线性对数阶<code>O(nlogn)</code></li><li>平方阶<code>O(n^2)</code>、立方阶<code>O(n^3)</code>、···、k次方阶<code>O(n^k)</code></li></ul></li><li>非多项式量级NP（NP：Non-Deterministic Polynomial，非确定多项式）：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。非多项式量级只有两个：指数阶<code>O(2^n)</code> 和 阶乘阶<code>O(n!)</code>。</li></ul><p><img src="/2022/02/26/data-structure-complexity/complexity.png"></p><ul><li>复杂度分析法则<ol><li>单段代码看高频：比如循环。</li><li>多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。</li><li>嵌套代码求乘积：比如递归、多重循环等</li><li>多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。</li></ol></li></ul><h3 id="3-复杂度分析的4个概念"><a href="#3-复杂度分析的4个概念" class="headerlink" title="3.复杂度分析的4个概念"></a>3.复杂度分析的4个概念</h3><p>代码复杂度在不同情况下出现量级差别时，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。大多数情况下，是不需要区别分析它们的。</p><ol><li>最好时间复杂度（best case time complexity）：代码在最理想情况下执行的时间复杂度。</li><li>最坏时间复杂度（worst case time complexity）：代码在最坏情况下执行的时间复杂度。</li><li>平均时间复杂度（average case time complexity）：用代码在所有情况下执行的次数的加权平均值表示。<ul><li>分析：代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</li></ul></li><li>均摊时间复杂度（amortized time complexity）：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。均摊结果一般都等于低级别复杂度。<ul><li>分析：两个条件满足时使用：①代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；②低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」前后端分离权限控制-指令级权限</title>
      <link href="/2021/12/30/spring-security-permission.html"/>
      <url>/2021/12/30/spring-security-permission.html</url>
      
        <content type="html"><![CDATA[<p>实现按钮级别的权限控制，基于上一篇<a href="https://my.oschina.net/chaoo/blog/5380267">Spring Secuirty（六）前后端分离菜单权限控制-前端动态路由</a>的扩展。<br>前端部分还是基于<a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>模板来演示。</p><p>这里实现按钮级别的权限判断的逻辑：每个按钮对应一个<code>权限标识</code>，后台根据用户角色计算出当前用户可访问的<code>权限标识</code>列表，前端登录后得到<code>权限标识</code>列表存入全局，通过单个按钮的<code>权限标识</code>去匹配列表里的。来实现按钮级别的权限判断。<span id="more"></span></p><h3 id="1-数据库添加权限表"><a href="#1-数据库添加权限表" class="headerlink" title="1. 数据库添加权限表"></a>1. 数据库添加权限表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 系统权限表</span></span><br><span class="line"> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `system_permission`;</span><br><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `system_permission` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">  `title` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line"> ) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统权限表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 权限&amp;角色 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `system_role_permission`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `system_role_permission` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `permission_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统角色权限关联表&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-前端代码改造"><a href="#2-前端代码改造" class="headerlink" title="2. 前端代码改造"></a>2. 前端代码改造</h3><p>登录后通过接口直接返回用户可访问指令级权限列表：<br><img src="/2021/12/30/spring-security-permission/up-584b8affd5e003dbb50e53f100779ae49c9.webp"></p><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>模板已经封装了一个通过角色来判断的指令权限：<a href="https://github.com/PanJiaChen/vue-element-admin/tree/master/src/directive/permission">v-permission</a>。</p><p>这里需要修改其逻辑：</p><h4 id="2-1-全局state中添加permissions列表"><a href="#2-1-全局state中添加permissions列表" class="headerlink" title="2.1 全局state中添加permissions列表"></a>2.1 全局<code>state</code>中添加<code>permissions</code>列表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---------------- state 中添加 permissions</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src\store\modules\user.js</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="comment">// ... other code</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">token</span>: <span class="title function_">getToken</span>(),</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">roles</span>: [],</span><br><span class="line">    <span class="attr">menus</span>: [],</span><br><span class="line">    <span class="attr">permissions</span>: [],</span><br><span class="line">    <span class="comment">// ... other code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="attr">SET_TOKEN</span>: <span class="function">(<span class="params">state, token</span>) =&gt;</span> &#123;</span><br><span class="line">    state.<span class="property">token</span> = token</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">SET_PERMISSIONS</span>: <span class="function">(<span class="params">state, permissions</span>) =&gt;</span> &#123;</span><br><span class="line">      state.<span class="property">permissions</span> = permissions</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ... other code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// user login</span></span><br><span class="line">  <span class="title function_">login</span>(<span class="params">&#123; commit &#125;, userInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// ... other code</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  <span class="title function_">getInfo</span>(<span class="params">&#123; commit, state &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">getInfo</span>()</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">          <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;Verification failed, please Login again.&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">const</span> &#123; roles, menus, permissions, id, username, avatar, roleDesc, fullName, phone &#125; = data</span><br><span class="line">          <span class="comment">// roles must be a non-empty array</span></span><br><span class="line">          <span class="keyword">if</span> (!roles || roles.<span class="property">length</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;getInfo: roles must be a non-null array!&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_ROLES&#x27;</span>, roles)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_MENUS&#x27;</span>, menus)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_PERMISSIONS&#x27;</span>, permissions)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_USERID&#x27;</span>, id)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_USERNAME&#x27;</span>, username)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_AVATAR&#x27;</span>, avatar)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_ROLEDESC&#x27;</span>, roleDesc)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_FULLNAME&#x27;</span>, fullName)</span><br><span class="line">          <span class="title function_">commit</span>(<span class="string">&#x27;SET_PHONE&#x27;</span>, phone)</span><br><span class="line">          <span class="title function_">resolve</span>(data)</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// user logout</span></span><br><span class="line">  <span class="title function_">logout</span>(<span class="params">&#123; commit, state, dispatch &#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// ... other code</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... other code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------- getters 中添加 permissions</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src\store\getters.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="comment">// ... other code</span></span><br><span class="line">  <span class="attr">permissions</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">user</span>.<span class="property">permissions</span>,</span><br><span class="line">  <span class="comment">// ... other code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br></pre></td></tr></table></figure><h4 id="2-2-重写全局v-permission指令逻辑"><a href="#2-2-重写全局v-permission指令逻辑" class="headerlink" title="2.2 重写全局v-permission指令逻辑"></a>2.2 重写全局<code>v-permission</code>指令逻辑</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src\directive\permission\permission.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkPermission</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; value.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> permissions = store.<span class="property">getters</span> &amp;&amp; store.<span class="property">getters</span>.<span class="property">permissions</span></span><br><span class="line">    <span class="keyword">const</span> permissionButton = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasPermission = permissions.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; permissions.<span class="title function_">some</span>(<span class="function"><span class="params">permission</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> permission === permissionButton</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!hasPermission) &#123;</span><br><span class="line">      el.<span class="property">parentNode</span> &amp;&amp; el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`need permissions! Like v-permission=&quot;sys:menu:edit&quot;`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">inserted</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="title function_">checkPermission</span>(el, binding)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">update</span>(<span class="params">el, binding</span>) &#123;</span><br><span class="line">    <span class="title function_">checkPermission</span>(el, binding)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-重新checkPermission权限判断函数逻辑"><a href="#2-3-重新checkPermission权限判断函数逻辑" class="headerlink" title="2.3 重新checkPermission权限判断函数逻辑"></a>2.3 重新<code>checkPermission</code>权限判断函数逻辑</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src\utils\permission.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span> see @/views/permission/directive.vue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">checkPermission</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; value.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> permissions = store.<span class="property">getters</span> &amp;&amp; store.<span class="property">getters</span>.<span class="property">permissions</span></span><br><span class="line">    <span class="keyword">const</span> permissionButton = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasPermission = permissions.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; permissions.<span class="title function_">some</span>(<span class="function"><span class="params">permission</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> permission === permissionButton</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> hasPermission</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`need permissions! Like v-permission=&quot;sys:menu:edit&quot;`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用指令级权限"><a href="#3-使用指令级权限" class="headerlink" title="3. 使用指令级权限"></a>3. 使用指令级权限</h3><p>使用<code>v-permission</code>指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- menu delete permission can see this --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-permission</span>=<span class="string">&quot;&#x27;sys:menu:del&#x27;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- menu edit permission can see this --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-permission</span>=<span class="string">&quot;&#x27;sys:menu:edit&#x27;&quot;</span>&gt;</span>edit<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> permission <span class="keyword">from</span> <span class="string">&#x27;@/directive/permission/index.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">directives</span>: &#123; permission &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>checkPermission</code>函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- menu delete permission can see this --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-if</span>=<span class="string">&quot;checkPermission(&#x27;sys:menu:del&#x27;)&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- menu edit permission can see this --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-tag</span> <span class="attr">v-if</span>=<span class="string">&quot;checkPermission(&#x27;sys:menu:edit&#x27;)&quot;</span>&gt;</span>edit<span class="tag">&lt;/<span class="name">el-tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> checkPermission <span class="keyword">from</span> <span class="string">&#x27;@/utils/permission&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">   <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    checkPermission</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-添加按钮权限，与菜单-x2F-按钮对角色授权演示"><a href="#4-添加按钮权限，与菜单-x2F-按钮对角色授权演示" class="headerlink" title="4. 添加按钮权限，与菜单&#x2F;按钮对角色授权演示"></a>4. 添加按钮权限，与菜单&#x2F;按钮对角色授权演示</h3><p>菜单中添加按钮的权限演示<br><img src="/2021/12/30/spring-security-permission/up-3304cdd327e2f4f01862531203ae17bfa62.webp"></p><p>菜单&#x2F;按钮对角色授权演示<br><img src="/2021/12/30/spring-security-permission/up-dde01457a309a26fc04f512830e18e71485.webp"></p><p>完整代码请查看源码：</p><blockquote><p>源码地址：<a href="https://github.com/chaooo/spring-security-jwt.git">https://github.com/chaooo/spring-security-jwt.git</a>,<br>这里我将本文的前后端分离后台菜单权限控制放在github源码tag的V5.0中，防止后续修改后代码对不上。</p></blockquote><h3 id="附：当前实例完整SQL"><a href="#附：当前实例完整SQL" class="headerlink" title="附：当前实例完整SQL"></a>附：当前实例完整SQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 系统用户表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `avatar` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif&#x27;</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `fullName` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;电话&#x27;</span>,</span><br><span class="line">  `login_flag` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否阻止登录：0否，其他是&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记：0未删，其他删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;系统用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统角色表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">  `role_desc` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记：0未删，其他删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `role_name` (`role_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;系统角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统菜单表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_menu`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_menu` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单名称&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;路由名称(前端匹配路由用)&#x27;</span>,</span><br><span class="line">  `icon` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;图标&#x27;</span>,</span><br><span class="line">  `parent_id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;父级菜单Id&#x27;</span>,</span><br><span class="line">  `hidden` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;隐藏状态：0显示，1隐藏&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;状态：0启用，1停用&#x27;</span>,</span><br><span class="line">  `sort` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;排序&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记：0未删，其他删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `name` (`name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;系统菜单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统权限表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_permission`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_permission` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限名称&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci COMMENT<span class="operator">=</span><span class="string">&#x27;系统权限表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 权限&amp;角色 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_permission`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_permission` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `permission_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统角色权限关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户&amp;角色 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_user` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统用户角色关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 菜单&amp;角色 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_menu`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_menu` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">bigint</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统角色菜单关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始数据</span></span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_user`(`id`,`username`,`password`,`create_time`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;sysadmin&#x27;</span>,<span class="string">&#x27;$2a$10$Ml/uEJ5BnUSdKspYM4vkneUHM0piXyAVU0aueWya/v7FBauz6XWE6&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_role`(`id`,`role_name`,`role_desc`,`create_time`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_menu` (`id`, `title`, `name`, `icon`, `parent_id`, `hidden`, `create_time`)</span><br><span class="line"><span class="keyword">VALUES</span>  (<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;系统设置&#x27;</span>,<span class="string">&#x27;SysSetting&#x27;</span>,<span class="string">&#x27;el-icon-s-tools&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;菜单管理&#x27;</span>,<span class="string">&#x27;SysMenus&#x27;</span>,<span class="string">&#x27;el-icon-menu&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;角色管理&#x27;</span>,<span class="string">&#x27;SysRoles&#x27;</span>,<span class="string">&#x27;peoples&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;用户管理&#x27;</span>,<span class="string">&#x27;SysUsers&#x27;</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;系统图标&#x27;</span>,<span class="string">&#x27;SysIcons&#x27;</span>,<span class="string">&#x27;el-icon-picture&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;菜单列表&#x27;</span>,<span class="string">&#x27;SysMenuList&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;菜单编辑&#x27;</span>,<span class="string">&#x27;SysMenuEdit&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;角色列表&#x27;</span>,<span class="string">&#x27;SysRoleList&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;角色编辑&#x27;</span>,<span class="string">&#x27;SysRoleEdit&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;用户列表&#x27;</span>,<span class="string">&#x27;SysUserList&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;用户编辑&#x27;</span>,<span class="string">&#x27;SysUserEdit&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,NOW()),</span><br><span class="line">        (<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;其他菜单&#x27;</span>,<span class="string">&#x27;Other&#x27;</span>,<span class="string">&#x27;bug&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;0&#x27;</span>,NOW());</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_permission`(`id`,`menu_id`,`name`,`title`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">6</span>,<span class="string">&#x27;sys:menu:edit&#x27;</span>,<span class="string">&#x27;编辑&#x27;</span>),(<span class="number">2</span>,<span class="number">6</span>,<span class="string">&#x27;sys:menu:del&#x27;</span>,<span class="string">&#x27;删除&#x27;</span>),(<span class="number">3</span>,<span class="number">8</span>,<span class="string">&#x27;sys:role:edit&#x27;</span>,<span class="string">&#x27;编辑&#x27;</span>),(<span class="number">4</span>,<span class="number">8</span>,<span class="string">&#x27;sys:role:del&#x27;</span>,<span class="string">&#x27;删除&#x27;</span>),(<span class="number">5</span>,<span class="number">10</span>,<span class="string">&#x27;sys:user:edit&#x27;</span>,<span class="string">&#x27;编辑&#x27;</span>),(<span class="number">6</span>,<span class="number">10</span>,<span class="string">&#x27;sys:user:del&#x27;</span>,<span class="string">&#x27;删除&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_user`(`user_id`, `role_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_menu`(`role_id`, `menu_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>),(<span class="number">1</span>, <span class="number">2</span>),(<span class="number">1</span>, <span class="number">3</span>),(<span class="number">1</span>, <span class="number">4</span>),(<span class="number">1</span>, <span class="number">5</span>),(<span class="number">1</span>, <span class="number">6</span>),(<span class="number">1</span>, <span class="number">7</span>),(<span class="number">1</span>, <span class="number">8</span>),(<span class="number">1</span>, <span class="number">9</span>),(<span class="number">1</span>, <span class="number">10</span>),(<span class="number">1</span>, <span class="number">11</span>),(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_role_permission`(`id`,`role_id`,`permission_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">1</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">1</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> Permissions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」前后端分离菜单权限控制-前端动态路由</title>
      <link href="/2021/12/27/spring-security-vue.html"/>
      <url>/2021/12/27/spring-security-vue.html</url>
      
        <content type="html"><![CDATA[<p>前端部分，这里基于<a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>模板来演示，<br><a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>是一个后台前端解决方案，它基于<a href="https://github.com/vuejs/vue">vue</a>和<a href="https://github.com/ElemeFE/element">element-ui</a>实现。<span id="more"></span></p><h3 id="1-安装-vue-element-admin"><a href="#1-安装-vue-element-admin" class="headerlink" title="1. 安装 vue-element-admin"></a>1. 安装 vue-element-admin</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/PanJiaChen/vue-element-admin.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> vue-element-admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖， 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题</span></span><br><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地开发 启动项目</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="2-改造前端路由挂载方式"><a href="#2-改造前端路由挂载方式" class="headerlink" title="2. 改造前端路由挂载方式"></a>2. 改造前端路由挂载方式</h3><p><a href="https://panjiachen.github.io/vue-element-admin-site/zh/">vue-element-admin</a>中权限的实现方式是：通过获取当前用户的权限去比对路由表，生成当前用户具有的权限可访问的路由表，通过<code>router.addRoutes</code>动态挂载到<code>router</code>上。</p><p>这里改造得更灵活一点，后台根据用户计算出可访问得菜单列表，直接返回用户可访问得菜单列表，前端也需要保存一份全的路由表，用户登录后得到可访问菜单，匹配前端保存的路由表然后动态挂载。</p><p>用户登录成功之后，在全局钩子<code>router.beforeEach</code>中拦截路由，判断是否已获得<code>token</code>，在获得<code>token</code>之后我们就要去获取用户的基本信息及可访问菜单，然后动态挂载路由。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src/permission.js</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="comment">// router.beforeEach</span></span><br><span class="line"><span class="keyword">const</span> hasRoles = store.<span class="property">getters</span>.<span class="property">roles</span> &amp;&amp; store.<span class="property">getters</span>.<span class="property">roles</span>.<span class="property">length</span> &gt; <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (hasRoles) &#123;</span><br><span class="line"><span class="title function_">next</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  <span class="keyword">const</span> &#123; menus &#125; = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getInfo&#x27;</span>)</span><br><span class="line">  <span class="comment">// generate accessible routes map based on menus</span></span><br><span class="line">  <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;permission/generateRoutes&#x27;</span>, menus)</span><br><span class="line">  <span class="comment">// dynamically add accessible routes</span></span><br><span class="line">  router.<span class="title function_">addRoutes</span>(accessRoutes)</span><br><span class="line">  <span class="comment">// ... other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-根据接口返回的菜单列表menus动态挂载路由"><a href="#2-1-根据接口返回的菜单列表menus动态挂载路由" class="headerlink" title="2.1 根据接口返回的菜单列表menus动态挂载路由"></a>2.1 根据接口返回的菜单列表<code>menus</code>动态挂载路由</h4><p>接口返回菜单数据：</p><p><img src="/2021/12/27/spring-security-vue/up-44f247866636a16715b39a0ed8941673c89.webp"></p><p>动态挂载路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src\store\modules\permission.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; constantRoutes, asyncRoutes, afterRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前路由名称对应的菜单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> menus 菜单列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name  路由名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterMeun</span>(<span class="params">menus, name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; menus.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> menu = menus[i]</span><br><span class="line">      <span class="keyword">if</span> (name === menu.<span class="property">name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> menu</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过后台请求的菜单列表递归过滤路由表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> routes asyncRoutes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> menus  接口返回的菜单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">filterAsyncRoutes</span>(<span class="params">routes, menus</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = &#123; ...route &#125;</span><br><span class="line">    <span class="keyword">const</span> meun = <span class="title function_">filterMeun</span>(menus, tmp.<span class="property">name</span>)</span><br><span class="line">    <span class="keyword">if</span> (meun != <span class="literal">null</span> &amp;&amp; meun.<span class="property">title</span>) &#123;</span><br><span class="line">      tmp.<span class="property">hidden</span> = meun.<span class="property">hidden</span> !== <span class="number">0</span></span><br><span class="line">      <span class="comment">// 显示的菜单替换后台设置的标题</span></span><br><span class="line">      <span class="keyword">if</span> (!tmp.<span class="property">hidden</span>) &#123;</span><br><span class="line">        tmp.<span class="property">meta</span>.<span class="property">title</span> = meun.<span class="property">title</span></span><br><span class="line">        tmp.<span class="property">sort</span> = meun.<span class="property">sort</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (meun.<span class="property">icon</span>) &#123;</span><br><span class="line">        tmp.<span class="property">meta</span>.<span class="property">icon</span> = meun.<span class="property">icon</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tmp.<span class="property">children</span>) &#123;</span><br><span class="line">        tmp.<span class="property">children</span> = <span class="title function_">filterAsyncRoutes</span>(tmp.<span class="property">children</span>, menus)</span><br><span class="line">      &#125;</span><br><span class="line">      res.<span class="title function_">push</span>(tmp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对菜单进行排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortRouters</span>(<span class="params">accessedRouters</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; accessedRouters.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> router = accessedRouters[i]</span><br><span class="line">    <span class="keyword">if</span> (router.<span class="property">children</span> &amp;&amp; router.<span class="property">children</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      router.<span class="property">children</span>.<span class="title function_">sort</span>(<span class="title function_">compare</span>(<span class="string">&#x27;sort&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  accessedRouters.<span class="title function_">sort</span>(<span class="title function_">compare</span>(<span class="string">&#x27;sort&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 升序比较函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">p</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> a = m[p]</span><br><span class="line">    <span class="keyword">const</span> b = n[p]</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">routes</span>: [],</span><br><span class="line">  <span class="attr">addRoutes</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="attr">SET_ROUTES</span>: <span class="function">(<span class="params">state, routes</span>) =&gt;</span> &#123;</span><br><span class="line">    state.<span class="property">addRoutes</span> = routes</span><br><span class="line">    state.<span class="property">routes</span> = constantRoutes.<span class="title function_">concat</span>(routes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="title function_">generateRoutes</span>(<span class="params">&#123; commit &#125;, menus</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 通过后台请求的菜单列表递归过滤路由表</span></span><br><span class="line">      <span class="keyword">const</span> roleAsyncRoutes = <span class="title function_">filterAsyncRoutes</span>(asyncRoutes, menus)</span><br><span class="line">      <span class="comment">// 对可访问菜单进行排序</span></span><br><span class="line">      <span class="title function_">sortRouters</span>(roleAsyncRoutes)</span><br><span class="line">      <span class="comment">// 拼接尾部公共菜单</span></span><br><span class="line">      <span class="keyword">const</span> accessedRoutes = roleAsyncRoutes.<span class="title function_">concat</span>(afterRoutes)</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;SET_ROUTES&#x27;</span>, accessedRoutes)</span><br><span class="line">      <span class="title function_">resolve</span>(accessedRoutes)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-前端保存的全路径路由表"><a href="#2-2-前端保存的全路径路由表" class="headerlink" title="2.2 前端保存的全路径路由表"></a>2.2 前端保存的全路径路由表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * src\router\index.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Layout</span> <span class="keyword">from</span> <span class="string">&#x27;@/layout&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有权限要求的基本路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/redirect&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/redirect/:path(.*)&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/redirect/index&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/login/index&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/error-page/404&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/dashboard/index&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Dashboard&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;后台首页&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;dashboard&#x27;</span>, <span class="attr">affix</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/profile&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/profile/index&#x27;</span>,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/profile/index&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Profile&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;个人中心&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">noCache</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态加载的路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/sys&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/sys/menus&#x27;</span>,</span><br><span class="line">      <span class="attr">alwaysShow</span>: <span class="literal">true</span>, <span class="comment">// will always show the root menu</span></span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;SysSetting&#x27;</span>, <span class="comment">// name必须和后台配置一致，不然匹配不到</span></span><br><span class="line">      <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;系统设置&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-s-tools&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;menus&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/menus/index&#x27;</span>),</span><br><span class="line">          <span class="attr">redirect</span>: <span class="string">&#x27;/sys/menus/list&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;SysMenus&#x27;</span>,</span><br><span class="line">          <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;菜单管理&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-menu&#x27;</span> &#125;,</span><br><span class="line">          <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/menus/list.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysMenuList&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;菜单列表&#x27;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/menus/form.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysMenuEdit&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑菜单&#x27;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/menus/form.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysMenuEdit&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;添加菜单&#x27;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;roles&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/roles/index&#x27;</span>),</span><br><span class="line">          <span class="attr">redirect</span>: <span class="string">&#x27;/sys/roles/list&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;SysRoles&#x27;</span>,</span><br><span class="line">          <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;角色管理&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;lock&#x27;</span> &#125;,</span><br><span class="line">          <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/roles/list.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysRoleList&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;角色列表&#x27;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/roles/form.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysRoleEdit&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑角色&#x27;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/roles/form.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysRoleEdit&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;添加角色&#x27;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;users&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/users/index&#x27;</span>),</span><br><span class="line">          <span class="attr">redirect</span>: <span class="string">&#x27;/sys/users/list&#x27;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;SysUsers&#x27;</span>,</span><br><span class="line">          <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;用户管理&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;user&#x27;</span> &#125;,</span><br><span class="line">          <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/users/list.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysUserList&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;用户列表&#x27;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/users/form.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysUserEdit&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;添加用户&#x27;</span> &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">path</span>: <span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">              <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">              <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/users/form.vue&#x27;</span>),</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;SysUserEdit&#x27;</span>,</span><br><span class="line">              <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑用户&#x27;</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">path</span>: <span class="string">&#x27;icons&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/sys/icons/index&#x27;</span>),</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;SysIcons&#x27;</span>,</span><br><span class="line">          <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;系统图标&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-picture&#x27;</span>, <span class="attr">noCache</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="comment">/** when your routing map is too long, you can split it into small modules **/</span></span><br><span class="line">  <span class="comment">// componentsRouter,</span></span><br><span class="line">  <span class="comment">// chartsRouter,</span></span><br><span class="line">  <span class="comment">// nestedRouter,</span></span><br><span class="line">  <span class="comment">// tableRouter,</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有权限要求的底部基本路由</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> afterRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;external-link&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;https://www.test.com/&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;友情链接&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;link&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 404 page must be placed at the end !!!</span></span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span>, <span class="attr">hidden</span>: <span class="literal">true</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createRouter</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">    <span class="comment">// mode: &#x27;history&#x27;, // require service support</span></span><br><span class="line">    <span class="attr">scrollBehavior</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">    <span class="attr">routes</span>: constantRoutes</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">resetRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = <span class="title function_">createRouter</span>()</span><br><span class="line">  router.<span class="property">matcher</span> = newRouter.<span class="property">matcher</span> <span class="comment">// reset router</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><blockquote><p>源码地址：<a href="https://github.com/chaooo/spring-security-jwt.git">https://github.com/chaooo/spring-security-jwt.git</a>,<br>这里我将本文的前后端分离后台菜单权限控制放在github源码tag的V4.0中，防止后续修改后代码对不上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」前后端分离后台菜单权限控制</title>
      <link href="/2021/12/13/spring-security-rbac.html"/>
      <url>/2021/12/13/spring-security-rbac.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-RBAC权限控制模型"><a href="#1-RBAC权限控制模型" class="headerlink" title="1. RBAC权限控制模型"></a>1. RBAC权限控制模型</h3><p>RBAC（Role-based access control）是一种以角色为基础的访问控制（Role-based access control，RBAC），它是一种较新且广为使用的权限控制机制，这种机制不是直接给用户赋予权限，而是将权限赋予角色。</p><p>RBAC 权限模型将用户按角色进行归类，通过用户的角色来确定用户对某项资源是否具备操作权限。RBAC 简化了用户与权限的管理，它将用户与角色关联、角色与权限关联、权限与资源关联，这种模式使得用户的授权管理变得非常简单和易于维护。<span id="more"></span></p><h3 id="2-数据库设计"><a href="#2-数据库设计" class="headerlink" title="2. 数据库设计"></a>2. 数据库设计</h3><p><img src="/2021/12/13/spring-security-rbac/up-fbcbfd800689ec7a2a799e6db4b0bbb84e6.webp"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  `username` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `role_name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">  `role_desc` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 菜单表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_menu`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_menu` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">  `menu_name` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单名称&#x27;</span>,</span><br><span class="line">  `menu_path` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单路径&#x27;</span>,</span><br><span class="line">  `menu_type` <span class="type">char</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单类型(1:一级菜单，2:子菜单，3:按钮)&#x27;</span>,</span><br><span class="line">  `menu_parent_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;父级菜单Id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;菜单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用户&amp;角色 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_user` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统用户角色关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 菜单&amp;角色 关联表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_menu`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_menu` (</span><br><span class="line">  `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单ID&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4 COMMENT<span class="operator">=</span><span class="string">&#x27;系统角色菜单关联表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始数据：</span></span><br><span class="line"><span class="comment">-- 管理员拥有所有菜单权限</span></span><br><span class="line"><span class="comment">-- 普通用户拥有查看权限</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role`(`id`, `role_name`, `role_desc`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;管理员&#x27;</span>),(<span class="number">2</span>, <span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;普通用户&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_menu`(`id`, `menu_name`,`menu_path`,`menu_type`,`menu_parent_id`)</span><br><span class="line">    <span class="keyword">VALUES</span>  (<span class="number">1</span>, <span class="string">&#x27;用户管理&#x27;</span>, <span class="string">&#x27;/user&#x27;</span>, <span class="number">1</span>, <span class="keyword">null</span>),</span><br><span class="line">            (<span class="number">2</span>, <span class="string">&#x27;用户列表&#x27;</span>, <span class="string">&#x27;/user/list&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">            (<span class="number">3</span>, <span class="string">&#x27;新增用户&#x27;</span>, <span class="string">&#x27;/user/add&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">            (<span class="number">4</span>, <span class="string">&#x27;修改用户&#x27;</span>, <span class="string">&#x27;/user/update&#x27;</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">            (<span class="number">5</span>, <span class="string">&#x27;删除用户&#x27;</span>, <span class="string">&#x27;/user/delete&#x27;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_user`(`user_id`, `role_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sys_role_menu`(`role_id`, `menu_id`)</span><br><span class="line">    <span class="keyword">VALUES</span>  (<span class="number">1</span>, <span class="number">1</span>),(<span class="number">1</span>, <span class="number">2</span>),(<span class="number">1</span>, <span class="number">3</span>),(<span class="number">1</span>, <span class="number">4</span>),(<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">            (<span class="number">2</span>, <span class="number">1</span>),(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="3-代码进化"><a href="#3-代码进化" class="headerlink" title="3. 代码进化"></a>3. 代码进化</h3><ol><li>修改注册逻辑，注册时添加用户权限</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseJson&lt;SysUser&gt; <span class="title function_">register</span><span class="params">(SysUser sysUser)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(sysUser.getUsername()) &amp;&amp; StringUtils.hasLength(sysUser.getPassword())) &#123;</span><br><span class="line">        <span class="comment">// 密码加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">encodePassword</span> <span class="operator">=</span> passwordEncoder.encode(sysUser.getPassword());</span><br><span class="line">        sysUser.setPassword(encodePassword);</span><br><span class="line">        <span class="comment">// 新增用户</span></span><br><span class="line">        sysUserDao.insertSysUser(sysUser);</span><br><span class="line">        <span class="comment">// 角色Ids，用&quot;,&quot;隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">roleIds</span> <span class="operator">=</span> sysUser.getRoleIds();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(roleIds)) &#123;</span><br><span class="line">            <span class="comment">// 设置用户角色</span></span><br><span class="line">            String[] split = roleIds.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(s)) &#123;</span><br><span class="line">                    <span class="comment">// 保存用户角色关系</span></span><br><span class="line">                    sysUserDao.insertUserRoleRelation(sysUser.getId(), Long.valueOf(s));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseJson.success(<span class="string">&quot;注册成功&quot;</span>, sysUser);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseJson.error(<span class="string">&quot;用户名或密码不能为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>封装JWT服务工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> roleList 角色列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(String username, List&lt;String&gt; roleList)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置签发时间</span></span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="comment">// 设置过期时间</span></span><br><span class="line">        calendar.add(Calendar.MINUTE, ConstantKey.TOKEN_EXPIRE);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setSubject(username + <span class="string">&quot;-&quot;</span> + roleList)</span><br><span class="line">                <span class="comment">// 签发时间</span></span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                <span class="comment">// 过期时间</span></span><br><span class="line">                .setExpiration(time)</span><br><span class="line">                <span class="comment">// 自定义算法与签名：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="comment">// 将token存入redis,并设置超时时间为token过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> time.getTime() - now.getTime();</span><br><span class="line">        redisService.set(token, token, expire);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析Token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseToken</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userinfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(ConstantKey.TOKEN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(token)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cacheToken</span> <span class="operator">=</span> String.valueOf(redisService.get(token));</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(cacheToken) &amp;&amp; !<span class="string">&quot;null&quot;</span>.equals(cacheToken)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                            <span class="comment">// 设置生成token的签名key</span></span><br><span class="line">                            .setSigningKey(ConstantKey.SIGNING_KEY)</span><br><span class="line">                            <span class="comment">// 解析token</span></span><br><span class="line">                            .parseClaimsJws(cacheToken).getBody();</span><br><span class="line">                    <span class="comment">// 取出用户信息</span></span><br><span class="line">                    userinfo = claims.getSubject();</span><br><span class="line">                    <span class="comment">// 重设Redis超时时间</span></span><br><span class="line">                    resetRedisExpire(token, claims);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Token过期续签，ExpiredJwtException=&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> e.getClaims();</span><br><span class="line">                    <span class="comment">// 取出用户信息</span></span><br><span class="line">                    userinfo = claims.getSubject();</span><br><span class="line">                    <span class="comment">// 刷新Token</span></span><br><span class="line">                    refreshToken(token, claims);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedJwtException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，UnsupportedJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MalformedJwtException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，MalformedJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，SignatureException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，IllegalArgumentException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userinfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析Token,取出用户名（Token过期仍取出用户名）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(ConstantKey.TOKEN_NAME);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(token)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userinfo</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                        <span class="comment">// 设置生成token的签名key</span></span><br><span class="line">                        .setSigningKey(ConstantKey.SIGNING_KEY)</span><br><span class="line">                        <span class="comment">// 解析token</span></span><br><span class="line">                        .parseClaimsJws(token).getBody();</span><br><span class="line">                <span class="comment">// 取出用户信息</span></span><br><span class="line">                userinfo = claims.getSubject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> e.getClaims();</span><br><span class="line">                <span class="comment">// 取出用户信息</span></span><br><span class="line">                userinfo = claims.getSubject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored)&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(userinfo))&#123;</span><br><span class="line">                username = userinfo.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重设Redis超时时间</span></span><br><span class="line"><span class="comment">     * 当前时间 + (`cacheToken`过期时间 - `cacheToken`签发时间)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetRedisExpire</span><span class="params">(String token, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// token签发时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">issuedAt</span> <span class="operator">=</span> claims.getIssuedAt().getTime();</span><br><span class="line">        <span class="comment">// token过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expiration</span> <span class="operator">=</span> claims.getExpiration().getTime();</span><br><span class="line">        <span class="comment">// 当前时间 + (`cacheToken`过期时间 - `cacheToken`签发时间)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> current + (expiration - issuedAt);</span><br><span class="line">        <span class="comment">// 重设Redis超时时间</span></span><br><span class="line">        redisService.expire(token, expireAt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新Token</span></span><br><span class="line"><span class="comment">     * 刷新Token的时机： 当cacheToken已过期 并且Redis在有效期内</span></span><br><span class="line"><span class="comment">     * 重新生成Token并覆盖Redis的v值(这时候k、v值不一样了)，然后设置Redis过期时间为：新Token过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshToken</span><span class="params">(String token, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 重新生成token</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置签发时间</span></span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="comment">// 设置过期时间: TOKEN_EXPIRE分钟</span></span><br><span class="line">        calendar.add(Calendar.MINUTE, ConstantKey.TOKEN_EXPIRE);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setSubject(claims.getSubject())</span><br><span class="line">                <span class="comment">// 签发时间</span></span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                <span class="comment">// 过期时间</span></span><br><span class="line">                .setExpiration(time)</span><br><span class="line">                <span class="comment">// 算法与签名(同生成token)：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="comment">// 将refreshToken覆盖Redis的v值,并设置超时时间为refreshToken过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expire</span> <span class="operator">=</span> time.getTime() - now.getTime();</span><br><span class="line">        redisService.set(token, token, expire);</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        log.info(<span class="string">&quot;刷新token执行时间: &#123;&#125;&quot;</span>, (System.currentTimeMillis() - current) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写获取用户可访问菜单接口（用户登录后，携带Token去获取用户角色，根据角色计算出用户可访问菜单）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/menu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseJson&lt;List&lt;SysMenu&gt;&gt; <span class="title function_">menuList</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jwtService.getUsername(request);</span><br><span class="line">    <span class="keyword">return</span> sysUserService.menuList(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseJson&lt;List&lt;SysMenu&gt;&gt; <span class="title function_">menuList</span><span class="params">(String username)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(username)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseJson.error(<span class="string">&quot;用户信息异常&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取用户角色Id</span></span><br><span class="line">    List&lt;Long&gt; roleIds = sysUserDao.getRoleIdsByUserId(username);</span><br><span class="line">    List&lt;SysMenu&gt; menus = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(roleIds)) &#123;</span><br><span class="line">        <span class="comment">// 根据角色Id获取菜单列表</span></span><br><span class="line">        menus = sysUserDao.getMenuListByRoleIds(roleIds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseJson.success(menus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getRoleIdsByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span></span><br><span class="line">    SELECT DISTINCT ru.role_id FROM sys_role_user ru</span><br><span class="line">    LEFT JOIN sys_user u ON ru.user_id = u.id</span><br><span class="line">    WHERE u.username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getMenuListByRoleIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.jwt.entity.SysMenu&quot;</span>&gt;</span></span><br><span class="line">    SELECT m.id, m.menu_name AS menuName, m.menu_path AS menuPath, m.menu_type AS menuType, m.menu_parent_id AS parentId</span><br><span class="line">    FROM sys_menu m</span><br><span class="line">             LEFT JOIN sys_role_menu rm ON m.id = rm.menu_id</span><br><span class="line">    WHERE rm.role_id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;roleId&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;roleIds&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;roleId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><ol><li>普通用户可访问菜单：</li></ol><p><img src="/2021/12/13/spring-security-rbac/up-2368413a1b85f66e78676578c3592e42076.webp"></p><ol start="2"><li>管理员可访问菜单：</li></ol><p><img src="/2021/12/13/spring-security-rbac/up-f0af2cb0f3d7a9221a95ddb78fd9f01cfd9.webp"></p><blockquote><p>源码地址：<a href="https://github.com/chaooo/spring-security-jwt.git">https://github.com/chaooo/spring-security-jwt.git</a>,<br>这里我将本文的前后端分离后台菜单权限控制放在github源码tag的V3.0中，防止后续修改后代码对不上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> RBAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」基于Redis的Token自动续签优化</title>
      <link href="/2021/12/10/spring-security-token.html"/>
      <url>/2021/12/10/spring-security-token.html</url>
      
        <content type="html"><![CDATA[<p>本文基于上一篇文章：《Spring Security（三）整合 JWT 实现无状态登录示例》。</p><p>在 <code>SpringSecurity</code> 整合 <code>JWT</code> 实现无状态登录示例中，我们在 <code>JwtAuthenticationFilter</code> (自定义<code>JWT</code>认证过滤器) 解析 <code>Token</code> 成功后，提供了续签逻辑：<span id="more"></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新Token的时机：</span></span><br><span class="line"><span class="comment"> * 1. 当前时间 &lt; token过期时间</span></span><br><span class="line"><span class="comment"> * 2. 当前时间 &gt; (签发时间 + (token过期时间 - token签发时间)/2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshToken</span><span class="params">(HttpServletResponse response, Claims claims)</span> &#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// token签发时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">issuedAt</span> <span class="operator">=</span> claims.getIssuedAt().getTime();</span><br><span class="line">    <span class="comment">// token过期时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">expiration</span> <span class="operator">=</span> claims.getExpiration().getTime();</span><br><span class="line">    <span class="comment">// (当前时间 &lt; token过期时间) &amp;&amp; (当前时间 &gt; (签发时间 + (token过期时间 - token签发时间)/2))</span></span><br><span class="line">    <span class="keyword">if</span> ((current &lt; expiration) &amp;&amp; (current &gt; (issuedAt + ((expiration - issuedAt) / <span class="number">2</span>)))) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 重新生成token</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置签发时间</span></span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="comment">// 设置过期时间: 5分钟</span></span><br><span class="line">        calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setSubject(claims.getSubject())</span><br><span class="line">                <span class="comment">// 签发时间</span></span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                <span class="comment">// 过期时间</span></span><br><span class="line">                .setExpiration(time)</span><br><span class="line">                <span class="comment">// 算法与签名(同生成token)：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="comment">// 主动刷新token，并返回给前端</span></span><br><span class="line">        response.addHeader(<span class="string">&quot;refreshToken&quot;</span>, refreshToken);</span><br><span class="line">        log.info(<span class="string">&quot;刷新token执行时间: &#123;&#125;&quot;</span>, (System.currentTimeMillis() - current) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑是：<code>Token</code> 未过期并且当前时间已经超过 <code>Token</code> 有效时间的一半，重新生成一个 <code>refreshToken</code>，并返回给前端，前端需要用 <code>refreshToken</code> 替换之前旧的 <code>Token</code>。</p><h3 id="Token续签优化方案"><a href="#Token续签优化方案" class="headerlink" title="Token续签优化方案"></a>Token续签优化方案</h3><p>预期效果：前端不需要手动替换 <code>Token</code>，每次用 <code>Token</code> 请求资源时自动续期。</p><p>实现方案：引入 <code>Redis</code>，实现逻辑：</p><ol><li>登录成功后将 <code>Token</code> 存储到 <code>Redis</code> 里面(k,v都为 <code>Token</code> 的值)，并设置 <code>Redis</code> 过期时间为： <code>Token</code> 过期时间。</li><li>用户发起请求时，每次都根据k为<code>Token</code>的键去换取 <code>Redis</code> 的值，这里命名为 <code>cacheToken</code>：<ul><li>当 <code>cacheToken</code> 在有效期内，重设 <code>Redis</code> 过期时间为：当前时间 + (<code>cacheToken</code>过期时间 - <code>cacheToken</code>签发时间)。</li><li>当 <code>cacheToken</code> 已过期（<code>Redis</code> 在有效期内），则 <code>JWT</code> 重新生成 <code>Token</code> 并覆盖v值(这时候k、v值不一样了)，然后设置 <code>Redis</code> 过期时间为： <code>cacheToken</code> 过期时间。</li><li>若 <code>Redis</code> 也过期，取不到 <code>cacheToken</code>，则拒绝访问或返回错误信息，需要重新登录。</li></ul></li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><h5 id="1-在-pom-xml-中引入-Redis-依赖："><a href="#1-在-pom-xml-中引入-Redis-依赖：" class="headerlink" title="1. 在 pom.xml 中引入 Redis 依赖："></a>1. 在 <code>pom.xml</code> 中引入 <code>Redis</code> 依赖：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-在-application-yml-配置文件中配置-Redis："><a href="#2-在-application-yml-配置文件中配置-Redis：" class="headerlink" title="2. 在 application.yml 配置文件中配置 Redis："></a>2. 在 <code>application.yml</code> 配置文件中配置 <code>Redis</code>：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password: 123456</span><br><span class="line">    # Redis数据库索引（默认为0）</span><br><span class="line">    database: 0</span><br><span class="line">    # 连接超时时间（毫秒）</span><br><span class="line">    timeout: 5000</span><br></pre></td></tr></table></figure><h5 id="3-简单的-RedisService-封装"><a href="#3-简单的-RedisService-封装" class="headerlink" title="3. 简单的 RedisService 封装"></a>3. 简单的 <code>RedisService</code> 封装</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;Serializable, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> operations.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断缓存中是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.hasLength(key) &amp;&amp; Boolean.TRUE.equals(redisTemplate.hasKey(key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (exists(key)) &#123;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存 并 加上过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, Date date)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations&lt;Serializable, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">            operations.set(key, value);</span><br><span class="line">            redisTemplate.expireAt(key, date);</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入过期时间（毫秒）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, Long expireTimeMillis)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.expire(key, expireTimeMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-修改JWT登录过滤器-JwtLoginFilter，构造方法中加入-RedisService，并生成-Token-后存入-Redis"><a href="#4-修改JWT登录过滤器-JwtLoginFilter，构造方法中加入-RedisService，并生成-Token-后存入-Redis" class="headerlink" title="4. 修改JWT登录过滤器 JwtLoginFilter，构造方法中加入 RedisService，并生成 Token 后存入 Redis:"></a>4. 修改JWT登录过滤器 <code>JwtLoginFilter</code>，构造方法中加入 <code>RedisService</code>，并生成 <code>Token</code> 后存入 <code>Redis</code>:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisService redisService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtLoginFilter</span><span class="params">(AuthenticationManager authenticationManager, RedisService redisService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        <span class="built_in">this</span>.redisService = redisService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试身份认证(接收并解析用户凭证)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> authenticationManager.authenticate(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证成功(用户成功登录后，这个方法会被调用，我们在这个方法里生成token)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication auth)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = auth.getAuthorities();</span><br><span class="line">            <span class="comment">// 定义存放角色集合的对象</span></span><br><span class="line">            List&lt;String&gt; roleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorities) &#123;</span><br><span class="line">                roleList.add(grantedAuthority.getAuthority());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 生成token</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">            <span class="comment">// 设置签发时间</span></span><br><span class="line">            calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">            <span class="comment">// 设置过期时间: 5分钟</span></span><br><span class="line">            calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                    .setSubject(auth.getName() + <span class="string">&quot;-&quot;</span> + roleList)</span><br><span class="line">                    <span class="comment">// 签发时间</span></span><br><span class="line">                    .setIssuedAt(now)</span><br><span class="line">                    <span class="comment">// 过期时间</span></span><br><span class="line">                    .setExpiration(time)</span><br><span class="line">                    <span class="comment">// 自定义算法与签名：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                    .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                    .compact();</span><br><span class="line">            <span class="comment">// 将token存入redis,并设置超时时间为token过期时间</span></span><br><span class="line">            redisService.set(token, token, time);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 返回token</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            log.info(<span class="string">&quot;用户登录成功，生成token=&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="comment">// 登录成功后，返回token到header里面</span></span><br><span class="line">            response.addHeader(<span class="string">&quot;Authorization&quot;</span>, token);</span><br><span class="line">            <span class="comment">// 登录成功后，返回token到body里面</span></span><br><span class="line">            ResponseJson&lt;String&gt; result = ResponseJson.success(<span class="string">&quot;登录成功&quot;</span>, token);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.getWriter().write(JSON.toJSONString(result));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;IOException:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;登录失败[&#123;&#125;]，AuthenticationException=&#123;&#125;&quot;</span>, request.getRequestURI(), exception.getMessage());</span><br><span class="line">        <span class="comment">// 登录失败，返回错误信息</span></span><br><span class="line">        ResponseJson&lt;Void&gt; result = ResponseJson.error(exception.getMessage(), <span class="literal">null</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(JSON.toJSONString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-修改JWT认证过滤器-JwtAuthenticationFilter，构造方法中加入-RedisService，并添加-Token-续签逻辑"><a href="#5-修改JWT认证过滤器-JwtAuthenticationFilter，构造方法中加入-RedisService，并添加-Token-续签逻辑" class="headerlink" title="5. 修改JWT认证过滤器 JwtAuthenticationFilter，构造方法中加入 RedisService，并添加 Token 续签逻辑:"></a>5. 修改JWT认证过滤器 <code>JwtAuthenticationFilter</code>，构造方法中加入 <code>RedisService</code>，并添加 <code>Token</code> 续签逻辑:</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicAuthenticationFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisService redisService;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtAuthenticationFilter</span><span class="params">(AuthenticationManager authenticationManager, RedisService redisService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authenticationManager);</span><br><span class="line">        <span class="built_in">this</span>.redisService = redisService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> getAuthentication(request, response);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title function_">getAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 解析token</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(token)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cacheToken</span> <span class="operator">=</span> String.valueOf(redisService.get(token));</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(token) &amp;&amp; !<span class="string">&quot;null&quot;</span>.equals(cacheToken)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                            <span class="comment">// 设置生成token的签名key</span></span><br><span class="line">                            .setSigningKey(ConstantKey.SIGNING_KEY)</span><br><span class="line">                            <span class="comment">// 解析token</span></span><br><span class="line">                            .parseClaimsJws(cacheToken).getBody();</span><br><span class="line">                    <span class="comment">// 取出用户信息</span></span><br><span class="line">                    user = claims.getSubject();</span><br><span class="line">                    <span class="comment">// 重设Redis超时时间</span></span><br><span class="line">                    resetRedisExpire(token, claims);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Token过期续签，ExpiredJwtException=&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                    <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> e.getClaims();</span><br><span class="line">                    <span class="comment">// 取出用户信息</span></span><br><span class="line">                    user = claims.getSubject();</span><br><span class="line">                    <span class="comment">// 刷新Token</span></span><br><span class="line">                    refreshToken(token, claims);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedJwtException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，UnsupportedJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (MalformedJwtException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，MalformedJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，SignatureException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，IllegalArgumentException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取用户权限和角色</span></span><br><span class="line">                    String[] split = user.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    ArrayList&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">                        authorities.add(<span class="keyword">new</span> <span class="title class_">GrantedAuthorityImpl</span>(s));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 返回Authentication</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, authorities);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，需要身份认证&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重设Redis超时时间</span></span><br><span class="line"><span class="comment">     * 当前时间 + (`cacheToken`过期时间 - `cacheToken`签发时间)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resetRedisExpire</span><span class="params">(String token, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// token签发时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">issuedAt</span> <span class="operator">=</span> claims.getIssuedAt().getTime();</span><br><span class="line">        <span class="comment">// token过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expiration</span> <span class="operator">=</span> claims.getExpiration().getTime();</span><br><span class="line">        <span class="comment">// 当前时间 + (`cacheToken`过期时间 - `cacheToken`签发时间)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> current + (expiration - issuedAt);</span><br><span class="line">        <span class="comment">// 重设Redis超时时间</span></span><br><span class="line">        redisService.expire(token, expireAt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新Token</span></span><br><span class="line"><span class="comment">     * 刷新Token的时机： 当cacheToken已过期 并且Redis在有效期内</span></span><br><span class="line"><span class="comment">     * 重新生成Token并覆盖Redis的v值(这时候k、v值不一样了)，然后设置Redis过期时间为：新Token过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshToken</span><span class="params">(String token, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 重新生成token</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 设置签发时间</span></span><br><span class="line">        calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="comment">// 设置过期时间: 5分钟</span></span><br><span class="line">        calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">        <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setSubject(claims.getSubject())</span><br><span class="line">                <span class="comment">// 签发时间</span></span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                <span class="comment">// 过期时间</span></span><br><span class="line">                .setExpiration(time)</span><br><span class="line">                <span class="comment">// 算法与签名(同生成token)：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="comment">// 将refreshToken覆盖Redis的v值,并设置超时时间为refreshToken过期时间</span></span><br><span class="line">        redisService.set(token, refreshToken, time);</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        log.info(<span class="string">&quot;刷新token执行时间: &#123;&#125;&quot;</span>, (System.currentTimeMillis() - current) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-修改-SpringSecurity-配置类，注入-RedisService："><a href="#6-修改-SpringSecurity-配置类，注入-RedisService：" class="headerlink" title="6. 修改 SpringSecurity 配置类，注入 RedisService："></a>6. 修改 <code>SpringSecurity</code> 配置类，注入 <code>RedisService</code>：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局请求忽略规则配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要放行的URL</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义认证策略：登录的时候会进入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 通过实现 AuthenticationProvider 自定义身份认证验证组件</span></span><br><span class="line">        auth.authenticationProvider(<span class="keyword">new</span> <span class="title class_">AuthenticationProviderImpl</span>(userDetailsService, bCryptPasswordEncoder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义 HTTP 验证规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 关闭Session</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            <span class="comment">// 所有请求需要身份认证</span></span><br><span class="line">            .and().authorizeRequests().anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">// 自定义JWT登录过滤器</span></span><br><span class="line">            .addFilter(<span class="keyword">new</span> <span class="title class_">JwtLoginFilter</span>(authenticationManager(), redisService))</span><br><span class="line">            <span class="comment">// 自定义JWT认证过滤器</span></span><br><span class="line">            .addFilter(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(authenticationManager(), redisService))</span><br><span class="line">            <span class="comment">// 自定义认证拦截器，也可以直接使用内置实现类Http403ForbiddenEntryPoint</span></span><br><span class="line">            .exceptionHandling().authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">AuthenticationEntryPointImpl</span>())</span><br><span class="line">            <span class="comment">// 允许跨域</span></span><br><span class="line">            .and().cors()</span><br><span class="line">            <span class="comment">// 禁用跨站伪造</span></span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>源码地址：<a href="https://github.com/chaooo/spring-security-jwt.git">https://github.com/chaooo/spring-security-jwt.git</a>,<br>这里我将本文的基于Redis的Token自动续签优化放在github源码tag的V2.0中，防止后续修改后代码对不上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」整合 JWT 实现无状态登录示例</title>
      <link href="/2021/12/09/spring-security-jwt.html"/>
      <url>/2021/12/09/spring-security-jwt.html</url>
      
        <content type="html"><![CDATA[<p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p><span id="more"></span><ul><li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li><li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li><li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li></ul><h3 id="1-依赖与配置文件"><a href="#1-依赖与配置文件" class="headerlink" title="1. 依赖与配置文件"></a>1. 依赖与配置文件</h3><ol><li>在 <code>pom.xml</code> 中引入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.78<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>用户信息从数据库中获取，在 <code>application.yml</code> 配置文件中配置：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://192.168.2.100:3306/security?characterEncoding=UTF8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: developer</span><br><span class="line">    password: 05bZ/OxTB:X+yd%1</span><br><span class="line"></span><br><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:mapper/*.xml</span><br></pre></td></tr></table></figure><h3 id="2-自定义Security策略"><a href="#2-自定义Security策略" class="headerlink" title="2. 自定义Security策略"></a>2. 自定义Security策略</h3><h4 id="2-1-通过继承-WebSecurityConfigurerAdapter-实现自定义Security策略"><a href="#2-1-通过继承-WebSecurityConfigurerAdapter-实现自定义Security策略" class="headerlink" title="2.1 通过继承 WebSecurityConfigurerAdapter 实现自定义Security策略"></a>2.1 通过继承 WebSecurityConfigurerAdapter 实现自定义Security策略</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 通过继承 WebSecurityConfigurerAdapter 实现自定义Security策略</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：声明当前类是一个配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableWebSecurity</span>：开启WebSecurity模式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@EnableGlobalMethodSecurity</span>(securedEnabled=true)：开启注解，支持方法级别的权限控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全局请求忽略规则配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要放行的URL</span></span><br><span class="line">        web.ignoring().antMatchers(<span class="string">&quot;/register&quot;</span>, <span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义认证策略：登录的时候会进入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> &#123;</span><br><span class="line">        <span class="comment">// 2.通过实现 AuthenticationProvider 自定义身份认证验证组件</span></span><br><span class="line">        auth.authenticationProvider(<span class="keyword">new</span> <span class="title class_">AuthenticationProviderImpl</span>(userDetailsService, bCryptPasswordEncoder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HTTP 验证规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">// 关闭Session</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            <span class="comment">// 所有请求需要身份认证</span></span><br><span class="line">            .and().authorizeRequests().anyRequest().authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            <span class="comment">// 3.自定义JWT登录过滤器</span></span><br><span class="line">            .addFilter(<span class="keyword">new</span> <span class="title class_">JwtLoginFilter</span>(authenticationManager()))</span><br><span class="line">            <span class="comment">// 4.自定义JWT认证过滤器</span></span><br><span class="line">            .addFilter(<span class="keyword">new</span> <span class="title class_">JwtAuthenticationFilter</span>(authenticationManager()))</span><br><span class="line">            <span class="comment">// 5.自定义认证拦截器，也可以直接使用内置实现类Http403ForbiddenEntryPoint</span></span><br><span class="line">            .exceptionHandling().authenticationEntryPoint(<span class="keyword">new</span> <span class="title class_">AuthenticationEntryPointImpl</span>())</span><br><span class="line">            <span class="comment">// 允许跨域</span></span><br><span class="line">            .and().cors()</span><br><span class="line">            <span class="comment">// 禁用跨站伪造</span></span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BCryptPasswordEncoder</code> 解析器注入到容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BCryptPasswordEncoder <span class="title function_">bCryptPasswordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>UserDetailsService</code> 接口，自定义逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SysUserDao sysUserDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 数据库中查找用户</span></span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">user</span> <span class="operator">=</span> sysUserDao.findByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户&quot;</span> + username + <span class="string">&quot;不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(user.getUsername(), user.getPassword(), emptyList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-通过实现-AuthenticationProvider-自定义身份认证验证组件"><a href="#2-2-通过实现-AuthenticationProvider-自定义身份认证验证组件" class="headerlink" title="2.2 通过实现 AuthenticationProvider 自定义身份认证验证组件"></a>2.2 通过实现 AuthenticationProvider 自定义身份认证验证组件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationProviderImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDetailsService userDetailsService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BCryptPasswordEncoder bCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthenticationProviderImpl</span><span class="params">(UserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDetailsService = userDetailsService;</span><br><span class="line">        <span class="built_in">this</span>.bCryptPasswordEncoder = bCryptPasswordEncoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来验证用户身份 （对传递的Authentication对象的身份验证）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication 传递的Authentication对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含凭证的经过完全认证的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException 份验证失败异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 获取认证的用户名 &amp; 密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> authentication.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="comment">// 认证逻辑</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(name);</span><br><span class="line">        <span class="keyword">if</span> (bCryptPasswordEncoder.matches(password, userDetails.getPassword())) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户登录成功，username=&#123;&#125;&quot;</span>, name);</span><br><span class="line">            <span class="comment">// 这里设置权限和角色</span></span><br><span class="line">            ArrayList&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            authorities.add( <span class="keyword">new</span> <span class="title class_">GrantedAuthorityImpl</span>(<span class="string">&quot;ROLE_ADMIN&quot;</span>));</span><br><span class="line">            authorities.add( <span class="keyword">new</span> <span class="title class_">GrantedAuthorityImpl</span>(<span class="string">&quot;AUTH_WRITE&quot;</span>));</span><br><span class="line">            <span class="comment">// 生成令牌 这里令牌里面存入了:name,password,authorities, 当然你也可以放其他内容</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(name, password, authorities);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前的AuthenticationProvider 是否支持对应的Authentication对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authentication Authentication对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> authentication.equals(UsernamePasswordAuthenticationToken.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>GrantedAuthority</code> 存储权限和角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 权限类型，负责存储权限和角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GrantedAuthorityImpl</span> <span class="keyword">implements</span> <span class="title class_">GrantedAuthority</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String authority;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GrantedAuthorityImpl</span><span class="params">(String authority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authority = authority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthority</span><span class="params">(String authority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authority = authority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.authority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-自定义JWT登录过滤器，继承-UsernamePasswordAuthenticationFilter"><a href="#2-3-自定义JWT登录过滤器，继承-UsernamePasswordAuthenticationFilter" class="headerlink" title="2.3 自定义JWT登录过滤器，继承 UsernamePasswordAuthenticationFilter"></a>2.3 自定义JWT登录过滤器，继承 UsernamePasswordAuthenticationFilter</h4><p>重写了其中的3个方法</p><ul><li><code>attemptAuthentication</code>：接收并解析用户凭证。</li><li><code>successfulAuthentication</code>：用户成功登录后被调用，我们在这个方法里生成token。</li><li><code>unsuccessfulAuthentication</code>：认证失败后被调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtLoginFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试身份认证(接收并解析用户凭证)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> authenticationManager.authenticate(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证成功(用户成功登录后，这个方法会被调用，我们在这个方法里生成token)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication auth)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; authorities = auth.getAuthorities();</span><br><span class="line">            <span class="comment">// 定义存放角色集合的对象</span></span><br><span class="line">            List&lt;String&gt; roleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority grantedAuthority : authorities) &#123;</span><br><span class="line">                roleList.add(grantedAuthority.getAuthority());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 生成token</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">            <span class="comment">// 设置签发时间</span></span><br><span class="line">            calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">            <span class="comment">// 设置过期时间: 5分钟</span></span><br><span class="line">            calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                    .setSubject(auth.getName() + <span class="string">&quot;-&quot;</span> + roleList)</span><br><span class="line">                    <span class="comment">// 签发时间</span></span><br><span class="line">                    .setIssuedAt(now)</span><br><span class="line">                    <span class="comment">// 过期时间</span></span><br><span class="line">                    .setExpiration(time)</span><br><span class="line">                    <span class="comment">// 自定义算法与签名：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                    .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                    .compact();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 返回token</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            log.info(<span class="string">&quot;用户登录成功，生成token=&#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="comment">// 登录成功后，返回token到header里面</span></span><br><span class="line">            response.addHeader(<span class="string">&quot;Authorization&quot;</span>, token);</span><br><span class="line">            <span class="comment">// 登录成功后，返回token到body里面</span></span><br><span class="line">            ResponseJson&lt;String&gt; result = ResponseJson.success(token);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.getWriter().write(JSON.toJSONString(result));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;IOException:&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;登录失败[&#123;&#125;]，AuthenticationException=&#123;&#125;&quot;</span>, request.getRequestURI(), exception.getMessage());</span><br><span class="line">        <span class="comment">// 登录失败，返回错误信息</span></span><br><span class="line">        ResponseJson&lt;Void&gt; result = ResponseJson.error(exception.getMessage(), <span class="literal">null</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(JSON.toJSONString(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义加密的签名<code>key</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义签名key常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstantKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;Charles@Jwt!&amp;Secret^#&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义全局API返回JSON数据对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseJson</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/** 自定义状态码 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="comment">/** 提示信息 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/** 返回数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ResponseJson</span><span class="params">(<span class="type">int</span> code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResponseJson&lt;Void&gt; <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;操作成功&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; ResponseJson&lt;T&gt; <span class="title function_">success</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(<span class="number">0</span>, <span class="string">&quot;操作成功&quot;</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; ResponseJson&lt;T&gt; <span class="title function_">success</span><span class="params">(String msg, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(<span class="number">0</span>, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; ResponseJson&lt;T&gt; <span class="title function_">success</span><span class="params">(<span class="type">int</span> code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(code, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResponseJson&lt;Void&gt; <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(-<span class="number">1</span>, <span class="string">&quot;操作失败&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResponseJson&lt;Void&gt; <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(-<span class="number">1</span>, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResponseJson&lt;Void&gt; <span class="title function_">error</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(code, msg, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; ResponseJson&lt;T&gt; <span class="title function_">error</span><span class="params">(String msg, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(-<span class="number">1</span>, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; ResponseJson&lt;T&gt; <span class="title function_">error</span><span class="params">(<span class="type">int</span> code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseJson</span>&lt;&gt;(code, msg, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ResponseJson&#123;&quot;</span> + <span class="string">&quot;code=&quot;</span> + code + <span class="string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, data=&quot;</span> + data + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-自定义JWT认证过滤器，继承-BasicAuthenticationFilter，重写doFilterInternal方法"><a href="#2-4-自定义JWT认证过滤器，继承-BasicAuthenticationFilter，重写doFilterInternal方法" class="headerlink" title="2.4 自定义JWT认证过滤器，继承 BasicAuthenticationFilter，重写doFilterInternal方法"></a>2.4 自定义JWT认证过滤器，继承 BasicAuthenticationFilter，重写doFilterInternal方法</h4><p>从http头的Authorization 项读取token数据，然后用Jwts包提供的方法校验token的合法性。如果校验通过，就认为这是一个取得授权的合法请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicAuthenticationFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtAuthenticationFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(authenticationManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authentication</span> <span class="operator">=</span> getAuthentication(request, response);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authentication);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title function_">getAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 解析token</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                        <span class="comment">// 设置生成token的签名key</span></span><br><span class="line">                        .setSigningKey(ConstantKey.SIGNING_KEY)</span><br><span class="line">                        <span class="comment">// 解析token</span></span><br><span class="line">                        .parseClaimsJws(token).getBody();</span><br><span class="line">                <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> claims.getSubject();</span><br><span class="line">                <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                    String[] split = user.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    ArrayList&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">                        authorities.add(<span class="keyword">new</span> <span class="title class_">GrantedAuthorityImpl</span>(s));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 刷新Token</span></span><br><span class="line">                    refreshToken(response, claims);</span><br><span class="line">                    <span class="comment">// 返回Authentication</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user, <span class="literal">null</span>, authorities);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExpiredJwtException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，ExpiredJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedJwtException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，UnsupportedJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedJwtException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，MalformedJwtException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SignatureException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，SignatureException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，IllegalArgumentException=&#123;&#125;&quot;</span>, request.getRequestURI(), e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.warn(<span class="string">&quot;访问[&#123;&#125;]失败，需要身份认证&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 刷新Token</span></span><br><span class="line"><span class="comment">     * 刷新Token的时机：</span></span><br><span class="line"><span class="comment">     * 1. 当前时间 &lt; token过期时间</span></span><br><span class="line"><span class="comment">     * 2. 当前时间 &gt; (签发时间 + (token过期时间 - token签发时间)/2)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshToken</span><span class="params">(HttpServletResponse response, Claims claims)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// token签发时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">issuedAt</span> <span class="operator">=</span> claims.getIssuedAt().getTime();</span><br><span class="line">        <span class="comment">// token过期时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">expiration</span> <span class="operator">=</span> claims.getExpiration().getTime();</span><br><span class="line">        <span class="comment">// (当前时间 &lt; token过期时间) &amp;&amp; (当前时间 &gt; (签发时间 + (token过期时间 - token签发时间)/2))</span></span><br><span class="line">        <span class="keyword">if</span> ((current &lt; expiration) &amp;&amp; (current &gt; (issuedAt + ((expiration - issuedAt) / <span class="number">2</span>)))) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 重新生成token</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">            <span class="comment">// 设置签发时间</span></span><br><span class="line">            calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">            <span class="comment">// 设置过期时间: 5分钟</span></span><br><span class="line">            calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">            <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                    .setSubject(claims.getSubject())</span><br><span class="line">                    <span class="comment">// 签发时间</span></span><br><span class="line">                    .setIssuedAt(now)</span><br><span class="line">                    <span class="comment">// 过期时间</span></span><br><span class="line">                    .setExpiration(time)</span><br><span class="line">                    <span class="comment">// 算法与签名(同生成token)：这里算法采用HS512，常量中定义签名key</span></span><br><span class="line">                    .signWith(SignatureAlgorithm.HS512, ConstantKey.SIGNING_KEY)</span><br><span class="line">                    .compact();</span><br><span class="line">            <span class="comment">// 主动刷新token，并返回给前端</span></span><br><span class="line">            response.addHeader(<span class="string">&quot;refreshToken&quot;</span>, refreshToken);</span><br><span class="line">            log.info(<span class="string">&quot;刷新token执行时间: &#123;&#125;&quot;</span>, (System.currentTimeMillis() - current) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-通过实现-AuthenticationEntryPoint-自定义认证拦截器"><a href="#2-5-通过实现-AuthenticationEntryPoint-自定义认证拦截器" class="headerlink" title="2.5 通过实现 AuthenticationEntryPoint 自定义认证拦截器"></a>2.5 通过实现 <code>AuthenticationEntryPoint</code> 自定义认证拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AuthenticationEntryPointImpl</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request 遇到了认证异常authException用户请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 将要返回给客户的相应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;预认证入口被调用。拒绝访问，AuthenticationException=&#123;&#125;&quot;</span>, exception.getMessage());</span><br><span class="line">        <span class="comment">// 没有权限，返回403</span></span><br><span class="line">        response.sendError(<span class="number">403</span>, <span class="string">&quot;Access Denied&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-示例DEMO"><a href="#3-示例DEMO" class="headerlink" title="3. 示例DEMO"></a>3. 示例DEMO</h3><p>sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;系统用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysUserApi</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SysUserService sysUserService;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseJson&lt;SysUser&gt; <span class="title function_">register</span><span class="params">(SysUser sysUser)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysUserService.register(sysUser);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseJson&lt;Void&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseJson.success(<span class="string">&quot;访问成功！公开接口：/hello&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/private&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseJson&lt;Void&gt; <span class="title function_">hello2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseJson.success(<span class="string">&quot;访问成功！非公开接口：/private&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysUserService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SysUserDao sysUserDao;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder passwordEncoder;</span><br><span class="line">    <span class="keyword">public</span> ResponseJson&lt;SysUser&gt; <span class="title function_">register</span><span class="params">(SysUser sysUser)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(sysUser.getUsername()) || StringUtils.isEmpty(sysUser.getPassword()))&#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseJson.error(<span class="string">&quot;用户名或密码不能为空&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">encodePassword</span> <span class="operator">=</span> passwordEncoder.encode(sysUser.getPassword());</span><br><span class="line">        sysUser.setPassword(encodePassword);</span><br><span class="line">        sysUserDao.insertSysUser(sysUser);</span><br><span class="line">        <span class="keyword">return</span> ResponseJson.success(<span class="string">&quot;注册成功&quot;</span>, sysUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DAO层</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SysUserDao</span> &#123;</span><br><span class="line">    SysUser <span class="title function_">findByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insertSysUser</span><span class="params">(SysUser sysUser)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertSysUser&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">INSERT INTO sys_user(username, password) VALUES(#&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.jwt.entity.SysUser&quot;</span>&gt;</span></span><br><span class="line">SELECT id,username,PASSWORD FROM sys_user WHERE username=#&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p>注册一个用户：</p><p><img src="/2021/12/09/spring-security-jwt/up-370de8ce7710b876dfd137c959fa7eee380.webp"></p><p>登录，返回Token：</p><p><img src="/2021/12/09/spring-security-jwt/up-1fef936e1e165efa73d6b133eba887c9d6d.webp"></p><p>访问公开接口：</p><p><img src="/2021/12/09/spring-security-jwt/up-f342a930a199bcca09e0866b790c3a6a2db.webp"></p><p>访问需要认证的接口，无权限返回403：</p><p><img src="/2021/12/09/spring-security-jwt/up-13ffbcfb34a1c5d879d1e2b2a0c883fb204.webp"></p><p>访问需要认证的接口，通过有效Token访问：</p><p><img src="/2021/12/09/spring-security-jwt/up-c5efb32d07d1bd147f8c3dae689cde5eda6.webp"></p><blockquote><p>源码地址：<a href="https://github.com/chaooo/spring-security-jwt.git">https://github.com/chaooo/spring-security-jwt.git</a>,<br>这里我将本文的登录认证逻辑放在github源码tag的V1.0中，防止后续修改后对不上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」安全架构与认证鉴权原理</title>
      <link href="/2021/11/29/spring-security-filter.html"/>
      <url>/2021/11/29/spring-security-filter.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring-Security-Servlet-安全架构"><a href="#1-Spring-Security-Servlet-安全架构" class="headerlink" title="1. Spring Security Servlet 安全架构"></a>1. Spring Security Servlet 安全架构</h3><p><code>Spring Security</code> 设计的 <code>Servlet</code> 安全从架构上分为三个层次，分别是「认证」、「鉴权」、「入侵防护」。通过<strong>过滤器机制</strong>将安全逻辑应用到 <code>Servlet</code> 项目。</p><p>请求的接收和处理是通过一个一个的过滤器顺序执行实现的，过滤器是 <code>Servlet</code> 项目处理请求的基础。</p><p><code>Spring</code> 将自己体系内的过滤器交由「过滤器代理<code>FilterChainProxy</code>」管理，<code>FilterChainProxy</code> 同样也是一个过滤器，被封装在 <code>Spring</code> 的「过滤器委托代理<code>DelegatingFilterProxy</code>」中。<br><code>Spring Security</code> 在 <code>FilterChainProxy</code> 中加入了「安全过滤器链<code>SecurityFilterChain</code>」实现安全保护功能。<span id="more"></span></p><p>其过程如图：<br><img src="/2021/11/29/spring-security-filter/up-0190e15403889a4a54ded3892f2a2d7cd18.webp"></p><p>安全过滤器链（<code>SecurityFilterChain</code>）的特点：</p><ul><li>为所有 <code>Spring Security</code> 支持的 <code>Servlet</code> 指明了起点；</li><li>对于一些后台操作，可以提升执行效率；</li><li>在 <code>Servlet</code> 容器中，过滤器的选择是由 <code>URL</code> 决定的，如此便可针对不同 <code>URL</code> 指定相互独立的安全策略。</li></ul><h4 id="1-1-安全过滤器-Filter"><a href="#1-1-安全过滤器-Filter" class="headerlink" title="1.1 安全过滤器 Filter"></a>1.1 安全过滤器 Filter</h4><p><code>Spring Security</code> 内置了 <code>33</code> 种安全过滤器，每个过滤器有固定的顺序及应用场景；内置过滤器的参数设置通过 <code>HttpSecurity</code> 类相应的配置方法完成。</p><p>在认证与授权中关键的三个过滤器：</p><ol><li><code>UsernamePasswordAuthenticationFilter</code>：该过滤器用于拦截我们表单提交的请求（默认为&#x2F;login），进行用户的认证过程。</li><li><code>FilterSecurityInterceptor</code>：该过滤器主要用来进行授权判断。</li><li><code>ExceptionTranslationFilter</code>：该过滤器主要用来捕获处理<code>spring security</code>抛出的异常，异常主要来源于<code>FilterSecurityInterceptor</code>。</li></ol><p><code>Spring Security</code> 的认证、授权异常在过滤器校验过程中产生，并在 <code>ExceptionTranslationFilter</code> 中接收并进行处理，</p><ol><li><code>ExceptionTranslationFilter</code> 过滤器首先像其他过滤器一样，调用过滤器链的执行方法 <code>FilterChain.doFilter(request, response)</code> 启动过滤处理；</li><li>如果当前的用户没有通过认证或者因为其他原因在执行过程中抛出了 AuthenticationException 异常，此时将开启「认证流程」：<ul><li>清空 <code>SecurityContextHolder</code> 对象；</li><li>并将原始请求信息「<code>request</code>」保存到 <code>RequestCache</code> 对象中；</li><li>使用 <code>AuthenticationEntryPoint</code> 对象存储的认证地址，向客户端索要身份证明。例如，使用浏览器登录的用户，将浏览器地址重定向到 &#x2F;login 或者回传一个 WWW-Authenticate 认证请求头。</li></ul></li><li>如果当前用户身份信息已确认，但是没有访问权限，则会产生 <code>AccessDeniedException</code> 异常，然后访问被拒绝。继续执行拒绝处理 <code>AccessDeniedHandler</code>。</li></ol><h4 id="1-2-自定义过滤器-Filter"><a href="#1-2-自定义过滤器-Filter" class="headerlink" title="1.2 自定义过滤器 Filter"></a>1.2 自定义过滤器 Filter</h4><p>在 <code>HttpSecurity</code> 对象中增加自定义 <code>Filter</code> 可用于实现认证方式的扩展等场景，扩展 <code>Filter</code> 需要实现 <code>javax.servlet.Filter</code> 接口；并且需要指定新过滤器的位置。</p><p>例如，扩展自定义接口 SimpleFilter。</p><ol><li>自定义接口类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;In SimpleFilter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>加入到指定位置，比如加在 UsernamePasswordAuthenticationFilter 之前</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(<span class="keyword">new</span> <span class="title class_">SimpleFilter</span>(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure><h3 id="2-Spring-Security-认证"><a href="#2-Spring-Security-认证" class="headerlink" title="2. Spring Security 认证"></a>2. Spring Security 认证</h3><h4 id="2-1-Spring-Security-基本认证组件"><a href="#2-1-Spring-Security-基本认证组件" class="headerlink" title="2.1 Spring Security 基本认证组件"></a>2.1 Spring Security 基本认证组件</h4><table>    <thead><tr><th>组别</th><th>组件名</th><th>简述</th></tr></thead>    <tbody>        <tr><td rowspan="4">存储单元</td><td>Authentication</td><td>维护用户用于认证的信息</td></tr>        <tr><td>GrantedAuthority</td><td>认证用户的权限信息比如角色、范围等等</td></tr>        <tr><td>SecurityContextHolder</td><td>用于维护 SpringContext</td></tr>        <tr><td>SecurityContext</td><td>用来存储当前认证用户的信息</td></tr>        <tr><td rowspan="4">认证管理</td><td>AuthenticationManager</td><td>SpringSecurity 向外提供的用于认证的 API 集合</td></tr>        <tr><td>ProviderManager</td><td>AuthenticationManager 的常见实现类</td></tr>        <tr><td>AuthenticationProvider</td><td>用于 ProviderManager 提供认证实现</td></tr>        <tr><td>AuthenticationEntryPoint</td><td>用于获取用户认证信息</td></tr>        <tr><td>流程管理</td><td>AbstractAuthenticationProcessingFilter</td><td>是认证过滤器的基础，用于组合认证流程</td></tr>    </tbody></table><h4 id="2-2-存储单元"><a href="#2-2-存储单元" class="headerlink" title="2.2 存储单元"></a>2.2 存储单元</h4><p><img src="/2021/11/29/spring-security-filter/up-911c8967517a976252c03eb5d98f9a97151.webp"></p><ol><li><code>SecurityContextHolder</code> 对象是整个 <code>Spring Security</code> 体系的核心，它维护着 <code>SecurityContext</code> 对象。它是唯一的。</li><li><code>SecurityContext</code> 对象用于衔接 <code>SecurityContextHolder</code> 和 <code>Authentication</code> 对象，是对 <code>Authentication</code> 的外层封装。</li><li><code>Authentication</code> 是用户的认证信息。</li></ol><p><code>Authentication</code>对象有三个核心属性：</p><ul><li><strong>principal</strong>：用户的身份信息；</li><li><strong>credentials</strong>：用户的认证凭据，比如密码，通常情况下，当用户完成认证后，此项内容就会被清空；</li><li><strong>authorities</strong>：用户的权限，用于更高层次的鉴权功能，通常包括角色、使用范围等信息。该属性基本由 <code>GrantedAuthority</code> 实现。<code>GrantedAuthority</code> 是在前述 <code>Authentication</code> 对象中所指的权限信息。在开发过程中，可以通过 <code>Authentication.getAuthorities()</code> 方法获取。权限信息通常包括角色、范围，或者其他扩展内容。</li></ul><p><code>Authentication</code> 两个主要作用：</p><ol><li>为 <code>AuthenticationManager</code> 对象提供用于认证的信息载体；</li><li>用于获取某个用户的基本信息。</li></ol><h4 id="2-3-认证管理"><a href="#2-3-认证管理" class="headerlink" title="2.3 认证管理"></a>2.3 认证管理</h4><ol><li><code>AuthenticationManager</code> 为 <code>Spring</code> 过滤器提供认证支持 <code>API</code>。<code>AuthenticationManager</code> 的实现形式并没有严格限制，通常情况下使用 <code>ProviderManager</code>。</li><li><code>ProviderManager</code> 是 <code>AuthenticationManager</code> 的最常用的实现类，它包含了一系列的 <code>AuthenticationProvider</code> 对象，用以判断认证流程是否完成、认证结构是否成功。</li><li><code>AuthenticationProvider</code>：每个 <code>ProviderManager</code> 可以包含多个 <code>AuthenticationProvider</code> ，每个 <code>AuthenticationProvider</code> 提供一种认证类型，例如：<code>DaoAuthenticationProvider</code> 可以完成「用户名 &#x2F; 密码」的认证，<code>JwtAuthenticationProvider</code> 用于完成 JWT 方式的认证。</li><li><code>AuthenticationEntryPoint</code> 在当一个请求包含的认证信息不全时，比如未认证终端访问受保护资源时发挥作用，如跳转到登录页面、返回认证要求等。</li></ol><h4 id="2-4-流程管理"><a href="#2-4-流程管理" class="headerlink" title="2.4 流程管理"></a>2.4 流程管理</h4><p><code>AbstractAuthenticationProcessingFilter</code> 是所有认证过滤器的基类。</p><ol><li>当用户提交认证信息，AbstractAuthenticationProcessingFilter 首先从请求信息（例如用户名、密码）中创建 Authentication 对象；</li><li>将 Authentication 对象传递给 AuthenticationManager 对象，用于后续认证；</li><li>如果认证失败，则执行失败流程：<ul><li>清空 SecurityContextHolder 对象；</li><li>触发 RememberMeServices.loginFail 方法；</li><li>触发 AuthenticationFailureHandler。</li></ul></li><li>如果认证成功，则执行成功流程：<ul><li>SessionAuthenticationStrategy 登记新的登录；</li><li>将 Authentication 对象设置到 SecurityContextHolder 对象中，并将 SecurityContext 对象保持到 Session 中；</li><li>调用 RememberMeServices.loginSuccess 方法；</li><li>ApplicationEventPublisher 发起事件 InteractiveAuthenticationSuccessEvent</li></ul></li></ol><h3 id="3-Spring-Security-鉴权"><a href="#3-Spring-Security-鉴权" class="headerlink" title="3. Spring Security 鉴权"></a>3. Spring Security 鉴权</h3><p>Spring Security 包含<strong>确认身份</strong>和<strong>确认身份的可执行操作</strong>两部分，前者为认证(<code>Authentication</code>)，后者即为鉴权(<code>Authorization</code>)；</p><h4 id="3-1-权限"><a href="#3-1-权限" class="headerlink" title="3.1 权限"></a>3.1 权限</h4><p><code>Spring Security</code> 的权限默认是以字符串形式存储的权限信息，比如角色名称、功能名称等；</p><p>在用户身份信息得到确认后，<code>Authentication</code> 中会存储一系列的 <code>GrantedAuthority</code> 对象，这些对象用来判断用户可以使用哪些资源。</p><p><code>GrantedAuthority</code> 对象通过 <code>AuthenticationManager</code> 插入到 <code>Authentication</code> 对象中，并被 <code>AccessDecisionManager</code> 使用，判断其权限。</p><p><code>GrantedAuthority</code> 是一个接口，其仅包含一个 <code>getAuthority()</code> 方法，返回一个字符串值，该值作为权限的描述，当权限较为复杂，该方法需要返回 null，此时 <code>AccessDecisionManager</code> 会根据 <code>getAuthority()</code> 返回值情况判断是否要进行特殊处理。</p><p><code>SimpleGrantedAuthority</code> 是 <code>GrantedAuthority</code> 的一个基础实现类，可以满足一般的业务需求。</p><h4 id="3-2-鉴权"><a href="#3-2-鉴权" class="headerlink" title="3.2 鉴权"></a>3.2 鉴权</h4><ul><li>前置鉴权：由 <code>AccessDecisionManager</code> 对象判断其是否允许继续执行； 权限判断发生在方法被调用前，或者 WEB 请求之前。不满足抛出 <code>AccessDeniedException</code> 异常。</li><li>后置鉴权：通过 <code>AfterInvocationManager</code> 进行管理；后置鉴权在资源被访问后，根据权限的判定来修改返回的内容，或者返回 <code>AccessDeniedException</code>。</li></ul><p>前置鉴权 <code>AccessDecisionManager</code> 对象由 <code>AbstractSecurityInterceptor</code> 发起调用，其职责是给出资源是否能被访问的最终结果；</p><ul><li><code>AccessDecisionManager</code> 包含三个主要方法：<ul><li><code>boolean supports(ConfigAttribute attribute);</code>：判断配置属性是否可被访问；</li><li><code>boolean supports(Class clazz);</code>：判断安全对象的类型是否支持被访问；</li><li><code>void decide(Authentication authentication, Object secureObject,Collection&lt;ConfigAttribute&gt; attrs) throws AccessDeniedException;</code>：通过认证信息、安全对象、权限信息综合判断安全对象是否允许被访问。</li></ul></li></ul><p><code>Spring Security</code> 内置了以「<strong>投票</strong>」为判定方法的鉴权策略。<code>Spring Security</code> 的鉴权策略可以由用户自己实现。</p><p><strong>投票策略</strong>下，<code>AccessDecisionManager</code> 控制着一系列的 <code>AccessDecisionVoter</code> 实例，判断权限是否满足，如果不满足抛出 <code>AccessDeniedException</code> 异常。</p><ul><li><code>AccessDecisionVoter</code> 也包含三个方法：<ul><li><code>boolean supports(ConfigAttribute attribute);</code>：判断配置属性是否支持；</li><li><code>boolean supports(Class clazz);</code>：判断类型是否支持；</li><li><code>int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attrs);</code>：根据认证信息对安全资源进行投票。</li></ul></li></ul><p>投票鉴权分为三类：</p><ul><li>基于角色的投票：<code>RoleVoter</code>；</li><li>基于认证信息的投票：<code>AuthenticatedVoter</code>，主要区分认证用户、匿名用户等；</li><li>自定义投票策略。</li></ul><h4 id="3-3-Servlet-请求鉴权流程"><a href="#3-3-Servlet-请求鉴权流程" class="headerlink" title="3.3 Servlet 请求鉴权流程"></a>3.3 Servlet 请求鉴权流程</h4><p><code>Servlet</code> 鉴权主要围绕着 <code>FilterSecurityInterceptor</code> 类展开，该类作为一个安全过滤器，被放置在 <code>FilterChainProxy</code> 中。</p><p>具体流程如下：</p><ol><li><code>FilterSecurityInterceptor</code> 从 <code>SecurityContextHolder</code> 中获取 <code>Authentication</code> 对象；</li><li><code>FilterSecurityInterceptor</code> 从 <code>HttpServletRequest</code>、<code>HttpServletREsponse</code>、 <code>FilterChain</code> 中创建 <code>FilterInvocation</code> 对象；</li><li>将创建的 <code>FilterInvocation</code> 对象传递给 <code>SecurityMetadataSource</code> 用来获取 <code>ConfigAttribute</code> 对象集合；</li><li>最后，将 <code>Authentication</code>、<code>FilterInvocation</code> 和 <code>ConfigAttribute</code> 对象传递给 <code>AccessDecisionManager</code> 实例验证权限：<ul><li>如果验证失败，将抛出 <code>AccessDeniedException</code> 异常，并由 <code>ExceptionTranslationFilter</code> 接收并处理；</li><li>如果验证通过，<code>FilterSecurityInterceptor</code> 将控制权交还给 <code>FilterChain</code>，使程序继续执行。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Security」Spring Security 基础入门示例</title>
      <link href="/2021/11/25/spring-security-base.html"/>
      <url>/2021/11/25/spring-security-base.html</url>
      
        <content type="html"><![CDATA[<p><code>Spring Security</code> 是一个功能强大且高度可定制的身份验证和访问控制的安全框架。它是 <code>Spring</code> 应用程序在安全框架方面的公认标准。</p><p>其核心特性包括：认证和授权、常规攻击防范、与 <code>Servlet</code> 接口集成、与 <code>Spring MVC</code> 集成等。</p><p>常规攻击防范在 <code>Spring Security</code> 安全框架中是默认开启的，常见的威胁抵御方式有：防止伪造跨站请求（<code>CSRF</code>），安全响应头（<code>HTTP Response headers</code>），<code>HTTP</code>通讯安全等<span id="more"></span></p><h3 id="1-入门示例"><a href="#1-入门示例" class="headerlink" title="1. 入门示例"></a>1. 入门示例</h3><p>新建 <code>SpringBoot</code> 项目，在 <code>pom.xml</code> 中增加 <code>Spring Security</code> 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>只要加入依赖，项目的所有接口都会被自动保护起来。</p></blockquote><p>创建一个 Controller：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloApi</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入<code>spring-boot-starter-security</code>启动后，<code>Spring Security</code>已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p><p>访问<code>/hello</code>接口 ，需要登录之后才能访问。</p><p><img src="/2021/11/25/spring-security-base/up-44bc65394ab67d8d0445bc7a0dc9913df6a.webp"></p><p>默认配置下，会自动生成一个 <code>user</code> 用户，并分配其随机密码，密码可以从控制台的日志信息中找到：</p><p><img src="/2021/11/25/spring-security-base/up-2a23b6505fa1faae06a8f1f25f910f979b7.webp"></p><h3 id="2-Spring-Security默认配置项"><a href="#2-Spring-Security默认配置项" class="headerlink" title="2. Spring Security默认配置项"></a>2. Spring Security默认配置项</h3><p><code>Spring Boot</code> 引入 <code>Spring Security</code> 启动后，将会自动开启如下配置项：</p><ul><li>默认开启一系列基于 <code>springSecurityFilterChain</code> 的 <code>Servlet</code> 过滤器，包含了几乎所有的安全功能，例如：保护系统 <code>URL</code>、验证用户名、密码表单、重定向到登录界面等；</li><li>创建 <code>UserDetailsService</code> 实例，并生成随机密码，用于获取登录用户的信息详情；</li><li>将安全过滤器应用到每一个请求上。</li></ul><p>除此之外，<code>Spring Security</code> 还有一些其他可配置的功能：</p><ul><li>限制所有访问必须首先通过认证；</li><li>生成默认登录表单；</li><li>创建用户名为 <code>user</code> 的可以通过表单认证的用户，并为其初始化密码；</li><li>使用 <code>BCrypt</code> 方式加密密码；</li><li>提供登出的能力；</li><li>保护系统不受 <code>CSRF</code> 攻击；</li><li>会话固定保护；</li><li>集成安全消息头；</li><li>提供一些默认的 <code>Servlet</code> 接口，如：「getRemoteUser」、「getUserPrincipal」、「isUserInRole」、「login」和「logout」。</li></ul><h3 id="3-配置文件定义用户信息"><a href="#3-配置文件定义用户信息" class="headerlink" title="3. 配置文件定义用户信息"></a>3. 配置文件定义用户信息</h3><p>也可以直接在 <code>application.yml</code> 配置文件中配置用户的基本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: user</span><br><span class="line">      password: 123</span><br></pre></td></tr></table></figure><p>配置完成后，重启项目，就可以使用这里配置的用户名&#x2F;密码登录了。</p><h3 id="4-Java代码定义用户信息"><a href="#4-Java代码定义用户信息" class="headerlink" title="4. Java代码定义用户信息"></a>4. Java代码定义用户信息</h3><p>如果需要自定义逻辑时，只需要实现<code>UserDetailsService</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 判断用户名是否存在(用户名也可查询数据库)，如果不存在抛出UsernameNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span>(!username.equals(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把查询出来的密码进行解析,或直接把password放到构造方法中。</span></span><br><span class="line">        <span class="comment">// 理解:password就是数据库中查询出来的密码，查询出来的内容不是123</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> encoder.encode(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值 <code>UserDetails</code> 是一个接口，要想返回 <code>UserDetails</code> 的实例就只能返回接口的实现类。<br>这里使用 <code>Spring Security</code> 中提供的 <code>org.springframework.security.core.userdetails.User</code>。</p><p><code>Spring Security</code> 要求：当进行自定义登录逻辑时容器内必须有 <code>PasswordEncoder</code> 实例。</p><p>客户端密码和数据库密码是否匹配是由 <code>Spring Security</code> 去完成的，但 <code>Security</code> 中没有默认密码解析器。所以当自定义登录逻辑时要求必须给容器注入<code>PaswordEncoder</code>的<code>bean</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">getPasswordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * BCryptPasswordEncoder是spring security官方推荐的解析器，</span></span><br><span class="line"><span class="comment">         * 它是对bcrypt强散列方法的具体实现，基于Hash算法实现的单向加密。</span></span><br><span class="line"><span class="comment">         * 可以通过strength控制加密强度，默认为10，长度越长安全性越高。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启项目后，在浏览器中输入账号：<code>admin</code>，密码：<code>123</code>，登录后就可以访问接口了。</p>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SpringCloud」OpenFeign整合Sentinel实现熔断降级</title>
      <link href="/2021/11/23/spring-cloud-sentinel.html"/>
      <url>/2021/11/23/spring-cloud-sentinel.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Sentinel简介"><a href="#1-Sentinel简介" class="headerlink" title="1. Sentinel简介"></a>1. Sentinel简介</h3><p><a href="https://github.com/alibaba/Sentinel">Sentinel</a> 是阿里开源的项目，提供了流量控制、熔断降级、系统负载保护等多个维度来保障服务之间的稳定性。</p><p>Sentinel 分为两个部分:</p><ul><li>核心库（<code>Java</code> 客户端）不依赖任何框架&#x2F;库，能够运行于所有 <code>Java</code> 运行时环境，同时对 <code>Dubbo / Spring Cloud</code> 等框架也有较好的支持。</li><li>控制台（<code>Dashboard</code>）基于 <code>Spring Boot</code> 开发，打包后可以直接运行，不需要额外的 <code>Tomcat</code> 等应用容器。<span id="more"></span></li></ul><p>这里仅介绍<code>Sentinel</code>核心库 与 <code>Spring Cloud OpenFeign</code>整合使用。</p><h3 id="2-Sentinel与OpenFeign整合"><a href="#2-Sentinel与OpenFeign整合" class="headerlink" title="2. Sentinel与OpenFeign整合"></a>2. Sentinel与OpenFeign整合</h3><p>基于上一篇<a href="https://my.oschina.net/chaoo/blog/5308587">OpenFeign服务间调用</a></p><h4 id="2-1-在pom-xml文件中添加依赖"><a href="#2-1-在pom-xml文件中添加依赖" class="headerlink" title="2.1 在pom.xml文件中添加依赖"></a>2.1 在<code>pom.xml</code>文件中添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2021.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-在YMAL配置文件中添加如下配置"><a href="#2-2-在YMAL配置文件中添加如下配置" class="headerlink" title="2.2 在YMAL配置文件中添加如下配置"></a>2.2 在<code>YMAL</code>配置文件中添加如下配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件打开 Sentinel 对 Feign 的支持</span><br><span class="line">feign:</span><br><span class="line">  sentinel:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure><blockquote><p><code>Feign</code> 对应的接口中的资源名策略定义：<code>httpmethod:protocol://requesturl</code>。<code>@FeignClient</code> 注解中的所有属性，<code>Sentinel</code> 都做了兼容。<br>如：ToolsFeign 接口中方法 getSendSms 对应的资源名为 POST:<a href="http://xxx-cloud-tools/tools/sms/send%E3%80%82">http://XXX-CLOUD-TOOLS/tools/sms/send。</a></p></blockquote><h4 id="2-3-修改OpenFeign调用远程服务，-FeignClient属性中配置降级回调类"><a href="#2-3-修改OpenFeign调用远程服务，-FeignClient属性中配置降级回调类" class="headerlink" title="2.3 修改OpenFeign调用远程服务，@FeignClient属性中配置降级回调类"></a>2.3 修改<code>OpenFeign</code>调用远程服务，<code>@FeignClient</code>属性中配置降级回调类</h4><p><code>@FeignClient</code>属性中的<code>fallback</code>和<code>fallbackFactory</code></p><ul><li><code>fallback</code>：定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，<code>fallback</code>指定的类必须实现<code>@FeignClient</code>标记的接口。</li><li><code>fallbackFactory</code>：工厂类，用于生成<code>fallback</code>类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。</li></ul><blockquote><p>注：同一个<code>@FeignClient</code>里，<code>fallback</code> 和 <code>fallbackFactory</code> 不能同时使用。</p></blockquote><h5 id="2-3-1-使用fallback示例"><a href="#2-3-1-使用fallback示例" class="headerlink" title="2.3.1 使用fallback示例"></a>2.3.1 使用fallback示例</h5><ol><li>按照<code>Feign</code>的规则定义接口，使用<code>fallback</code>属性：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value是远程调用微服务在注册中心的服务名。</span></span><br><span class="line"><span class="comment"> * fallback：定义容错的类，当远程调用的接口失败或者超时的时候，会调用对应接口的容错逻辑，</span></span><br><span class="line"><span class="comment"> * fallback指定的类必须实现<span class="doctag">@FeignClient</span>标记的接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;XXX-CLOUD-TOOLS&quot;, fallback = ToolsFeignFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ToolsFeign</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程调用TOOLS服务接口“/tools/sms/send”--请求发短信</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/tools/sms/send&quot;)</span></span><br><span class="line">    String <span class="title function_">getSendSms</span><span class="params">(<span class="meta">@RequestParam</span> String mobile, <span class="meta">@RequestParam</span> String content)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写降级回调类<code>ToolsFeignFallback.calss</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolsFeignFallback</span> <span class="keyword">implements</span> <span class="title class_">ToolsFeign</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSendSms</span><span class="params">(String mobile, String content)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;接口容错-fallback&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-使用fallbackFactory示例"><a href="#2-3-2-使用fallbackFactory示例" class="headerlink" title="2.3.2 使用fallbackFactory示例"></a>2.3.2 使用fallbackFactory示例</h5><ol><li>按照<code>Feign</code>的规则定义接口，使用<code>fallbackFactory</code>属性：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value是远程调用微服务在注册中心的服务名。</span></span><br><span class="line"><span class="comment"> * fallbackFactory：工厂类，用于生成fallback类实例，</span></span><br><span class="line"><span class="comment"> * 通过此属性可以实现每个接口通用的容错逻辑，以达到减少重复的代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;XXX-CLOUD-TOOLS&quot;, fallbackFactory = ToolsFeignFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ToolsFeign</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程调用TOOLS服务接口“/tools/sms/send”--请求发短信</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/tools/sms/send&quot;)</span></span><br><span class="line">    String <span class="title function_">getSendSms</span><span class="params">(<span class="meta">@RequestParam</span> String mobile, <span class="meta">@RequestParam</span> String content)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写降级回调工厂类<code>ToolsFeignFallbackFactory.calss</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolsFeignFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ToolsFeignFallback&gt; &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ToolsFeignFallback <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ToolsFeignFallback</span>(throwable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写降级回调类<code>ToolsFeignFallback.calss</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sentinel 降级处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToolsFeignFallback</span> <span class="keyword">implements</span> <span class="title class_">ToolsFeign</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Throwable throwable;</span><br><span class="line">ToolsFeignFallback(Throwable throwable) &#123;</span><br><span class="line"><span class="built_in">this</span>.throwable = throwable;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用服务提供方的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSendSms</span><span class="params">(String mobile, String content)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;接口容错-fallback&quot;</span> + throwable.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Sentinel-熔断降级"><a href="#3-Sentinel-熔断降级" class="headerlink" title="3. Sentinel 熔断降级"></a>3. Sentinel 熔断降级</h3><h4 id="3-1-Sentinel-熔断策略"><a href="#3-1-Sentinel-熔断策略" class="headerlink" title="3.1 Sentinel 熔断策略"></a>3.1 Sentinel 熔断策略</h4><ul><li><strong>慢调用比例</strong> (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 <code>RT</code>（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（<code>HALF-OPEN</code> 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li><li><strong>异常比例</strong> (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（<code>HALF-OPEN</code> 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 <code>0% - 100%</code>。</li><li><strong>异常数</strong> (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（<code>HALF-OPEN</code> 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li></ul><blockquote><p>注意异常降级仅针对业务异常，对 <code>Sentinel</code> 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。<br>开源整合模块，如 <code>Sentinel Dubbo Adapter</code>, <code>Sentinel Web Servlet Filter</code> 或 <code>@SentinelResource</code> 注解会自动统计业务异常，无需手动调用。</p></blockquote><h4 id="3-2-Sentinel熔断降级规则说明"><a href="#3-2-Sentinel熔断降级规则说明" class="headerlink" title="3.2 Sentinel熔断降级规则说明"></a>3.2 Sentinel熔断降级规则说明</h4><p>熔断降级规则（DegradeRule）包含下面几个重要的属性：</p><table><thead><tr><th align="center">Field</th><th align="left">说明</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="center">resource</td><td align="left">资源名，即规则的作用对象</td><td align="left">–</td></tr><tr><td align="center">grade</td><td align="left">熔断策略，支持 慢调用比例&#x2F;异常比例&#x2F;异常数策略</td><td align="left">慢调用比例</td></tr><tr><td align="center">count</td><td align="left">慢调用比例模式下为慢调用临界 RT（超出该值计为慢调用）；异常比例&#x2F;异常数模式下为对应的阈值</td><td align="left">–</td></tr><tr><td align="center">timeWindow</td><td align="left">熔断时长，单位为 s</td><td align="left">–</td></tr><tr><td align="center">minRequestAmount</td><td align="left">熔断触发的最小请求数，请求数小于该值时即使异常比率超出阈值也不会熔断（1.7.0 引入）</td><td align="left">5</td></tr><tr><td align="center">statIntervalMs</td><td align="left">统计时长（单位为 ms），如 60*1000 代表分钟级（1.8.0 引入）</td><td align="left">1000 ms</td></tr><tr><td align="center">slowRatioThreshold</td><td align="left">慢调用比例阈值，仅慢调用比例模式有效（1.8.0 引入）</td><td align="left">–</td></tr></tbody></table><h4 id="3-3-熔断器事件监听"><a href="#3-3-熔断器事件监听" class="headerlink" title="3.3 熔断器事件监听"></a>3.3 熔断器事件监听</h4><p>Sentinel 支持注册自定义的事件监听器监听熔断器状态变换事件（state change event）。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EventObserverRegistry.getInstance().addStateChangeObserver(<span class="string">&quot;logging&quot;</span>, (prevState, newState, rule, snapshotValue) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (newState == State.OPEN) &#123;</span><br><span class="line">        <span class="comment">// 变换至 OPEN state 时会携带触发时的值</span></span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;%s -&gt; OPEN at %d, snapshotValue=%.2f&quot;</span>, prevState.name(), TimeUtil.currentTimeMillis(), snapshotValue));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.err.println(String.format(<span class="string">&quot;%s -&gt; %s at %d&quot;</span>, prevState.name(), newState.name(), TimeUtil.currentTimeMillis()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SpringCloud」OpenFeign服务间调用</title>
      <link href="/2021/11/12/spring-cloud-feign.html"/>
      <url>/2021/11/12/spring-cloud-feign.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring-Cloud-OpenFeign简介"><a href="#1-Spring-Cloud-OpenFeign简介" class="headerlink" title="1. Spring Cloud OpenFeign简介"></a>1. Spring Cloud OpenFeign简介</h3><p><code>OpenFeign</code>是<code>SpringCloud</code>提供的一个声明式的伪<code>Http</code>客户端，它使得调用远程服务就像调用本地服务一样简单，只需要创建一个接口并添加一个注解即可。<br><code>OpenFeign</code>是<code>SpringCloud</code>在<code>Feign</code>的基础上支持了<code>Spring MVC</code>的注解，并通过动态代理的方式产生实现类来做负载均衡并进行调用其他服务。<span id="more"></span></p><h4 id="1-1-OpenFeign使用流程："><a href="#1-1-OpenFeign使用流程：" class="headerlink" title="1.1 OpenFeign使用流程："></a>1.1 OpenFeign使用流程：</h4><ol><li>引入<code>Spring Cloud OpenFeign</code>的依赖</li><li>启动类上添加注解<code>@EnableFeignCleints</code></li><li>按照<code>Feign</code>的规则定义接口并添加<code>@FeignClient</code>注解</li><li>在需要使用<code>Feign</code>接口的类里注入，直接调用接口方法</li></ol><h3 id="2-OpenFeign的使用"><a href="#2-OpenFeign的使用" class="headerlink" title="2. OpenFeign的使用"></a>2. OpenFeign的使用</h3><ol><li>在<code>pom.xml</code>文件中添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在启动类上，加上<code>@EnableFeignCleints</code>注解：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// basePackages 是Feign接口定义的路径</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &#123;&quot;com.XXX.feign&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>按照<code>Feign</code>的规则定义接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号内是远程调用微服务在注册中心的服务名</span></span><br><span class="line"><span class="meta">@FeignClient(&quot;XXX-CLOUD-TOOLS&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ToolsFeign</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程调用TOOLS服务接口“/tools/sms/send”--请求发短信</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/tools/sms/send&quot;)</span></span><br><span class="line">    String <span class="title function_">getSendSms</span><span class="params">(<span class="meta">@RequestParam</span> String mobile, <span class="meta">@RequestParam</span> String content)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用<code>Feign</code>接口方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">RemoteCallService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在需要使用`Feign`接口的类里注入ToolsFeign</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ToolsFeign toolsFeign;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 ToolsFeign 发送短信</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">remoteSendSms</span><span class="params">(String mobile, String content)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toolsFeign.getSendSms(mobile, content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>远程服务接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/tools&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsApi</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送短信</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> smsDto &#123;</span></span><br><span class="line"><span class="comment">     *                mobile  手机号</span></span><br><span class="line"><span class="comment">     *                content 短信内容</span></span><br><span class="line"><span class="comment">     *               &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sms/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseJson&lt;String&gt; <span class="title function_">sendSms</span><span class="params">(SmsDto smsDto)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> SmsUtil.sendSms(smsDto.getMobile(), smsDto.getContent());</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">json</span> <span class="operator">=</span> (JSONObject) JSONObject.parse(result);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != json &amp;&amp; json.getInteger(<span class="string">&quot;code&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseJson.success(<span class="number">0</span>, <span class="string">&quot;发送成功&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseJson.error(<span class="number">0</span>, <span class="string">&quot;发送失败&quot;</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-OpenFeign的核心工作原理："><a href="#3-OpenFeign的核心工作原理：" class="headerlink" title="3. OpenFeign的核心工作原理："></a>3. OpenFeign的核心工作原理：</h3><ol><li>通过<code>@EnableFeignCleints</code>触发<code>Spring</code>应用程序对<code>classpath</code>中<code>@FeignClient</code>修饰类的扫描</li><li>解析到<code>@FeignClient</code>修饰类后，<code>Feign</code>框架通过扩展<code>SpringBeanDeifinition</code>的注册逻辑，最终注册一个<code>FeignClientFacotoryBean</code>进入<code>Spring</code>容器</li><li><code>Spring</code>容器在初始化其他用到<code>@FeignClient</code>接口的类时，获得的是<code>FeignClientFacotryBean</code>产生的一个代理对象<code>Proxy</code>.</li><li>基于<code>java</code>原生的动态代理机制，针对<code>Proxy</code>的调用，都会被统一转发给<code>Feign</code>框架所定义的一个<code>InvocationHandler</code>，由该<code>Handler</code>完成后续的<code>HTTP</code>转换，发送，接收，翻译<code>HTTP</code>响应的工作</li></ol><h3 id="4-OpenFeign日志"><a href="#4-OpenFeign日志" class="headerlink" title="4. OpenFeign日志"></a>4. OpenFeign日志</h3><p><code>Feign</code> 和 <code>RestTemplate</code> 不一样 ，对请求细节封装的更加彻底，不管是请求还是请求的参数，还是响应的状态都看不到，想要看到请求的细节需要通过<code>Feign</code>的日志，我们可以通过配置来调整日志级别，从而了解<code>OpenFeign</code>中<code>Http</code>请求的细节。即对<code>OpenFeign</code>远程接口调用的情况进行监控和日志输出。</p><h4 id="4-1-日志级别"><a href="#4-1-日志级别" class="headerlink" title="4.1 日志级别"></a>4.1 日志级别</h4><ul><li><code>NONE</code>：默认级别，不显示日志</li><li><code>BASIC</code>：仅记录请求方法、<code>URL</code>、响应状态及执行时间</li><li><code>HEADERS</code>：除了<code>BASIC</code>中定义的信息之外，还有请求和响应头信息</li><li><code>FULL</code>：除了<code>HEADERS</code>中定义的信息之外，还有请求和响应正文及元数据信息</li></ul><h4 id="4-2-配置日志bean"><a href="#4-2-配置日志bean" class="headerlink" title="4.2 配置日志bean"></a>4.2 配置日志bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-开启日志"><a href="#4-3-开启日志" class="headerlink" title="4.3 开启日志"></a>4.3 开启日志</h4><p>在<code>YMAL</code>配置文件中中指定监控的接口，以及日志级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.XXX.feign.ToolsFeign: debug  # 以什么级别监控哪个接口</span><br></pre></td></tr></table></figure><p><img src="/2021/11/12/spring-cloud-feign/up-509245506c54819c3220067d999b6df8a85.webp"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> OpenFeign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SpringCloud」Config配置中心</title>
      <link href="/2021/11/09/spring-cloud-config.html"/>
      <url>/2021/11/09/spring-cloud-config.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Spring-Cloud-Config简介"><a href="#1-Spring-Cloud-Config简介" class="headerlink" title="1. Spring Cloud Config简介"></a>1. Spring Cloud Config简介</h3><p><code>Spring Cloud Config</code>可以为微服务架构中的应用提供集中化的外部配置支持，它分为服务端和客户端两个部分。<br>服务端被称为分布式配置中心，它是个独立的应用，可以从配置仓库获取配置信息并提供给客户端使用。<br>客户端可以通过配置中心来获取配置信息，在启动时加载配置。<br><code>Spring Cloud Config</code>默认采用<code>Git</code>来存储配置信息，所以天然就支持配置信息的版本管理，并且可以使用<code>Git</code>客户端来方便地管理和访问配置信息。<span id="more"></span></p><h3 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h3><p>因为<code>config server</code>是需要到<code>git</code>上拉取配置文件的，所以还需要在远程的<code>git</code>上新建一个存放配置文件的仓库，<br>如下仓库中存放客户端配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application-beta.yml</span><br><span class="line">application-dev.yml</span><br><span class="line">application-prod.yml</span><br></pre></td></tr></table></figure><h3 id="3-配置中心服务端搭建"><a href="#3-配置中心服务端搭建" class="headerlink" title="3. 配置中心服务端搭建"></a>3. 配置中心服务端搭建</h3><ol><li>搭建服务端配置中心（<code>config-server</code>），在<code>pom.xml</code>文件中添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置服务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册到注册中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在服务端编辑<code>application.yml</code>配置文件内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8009</span><br><span class="line"># 指定当前服务的名称，这个名称会注册到注册中心</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: config-server</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git: #配置存储配置信息的Git仓库</span><br><span class="line">          uri: http://git.xxx.com/config-files.git # 远程git仓库的地址</span><br><span class="line">          username: username                       # git账户名</span><br><span class="line">          password: password                       # git密码</span><br><span class="line">          clone-on-start: true                     # 开启启动时直接从git获取配置</span><br><span class="line">          search-paths: /**                        # 指定搜索根路径下的目录，若有多个路径使用逗号隔开</span><br><span class="line"></span><br><span class="line"># 指定服务注册中心的地址</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true                                       # 是否使用 ip 地址注册</span><br><span class="line">    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; # ip:port</span><br><span class="line">  client:</span><br><span class="line">    service-url:                                                  # 设置服务注册中心地址</span><br><span class="line">      defaultZone: http://localhost:18000/eureka/</span><br></pre></td></tr></table></figure><ol start="3"><li>在启动类上，加上<code>@EnableConfigServer</code>注解，声明这是一个<code>config-server</code>。代码如下：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `<span class="doctag">@EnableDiscoveryClient</span>`: 声明一个可以被发现的客户端</span></span><br><span class="line"><span class="comment"> * `<span class="doctag">@EnableConfigServer</span>`: 声明一个Config配置服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>启动项目，访问<code>http://localhost:8009/master/application-dev.yml</code>，可以看到能够访问到客户端配置文件的内容。</li></ol><h3 id="4-客户端获取配置"><a href="#4-客户端获取配置" class="headerlink" title="4. 客户端获取配置"></a>4. 客户端获取配置</h3><ol><li>在<code>pom.xml</code>文件中添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编辑<code>bootstrap.yml</code>配置文件内容如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 18001</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:            #Config客户端配置</span><br><span class="line">      profile: dev                 #启用配置后缀名称</span><br><span class="line">      label: master                #分支名称</span><br><span class="line">      uri: http://localhost:8009   #配置中心地址</span><br><span class="line">      name: application            #配置文件名称</span><br></pre></td></tr></table></figure><p>启动服务，配置中心读取的配置生效。</p><h3 id="5-获取配置信息的基本规则"><a href="#5-获取配置信息的基本规则" class="headerlink" title="5. 获取配置信息的基本规则"></a>5. 获取配置信息的基本规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 获取配置信息</span><br><span class="line">/&#123;label&#125;/&#123;name&#125;‐&#123;profile&#125;</span><br><span class="line"># 获取配置文件信息</span><br><span class="line">/&#123;label&#125;/&#123;name&#125;‐&#123;profile&#125;.yml</span><br></pre></td></tr></table></figure><ul><li><code>name</code> : 文件名，一般以服务名(<code>spring.application.name</code>)来命名，如果配置了<code>spring.cloud.config.name</code>，则为该名称.</li><li><code>profiles</code> : 一般作为环境标识，对应配置文件中的<code>spring.cloud.config.profile</code></li><li><code>lable</code> : 分支（<code>branch</code>），指定访问某分支下的配置文件，对应配置文件中的<code>spring.cloud.config.label</code>，默认值是在服务器上设置的(对于基于<code>git</code>的服务器，通常是“<code>master</code>”)</li></ul><h4 id="5-1-Maven的Profile管理"><a href="#5-1-Maven的Profile管理" class="headerlink" title="5.1 Maven的Profile管理"></a>5.1 Maven的Profile管理</h4><p><code>Maven</code>提供了<code>Profile</code>切换功能(多环境<code>dev,beta,prod</code>)， 如下<code>pom.xml</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 环境标识，需要与配置文件的名称相对应 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activatedProperties</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">activatedProperties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 默认环境 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>beta<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activatedProperties</span>&gt;</span>beta<span class="tag">&lt;/<span class="name">activatedProperties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activatedProperties</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">activatedProperties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件<code>bootstrap.yml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:                             # Config客户端配置</span><br><span class="line">      profile: @activatedProperties@    # 启用配置后缀名称</span><br><span class="line">      label: master                     # 分支名称</span><br><span class="line">      uri: http://localhost:8009        # 配置中心地址</span><br><span class="line">      name: application                 # 配置文件名称</span><br></pre></td></tr></table></figure><p><code>SpringBoot</code>一把情况下会遵从你选的环境将<code>@activatedProperties@</code>替换掉。</p><p>但<code>SpringCloud</code>比较特殊，使用配置中心后客户端不会再使用<code>application.yml</code>，而是使用<code>bootstrap.yml</code>。但是<code>Maven</code>不认<code>bootstrap.yml</code>里的<code>@activatedProperties@</code>。</p><p><strong>解决</strong>：在<code>pom.xml</code>的<code>build</code>标签里添加如下代码，用于过滤<code>yml</code>文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可以在此配置过滤文件  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--开启filtering功能  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-将不同服务的配置文件放到以服务名命名的目录下"><a href="#5-2-将不同服务的配置文件放到以服务名命名的目录下" class="headerlink" title="5.2 将不同服务的配置文件放到以服务名命名的目录下"></a>5.2 将不同服务的配置文件放到以服务名命名的目录下</h4><p>因为<code>config server</code>默认情况下只会搜索<code>git</code>仓库根路径下的配置文件，所以我们还需要加上一个配置项：<code>search-paths</code>，<br>该配置项用于指定<code>config server</code>搜索哪些路径下的配置文件，需要注意的是这个路径是相对于<code>git</code>仓库的，并非是项目的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          ...</span><br><span class="line">          search-paths: /**  # 指定搜索根路径下的所有目录，若有多个路径使用逗号隔开</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SpringCloud」Gateway网关</title>
      <link href="/2021/10/29/spring-cloud-gateway.html"/>
      <url>/2021/10/29/spring-cloud-gateway.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Gateway简介"><a href="#1-Gateway简介" class="headerlink" title="1. Gateway简介"></a>1. Gateway简介</h3><p>Spring Cloud Gateway 是基于 Spring5.0、SpringBoot2.0 和 Project Reactor 开发的网关，旨在提供一种简单而有效的方式来对API进行路由，基于过滤器链的方式提供：安全，监控&#x2F;埋点，和限流。</p><p>Spring Cloud Gateway 基于 Spring Boot2.x、Spring WebFlux 和 Project Reactor构建，属于异步非阻塞模型。<span id="more"></span></p><h3 id="1-1-核心概念"><a href="#1-1-核心概念" class="headerlink" title="1.1 核心概念"></a>1.1 核心概念</h3><p>路由（Route）：路由是网关最基础的部分，路由信息由ID、目标URI、一组断言和一组过滤器组成。如果断言路由为真，则说明请求的 URI 和配置匹配。</p><p>断言（Predicate）：Java8 中的断言函数。Spring Cloud Gateway 中的断言函数输入类型是 Spring 5.0 框架中的 ServerWebExchange。Spring Cloud Gateway 中的断言函数允许开发者去定义匹配来自于 Http Request 中的任何信息，比如请求头和参数等。</p><p>过滤器（Filter）：使用特定工厂构建的 Spring Framework GatewayFilter 实例。过滤器将会对请求和响应进行处理。</p><h3 id="1-2-工作流程"><a href="#1-2-工作流程" class="headerlink" title="1.2 工作流程"></a>1.2 工作流程</h3><p><img src="/2021/10/29/spring-cloud-gateway/up-d4f455febd78f36b2be8fcc90839349977e.webp"></p><p>客户端向 Spring Cloud Gateway 发出请求。 由网关处理程序 Gateway Handler Mapping 映射确定请求与路由匹配，则将其发送到网关 Web 处理程序 Gateway Web Handler。 Web 处理程序通过指定的过滤器链将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器被虚线分隔的原因是过滤器可以在发送代理请求之前和之后运行逻辑。执行所有 pre 过滤器逻辑，然后发出代理请求；发出代理请求后，将运行 post 过滤器逻辑。</p><h3 id="2-Gateway网关搭建"><a href="#2-Gateway网关搭建" class="headerlink" title="2. Gateway网关搭建"></a>2. Gateway网关搭建</h3><ol><li>在Spring Cloud父工程中创建module</li><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入spring cloud gateway依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入SpringCloud Eureka client依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>启动类上加注解<code>@EnableDiscoveryClient</code>注册到Eureka</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @EnableEurekaClient: 声明一个Eureka客户端，只能注册到Eureka Server</span></span><br><span class="line"><span class="comment">// @EnableDiscoveryClient: 声明一个可以被发现的客户端，可以是其他注册中心</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>配置文件application.yml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 18001</span><br><span class="line"></span><br><span class="line"># 指定当前服务的名称，这个名称会注册到注册中心</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: @artifactId@</span><br><span class="line">  cloud:              # spring cloud gateway 路由配置方式</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:      # 是否与服务发现组件进行结合，通过 serviceId 转发到具体的服务实例。</span><br><span class="line">        locator:      # 默认为false，设为true便开启通过服务中心的自动根据 serviceId 创建路由的功能。</span><br><span class="line">          enabled: true</span><br><span class="line">        lowerCaseServiceId: true # 将请求路径的服务名配置改成小写</span><br><span class="line">      routes:</span><br><span class="line">        - id: user-server                 # 自定义的路由 ID，保持唯一性</span><br><span class="line">          uri: lb://XXXX-cloud-user       # 从注册中心获取服务，且以lb(load-balance)负载均衡方式转发</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/user/**               # 将以/user/开头的请求转发到uri为lb://XXXX-cloud-user的地址上</span><br><span class="line">        - id: product-server</span><br><span class="line">          uri: lb://XXXX-cloud-product</span><br><span class="line">          predicates:</span><br><span class="line">            - Path=/product/**            # 将以/product/开头的请求转发到uri为lb://XXXX-cloud-product的地址上</span><br><span class="line"></span><br><span class="line"># 指定服务注册中心的地址</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true       # 是否使用 ip 地址注册</span><br><span class="line">    instance-id: $&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125; # ip:port</span><br><span class="line">  client:</span><br><span class="line">    service-url:                  # 设置服务注册中心地址</span><br><span class="line">      defaultZone: http://localhost:18000/eureka/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-路由配置"><a href="#3-路由配置" class="headerlink" title="3. 路由配置"></a>3. 路由配置</h3><h4 id="3-1-路由配置方式"><a href="#3-1-路由配置方式" class="headerlink" title="3.1 路由配置方式"></a>3.1 路由配置方式</h4><ol><li>基础URI路由配置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: product-service         # 自定义的路由 ID，保持唯一</span><br><span class="line">          uri: http://localhost:9004  # 目标服务地址</span><br><span class="line">          predicates:                 # 断言（判断条件）：Predicate接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。</span><br><span class="line">            - Path=/product/**</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>单个URI的地址的schema协议，一般为http或者https协议。 和注册中心相结合的路由配置的schema协议部分为自定义的lb:类型，表示从微服务注册中心（如Eureka）订阅服务，并且进行服务的路由。</p></blockquote><ol><li>基于代码的路由配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouteLocator <span class="title function_">customRouteLocator</span><span class="params">(RouteLocatorBuilder builder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.routes()   <span class="comment">// 参数分别为：路由 ID，断言（判断条件），目标服务地址</span></span><br><span class="line">                .route(<span class="string">&quot;product-service&quot;</span>, r -&gt; r.path(<span class="string">&quot;/product/**&quot;</span>).uri(<span class="string">&quot;http://localhost:9004&quot;</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-路由匹配规则"><a href="#3-2-路由匹配规则" class="headerlink" title="3.2 路由匹配规则"></a>3.2 路由匹配规则</h4><p>Spring Cloud Gateway 是通过 Spring WebFlux 的 HandlerMapping 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。</p><p>路由谓词工厂（Route Predicate Factories）</p><table><thead><tr><th>类型</th><th>路由谓词</th><th>路由谓词工厂</th><th>描述</th></tr></thead><tbody>  <tr><td rowspan="3">时间相关</td><td>After</td><td>AfterRoutePredicateFactory</td><td>在某个时间之后的请求才会被转发，如：`- After=2017-01-20T17:42:47.789-07:00[America/Denver]`</td></tr>  <tr><td>Before</td><td>BeforeRoutePredicateFactory</td><td>在某个时间之前的请求才会被转发，如：`- Before=2017-01-20T17:42:47.789-07:00[America/Denver]`</td></tr>  <tr><td>Between</td><td>BetweenRoutePredicateFactory</td><td>在某个时间段之间的才会被转发，如：`- Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]`</td></tr>  <tr><td>Cookie相关</td><td>Cookie</td><td>CookieRoutePredicateFactory</td><td>`- Cookie=chocolate, ch.p`名为chocolate的表单或者满足正则ch.p的表单才会被匹配到进行请求转发</td></tr>  <tr><td rowspan="2">Header相关</td><td>Header</td><td>HeaderRoutePredicateFactory</td><td>`- Header=X-Request-Id, \d+`携带参数X-Request-Id或者满足\d+的请求头才会匹配</td></tr>  <tr><td>Host</td><td>HostRoutePredicateFactory</td><td>`- Host=**.somehost.org,**.anotherhost.org`当主机名为somehost.org或anotherhost.org的时候才会被转发</td></tr>  <tr><td rowspan="5">请求相关</td><td>Method</td><td>MethodRoutePredicateFactory</td><td>`- Method=GET,POST`只有GET和POST方法才会匹配转发请求</td></tr>  <tr><td>Path</td><td>PathRoutePredicateFactory</td><td>`- Path=/red/{segment},/blue/{segment}`当请求的路径为/red/、/blue/开头的时才会被转发</td></tr>  <tr><td>Query</td><td>QueryRoutePredicateFactory</td><td>`- Query=green`只要请求中包含green参数即可</td></tr>  <tr><td>RemoteAddr</td><td>RemoteAddrRoutePredicateFactory</td><td>`- RemoteAddr=192.168.1.1/24`主机IP</td></tr>  <tr><td>Weight</td><td>WeightRoutePredicateFactory</td><td>`- Weight=group1, 2`权重是按组计算的, 两个参数：group 和 weight（int）</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: predicate_route_test</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]</span><br><span class="line">        - Method=GET,POST</span><br><span class="line">        - Host=**.somehost.org,**.anotherhost.org</span><br><span class="line">        - Header=X-Request-Id, \d+</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-过滤器规则"><a href="#4-过滤器规则" class="headerlink" title="4. 过滤器规则"></a>4. 过滤器规则</h3><p>Spring Cloud Gateway 除了具备请求路由功能之外，也支持对请求的过滤。</p><ul><li>Spring Cloud Gateway的Filter的生命周期：”pre”和”post”。<ul><li>PRE：这种过滤器在请求被路由之前调用。我们可以利用这种过滤器实现身份认证、在集群中选择请求的微服务、记录调试信息等。</li><li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可以用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等等。</li></ul></li><li>Spring Cloud Gateway的Filter从作用范围可以分为两种：局部过滤器（GatewayFilter）和 全局过滤器（GlobalFilter）。<ul><li>GatewayFilter：应用到当个路由或者一个分组的路由上。</li><li>GlobalFilter：应用到所有的路由上。</li></ul></li></ul><h4 id="4-1-局部过滤器"><a href="#4-1-局部过滤器" class="headerlink" title="4.1 局部过滤器"></a>4.1 局部过滤器</h4><p>局部过滤器（GatewayFilter），是针对单个路由的过滤器。可以对访问的URL过滤，进行切面处理。Spring Cloud Gateway 包含许多内置的 GatewayFilter 工厂。</p><table><thead><tr><th>过滤器工厂</th><th>作用</th><th>参数</th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>为原始请求添加Header</td><td>Header的名称及值</td></tr><tr><td>AddRequestParameter</td><td>为原始请求添加请求参数</td><td>参数名称及值</td></tr><tr><td>AddResponseHeader</td><td>为原始响应添加Header</td><td>Header的名称及值</td></tr><tr><td>DedupeResponseHeader</td><td>剔除响应头中重复的值</td><td>需要去重的Header名称及去重策略</td></tr><tr><td>CircuitBreaker</td><td>为路由引入CircuitBreaker的断路器保护</td><td>CircuitBreakerCommand的名称</td></tr><tr><td>MapRequestHeader</td><td>将fromHeader的值更新到toHeader</td><td>fromHeader名称, toHeader名称</td></tr><tr><td>FallbackHeaders</td><td>为fallbackUri的请求头中添加具体的异常信息</td><td>Header的名称</td></tr><tr><td>PrefixPath</td><td>为原始请求路径添加前缀</td><td>前缀路径</td></tr><tr><td>PreserveHostHeader</td><td>为请求添加一个 preserveHostHeader&#x3D;true的属 性，路由过滤器会检查该属性以 决定是否要发送原始的Host</td><td>无</td></tr><tr><td>RequestRateLimiter</td><td>用于对请求限流，限流算法为令 牌桶</td><td>keyResolver、 rateLimiter、 statusCode、 denyEmptyKey、 emptyKeyStatus</td></tr><tr><td>Redirect</td><td>将原始请求重定向到指定的URL</td><td>http状态码及重定向的 url</td></tr><tr><td>RemoveRequestHeader</td><td>为原始请求删除某个Header</td><td>Header名称</td></tr><tr><td>RemoveResponseHeader</td><td>为原始响应删除某个Header</td><td>Header名称</td></tr><tr><td>RemoveRequestParameter</td><td>为原始请求删除请求参数</td><td>参数名称</td></tr><tr><td>RewritePath</td><td>重写原始的请求路径</td><td>原始路径正则表达式以 及重写后路径的正则表 达式</td></tr><tr><td>RewriteLocationResponseHeader</td><td>重写响应头中 Location 的值</td><td>输入四个参数：stripVersionMode、locationHeaderName、hostValue、protocolsRegex</td></tr><tr><td>RewriteResponseHeader</td><td>重写原始响应中的某个Header</td><td>Header名称，值的正 则表达式，重写后的值</td></tr><tr><td>SaveSession</td><td>在转发请求之前，强制执行 WebSession::save操作</td><td>无</td></tr><tr><td>SecureHeaders</td><td>为原始响应添加一系列起安全作 用的响应头</td><td>无，支持修改这些安全 响应头的值</td></tr><tr><td>SetPath</td><td>修改原始的请求路径</td><td>修改后的路径</td></tr><tr><td>SetRequestHeader</td><td>重置请求头的值</td><td>Header的名称及值</td></tr><tr><td>SetResponseHeader</td><td>修改原始响应中某个Header的值</td><td>Header名称，修改后 的值</td></tr><tr><td>SetStatus</td><td>修改原始响应的状态码</td><td>HTTP 状态码，可以是 数字，也可以是字符串</td></tr><tr><td>StripPrefix</td><td>用于截断原始请求的路径</td><td>使用数字表示要截断的 路径的数量</td></tr><tr><td>Retry</td><td>针对不同的响应进行重试</td><td>retries、statuses、 methods、series</td></tr><tr><td>RequestSize</td><td>设置允许接最大请求包的大小。如果请求包大小超过设置的 值，则返回 413 Payload Too Large</td><td>请求包大小，单位为字 节，默认值为5M</td></tr><tr><td>SetRequestHost</td><td>用指定的值替换现有的host header</td><td>指定的Host</td></tr><tr><td>ModifyRequestBody</td><td>在转发请求之前修改原始请求体内容</td><td>修改后的请求体内容</td></tr><tr><td>ModifyResponseBody</td><td>修改原始响应体的内容</td><td>修改后的响应体内容</td></tr></tbody></table><blockquote><p>每个过滤器工厂都对应一个实体类，并且这些类的名称必须以GatewayFilterFactory结尾，这是Spring Cloud Gateway的一个约定，例如AddRequestHeader对一个的实体类为AddRequestHeaderGatewayFilterFactory。</p></blockquote><p>4.1.1 限流过滤器RequestRateLimiter</p><p>Spring Cloud Gateway官方提供了基于令牌桶的限流支持。 基于其内置的过滤器工厂RequestRateLimiterGatewayFilterFactory实现。 在过滤器工厂中是通过Redis和Lua脚本结合的方式进行流量控制。</p><ol><li>首先引入Redis依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- reactive redis依赖包（包含Lettuce客户端） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway-server</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>               <span class="comment"># 开启从注册中心动态创建路由的功能，利用微服务名进行路由</span></span><br><span class="line">          <span class="attr">lower-case-service-id:</span> <span class="literal">true</span> <span class="comment"># 微服务名称以小写形式呈现</span></span><br><span class="line">      <span class="attr">routes:</span>       <span class="comment"># 配置路由： 路由id，路由到微服务的uri,断言（判断条件）</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">product-service</span>       <span class="comment"># 路由id</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service-product</span> <span class="comment"># 路由到微服务的uri。 lb://xxx，lb代表从注册中心获取服务列表，xxx代表需要转发的微服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span>               <span class="comment"># 断言（判断条件）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/product-service/**</span></span><br><span class="line">          <span class="attr">filters:</span>   <span class="comment"># 配置路由过滤器</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RequestRateLimiter</span>                 <span class="comment"># 使用的限流过滤器是Spring Cloud Gateway提供的</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="attr">key-resolver:</span> <span class="string">&#x27;#&#123;@pathKeyResolver&#125;&#x27;</span>   <span class="comment"># 使用SpEL从容器中获取对象</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.replenishRate:</span> <span class="number">1</span>   <span class="comment"># 令牌桶每秒填充平均速率，允许用户每秒处理多少个请求</span></span><br><span class="line">                <span class="attr">redis-rate-limiter.burstCapacity:</span> <span class="number">3</span>   <span class="comment"># 令牌桶的上限，令牌桶的容量，允许在一秒钟内完成的最大请求数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>配置Redis中key的解析器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyResolverConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于请求路径的限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyResolver <span class="title function_">pathKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(exchange.getRequest().getPath().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于请求参数的限流</span></span><br><span class="line"><span class="comment">     * 请求/abc?userId=1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyResolver <span class="title function_">useKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;userId&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于请求IP地址的限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyResolver <span class="title function_">ipKeyResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;x-Forwarded-For&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Spring Cloud Gateway目前提供的限流还是比较简单的，在实际开发中我们的限流策略会有很多种情况， 比如：对不同接口的限流，被限流后的友好提示，这些可以通过自定义RedisRateLimiter来实现自己的限流策略。</p></blockquote><h4 id="4-2-全局过滤器"><a href="#4-2-全局过滤器" class="headerlink" title="4.2 全局过滤器"></a>4.2 全局过滤器</h4><p>全局过滤器（GlobalFilter）作用于所有路由，Spring Cloud Gateway定义了Global Filter接口，用户可以自定义实现自己的Global Filter。 通过全局过滤器可以实现对权限的统一校验，安全性校验等功能。</p><table><thead><tr><th>过滤器工厂</th><th>描述</th></tr></thead><tbody><tr><td>ForwardRoutingFilter</td><td>它会从exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);获取路由配置的URI，如果这个URI是forward模式，过滤器会将请求转发到DispatcherHandler，然后匹配到网关本的请求路径之中，原来请求的URI将被forward的URI覆盖，原始的请求URI被存储到exchange的ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR属性之中。</td></tr><tr><td>LoadBalancerClientFilter</td><td>它是用来处理负载均衡的过滤器。在网关后面的服务可以启动多个服务实例，这个过滤器就是把请求根据均衡规则路由到某台服务实例上面。它从exchange的ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR属性中获取URI，如果这个URI的scheme是“lb”，如：lb:&#x2F;&#x2F;myserivce，它会使用spring cloud 的LoadBalancerClient解析myservice服务名，获取一个服务实例的host和port，并替换原来的客户端请求。原来请求的url会存储在exchange的ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR属性中。这个过滤器也会从exchange中获取ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR属性值，如果它的值也是“lb”，也会使用相同的规则路由。</td></tr><tr><td>NettyRoutingFilter</td><td>这是一个优先级最低的过滤器，如果从exchange的ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR获取的URL的scheme是https或http，它将使用Netty的HttpClient创建向下执行的请求代理，请求返回的结果将存储在exchange的ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR属性中，过滤器链后面的过滤器可以从中获取返回的结果。（还有一个测试使用的过滤器，WebClientHttpRoutingFilter，它和NettyRoutingFilter的功能一样，但是不使用netty）。</td></tr><tr><td>NettyWriteResponseFilter</td><td>它的优先级是最高的，它是“post”类型的过滤器。如果在exchange中ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR的属性存在HttpClientResponse，它会在所有的其它的过滤器执行完成之后运行，将响应的数据发送给网关的客户端。</td></tr><tr><td>RouteToRequestUrlFilter</td><td>它的作用是把浏览器的URL请求的Path路径添加到路由的URI之中，比如浏览器请求网关的URL是：<code>http://localhost:8080/app-a/app/balance</code>，路由的URI配置是：<code>uri: lb://app-a</code>，那么添加之后的路由的URI是：<code>lb://app-a/app/balance</code>，并将它存储在exchange的ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR属性之中。</td></tr><tr><td>WebsocketRoutingFilter</td><td>它是用来路由WebScoket请求，在exchange的ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR的URI中，如果scheme是ws或wss，它会使用Spring Web Socket 模块转发WebSocket请求。WebSockets可以使用路由进行负载均衡，比如：lb:ws:&#x2F;&#x2F;serviceid。</td></tr><tr><td>GatewayMetricsFilter</td><td>它用来统计一些网关的性能指标。需要添加spring-boot-starter-actuator的项目依赖。</td></tr></tbody></table><p>在网关路由 ServerWebExchange 后，它将通过在 exchange 添加一个 gatewayAlreadyRouted 属性，从而将exchange标记为 routed 。一旦请求被标记为 routed ，其他路由过滤器将不会再次路由请求，而是直接跳过，防止重复的路由操。可以使用便捷方法将 exchange 标记为 routed ，或检查 exchange 是否是 routed。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerWebExchangeUtils.isAlreadyRouted   <span class="comment">//检查是否已被路由</span></span><br><span class="line">ServerWebExchangeUtils.setAlreadyRouted  <span class="comment">//设置routed状态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-自定义全局过滤器鉴权"><a href="#4-3-自定义全局过滤器鉴权" class="headerlink" title="4.3 自定义全局过滤器鉴权"></a>4.3 自定义全局过滤器鉴权</h4><p>鉴权逻辑： ①当客户端第一次请求服务的时候，服务端对用户进行信息认证（登录）。 ②认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证。 ③以后每次请求，客户端都携带认证的token。 ④服务端对token进行解密，判断是否有效。</p><p>对于验证用户是否已经登录授权的过程可以在网关层统一校验。校验的标准就是请求中是否携带token凭证以及token的正确性。</p><p>这里代码实现仅判断是否携带token凭证：<code>TokenFilter.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否携带token凭证</span></span><br><span class="line"><span class="comment">     * 对请求参数中的access-token进行判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().getFirst(<span class="string">&quot;access-token&quot;</span>);</span><br><span class="line">        <span class="comment">//如果token为空</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="comment">//设置Http的状态码</span></span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="comment">//请求结束</span></span><br><span class="line">            <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果token存在，继续执行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定过滤器的执行顺序，返回值越小，优先级越高</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SpringCloud」Eureka注册中心</title>
      <link href="/2021/10/26/spring-cloud-eureka.html"/>
      <url>/2021/10/26/spring-cloud-eureka.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Eureka简介"><a href="#1-Eureka简介" class="headerlink" title="1. Eureka简介"></a>1. Eureka简介</h3><p>Eureka是一种RESTful服务，主要用于AWS云中间层服务器的发现、负载平衡和故障转移。</p><p>Eureka包含两个组件：服务注册中心Eureka Server 和 服务客户端Eureka Client。<span id="more"></span></p><h4 id="1-1-注册中心-Eureka-Server"><a href="#1-1-注册中心-Eureka-Server" class="headerlink" title="1.1 注册中心 Eureka Server"></a>1.1 注册中心 Eureka Server</h4><p>Eureka Server提供注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息。</p><p>Eureka Server通过Register、Get、Renew等接口提供服务的注册、发现和心跳检测等服务。</p><h4 id="1-2-服务客户端-Eureka-Client"><a href="#1-2-服务客户端-Eureka-Client" class="headerlink" title="1.2 服务客户端 Eureka Client"></a>1.2 服务客户端 Eureka Client</h4><p>Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。</p><p>Eureka Client分为两个角色，分别是：Service Provider（服务提供方）和Service Consumer（服务消费方）。</p><h3 id="2-Eureka基础架构原理"><a href="#2-Eureka基础架构原理" class="headerlink" title="2. Eureka基础架构原理"></a>2. Eureka基础架构原理</h3><p><img src="/2021/10/26/spring-cloud-eureka/up-d28c3c3226eac7916a1e08da8bce40dfbd8.webp"></p><ul><li><code>Eureka Server</code>：提供服务注册和发现，多个Eureka Server之间会同步数据，做到状态一致（最终一致性）</li><li><code>Service Provider</code>：服务提供方，将自身服务注册到Eureka。</li><li><code>Service Consumer</code>：服务消费方，通过Eureka Server发现服务，并消费。</li></ul><h4 id="2-1-Eureka自我保护机制"><a href="#2-1-Eureka自我保护机制" class="headerlink" title="2.1 Eureka自我保护机制"></a>2.1 Eureka自我保护机制</h4><p>微服务在Eureka上注册后，会每30秒发送心跳包，Eureka通过心跳来判断服务时候健康，默认90s没有得到客户端的心跳，则注销该实例。</p><p>导致Eureka Server收不到心跳包的可能：一是微服务自身故障，二是微服务与Eureka之间的网络故障。<br>通常微服务的自身的故障只会导致个别服务出现故障，而网络故障通常会导致大面积服务出现故障。</p><p>Eureka设置了一个阀值，当判断挂掉的服务的数量超过阀值（心跳失败比例在15分钟之内低于85%）时，Eureka Server认为很大程度上出现了网络故障，将不再删除心跳过期的服务，这种服务保护算法叫做Eureka Server的服务保护模式。</p><p>当网络故障恢复后，Eureka Server会退出”自我保护模式”。</p><p>Eureka还有客户端缓存功能(也就是微服务的缓存功能)。即便Eureka Server集群中所有节点都宕机失效，微服务的Provider和Consumer都能正常通信。<br>只要Consumer不关闭，缓存始终有效，直到一个应用下的所有Provider访问都无效的时候，才会访问Eureka Server重新获取服务列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false # 是否开启服务的自我保护: true开启，false关闭</span><br><span class="line">    eviction:</span><br><span class="line">      interval-timer-in-ms: 60000   # 清理无效节点的频率，默认 60000 毫秒（60 秒）</span><br></pre></td></tr></table></figure><h3 id="3-Eureka注册中心搭建"><a href="#3-Eureka注册中心搭建" class="headerlink" title="3. Eureka注册中心搭建"></a>3. Eureka注册中心搭建</h3><ol><li>在Spring Cloud父工程中创建module</li><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入SpringCloud Eureka server的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类上加注解<code>@EnableEurekaServer</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明当前项目为Eureka Server</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 18000</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    # 由于该应用为注册中心，所以设置为false，代表不向注册中心注册自己</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    # 不主动发现别人</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    # 声明注册中心的地址</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:18000/eureka/</span><br></pre></td></tr></table></figure><ol start="5"><li>启动注册中心 访问注册中心的监控页面<code>http://localhost:18000</code></li></ol><h3 id="4-Eureka客户端搭建"><a href="#4-Eureka客户端搭建" class="headerlink" title="4. Eureka客户端搭建"></a>4. Eureka客户端搭建</h3><ol><li>创建项目</li><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入SpringCloud Eureka client的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类上加注解<code>@EnableDiscoveryClient</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @EnableEurekaClient: 声明一个Eureka客户端，只能注册到Eureka Server</span></span><br><span class="line"><span class="comment">// @EnableDiscoveryClient: 声明一个可以被发现的客户端，可以是其他注册中心</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置文件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 18001</span><br><span class="line"></span><br><span class="line"># 指定当前服务的名称，这个名称会注册到注册中心</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: @artifactId@</span><br><span class="line"></span><br><span class="line"># 指定服务注册中心的地址</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http://localhost:18000/eureka</span><br></pre></td></tr></table></figure><p>通过以上四步 就完成了一个 Eureka客户端的搭建，直接启动项目， 访问Eureka的注册中心<code>http://localhost:18000</code>查看当前服务。</p><h3 id="5-CAP定理"><a href="#5-CAP定理" class="headerlink" title="5. CAP定理"></a>5. CAP定理</h3><ul><li>分布式系统有三个指标：<ul><li>Consistency 一致性；</li><li>Availability 可用性；</li><li>Partition tolerance 分区容错性；</li></ul></li><li>这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</li></ul><table><thead><tr><th align="center">指标</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center"><strong>数据一致性</strong> (Consistency)</td><td align="left">也叫做数据原子性系统在执行某项操作后仍然处于一致的状态。在分布式系统中，更新操作执行成功后所有的用户都应该读到最新的值，这样的系统被认为是具有强一致性的。等同于所有节点访问同一份最新的数据副本。 <strong>优点</strong>： 数据一致，没有数据错误可能。 <strong>缺点</strong>： 相对效率降低。</td></tr><tr><td align="center"><strong>服务可用性</strong> (Availablity)</td><td align="left">每一个操作总是能够在一定的时间内返回结果，这里需要注意的是”一定时间内”和”返回结果”。一定时间内指的是，在可以容忍的范围内返回结果，结果可以是成功或者是失败。</td></tr><tr><td align="center"><strong>分区容错性</strong> (Partition-torlerance)</td><td align="left">在网络分区的情况下，被分隔的节点仍能正常对外提供服务(分布式集群，数据被分布存储在不同的服务器上，无论什么情况，服务器都能正常被访问)</td></tr></tbody></table><p>CAP由Eric Brewer在2000年PODC会议上提出。该猜想在提出两年后被证明成立，成为我们熟知的CAP定理。</p><p>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。 因为可能通信失败（即出现分区容错），所以，对于分布式系统，我们只能能考虑当发生分区错误时，如何选择一致性和可用性。</p><blockquote><p>需要强调的是：C 和 A 的抉择是发生在有分区问题的时候，正常情况下系统就应该有完美的数据一致性和可用性。</p></blockquote><p>而根据一致性和可用性的选择不同，开源的分布式系统往往又被分为 CP 系统和 AP 系统。<br>  当一套系统在发生分区故障后，客户端的任何请求都被卡死或者超时，但是，系统的每个节点总是会返回一致的数据，则这套系统就是 CP 系统，经典的比如 Zookeeper。<br>  如果一套系统发生分区故障后，客户端依然可以访问系统，但是获取的数据有的是新的数据，有的还是老数据，那么这套系统就是 AP 系统，经典的比如 Eureka。</p><p>很多时候一致性和可用性并不是二选一的问题，大部分的时候，系统设计会尽可能的实现两点，在二者之间做出妥协，当强调一致性的时候，并不表示可用性是完全不可用的状态，比如，Zookeeper 只是在 master 出现问题的时候，才可能出现几十秒的不可用状态，而别的时候，都会以各种方式保证系统的可用性。而强调可用性的时候，也往往会采用一些技术手段，去保证数据最终是一致的。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SpringBoot使用RocketMQ实战样例</title>
      <link href="/2021/06/11/spring-boot-rocketmq.html"/>
      <url>/2021/06/11/spring-boot-rocketmq.html</url>
      
        <content type="html"><![CDATA[<p>通过<code>rocketmq-spring-boot-starte</code>r可以快速的搭建<code>RocketMQ</code>生产者和消费者服务。<span id="more"></span></p><ol><li><code>pom.xml</code>引入组件<code>rocketmq-spring-boot-starter</code>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改<code>application.yml</code>，添加<code>RocketMQ</code>相关配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个name-server(集群)使用英文;分割</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.100</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">test-group</span></span><br></pre></td></tr></table></figure><ol start="3"><li>发送消息与消费消息</li></ol><p>使用<code>RocketMQTemplate</code>实现消息的发送;<br>使用实现<code>RocketMQListener</code>接口，并添加<code>@RocketMQMessageListener</code>注解，声明消费主题，消费者分组等，且默认消费模式是集群消费。</p><h3 id="1-普通消息"><a href="#1-普通消息" class="headerlink" title="1. 普通消息"></a>1. 普通消息</h3><p>发送消息测试接口：<code>http://localhost:8080/send/common</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RocketMqController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;send/common&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">sendCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rocketMQTemplate.syncSend(<span class="string">&quot;common_topic&quot;</span>, <span class="string">&quot;普通消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通消息监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `<span class="doctag">@RocketMQMessageListener</span>`默认的消费模式是集群消费</span></span><br><span class="line"><span class="comment"> * 在集群消费模式中，在同一个topic下，相同的ConsumerGroup只会有一个Consumer收到消息。</span></span><br><span class="line"><span class="comment"> * RocketMQListener&lt;T&gt; 泛型必须和接收的消息类型相同，这里是String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;common_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;test_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-带Tag的消息"><a href="#2-带Tag的消息" class="headerlink" title="2. 带Tag的消息"></a>2. 带Tag的消息</h3><p>发送消息测试接口：<code>http://localhost:8080/send/tag</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/tag&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendWithTag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate.syncSend(<span class="string">&quot;tag_topic&quot;</span>+ <span class="string">&quot;:&quot;</span> + <span class="string">&quot;tag&quot;</span>, <span class="string">&quot;tag消息,tag:tag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果我们的消费者指定了消费的Tag后，发送的消息如果不带tag，将会消费不到；</span></span><br><span class="line"><span class="comment"> * 如果我们的生产者指定了Tag，但是消费者的selectorExpression没有设置，即用默认的“*”,那么这个消费者也会消费到。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;tag_topic&quot;,</span></span><br><span class="line"><span class="meta">        selectorType = SelectorType.TAG,</span></span><br><span class="line"><span class="meta">        selectorExpression = &quot;tag&quot;,//指定了tag后，发送的消息如果不带tag，将会消费不到</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;tag_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TagMsgListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-消费模式为广播消费"><a href="#3-消费模式为广播消费" class="headerlink" title="3. 消费模式为广播消费"></a>3. 消费模式为广播消费</h3><p>发送消息测试接口：<code>http://localhost:8080/send/broadcast</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/broadcast&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendWithManyTag</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate.syncSend(<span class="string">&quot;broadcast_topic&quot;</span>, <span class="string">&quot;广播消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过messageModel = MessageModel.BROADCASTING 指定消费模式为广播消费。(默认集群模式)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;broadcast_topic&quot;,</span></span><br><span class="line"><span class="meta">        messageModel = MessageModel.BROADCASTING,//指定为广播消费</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;broadcast_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BroadcastListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-顺序发送的消息，随机消费"><a href="#4-顺序发送的消息，随机消费" class="headerlink" title="4. 顺序发送的消息，随机消费"></a>4. 顺序发送的消息，随机消费</h3><p>发送消息测试接口：<code>http://localhost:8080/send/random</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/random&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;SendResult&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> rocketMQTemplate.syncSend(<span class="string">&quot;random_topic&quot;</span>, <span class="string">&quot;无序消息&quot;</span> + i);</span><br><span class="line">        results.add(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顺序发送的消息，消费顺序不一定是按照我们发送的顺序来消费的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;random_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;random_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//发送消息是顺序发送的0,1,2,3,消费的顺序不一定是顺序的</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-顺序消费"><a href="#5-顺序消费" class="headerlink" title="5. 顺序消费"></a>5. 顺序消费</h3><p>发送消息测试接口：<code>http://localhost:8080/send/order</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;SendResult&gt; results = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> rocketMQTemplate.syncSendOrderly(<span class="string">&quot;order_topic&quot;</span>, <span class="string">&quot;有序消息&quot;</span> + i, <span class="string">&quot;hashkey&quot;</span>);</span><br><span class="line">        results.add(sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过设置属性consumeMode = ConsumeMode.ORDERLY，指定消费模式为顺序消费，消费的顺序也和发送顺序一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;order_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumeMode = ConsumeMode.ORDERLY,//指定为顺序消费</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;order_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">//发送消息是顺序发送的0,1,2,3,消费的顺序也是顺序的</span></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-异步消息"><a href="#6-异步消息" class="headerlink" title="6. 异步消息"></a>6. 异步消息</h3><p><code>producer</code>向<code>broker</code>发送消息时指定消息发送成功及发送异常的回调方法，调用<code>API</code>后立即返回，<code>producer</code>发送消息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行。</p><p>发送消息测试接口：<code>http://localhost:8080/send/async</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/async&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    rocketMQTemplate.asyncSend(<span class="string">&quot;async_topic&quot;</span>, <span class="string">&quot;异步消息&quot;</span>, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送成功:&#123;&#125;&quot;</span>, JSON.toJSONString(sendResult));</span><br><span class="line">            <span class="comment">//可以处理相应的业务</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">            <span class="comment">//可以处理相应的业务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;async_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;async_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-单向发送消息"><a href="#7-单向发送消息" class="headerlink" title="7. 单向发送消息"></a>7. 单向发送消息</h3><p>单向发送消息这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p><p>发送消息测试接口：<code>http://localhost:8080/send/oneway</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/oneway&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneway</span><span class="params">()</span> &#123;</span><br><span class="line">    rocketMQTemplate.sendOneWay(<span class="string">&quot;oneway_topic&quot;</span>, <span class="string">&quot;单向消息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;oneway_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;oneway_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-延时消息"><a href="#8-延时消息" class="headerlink" title="8. 延时消息"></a>8. 延时消息</h3><p>发送消息测试接口：<code>http://localhost:8080/send/delay</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/delay&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 延时消息的使用限制messageDelayLevel:&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span></span><br><span class="line">    <span class="comment">// 开源版RocketMQ并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h分别对应着等级1到18 消息消费失败会进入延时消息队列</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">txt</span> <span class="operator">=</span> <span class="string">&quot;延时消息:&quot;</span> + LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    Message&lt;String&gt; message = MessageBuilder.withPayload(txt).build();</span><br><span class="line">    <span class="comment">// 延时等级取4，延时30s</span></span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate.syncSend(<span class="string">&quot;delay_topic&quot;</span>, message, <span class="number">2000</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;delay_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;delay_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;于&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-事务消息（半消息）"><a href="#9-事务消息（半消息）" class="headerlink" title="9. 事务消息（半消息）"></a>9. 事务消息（半消息）</h3><ul><li>事务消息共有三种状态，提交状态、回滚状态、中间状态：<ul><li>TransactionStatus.CommitTransaction: 提交事务，它允许消费者消费此消息。</li><li>TransactionStatus.RollbackTransaction: 回滚事务，它代表该消息将被删除，不允许被消费。</li><li>TransactionStatus.Unknown: 中间状态，它代表需要检查消息队列来确定状态。</li></ul></li><li>事务消息仅仅只是保证本地事务和MQ消息发送形成整体的 原子性，而投递到MQ服务器后，并无法保证消费者一定能消费成功。</li></ul><p>发送消息测试接口：<code>http://localhost:8080/send/tx</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;send/tx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">sendTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">    Map&lt;String, String&gt; txtMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    txtMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;key&quot;</span> + i);</span><br><span class="line">    txtMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;事务消息&quot;</span>);</span><br><span class="line">    txtMap.put(<span class="string">&quot;desc&quot;</span>, <span class="string">&quot;事务消息&quot;</span> + i);</span><br><span class="line">    Message&lt;Map&lt;String, String&gt;&gt; message = MessageBuilder.withPayload(txtMap).setHeader(<span class="string">&quot;key&quot;</span>, txtMap.get(<span class="string">&quot;key&quot;</span>)).build();</span><br><span class="line">    <span class="keyword">return</span> rocketMQTemplate.sendMessageInTransaction(<span class="string">&quot;tx_topic&quot;</span>, message , i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者端需要实现<code>RocketMQLocalTransactionListener</code>接口，重写执行本地事务的方法和检查本地事务方法；<br><code>@RocketMQTransactionListener</code>注解表明这个一个生产端的消息监听器，需要配置监听的事务消息生产者组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RocketMQTransactionListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxProducerListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQLocalTransactionListener</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次推送消息会执行executeLocalTransaction方法，首先会发送半消息，到这里的时候是执行具体本地业务，</span></span><br><span class="line"><span class="comment">     * 执行成功后手动返回RocketMQLocalTransactionState.COMMIT状态，</span></span><br><span class="line"><span class="comment">     * 这里是保证本地事务执行成功，如果本地事务执行失败则可以返回ROLLBACK进行消息回滚。 </span></span><br><span class="line"><span class="comment">     * 此时消息只是被保存到broker，并没有发送到topic中，broker会根据本地返回的状态来决定消息的处理方式。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message message, Object arg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行本地事务&quot;</span>);</span><br><span class="line">        RocketMQLocalTransactionState state;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) arg;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 偶数抛出异常</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i / <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// COMMIT:即生产者通知Rocket该消息可以消费</span></span><br><span class="line">            state = RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">            log.info(<span class="string">&quot;本地事务已提交。&#123;&#125;&quot;</span>,message.getHeaders().get(<span class="string">&quot;key&quot;</span>).toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;执行本地事务失败。&#123;&#125;&quot;</span>,e);</span><br><span class="line">            <span class="comment">// ROLLBACK:即生产者通知Rocket将该消息删除</span></span><br><span class="line">            state = RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RocketMQLocalTransactionState <span class="title function_">checkLocalTransaction</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行回查&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断具体业务逻辑，来决定是否回滚还是提交</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ( flag ) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;回滚半消息&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> RocketMQLocalTransactionState.ROLLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;提交半消息&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> RocketMQLocalTransactionState.COMMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务消息只是保证了本地事务和消息发送的原子性，</span></span><br><span class="line"><span class="comment"> * 如果 消费端消费失败 后的处理方式，建议是记录异常信息然后 人工处理 ，</span></span><br><span class="line"><span class="comment"> * 并不建议回滚上游服务的数据(因为两者是 解耦 的，而且 复杂度 太高)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;tx_topic&quot;,</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;tx_group&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConsumerListener</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;Map&lt;String, String&gt;&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Map&lt;String, String&gt; message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;收到消息：&#123;&#125;&quot;</span>, <span class="built_in">this</span>.getClass().getSimpleName(), message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-部分测试日志打印"><a href="#10-部分测试日志打印" class="headerlink" title="10. 部分测试日志打印"></a>10. 部分测试日志打印</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">2021-06-11 17:25:02.861  INFO 13904 --- [MessageThread_3] com.demo.CommonListener      : CommonListener收到消息：普通消息</span><br><span class="line">2021-06-11 17:25:10.296  INFO 13904 --- [MessageThread_2] com.demo.TagMsgListener      : TagMsgListener收到消息：tag消息,tag:tag</span><br><span class="line">2021-06-11 17:26:05.070  INFO 13904 --- [MessageThread_1] com.demo.BroadcastListener   : BroadcastListener收到消息：广播消息</span><br><span class="line">2021-06-11 17:27:19.969  INFO 13904 --- [MessageThread_2] com.demo.RandomListener      : RandomListener收到消息：无序消息1</span><br><span class="line">2021-06-11 17:27:19.969  INFO 13904 --- [MessageThread_1] com.demo.RandomListener      : RandomListener收到消息：无序消息0</span><br><span class="line">2021-06-11 17:27:19.970  INFO 13904 --- [MessageThread_4] com.demo.RandomListener      : RandomListener收到消息：无序消息3</span><br><span class="line">2021-06-11 17:27:19.970  INFO 13904 --- [MessageThread_3] com.demo.RandomListener      : RandomListener收到消息：无序消息2</span><br><span class="line">2021-06-11 17:28:15.530  INFO 13904 --- [MessageThread_2] com.demo.OrderListener       : OrderListener收到消息：有序消息0</span><br><span class="line">2021-06-11 17:28:15.531  INFO 13904 --- [MessageThread_3] com.demo.OrderListener       : OrderListener收到消息：有序消息1</span><br><span class="line">2021-06-11 17:28:15.533  INFO 13904 --- [MessageThread_4] com.demo.OrderListener       : OrderListener收到消息：有序消息2</span><br><span class="line">2021-06-11 17:28:15.540  INFO 13904 --- [MessageThread_5] com.demo.OrderListener       : OrderListener收到消息：有序消息3</span><br><span class="line">2021-06-11 17:29:24.630  INFO 13904 --- [MessageThread_1] com.demo.AsyncListener       : AsyncListener收到消息：异步消息</span><br><span class="line">2021-06-11 17:29:24.644  INFO 13904 --- [ublicExecutor_1] o.example.controller.RocketMqController  : 发送成功:&#123;&quot;messageQueue&quot;:&#123;&quot;brokerName&quot;:&quot;localhost.localdomain&quot;,&quot;queueId&quot;:0,&quot;topic&quot;:&quot;async_topic&quot;&#125;,&quot;msgId&quot;:&quot;7F000001365018B4AAC237405B920066&quot;,&quot;offsetMsgId&quot;:&quot;C0A8026400002A9F000000000004FF02&quot;,&quot;queueOffset&quot;:0,&quot;regionId&quot;:&quot;DefaultRegion&quot;,&quot;sendStatus&quot;:&quot;SEND_OK&quot;,&quot;traceOn&quot;:true&#125;</span><br><span class="line">2021-06-11 17:30:12.790  INFO 13904 --- [MessageThread_1] com.demo.OnewayListener      : OnewayListener收到消息：单向消息</span><br><span class="line">2021-06-11 17:31:06.185  INFO 13904 --- [MessageThread_1] com.demo.DelayListener       : DelayListener于2021-06-11 17:31:06收到消息：延时消息:2021-06-11 17:30:36</span><br><span class="line">2021-06-11 17:31:22.216  INFO 13904 --- [nio-8080-exec-5] com.demo.TxProducerListener  : 开始执行本地事务</span><br><span class="line">2021-06-11 17:31:22.217  INFO 13904 --- [nio-8080-exec-5] com.demo.TxProducerListener  : 本地事务已提交。key5</span><br><span class="line">2021-06-11 17:31:22.233  INFO 13904 --- [MessageThread_3] com.demo.TxConsumerListener  : TxConsumerListener收到消息：&#123;name=事务消息, key=key5, desc=事务消息5&#125;</span><br><span class="line">2021-06-11 17:31:27.872  INFO 13904 --- [nio-8080-exec-4] com.demo.TxProducerListener  : 开始执行本地事务</span><br><span class="line">2021-06-11 17:31:27.880  INFO 13904 --- [nio-8080-exec-4] com.demo.TxProducerListener  : 执行本地事务失败。&#123;&#125;</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at com.demo.TxProducerListener.executeLocalTransaction(TxProducerListener.java:42) ~[classes/:na]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>源码地址：<a href="https://gitee.com/chaoo/mq-test.git">https://gitee.com/chaoo/mq-test.git</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」RocketMQ安装并整合SpringBoot</title>
      <link href="/2021/06/10/env-mq-rocketmq.html"/>
      <url>/2021/06/10/env-mq-rocketmq.html</url>
      
        <content type="html"><![CDATA[<p><strong>RocketMQ</strong> 是阿里巴巴团队使用<code>Java</code>语言开发的一个分布式、队列模型的消息中间件，后开源给<code>Apache</code>基金会成为了<code>Apache</code>的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。</p><p><strong>RocketMQ</strong> 主要由<code>Producer</code>、<code>Broker</code>、<code>Consumer</code>、<code>NameServer</code>组成；其中<code>Producer</code>负责生产消息；<code>Consumer</code>负责消费消息；<code>Broker</code>是<code>MQ</code>服务,负责接收、分发消息；<code>NameServer</code>是路由中心，负责<code>MQ</code>服务之间的协调。<span id="more"></span></p><h3 id="1-Centos安装RocketMQ"><a href="#1-Centos安装RocketMQ" class="headerlink" title="1.  Centos安装RocketMQ"></a>1.  Centos安装RocketMQ</h3><ol><li><a href="https://rocketmq.apache.org/dowloading/releases/">官网</a>下载<code>RocketMQ</code>安装包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">进入自定义软件安装目录</span></span><br><span class="line">cd /mnt/newdatadrive/apps</span><br><span class="line"><span class="meta"># </span><span class="language-bash">wget下载RocketMQ安装包</span></span><br><span class="line">wget -c &quot;https://mirrors.bfsu.edu.cn/apache/rocketmq/4.8.0/rocketmq-all-4.8.0-bin-release.zip&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>解压安装（环境基于<code>JDK1.8</code>或以上）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">解压</span></span><br><span class="line">unzip rocketmq-all-4.8.0-bin-release.zip</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重命名为rocketmq</span></span><br><span class="line">mv rocketmq-all-4.8.0-bin-release rocketmq</span><br><span class="line"><span class="meta"># </span><span class="language-bash">进入安装目录</span></span><br><span class="line">cd rocketmq</span><br></pre></td></tr></table></figure><ol start="3"><li>修改配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">RocketMQ的默认内存占用非常高，是4×4g的，将4g调整为512m</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">编辑runserver.sh</span></span><br><span class="line">vim bin/runserver.sh</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br><span class="line"><span class="meta"># </span><span class="language-bash">编辑runbroker.sh</span></span><br><span class="line">vim bin/runbroker.sh</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>配置<code>RocketMQ</code>的环境变量</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">编辑/etc/profile</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta"># </span><span class="language-bash">添加：</span></span><br><span class="line">export ROCKETMQ_HOME=/mnt/newdatadrive/apps/rocketmq</span><br><span class="line">export PATH=$JAVA_HOME/bin:$ROCKETMQ_HOME/bin:$PATH</span><br><span class="line"><span class="meta"># </span><span class="language-bash">使rocketmq的配置生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="5"><li>启动<code>RockerMQ</code>顺序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">先启动 NameServer，然后启动 Broker</span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br></pre></td></tr></table></figure><ol start="6"><li>关闭<code>RockerMQ</code>顺序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">先关闭Broker，再关闭NameServer</span></span><br><span class="line">sh bin/mqshutdown broker</span><br><span class="line">sh bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure><ol start="7"><li>启动日志</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">查看 Name Server 启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看 Broker Server 启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">若出现如下报错</span></span><br><span class="line">file doesn&#x27;t exist on this path: /root/store/commitlog</span><br><span class="line">file doesn&#x27;t exist on this path: /root/store/consumequeue</span><br><span class="line"><span class="meta"># </span><span class="language-bash">对应创建即可：</span></span><br><span class="line">cd ~/store</span><br><span class="line">mkdir commitlog consumequeue</span><br></pre></td></tr></table></figure><ol start="8"><li>防火墙<ul><li>若外网<code>IP</code>调试，关闭防火墙 或 开放防火墙端口<code>9876,10911</code></li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">NameServer默认端口：9876</span></span><br><span class="line">firewall-cmd --add-port=9876/tcp --permanent</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Broker对外服务的监听端口</span></span><br><span class="line">firewall-cmd --add-port=10911/tcp --permanent</span><br><span class="line"><span class="meta"># </span><span class="language-bash">更新防火墙规则</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="2-SpringBoot-整合-RocketMQ"><a href="#2-SpringBoot-整合-RocketMQ" class="headerlink" title="2. SpringBoot 整合 RocketMQ"></a>2. SpringBoot 整合 RocketMQ</h3><ol><li><code>pom.xml</code>引入组件<code>rocketmq-spring-boot-starter</code>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.rocketmq/rocketmq-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改<code>application.yml</code>，添加<code>RocketMQ</code>相关配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个name-server(集群)使用英文;分割</span></span><br><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">name-server:</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.100</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">test-group</span></span><br></pre></td></tr></table></figure><ol start="3"><li>消息生产者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic   主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String topic, String message)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.rocketMQTemplate.convertAndSend(topic, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>消费者</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者监听消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">        topic = &quot;test-topic&quot;,          // 指定topic</span></span><br><span class="line"><span class="meta">        consumerGroup = &quot;test-group&quot;,  // 指定消费组</span></span><br><span class="line"><span class="meta">        selectorExpression = &quot;*&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;收到的消息是: &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageProducer messageProducer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testMQ</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello RocketMQ!&quot;</span>;</span><br><span class="line">        messageProducer.sendMessage(<span class="string">&quot;test-topic&quot;</span>,message);</span><br><span class="line">        log.info(<span class="string">&quot;生产一条消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>运行结果<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2021-06-10 14:56:25.180  INFO 17720 --- [           main] a.r.s.s.DefaultRocketMQListenerContainer : running container: DefaultRocketMQListenerContainer&#123;consumerGroup=&#x27;test-group&#x27;, nameServer=&#x27;192.168.2.100:9876&#x27;, topic=&#x27;test-topic&#x27;, consumeMode=CONCURRENTLY, selectorType=TAG, selectorExpression=&#x27;*&#x27;, messageModel=CLUSTERING&#125;</span><br><span class="line">2021-06-10 14:56:25.188  INFO 17720 --- [           main] o.a.r.s.a.ListenerContainerConfiguration : Register the listener to container, listenerBeanName:messageConsumer, containerBeanName:org.apache.rocketmq.spring.support.DefaultRocketMQListenerContainer_1</span><br><span class="line">2021-06-10 14:56:25.230  INFO 17720 --- [           main] c.e.fastdfsdemo.DemoApplicationTests     : Started DemoApplicationTests in 10.371 seconds (JVM running for 13.888)</span><br><span class="line">2021-06-10 14:56:26.410  INFO 17720 --- [           main] c.e.fastdfsdemo.DemoApplicationTests     : 生产一条消息：Hello RocketMQ!</span><br><span class="line">2021-06-10 14:56:26.426  INFO 17720 --- [MessageThread_1] c.e.f.rocketmq.MessageConsumer           : 收到的消息是: Hello RocketMQ!</span><br><span class="line">2021-06-10 14:56:26.496  INFO 17720 --- [lientSelector_1] RocketmqRemoting                         : closeChannel: close the connection to remote address[192.168.2.100:10911] result: true</span><br><span class="line">2021-06-10 14:56:26.496  INFO 17720 --- [lientSelector_1] RocketmqRemoting                         : closeChannel: close the connection to remote address[192.168.2.100:9876] result: true</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」记一次生产事故引发的FastDFS图片迁移</title>
      <link href="/2021/05/28/env-centos8-fastdfs-rsync.html"/>
      <url>/2021/05/28/env-centos8-fastdfs-rsync.html</url>
      
        <content type="html"><![CDATA[<ul><li><p><strong>事件经过</strong>：由于前端同学不小心把上传图片服务器地址写死了测试域名（指向测试服务器），然后项目上到正式环境，一段时间后，发现用户发布商品时的商品详情富文本中的图片全部指向测试图片服务器域名，然后图片又太多了，手动逐条修复数据不太现实。<span id="more"></span></p></li><li><p><strong>解决思路</strong>：</p><ul><li>从数据库中查询商品详情富文本，分析出所有测试域名图片的<code>Url</code>地址；</li><li>通过<code>Url</code>下载图片到本地服务器并保持图片存放路径与图片文件名和原本一致；</li><li>通过<code>rsync</code>远程同步命令同步到正式服务器；</li><li>修改数据库中商品图片<code>Url</code>地址指向正式服务器域名(因为路径和文件名与测试服务器一致，只需替换域名即可)。</li></ul></li></ul><ol><li>引入<code>pom.xml</code>依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>提供出临时接口以备调用同步图片</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提供出临时接口以备调用修复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/product/img/repair&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repairProductImg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取带有测试域名图片的富文本列表</span></span><br><span class="line">    List&lt;String&gt; infoList = productDao.getProductInfo();</span><br><span class="line">    <span class="comment">// 下载图片到本地服务器</span></span><br><span class="line">    infoList.forEach(RepairImgUtil::saveProductImg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="operator">!</span><span class="comment">-- 这里测试图片服务器域名为：img-test.abc.com --&gt;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getProductInfo&quot; resultType<span class="operator">=</span>&quot;java.lang.String&quot;<span class="operator">&gt;</span></span><br><span class="line">      <span class="keyword">select</span> detail <span class="keyword">from</span> productInfo <span class="keyword">where</span> detail <span class="keyword">like</span> <span class="string">&#x27;%img-test.abc.com%&#x27;</span></span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepairImgUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存图片到本地服务器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> textBody 富文本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveProductImg</span><span class="params">(String textBody)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析富文本</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">doc</span> <span class="operator">=</span> Jsoup.parseBodyFragment(textBody).body();</span><br><span class="line">        <span class="type">Elements</span> <span class="variable">images</span> <span class="operator">=</span> doc.select(<span class="string">&quot;img[src]&quot;</span>);</span><br><span class="line">        List&lt;String&gt; srcList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Element element : images) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> element.attr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">            <span class="comment">// 筛选测试服务器的图片路径</span></span><br><span class="line">            <span class="keyword">if</span> (imgUrl.indexOf(<span class="string">&quot;img-test.abc.com&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                srcList.add(imgUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本地存放路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">basePath</span> <span class="operator">=</span> <span class="string">&quot;/apps/fdfs/storage/data/&quot;</span>;</span><br><span class="line">        srcList.forEach(img -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 下载图片，并根据路径规律保持原有路径</span></span><br><span class="line">                RepairImgUtil.downloadImage(img, img.substring(<span class="number">45</span>), basePath+img.substring(<span class="number">39</span>, <span class="number">45</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;try-catch:&quot;</span>,e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载图片</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urlString 图片链接</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename  图片名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> savePath  保存路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">downloadImage</span><span class="params">(String urlString, String filename, String savePath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 构造URL打开连接，并设置输入流与缓冲</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlString);</span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">con</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">        con.setConnectTimeout(<span class="number">5</span>*<span class="number">1000</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> con.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bs = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 读取到的数据长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 输出的文件流</span></span><br><span class="line">        File sf=<span class="keyword">new</span> <span class="title class_">File</span>(savePath);</span><br><span class="line">        <span class="keyword">if</span>(!sf.exists())&#123;</span><br><span class="line">           sf.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(sf.getPath()+<span class="string">&quot;/&quot;</span>+filename);</span><br><span class="line">        <span class="comment">// 开始读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bs, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        os.close();</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="comment">// 打印图片链接</span></span><br><span class="line">        log.info(urlString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用接口后，图片会先备份到本地服务器，通过rsync远程同步命令同步到正式服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录远程服务器，进入图片服务器目录</span></span><br><span class="line"><span class="built_in">cd</span> /apps/fdfs</span><br><span class="line"><span class="comment"># 远程登陆下载图片的服务器并同步数据</span></span><br><span class="line">rsync -avz myuser@119.29.36.15:/apps/fdfs/storage  ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据提示，确认连接输入 yes，输入本地服务器（下载图片的服务器）用户密码后开始同步</span></span><br><span class="line"></span><br><span class="line">The authenticity of host <span class="string">&#x27;119.29.36.15 (119.29.36.15)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:5m4KgPF0QgBO1xE7Tz1RT7U/tfCue+QBE/t4zEDEDJQ.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>119.29.36.15<span class="string">&#x27; (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">myuser@119.29.36.15&#x27;</span>s password: </span><br><span class="line">receiving incremental file list</span><br><span class="line">storage/</span><br><span class="line">storage/data/</span><br><span class="line">storage/data/03/</span><br><span class="line">storage/data/03/08/</span><br><span class="line">storage/data/03/08/Cmgy61-BU3GANDoCAAGOnj-x-ws715.jpg</span><br><span class="line">storage/data/03/08/Cmgy61-BU8SAeTvqAAGOnj-x-ws868.jpg</span><br><span class="line">storage/data/03/08/Cmgy61-BVn-AdXoKAA2Msh3VVsk076.jpg</span><br><span class="line">...</span><br><span class="line">storage/data/03/3C/Cmgy62CwSTOARHdWABLV4kLKua4925.png</span><br><span class="line"></span><br><span class="line">sent 15,786 bytes  received 422,224,711 bytes  10,425,691.28 bytes/sec</span><br><span class="line">total size is 448,804,964  speedup is 1.06</span><br></pre></td></tr></table></figure><ol start="4"><li>把测试域名换成正式域名访问图片成功！最后修改数据库商品详情：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> productInfo <span class="keyword">set</span> detail <span class="operator">=</span> REPLACE(detail, <span class="string">&#x27;img-test.abc.com%&#x27;&#x27;, &#x27;</span>img.abc.com<span class="operator">%</span><span class="string">&#x27;&#x27;</span>) <span class="keyword">where</span> detail <span class="keyword">like</span> <span class="keyword">like</span> <span class="string">&#x27;%img-test.abc.com%&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SpringBoot Thymeleaf页面静态化实现</title>
      <link href="/2021/05/11/spring-boot-html.html"/>
      <url>/2021/05/11/spring-boot-html.html</url>
      
        <content type="html"><![CDATA[<p>页面静态化是指把动态生成的HTML页面变为静态文件保存，当请求到来，直接访问静态文件，而不需要经过项目服务器的渲染。<span id="more"></span></p><h3 id="1-配置Nginx代理静态页面"><a href="#1-配置Nginx代理静态页面" class="headerlink" title="1. 配置Nginx代理静态页面"></a>1. 配置Nginx代理静态页面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root D:/temp/static;                  # 自定义静态文件存放根目录</span><br><span class="line">    set $www_temp_path $request_filename; # 设置请求的文件名到临时变量</span><br><span class="line">    if ($uri = &#x27;/&#x27;) &#123;                     # 若为根目录则加上/index.html</span><br><span class="line">        set $www_temp_path $request_filename/index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!-f $www_temp_path) &#123;             # 若请求的文件不存在，就反向代理服务器的渲染</span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    # 其他配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启<code>Nginx</code>。</p><h3 id="2-Thymeleaf实现手动把模板渲染结果写入到指定位置"><a href="#2-Thymeleaf实现手动把模板渲染结果写入到指定位置" class="headerlink" title="2. Thymeleaf实现手动把模板渲染结果写入到指定位置"></a>2. Thymeleaf实现手动把模板渲染结果写入到指定位置</h3><p><code>Thymeleaf</code>手动渲染原理：当与<code>SpringBoot</code>结合时，放入<code>Model</code>的数据就会被放到上下文(<code>Context</code>)中，并且此时模板解析器(<code>TemplateResolver</code>)已经创建完成(默认模板存放位置:<code>templates</code>，默认模板文件类型:<code>html</code>)；然后通过模板引擎(<code>TemplateEngine</code>)结合上下文(<code>Context</code>)与模板解析器(<code>TemplateResolver</code>)，利用内置的语法规则解析，从而输出解析后的文件到指定目录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板引擎处理函数</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> templateName 模板名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context      上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> writer       输出目的地的流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">templateEngine.process(templateName, context, writer);</span><br></pre></td></tr></table></figure><ul><li><strong>具体实现</strong></li></ul><p>相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line"># 自定义静态文件存放根目录</span><br><span class="line">myserver:</span><br><span class="line">  destPath: D:/temp/static</span><br></pre></td></tr></table></figure><p>接口和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateApi</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GenerateHtml generateHtml;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成静态首页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/generate/home&quot;)</span></span><br><span class="line">    <span class="keyword">public</span>  String <span class="title function_">generateStaticHome</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generateHtml.generateStaticHome(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenerateHtml</span> &#123;</span><br><span class="line">    String <span class="title function_">generateStaticHome</span><span class="params">(ServerWebExchange exchange)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateHtmlImpl</span> <span class="keyword">implements</span> <span class="title class_">GenerateHtml</span> &#123;</span><br><span class="line">    <span class="comment">/** 打包时间 */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.application.build-time&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String buildTime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 静态文件存放根目录 */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myserver.destPath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String destPath;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 模板引擎 */</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成静态首页</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateStaticHome</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="comment">// 上下文</span></span><br><span class="line">        <span class="type">SpringWebFluxContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringWebFluxContext</span>(exchange);</span><br><span class="line">        <span class="comment">// 设置页面数据</span></span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        modelMap.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;testGenerateStaticHome&quot;</span>);</span><br><span class="line">        modelMap.put(<span class="string">&quot;version&quot;</span>, buildTime);</span><br><span class="line">        context.setVariables(modelMap);</span><br><span class="line">        <span class="comment">// 输出流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath, <span class="string">&quot;index.html&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dest.exists()) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> dest.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(dest, <span class="string">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 模板引擎生成html</span></span><br><span class="line">            templateEngine.process(<span class="string">&quot;index&quot;</span>, context, writer);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[静态页服务]：生成静态首页成功! ^_^&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;[静态页服务]：生成静态首页异常!&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[静态页服务]：生成静态首页异常!&quot;</span>+e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>html模板原型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Thymeleaf 静态页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/css/index.css(v=$&#123;version&#125;)&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;页面名字：&#x27; + $&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;页面版本：&#x27; + $&#123;version&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动测试：浏览器访问：<code>http://127.0.0.1:8080/generate/home</code>或编写测试类测试。</p><h3 id="3-将项目resources目录下静态资源复制到指定位置"><a href="#3-将项目resources目录下静态资源复制到指定位置" class="headerlink" title="3. 将项目resources目录下静态资源复制到指定位置"></a>3. 将项目resources目录下静态资源复制到指定位置</h3><p>相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接口和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenerateHtml</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝静态资源文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">generateStaticFiles</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateHtmlImpl</span> <span class="keyword">implements</span> <span class="title class_">GenerateHtml</span> &#123;</span><br><span class="line">    <span class="comment">/** 静态文件存放根目录 */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;myserver.destPath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String destPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拷贝静态资源文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateStaticFiles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            copyResourceToFile();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[静态页服务]：拷贝静态资源文件成功! ^_^&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;[静态页服务]：拷贝静态资源文件异常!&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[静态页服务]：拷贝静态资源文件异常!&quot;</span>+e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 资源清单获取并拷贝</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">copyResourceToFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 资源清单获取</span></span><br><span class="line">        <span class="type">ResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        org.springframework.core.io.Resource[] resources = resolver.getResources(<span class="string">&quot;static/**&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (org.springframework.core.io.Resource resource : resources) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> resource.getFilename();</span><br><span class="line">            <span class="keyword">assert</span> fileName != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (fileName.indexOf(<span class="string">&quot;.&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream = resource.getInputStream();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(String.format(<span class="string">&quot;[%s]获取输入流发生异常!&quot;</span>, resource.getURL()));</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;[%s]获取输入流发生异常!&quot;</span>, resource.getURL()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 分析相对目录</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">tempPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                String[] urls = resource.getURL().toString().split(<span class="string">&quot;/static/&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (urls.length &gt;= <span class="number">2</span> )&#123;</span><br><span class="line">                    tempPath = urls[urls.length-<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;relativeRootPath有误：无法分析相对目录&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                tempPath = tempPath.substring(<span class="number">0</span>, tempPath.length() - fileName.length());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.isEmpty(tempPath)) &#123;</span><br><span class="line">                    tempPath = File.separator;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> destPath + File.separator + tempPath;</span><br><span class="line">                <span class="keyword">if</span> (createDir(filePath)) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">destName</span> <span class="operator">=</span> filePath + fileName;</span><br><span class="line">                    <span class="comment">// 输出流</span></span><br><span class="line">                    <span class="type">File</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destName);</span><br><span class="line">                    <span class="keyword">if</span> (dest.exists()) &#123;</span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">delete</span> <span class="operator">=</span> dest.delete();</span><br><span class="line">                    &#125;</span><br><span class="line">                    FileUtils.copyInputStreamToFile(inputStream, dest);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;创建本地目录[%s]失败！&quot;</span>, resource.getURL()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">createDir</span><span class="params">(String dirName)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirName);</span><br><span class="line">        <span class="keyword">if</span> (dir.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dirName.endsWith(File.separator)) &#123;</span><br><span class="line">            dirName = dirName + File.separator;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dir.mkdirs()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;创建目录&quot;</span> + dirName + <span class="string">&quot;成功！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;创建目录&quot;</span> + dirName + <span class="string">&quot;失败！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可在项目启动后执行覆盖拷贝操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> GenerateHtml generateHtml;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          log.info(<span class="string">&quot;执行MyCommandLineRunner:拷贝静态文件！&quot;</span>);</span><br><span class="line">          <span class="comment">// 拷贝静态资源文件</span></span><br><span class="line">          generateHtml.generateStaticFiles();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>重启测试：<br>发现指定目录生成了静态文件，并且请求速度得到了极大提升。</li></ul><p>生成静态文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Thymeleaf 静态页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/css/index.css?v=20210511-075911&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>页面名字：testGenerateStaticHome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>页面版本：20210511-075911<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Redis」Redis故障处理-持久化时内存不足</title>
      <link href="/2021/05/06/redis-error.html"/>
      <url>/2021/05/06/redis-error.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Java错误日志:</span></span><br><span class="line">redis.clients.jedis.exceptions.JedisDataException: MISCONF Redis is configured to save RDB snapshots, but is currently not able to persist on disk. Commands that may modify the data <span class="built_in">set</span> are disabled. Please check Redis logs <span class="keyword">for</span> details about the error.</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis错误日志:</span></span><br><span class="line">Can<span class="string">&#x27;t save in background: fork: Resource temporaily unavailable</span></span><br><span class="line"><span class="string"># 或</span></span><br><span class="line"><span class="string">Can’t save in background: fork: Cannot allocate memory</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><code>Redis</code>在个默认情况下，如果在<code>RDB snapshots</code>持久化过程中出现问题，<code>Redis</code>不允许用户进行任何更新操作；即：<code>stop-writes-on-bgsave-error yes</code>。</p><p>临时解决方案是通过命令：<code>config set stop-writes-on-bgsave-error no</code> 设置这个选项为<code>false</code>，让程序忽略了这个异常，使得程序能够继续往下运行，但写硬盘仍然是失败的！</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="Redis数据回写机制"><a href="#Redis数据回写机制" class="headerlink" title="Redis数据回写机制"></a>Redis数据回写机制</h4><p><code>Redis</code>在进行持久化的时候，有的时候可以在日志中看到fork进程失败的提示，一般是系统可用的内存空间不够导致，这需要我们对<code>fork</code>原理明白，才能更好的进行参数调整。</p><p>一般来说<code>Redis</code>在进行<code>RDB</code>的时候，会<code>fork</code>出一个子进程，子进程和父进程会共享一个地址空间，在<code>fork</code>子进程的时候，会检查当前机器可用的内存是否满足<code>fork</code>出一个子进程的要求，一般由操作系统<code>overcommit_memory</code>(系统内存分配策略)决定。</p><ul><li><code>Redis</code>的数据回写机制分同步和异步两种，<ul><li>同步回写即<code>SAVE</code>命令，主进程直接向磁盘回写数据。在数据大的情况下会导致系统假死很长时间，所以一般不是推荐的。</li><li>异步回写即<code>BGSAVE</code>命令，主进程<code>fork</code>后，复制自身并通过这个新的进程回写磁盘，回写结束后新进程自行关闭。由于这样做不需要主进程阻塞，系统不会假死，一般默认会采用这个方法。</li></ul></li></ul><p><code>Redis</code>默认采用异步回写，所以如果我们要将数据刷到硬盘上，这时<code>Redis</code>分配内存不能太大，否则很容易发生内存不够用无法<code>fork</code>的问题；<br>设置一个合理的写磁盘策略，否则写频繁的应用，也会导致频繁的<code>fork</code>操作，对于占用了大内存的<code>Redis</code>来说，<code>fork</code>消耗资源的代价是很大的；</p><h4 id="系统内存分配策略"><a href="#系统内存分配策略" class="headerlink" title="系统内存分配策略"></a>系统内存分配策略</h4><p><code>Linux</code>对大部分申请内存的请求都回复<code>yes</code>，以便能跑更多更大的程序。</p><p>因为申请内存后，并不会马上使用内存，将这些不会使用的空闲内存分配给其它程序使用，以提高内存利用率，这种技术叫做<code>Overcommit</code>。</p><p>一般情况下，当所有程序都不会用到自己申请的所有内存时，系统不会出问题，但是如果程序随着运行，需要的内存越来越大，在自己申请的大小范围内，不断占用更多内存，直到超出物理内存，当<code>Linux</code>发现内存不足时，会发生<code>OOM killer(OOM=out-of-memory)</code>。</p><p><code>OOM killer</code>会选择杀死一些进程，以便释放内存。当发生<code>OOM killer</code>时，会记录在系统日志中<code>/var/log/messages</code>。</p><p>用户态进程，非内核线程，占用内存越多和运行时间越短的进程越有可能被杀掉。</p><ul><li><p>在<code>Linux</code>下有个vm内核参数：<code>CommitLimit</code>用于限制系统应用使用的内存资源；执行<code>grep -i commit  /proc/meminfo</code>，看到<code>CommitLimit</code>和<code>Committed_As</code>参数。</p><ul><li><code>CommitLimit</code>是一个内存分配上限，<code>CommitLimit = 物理内存 * overcommit_ratio(/proc/sys/vm/overcmmit_ratio，默认50，即50%) + swap大小</code></li><li><code>Committed_As</code>是已经分配的内存大小(应用程序要申请的内存 + 系统已经分配的内存)。</li></ul></li><li><p><code>vm.overcommit_memory</code>文件指定了内核针对内存分配的策略，其值可以是<code>0、1、2</code>。                          </p><ul><li><code>0</code>：启发策略(默认)；表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。系统在为应用进程分配虚拟地址空间时，会判断当前申请的虚拟地址空间大小是否超过剩余内存大小，如果超过，则虚拟地址空间分配失败。因此，也就是如果进程本身占用的虚拟地址空间比较大或者剩余内存比较小时，<code>fork</code>、<code>malloc</code>等调用可能会失败。 <code>0</code>即是启发式的<code>overcommitting handle</code>，会尽量减少<code>swap</code>交换分区的使用，<code>root</code>可以分配比一般用户略多的内存。</li><li><code>1</code>：允许<code>overcommit</code>；表示内核允许分配所有的物理内存，而不管当前的内存状态如何，允许超过<code>CommitLimit</code>，这种情况下，避免了<code>fork</code>可能产生的失败，但由于<code>malloc</code>是先分配虚拟地址空间，而后通过异常陷入内核分配真正的物理内存，在内存不足的情况下，这相当于完全屏蔽了应用进程对系统内存状态的感知，即<code>malloc</code>总是能成功，一旦内存不足，会引起系统<code>OOM</code>杀进程，应用程序对于这种后果是无法预测的。 直至内存用完为止。在数据库服务器上不建议设置为1，从而尽量避免使用<code>swap</code>交换分区。</li><li><code>2</code>：禁止<code>overcommit</code>；表示不允许超过<code>CommitLimit</code>值。由于很多情况下，进程的虚拟地址空间占用远大于其实际占用的物理内存，这样一旦内存使用量上去以后，对于一些动态产生的进程(需要复制父进程地址空间)则很容易创建失败，如果业务过程没有过多的这种动态申请内存或者创建子进程，则影响不大，否则会产生比较大的影响 。这种情况下系统所能分配的内存不会超过上面提到的<code>CommitLimit</code>大小，如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序。</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="修改系统内存分配策略"><a href="#修改系统内存分配策略" class="headerlink" title="修改系统内存分配策略"></a>修改系统内存分配策略</h4><p>我们可以通过设置<code>overcommit_memory=1</code>的优化，减少操作系统内存，提高<code>Redis</code>的<code>fork</code>成功率，因为<code>fork</code>后的进程和父进程共享一个数据空间，持久化要新增的内存空间都会小于父进程已经使用的空间，具体有三种方式修改内核参数，但要有<code>root</code>权限：</p><ol><li>编辑<code>/etc/sysctl.conf</code> ，改<code>vm.overcommit_memory=1</code>，然后<code>sysctl -p</code>使配置文件生效；</li><li>命令：<code>sysctl vm.overcommit_memory=1</code> ；</li><li>命令：<code>echo 1 &gt; /proc/sys/vm/overcommit_memory</code>；</li></ol><h4 id="关闭THP（Transparent-Huge-Pages）"><a href="#关闭THP（Transparent-Huge-Pages）" class="headerlink" title="关闭THP（Transparent Huge Pages）"></a>关闭THP（Transparent Huge Pages）</h4><p>当<code>Redis</code>持久化<code>fork</code>子进程后，占用内存大小和父进程等同，由于<code>Linux</code>在写时有<code>copy-on-write</code>机制，父子进程共享相同的物理内存页，当父进程处理写请求的时候会把要修改的页创建副本，而子进程在<code>fork</code>过程中共享整个父进程的内存快照。如果我们要减少创建的副本的大小，就涉及操作系统的另外一个概念<code>Huge Pages</code>(大页)。</p><p>在<code>Redhat Linux</code>中，内存都是以页的形式划分的，默认情况下每页是<code>4K</code>，这就意味着如果物理内存很大，则映射表的条目将会非常多，会影响<code>CPU</code>的检索效率。因为内存大小是固定的，为了减少映射表的条目，可采取的办法只有增加页的尺寸。<code>Linux Kernel</code>在<code>2.6.38</code>内核中增加了<code>THP</code>(Transparent Huge Pages)的特性，支持大内存页（<code>2MB</code>）分配，默认开启。当开启后可以加快<code>fork</code>子进程的速度，但<code>fork</code>操作之后，每个内存页从原来的<code>4KB</code>变成了<code>2MB</code>，会大幅增加重写期间父进程内存消耗，同时每次写命令引起的复制内存页单位放大了<code>512</code>倍，会拖慢写操作的执行时间，因此在使用<code>Redis</code>的时候<code>Redis</code>建议关闭<code>THP</code>，方法为：<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>。为了让机器重启该参数仍然生效，建议在<code>/etc/rc.local</code>中追加<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>，避免失效。当大页被关闭后，可以看到同等操作下，<code>RDB</code>备份时候的<code>copy-on-write</code>变化内存空间会减少。</p><p>综上分析，我们可以操作系统物理内存和<code>Redis</code>内存之间的一些关系，尤其<code>Redis</code>在持久化的时候<code>fork</code>进程会随操作系统的参数不同，需要的内存也有所不同，为了加快<code>fork</code>子进程的速度以及主备之间的文件传输同步，一般我们建议一个<code>Redis</code>节点的最大内存在<code>10G-15G</code>左右，操作系统的内存适当冗余，尽量控制同一台机器的多个<code>Redis</code>节点在同一个时间点进行<code>RDB</code>备份（可以通过缓存中心定时备份），导致内存同一时刻增加避免内存空间不足导致的<code>fork</code>失败，最安全保险的情况是内存为<code>Redis</code>的<code>2倍</code>，但是在<strong>vm.overcommit_memory&#x3D;1</strong>和<strong>大页关闭</strong>的情况下，可以根据实际使用，降低操作系统的整个内存大小 。</p><ul><li>参考文章：<ul><li><code>https://www.jianshu.com/p/785ee3bea266</code></li><li><code>https://www.cnblogs.com/wjoyxt/p/3777042.html</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Reactive Stack」响应式 HTTP 请求客户端 WebClient</title>
      <link href="/2021/03/20/spring-reactive-http.html"/>
      <url>/2021/03/20/spring-reactive-http.html</url>
      
        <content type="html"><![CDATA[<p><strong>WebClient</strong>是<code>Spring WebFlux</code>模块提供的一个非阻塞的基于响应式编程的进行<code>HTTP</code>请求的客户端工具。<span id="more"></span></p><p>引入<code>WebFlux</code>依赖则可使用<code>WebClient</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-创建WebClient实例"><a href="#1-创建WebClient实例" class="headerlink" title="1. 创建WebClient实例"></a>1. 创建WebClient实例</h3><p><code>WebClient</code>接口提供了三个不同的静态方法（<code>create()</code>，<code>create(String baseUrl)</code>，<code>builder()</code>）和一个内部类（<code>WebClient.Bulider</code>）来创建<code>WebClient</code>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动注入WebClient的内部类WebClient.Builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> WebClient.Builder clientBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// WebClient.create()创建</span></span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient1</span> <span class="operator">=</span> WebClient.create();</span><br><span class="line">    <span class="comment">// WebClient.create(String baseUrl)</span></span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient2</span> <span class="operator">=</span> WebClient.create(<span class="string">&quot;http://www.test.com&quot;</span>);</span><br><span class="line">    <span class="comment">// WebClient.builder()创建</span></span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient3</span> <span class="operator">=</span> WebClient.builder().build();</span><br><span class="line">    <span class="comment">// 内部类WebClient.Builder创建</span></span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient4</span> <span class="operator">=</span> clientBuilder.build();</span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient5</span> <span class="operator">=</span> clientBuilder.baseUrl(<span class="string">&quot;http://www.test.com&quot;</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-GET-请求"><a href="#2-GET-请求" class="headerlink" title="2. GET 请求"></a>2. GET 请求</h3><h4 id="2-1-发起GET请求"><a href="#2-1-发起GET请求" class="headerlink" title="2.1 发起GET请求"></a>2.1 发起GET请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder clientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                      <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/string&quot;</span>)        <span class="comment">// 请求路径</span></span><br><span class="line">                .retrieve()                 <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class);  <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-GET请求参数传递"><a href="#2-2-GET请求参数传递" class="headerlink" title="2.2 GET请求参数传递"></a>2.2 GET请求参数传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder clientBuilder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 请求路径里带参数(?id=5&amp;name=abc)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                             <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/param?id=5&amp;name=abc&quot;</span>)  <span class="comment">// 请求路径(带参数)</span></span><br><span class="line">                .retrieve()                        <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class);         <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 占位符的形式传递参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                             <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/&#123;1&#125;/&#123;2&#125;&quot;</span>, name, id)    <span class="comment">// 请求路径(占位符参数,若id=5,name=abc，则为&quot;/test/abc/5&quot;)</span></span><br><span class="line">                .retrieve()                        <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class);         <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 另一种占位符的形式传递参数(类似<span class="doctag">@PathVariable</span>)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/&#123;name&#125;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test3</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, <span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                              <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/&#123;name&#125;/&#123;id&#125;&quot;</span>, name, id) <span class="comment">// 请求路径(另一种占位符参数)</span></span><br><span class="line">                .retrieve()                         <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class);          <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 使用 map 装载参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;id&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                              <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/&#123;name&#125;/&#123;id&#125;&quot;</span>, map)      <span class="comment">// 请求路径(使用map装载参数)</span></span><br><span class="line">                .retrieve()                         <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class);          <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-POST请求"><a href="#3-POST请求" class="headerlink" title="3. POST请求"></a>3. POST请求</h3><h4 id="3-1-发起POST请求"><a href="#3-1-发起POST请求" class="headerlink" title="3.1 发起POST请求"></a>3.1 发起POST请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder clientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test/post&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .post()                     <span class="comment">// POST 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/post&quot;</span>)          <span class="comment">// 请求路径</span></span><br><span class="line">                .retrieve()                 <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class);  <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-POST请求参数传递"><a href="#3-2-POST请求参数传递" class="headerlink" title="3.2 POST请求参数传递"></a>3.2 POST请求参数传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/test6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//提交参数设置</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; mulMap = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    mulMap.add(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    mulMap.add(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">    Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">            .post()                                             <span class="comment">// POST 请求</span></span><br><span class="line">            .uri(<span class="string">&quot;/test/post&quot;</span>)                                  <span class="comment">// 请求路径</span></span><br><span class="line">            .contentType(MediaType.APPLICATION_FORM_URLENCODED) <span class="comment">// Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line">            .body(BodyInserters.fromFormData(mulMap))           <span class="comment">// 请求参数</span></span><br><span class="line">            .retrieve()                                         <span class="comment">// 获取响应体</span></span><br><span class="line">            .bodyToMono(String.class);                          <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">    <span class="comment">// 打印响应数据</span></span><br><span class="line">    stringMono.subscribe(log::info);</span><br><span class="line">    <span class="keyword">return</span> stringMono;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-请求异常处理"><a href="#4-请求异常处理" class="headerlink" title="4. 请求异常处理"></a>4. 请求异常处理</h3><p>使用<code>WebClient</code>发送请求时， 如果接口返回的不是<code>200</code>状态（而是<code>4xx</code>、<code>5xx</code>这样的异常状态），则会抛出<code>WebClientResponseException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder clientBuilder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 【doOnError】方法适配所有异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/error1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()</span><br><span class="line">                .uri(<span class="string">&quot;/test/error&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(String.class)</span><br><span class="line">                .doOnError(WebClientResponseException.class, err -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;发生错误：&quot;</span> + err.getRawStatusCode() + <span class="string">&quot; &quot;</span> + err.getResponseBodyAsString());</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 【onStatus】方法根据状态码来适配指定异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/error2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test8</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()</span><br><span class="line">                .uri(<span class="string">&quot;/test/error&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .onStatus(HttpStatus::is4xxClientError, resp -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;发生错误：&quot;</span> + resp.statusCode().value() + <span class="string">&quot; &quot;</span> + resp.statusCode().getReasonPhrase());</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;请求失败&quot;</span>));</span><br><span class="line">                &#125;)</span><br><span class="line">                .onStatus(HttpStatus::is5xxServerError, resp -&gt; &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;发生错误：&quot;</span> + resp.statusCode().value() + <span class="string">&quot; &quot;</span> + resp.statusCode().getReasonPhrase());</span><br><span class="line">                    <span class="keyword">return</span> Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;服务器异常&quot;</span>));</span><br><span class="line">                &#125;)</span><br><span class="line">                .bodyToMono(String.class);</span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 【onErrorReturn】方法来设置在发生异常时返回默认值，</span></span><br><span class="line"><span class="comment">     *    当请求发生异常是会使用该默认值作为响应结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/error3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test9</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()</span><br><span class="line">                .uri(<span class="string">&quot;/test/error&quot;</span>)</span><br><span class="line">                .retrieve()</span><br><span class="line">                .bodyToMono(String.class)</span><br><span class="line">                .onErrorReturn(<span class="string">&quot;请求失败&quot;</span>);          <span class="comment">// 失败时返回默认值“请求失败”</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4. 设置【超时属性】</span></span><br><span class="line"><span class="comment">     * 使用timeout()方法设置一个超时时长。如果HTTP请求超时，便会发生TimeoutException异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/setting&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test10</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                          <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/setting&quot;</span>)         <span class="comment">// 请求路径</span></span><br><span class="line">                .retrieve()                      <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class)        <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">                .timeout(Duration.ofSeconds(<span class="number">3</span>)); <span class="comment">// 3秒超时</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5. 设置【异常自动重试】</span></span><br><span class="line"><span class="comment">     * 使用retry()方法可以设置当请求异常时的最大重试次数，如果不带参数则表示无限重试，直至成功。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test/setting2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test11</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">        Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">                .get()                          <span class="comment">// GET 请求</span></span><br><span class="line">                .uri(<span class="string">&quot;/test/setting&quot;</span>)         <span class="comment">// 请求路径</span></span><br><span class="line">                .retrieve()                      <span class="comment">// 获取响应体</span></span><br><span class="line">                .bodyToMono(String.class)        <span class="comment">// 响应数据类型转换(这里是String，也可以是自定义对象或集合)</span></span><br><span class="line">                .timeout(Duration.ofSeconds(<span class="number">3</span>))  <span class="comment">// 3秒超时</span></span><br><span class="line">                .retry(<span class="number">2</span>);                       <span class="comment">// 重试2次</span></span><br><span class="line">        <span class="comment">// 打印响应数据</span></span><br><span class="line">        stringMono.subscribe(log::info);</span><br><span class="line">        <span class="keyword">return</span> stringMono;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Exchange获取完整的请求响应结果"><a href="#5-Exchange获取完整的请求响应结果" class="headerlink" title="5. Exchange获取完整的请求响应结果"></a>5. Exchange获取完整的请求响应结果</h3><p>前面我们都是使用<code>retrieve()</code>方法是直接获取响应体的内容。</p><p>使用<code>exchangeToMono()</code>和<code>exchangeToFlux()</code>方法获取完整的代表响应结果的对象，通过该对象我们可以获取响应码、<code>contentType</code>、<code>contentLength</code>、响应消息体等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/test/res&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">test12</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//提交参数设置</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; mulMap = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">    mulMap.add(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    mulMap.add(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">    <span class="type">WebClient</span> <span class="variable">webClient</span> <span class="operator">=</span> webClientBuilder.baseUrl(<span class="string">&quot;https://www.test.com&quot;</span>).build();</span><br><span class="line">    Mono&lt;String&gt; stringMono = webClient</span><br><span class="line">            .post()                                             <span class="comment">// POST 请求</span></span><br><span class="line">            .uri(<span class="string">&quot;/test/post&quot;</span>)                               <span class="comment">// 请求路径</span></span><br><span class="line">            .contentType(MediaType.APPLICATION_FORM_URLENCODED) <span class="comment">// Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line">            .body(BodyInserters.fromFormData(mulMap))           <span class="comment">// 请求参数</span></span><br><span class="line">            .exchangeToMono(response -&gt; &#123;                       <span class="comment">// 响应结果response</span></span><br><span class="line">                <span class="keyword">if</span> (response.statusCode().equals(HttpStatus.OK)) &#123;  <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">return</span> response.bodyToMono(String.class);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> response.createException().flatMap(Mono::error);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 打印响应数据</span></span><br><span class="line">    stringMono.subscribe(log::info);</span><br><span class="line">    <span class="keyword">return</span> stringMono;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-WebClient在Spring-Cloud中的使用"><a href="#6-WebClient在Spring-Cloud中的使用" class="headerlink" title="6. WebClient在Spring Cloud中的使用"></a>6. WebClient在Spring Cloud中的使用</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置，创建<code>WebClient.Bulider</code>类型的<code>Bean</code>，加上<code>@LoadBalaced</code>为<code>WebClient</code>增加负载均衡的支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadbalanceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> WebClient.Builder <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Controller，客户端实现访问服务端资源，并对外提供访问接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReactiveClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient.Builder clientBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get/string&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">getServerString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 WebClient 访问 CLOUD-SERVER 服务的资源 （这里的CLOUD-SERVER是服务注册中心注册的微服务名）</span></span><br><span class="line">        <span class="keyword">return</span> clientBuilder.baseUrl(<span class="string">&quot;http://CLOUD-SERVER&quot;</span>).build().get().uri(<span class="string">&quot;/test/string&quot;</span>).retrieve().bodyToMono(String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringReactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringReactive </tag>
            
            <tag> WebClient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Reactive Stack」服务端事件推送Server-Sent Events</title>
      <link href="/2021/03/12/spring-reactive-sse.html"/>
      <url>/2021/03/12/spring-reactive-sse.html</url>
      
        <content type="html"><![CDATA[<p><strong>SSE</strong>：<code>Server-Sent Events</code>服务器推送事件，是一种仅发送文本消息的技术。<code>SSE</code>基于<code>HTTP</code>协议中的持久连接。<code>SSE</code>是<code>HTML5</code>标准协议中的一部分。</p><p>客户端接收服务端<strong>异步更新</strong>的消息可以分为两类：客户端拉取和服务端推送。<span id="more"></span></p><p>客户端拉取：通过短轮询或者长轮询定期请求服务器进行更新。</p><p>服务端推送：<code>SSE</code>和<code>WebSocket</code>，<code>SSE</code>是单向，<code>WebSocket</code>是双向；<code>SSE</code>基于<code>HTTP</code>协议，<code>WebSocket</code>基于<code>WebSocket</code>协议(<code>HTTP</code>以外的协议);</p><h3 id="SSE网络协议"><a href="#SSE网络协议" class="headerlink" title="SSE网络协议"></a>SSE网络协议</h3><ul><li>基于纯文本的简单协议。服务器端的响应内容类型必须是<code>text/event-stream</code>。响应文本的内容是一个事件流，事件流是一个简单的文本流，仅支持<code>UTF-8</code>格式的编码。</li><li>事件流由不同的事件组成。不同事件间通过仅包含回车符和换行符的空行（<code>\r\n</code>）来分隔。</li><li>每个事件可以由多行构成，每行由类型和数据两部分组成。类型与数据通过冒号（<code>:</code>）进行分隔，冒号前的为类型，冒号后的为其对应的值。每个事件可以包含如下类型的行：<ul><li>类型为空白，表示该行是注释，会在处理时被忽略。</li><li>类型为<code>data</code>，表示该行是事件所包含的数据。以<code>data</code>开头的行可以出现多次。所有这些行都是该事件的数据。</li><li>类型为<code>event</code>，表示该行用来声明事件的类型，即事件名称。浏览器在收到数据时，会产生对应名称的事件。</li><li>类型为<code>id</code>，表示该行用来声明事件的标识符。</li><li>类型为<code>retry</code>，表示该行用来声明浏览器在连接断开之后进行重连的等待时间。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data: china // 该事件仅包含数据</span><br><span class="line"></span><br><span class="line">data: Beijing // 该事件包含数据与事件标识</span><br><span class="line"><span class="built_in">id</span>: 100</span><br><span class="line"></span><br><span class="line">event: myevent // 该事件指定了名称</span><br><span class="line">data:shanghai</span><br><span class="line"><span class="built_in">id</span>: 101</span><br><span class="line"></span><br><span class="line">: this is a comment // 该事件具有注释、名称，且包含两行数据</span><br><span class="line">event:city</span><br><span class="line">data: guangzhou</span><br><span class="line">data: shenzhen</span><br></pre></td></tr></table></figure><ul><li>事件标识<code>id</code>作用: 如果服务端发送的事件中包含事件标识<code>id</code>，那么浏览器会将最近一次接收到的事件标识<code>id</code>记录到<code>HTTP</code>头的<code>Last-Event-ID</code>属性中。如果浏览器与服务端的连接中断，当浏览器再次连接时，会将<code>Last-Event-ID</code>记录的事件标识<code>id</code>发送给服务端。服务器端通过浏览器端发送的事件标识<code>id</code>来确定将继续连接哪个事件。</li></ul><p>订阅一个服务端推送事件(<code>GET</code>请求)，需要设置 包含如下请求头的<code>Request</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/event-stream <span class="comment"># 指明MediaType是事件流</span></span><br><span class="line">Cache-Control: no-cache   <span class="comment"># 不要对事件进行缓存</span></span><br><span class="line">Connection: keep-alive    <span class="comment"># 长连接</span></span><br></pre></td></tr></table></figure><p>服务端需要提供 包含以下响应头的Response：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/event-stream;charset=UTF-8  <span class="comment"># 告诉客户端响应是一个事件流</span></span><br><span class="line">Transfer-Encoding: chunked                     <span class="comment"># 告诉客户端内容大小未知，为流传输</span></span><br></pre></td></tr></table></figure><h3 id="在WebFlux中实现发送事件"><a href="#在WebFlux中实现发送事件" class="headerlink" title="在WebFlux中实现发送事件"></a>在WebFlux中实现发送事件</h3><p>首先，在<code>pom.xml</code>文件中，引入<code>webflux</code>；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个<code>controller</code>类并用<code>@RestController</code>注解标记；<br>创建一个接受<code>Http GET</code>请求的方法，该方法返回一个<code>Flux</code>对象，并配置<code>produces=text/event-stream</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/test/sse&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> Flux&lt;String&gt; <span class="title function_">flux</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Flux.interval(Duration.ofMillis(<span class="number">1000</span>)).map(i -&gt; <span class="string">&quot; -&gt; &quot;</span> +i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问<code>/test/sse</code>就会看到每一秒推送一个数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: -&gt; 0</span><br><span class="line">data: -&gt; 1</span><br><span class="line">data: -&gt; 2</span><br><span class="line">data: -&gt; 3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><strong>一次性事件</strong>：短暂的去发送事件是比较简单的，只需要使用<code>Flux.just()</code>将消息列表里的消息一条条发送出去即可。</li><li><strong>周期性事件</strong>：长期的发送事件在发送本身上是没有区别，主要是需要一个周期性线程定期处理发送事务，这里直接使用<code>Flux.inteval()</code>来轮询。</li><li><strong>非周期性事件</strong>：可以通过<code>Spring</code>的事件监听接口来实现，关键点在于要把监听消息的处理器和Flux的构造结合起来。</li></ul><h3 id="SSE的注意事项"><a href="#SSE的注意事项" class="headerlink" title="SSE的注意事项"></a>SSE的注意事项</h3><ol><li><code>SSE</code>只适合发送文本消息；尽管可以使用<code>Base64</code>编码和<code>gzip</code>压缩来发送二进制消息，但效率可能很低。</li><li>早期的一些浏览器，如<code>Internet Explorer</code>不支持。</li><li><code>Internet Explorer/Edge</code>和许多移动浏览器不支持<code>SSE</code>；尽管可以使用<code>polyfills</code>，但它们可能效率低下</li><li>在系统设计时，同一个页面最好只维持1个<code>SSE</code>连接，通过事件来区分。因为浏览器对同时并发的连接数有限制，一般最大是6个。</li></ol><h3 id="前端接收Server-Sent事件通知"><a href="#前端接收Server-Sent事件通知" class="headerlink" title="前端接收Server-Sent事件通知"></a>前端接收Server-Sent事件通知</h3><p><code>JavaScript</code>里用<strong>EventSource</strong>对象来接收服务器发送事件通知：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="title class_">EventSource</span>)!==<span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> source=<span class="keyword">new</span> <span class="title class_">EventSource</span>(<span class="string">&quot;http://localhost:8080/test/sse&quot;</span>);</span><br><span class="line">    source.<span class="property">onmessage</span>=<span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(event.<span class="property">data</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;抱歉，你的浏览器不支持 server-sent 事件...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EventSource</code>是服务器推送的一个网络事件接口。一个<code>EventSource</code>实例会对<code>HTTP</code>服务开启一个持久化的连接，以<code>text/event-stream</code>格式发送事件, 会一直保持开启直到被要求关闭。</p><ul><li><code>EventSource</code>属性<ul><li><code>EventSource.onerror</code>：EventHandler，当发生错误时被调用，并且在此对象上派发<code>error</code>事件。</li><li><code>EventSource.onmessage</code>：EventHandler，当收到一个<code>message</code>事件，当接收到消息时被调用。</li><li><code>EventSource.onopen</code>：EventHandler，当收到一个<code>open</code>事件，当连接刚打开时被调用。</li><li><code>EventSource.readyState</code>(只读)：unsigned short值，代表连接状态。可能值是CONNECTING(0), OPEN(1), 或者CLOSED(2)。</li><li><code>EventSource.url</code>(只读)：一个DOMString，代表事件源的URL。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringReactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringReactive </tag>
            
            <tag> SSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Reactive Stack」响应式方式访问Redis</title>
      <link href="/2021/03/04/spring-reactive-redis.html"/>
      <url>/2021/03/04/spring-reactive-redis.html</url>
      
        <content type="html"><![CDATA[<p><code>Spring Data Redis</code>中同时支持了<code>Jedis</code>客户端和<code>Lettuce</code>客户端。但是仅<code>Lettuce</code>是支持<code>Reactive</code>方式的操作；这里选择默认的<code>Lettuce</code>客户端。<span id="more"></span></p><ol><li><p>创建<code>Maven</code>项目，并在<code>pom.xml</code>导入依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- reactive redis依赖包（包含Lettuce客户端） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件<code>application.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password: 123456</span><br><span class="line">    #Redis数据库索引（默认为0）</span><br><span class="line">    database: 0</span><br><span class="line">    #连接超时时间（毫秒）</span><br><span class="line">    timeout: 5000</span><br></pre></td></tr></table></figure></li><li><p>注入配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReactiveRedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ReactiveRedisTemplate <span class="title function_">reactiveRedisTemplate</span><span class="params">(ReactiveRedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ReactiveRedisTemplate</span>&lt;&gt;(factory, RedisSerializationContext.string());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单的RedisService封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReactiveRedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key==<span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Boolean&gt; <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Boolean&gt; <span class="title function_">set</span><span class="params">(String key, String value, Long time)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().set(key, value, Duration.ofSeconds(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Boolean&gt; <span class="title function_">exists</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Long&gt; <span class="title function_">remove</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReactiveRedisTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 保存5分钟</span></span><br><span class="line">        redisService.set(<span class="string">&quot;test1&quot;</span>, <span class="string">&quot;test1_value&quot;</span>, <span class="number">5</span> * <span class="number">60L</span>).subscribe(System.out::println);</span><br><span class="line">        redisService.get(<span class="string">&quot;test1&quot;</span>).subscribe(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>测试运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line">test1_value</span><br></pre></td></tr></table></figure><blockquote><p>本文使用Spring Boot版本：2.4.3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringReactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Redis </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringReactive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Reactive Stack」使用R2DBC访问MySQL</title>
      <link href="/2021/03/03/spring-reactive-r2dbc.html"/>
      <url>/2021/03/03/spring-reactive-r2dbc.html</url>
      
        <content type="html"><![CDATA[<p><code>MySQL</code>等一系列的关系型数据库也在<code>R2DBC</code>等包的帮助下支持响应式。<br><code>R2DBC</code>基于<code>Reactive Streams</code>反应流规范，它是一个开放的规范，为驱动程序供应商和使用方提供接口(<code>r2dbc-spi</code>)，与<code>JDBC</code>的阻塞特性不同，它提供了完全反应式的<strong>非阻塞API</strong>与<strong>关系型数据库</strong>交互。<span id="more"></span></p><ol><li><p>创建<code>Maven</code>项目，并导入依赖<code>pom.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- data-r2dbc同时也会将r2dbc-pool导入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-r2dbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- r2dbc mysql 库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dev.miku<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>r2dbc-mysql<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件<code>application.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  r2dbc:</span><br><span class="line">    url: r2dbcs:mysql://192.168.2.100:3306/test?characterEncoding=UTF8&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    username: developer</span><br><span class="line">    password: 123456</span><br><span class="line">    </span><br><span class="line">#日志配置</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    root: info</span><br><span class="line">    # 调试环境查看执行的sql</span><br><span class="line">    dev.miku.r2dbc.mysql.client.ReactorNettyClient: debug</span><br></pre></td></tr></table></figure></li><li><p><code>SQL</code>与<code>Model</code>类</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `base_user` (</span><br><span class="line">  `userId` <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">  `userName` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `userMobile` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="keyword">null</span> comment <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  <span class="keyword">primary</span> key (`userId`),</span><br><span class="line">  <span class="keyword">unique</span> key `userMobile` (`userMobile`)</span><br><span class="line">) engine<span class="operator">=</span>innodb comment<span class="operator">=</span><span class="string">&#x27;测试用户信息&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `base_user` (`userName`, `userMobile`) <span class="keyword">values</span> (<span class="string">&#x27;黑子&#x27;</span>, <span class="string">&#x27;15914061216&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `base_user` (`userName`, `userMobile`) <span class="keyword">values</span> (<span class="string">&#x27;大黄&#x27;</span>, <span class="string">&#x27;15914061217&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseUser</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际开发中，由于历史原因数据库字段大多与<code>Model</code>类字段无法对应，这里也不对应，在<code>sql</code>中用别名对应。</p></blockquote><ol start="4"><li><p>编写<code>DAO</code>层，这里继承的事响应式的<code>crud</code>类<code>ReactiveCrudRepository</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseUserDao</span> <span class="keyword">extends</span> <span class="title class_">ReactiveCrudRepository</span>&lt;BaseUser, Integer&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户id查询用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> BaseUser</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Query(&quot;select userId as id, userMobile as mobile, userName as name from base_user where userId= :id&quot;)</span></span><br><span class="line">    Mono&lt;BaseUser&gt; <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name userName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(&quot;update base_user set userName= :name where userId= :id&quot;)</span></span><br><span class="line">    Mono&lt;Integer&gt; <span class="title function_">updateNameById</span><span class="params">(Integer id, String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name userName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mobile userMobile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(&quot;insert into base_user(userName, userMobile) values (:name, :mobile)&quot;)</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">insertUser</span><span class="params">(String name, String mobile)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户id删除用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query(&quot;delete from base_user where userId= :id&quot;)</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">deleteById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写<code>Service</code>层，这里返回的值为<code>Reactor</code>的对象<code>Flux</code>或<code>Mono</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseUserDao baseUserDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;BaseUser&gt; <span class="title function_">findById</span> <span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Integer&gt; <span class="title function_">updateById</span><span class="params">(BaseUser user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserDao.updateNameById(user.getId(), user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">insertUser</span><span class="params">(BaseUser user)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserDao.insertUser(user.getName(), user.getMobile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">deleteById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserDao.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写<code>Controller</code>层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BaseUserService baseUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;BaseUser&gt; <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Integer&gt; <span class="title function_">updateById</span><span class="params">(BaseUser user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserService.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/insert&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">insertUser</span><span class="params">(BaseUser user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserService.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/delete&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">deleteById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseUserService.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试:</p><ul><li>查询：<code>curl -X GET &quot;http://localhost:8080/user/get?id=1&quot;</code></li><li>更新：<code>curl -X POST &quot;http://localhost:8080/user/update?id=1&amp;name=小黑子&quot;</code></li><li>新增：<code>curl -X POST &quot;http://localhost:8080/user/insert?name=小蓝子&amp;mobile=15815011618&quot;</code></li><li>删除：<code>curl -X POST &quot;http://localhost:8080/user/delete?id=1&quot;</code></li></ul></li></ol><blockquote><p>本文使用Spring Boot版本：2.4.3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringReactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> MySQL </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringReactive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Reactive Stack」Reactor异常处理</title>
      <link href="/2021/03/02/spring-reactive-exception.html"/>
      <url>/2021/03/02/spring-reactive-exception.html</url>
      
        <content type="html"><![CDATA[<p>不管是在响应式编程还是普通的程序设计中，异常处理都是一个非常重要的方面。</p><p>对于<code>Flux</code>或者<code>Mono</code>来说，所有的异常都是一个终止的操作，即使你使用了异常处理，原生成序列也不会继续。<br>但是如果你对异常进行了处理，那么它会将<code>oneError</code>信号转换成为新的序列的开始，并将替换掉之前上游产生的序列。<span id="more"></span></p><p>先看一个<code>Flux</code>产生异常的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会得到一个异常<code>ErrorCallbackNotImplemented</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100 / 10 = 1</span><br><span class="line">100 / 5 = 2</span><br><span class="line">reactor.core.Exceptions<span class="variable">$ErrorCallbackNotImplemented</span>: java.lang.ArithmeticException: / by zero</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><h3 id="1-onError方法"><a href="#1-onError方法" class="headerlink" title="1. onError方法"></a>1. onError方法</h3><p><code>Reactor</code>中<code>subscribe</code>的<code>onError</code>方法(subscribe第二个参数)，就是<code>try catch</code>的一个具体应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .subscribe(System.out::println,</span><br><span class="line">            error -&gt; System.err.println(<span class="string">&quot;Error: &quot;</span> + error));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100 / 10 = 1</span><br><span class="line">100 / 5 = 2</span><br><span class="line">Error: java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><h3 id="2-onErrorReturn方法"><a href="#2-onErrorReturn方法" class="headerlink" title="2. onErrorReturn方法"></a>2. onErrorReturn方法</h3><p><code>onErrorReturn</code>可以在遇到异常的时候<code>fallback</code>到一个静态的默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .onErrorReturn(<span class="string">&quot;Divided by zero :(&quot;</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100 / 10 = 1</span><br><span class="line">100 / 5 = 2</span><br><span class="line">Divided by zero :(</span><br></pre></td></tr></table></figure><p><code>onErrorReturn</code>还支持一个<code>Predicate</code>参数，用来判断要<code>falback</code>的异常是否满足条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Flux&lt;T&gt; <span class="title function_">onErrorReturn</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> Throwable&gt; predicate, T fallbackValue)</span> </span><br></pre></td></tr></table></figure><h3 id="3-onErrorResume方法"><a href="#3-onErrorResume方法" class="headerlink" title="3. onErrorResume方法"></a>3. onErrorResume方法</h3><p><code>onErrorResume</code>可以在捕获异常之后调用其他的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .onErrorResume(e -&gt; System.out::println)</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100 / 10 = 1</span><br><span class="line">100 / 5 = 2</span><br><span class="line">reactor.core.publisher.FluxOnErrorResume<span class="variable">$ResumeSubscriber</span>@23469199</span><br></pre></td></tr></table></figure><h3 id="4-retry方法"><a href="#4-retry方法" class="headerlink" title="4. retry方法"></a>4. retry方法</h3><p><code>retry</code>的作用就是当遇到异常的时候，重启一个新的序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test8</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .retry(<span class="number">1</span>)</span><br><span class="line">        .elapsed()</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[4,100 / 10 = 1]</span><br><span class="line">[0,100 / 5 = 2]</span><br><span class="line">[9,100 / 10 = 1]</span><br><span class="line">[0,100 / 5 = 2]</span><br><span class="line">reactor.core.Exceptions<span class="variable">$ErrorCallbackNotImplemented</span>: java.lang.ArithmeticException: / by zero</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><blockquote><p><code>elapsed</code>是用来展示产生的value时间之间的duration。从结果我们可以看到，<code>retry</code>之前是不会产生异常信息的。</p></blockquote><h3 id="5-doOnError方法"><a href="#5-doOnError方法" class="headerlink" title="5. doOnError方法"></a>5. doOnError方法</h3><p><code>doOnError</code>只记录异常信息，不破坏原来的<code>React</code>结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .doOnError(error -&gt; System.out.println(<span class="string">&quot;we got the error: &quot;</span>+ error))</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">100 / 10 = 1</span><br><span class="line">100 / 5 = 2</span><br><span class="line">we got the error: java.lang.ArithmeticException: / by zero</span><br><span class="line">reactor.core.Exceptions<span class="variable">$ErrorCallbackNotImplemented</span>: java.lang.ArithmeticException: / by zero</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><blockquote><p><code>doOn</code>系列方法是<code>publisher</code>的同步钩子方法，在<code>subscriber</code>触发一系列事件的时候触发</p></blockquote><h3 id="6-doFinally方法"><a href="#6-doFinally方法" class="headerlink" title="6. doFinally方法"></a>6. doFinally方法</h3><p><code>doFinally</code>可以像传统的同步代码那样使用<code>finally</code>去做一些事情，比如关闭<code>http</code>连接，清理资源等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">    Flux.just(<span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>)</span><br><span class="line">        .map(i -&gt; <span class="string">&quot;100 / &quot;</span> + i + <span class="string">&quot; = &quot;</span> + (<span class="number">10</span> / i))</span><br><span class="line">        .doFinally(error -&gt; System.out.println(<span class="string">&quot;Finally，I will make sure to do something:&quot;</span>+error))</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100 / 10 = 1</span><br><span class="line">100 / 5 = 2</span><br><span class="line">reactor.core.Exceptions<span class="variable">$ErrorCallbackNotImplemented</span>: java.lang.ArithmeticException: / by zero</span><br><span class="line">Caused by: java.lang.ArithmeticException: / by zero</span><br><span class="line">at ...</span><br><span class="line">Finally，我会确保做一些事情:onError</span><br></pre></td></tr></table></figure><p>第二种收尾操作的方法是<code>using</code>，我们先看一个<code>using</code>的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D&gt; Flux&lt;T&gt; <span class="title function_">using</span><span class="params">(Callable&lt;? extends D&gt; resourceSupplier, Function&lt;? <span class="built_in">super</span> D, ? extends</span></span><br><span class="line"><span class="params">    Publisher&lt;? extends T&gt;&gt; sourceSupplier, Consumer&lt;? <span class="built_in">super</span> D&gt; resourceCleanup)</span></span><br></pre></td></tr></table></figure><p>可以看到<code>using</code>支持三个参数，<code>resourceSupplier</code>是一个生成器，用来在<code>subscribe</code>的时候生成要发送的<code>resource</code>对象。<br><code>sourceSupplier</code>是一个生成<code>Publisher</code>的工厂，接收<code>resourceSupplier</code>传过来的<code>resource</code>，然后生成<code>Publisher</code>对象。<br><code>resourceCleanup</code>用来对<code>resource</code>进行收尾操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AtomicBoolean</span> <span class="variable">isDisposed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">disposableInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Disposable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">            isDisposed.set(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;DISPOSABLE&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Flux.using(</span><br><span class="line">        () -&gt; disposableInstance,</span><br><span class="line">        disposable -&gt; Flux.just(disposable.toString()),</span><br><span class="line">        Disposable::dispose)</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringReactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringReactive </tag>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring Reactive Stack」Spring WebFlux响应式Web框架入门</title>
      <link href="/2021/02/25/spring-reactive-webflux.html"/>
      <url>/2021/02/25/spring-reactive-webflux.html</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/02/25/spring-reactive-webflux/up-ee8803006ea5a4169467074917d6fdd0b12.webp"></p><p><code>Spring WebFlux</code>是<code>Spring Framework 5.0</code>中引入的以<code>Reactor</code>为基础的响应式编程<code>Web</code>框架。</p><p><strong>WebFlux</strong> 的异步处理是基于<code>Reactor</code>实现的，是将输入流适配成<code>Mono</code>或<code>Flux</code>进行统一处理。<span id="more"></span></p><h3 id="1-响应式流-Reactive-Streams"><a href="#1-响应式流-Reactive-Streams" class="headerlink" title="1. 响应式流(Reactive Streams)"></a>1. 响应式流(Reactive Streams)</h3><ul><li><p><strong>Reactor</strong> 是一个响应式流，它有对应的发布者(<code>Publisher</code>)，用两个类来表示：</p><ul><li><code>Flux</code>(返回0-n个元素)</li><li><code>Mono</code>(返回0或1个元素)</li></ul></li><li><p><strong>Reactor</strong> 的订阅者(<code>Subscriber</code>)则是由<code>Spring</code>框架去完成。</p></li><li><p><strong>响应式流(Reactive Streams)</strong> 其实就是一个规范，其特点：</p><ul><li>无阻塞；</li><li>一个数据流；</li><li>可以异步执行；</li><li>能够处理背压；</li></ul></li><li><p><strong>背压(Backpressure)</strong> 可以简单理解为 消费决定生产，生产者可以根据消费压力进行动态调节生产速率的机制。</p></li></ul><h3 id="2-发布者-Publisher"><a href="#2-发布者-Publisher" class="headerlink" title="2. 发布者(Publisher)"></a>2. 发布者(Publisher)</h3><p>由于响应流的特点，我们不能再返回一个简单的<code>POJO</code>对象来表示结果了。必须返回一个类似<code>Java</code>中的<code>Future</code>的概念，在有结果可用时通知消费者进行消费响应。</p><p><code>Reactive Stream</code>规范中这种被定义为<code>Publisher</code> ，<code>Publisher</code>是一个可以提供<code>0-N</code>个序列元素的提供者，并根据其订阅者<code>Subscriber</code>的需求推送元素。一个<code>Publisher</code>可以支持多个订阅者，并可以根据订阅者的逻辑进行推送序列元素。</p><p>可以通过下图Excel来理解，<code>1-9</code>行可以看作发布者<code>Publisher</code>提供的元素序列，<code>10-13</code>行的结果计算看作订阅者<code>Subscriber</code>。</p><p><img src="/2021/02/25/spring-reactive-webflux/publisher.gif"></p><p>响应式的一个重要特点：当没有订阅时发布者(<code>Publisher</code>)什么也不做。</p><p>而<code>Flux</code>和<code>Mono</code>都是<code>Publisher</code>在<code>Reactor3</code>实现。<code>Publisher</code>提供了<code>subscribe</code>方法，允许消费者在有结果可用时进行消费。如果没有消费者<code>Publisher</code>不会做任何事情，他根据消费情况进行响应。<code>Publisher</code>可能返回零或者多个，甚至可能是无限的，为了更加清晰表示期待的结果就引入了两个实现模型<code>Mono</code>和<code>Flux</code>。</p><p>在<code>WebFlux</code>中，你的方法只需返回<code>Mono或Flux</code>即可。你的代码基本也只和<code>Mono</code>或<code>Flux</code>打交道。而<code>WebFlux</code>则会实现<code>Subscriber</code> ，<code>onNext</code>时将业务开发人员编写的<code>Mono</code>或<code>Flux</code>转换为<code>HTTP Response</code>返回给客户端。</p><h3 id="3-Mono和Flux的抽象模型"><a href="#3-Mono和Flux的抽象模型" class="headerlink" title="3. Mono和Flux的抽象模型"></a>3. Mono和Flux的抽象模型</h3><p>Mono和Flux都是Publisher(发布者)的实现模型。</p><h4 id="3-1-Flux"><a href="#3-1-Flux" class="headerlink" title="3.1 Flux"></a>3.1 Flux</h4><p><code>Flux</code>是一个发出(<code>emit</code>)<code>0-N</code>个元素组成的异步序列的<code>Publisher&lt;T&gt;</code>,可以被<code>onComplete</code>信号或者<code>onError</code>信号所终止。<br>在响应流规范中存在三种给下游消费者调用的方法 <code>onNext</code>, <code>onComplete</code>, 和<code>onError</code>。<br>下面这张图表示了<code>Flux</code>的抽象模型：</p><p><img src="/2021/02/25/spring-reactive-webflux/flux.jpg"></p><h4 id="3-2-Mono"><a href="#3-2-Mono" class="headerlink" title="3.2 Mono"></a>3.2 Mono</h4><p><code>Mono</code>是一个发出(<code>emit</code>)<code>0-1</code>个元素的<code>Publisher&lt;T&gt;</code>,可以被<code>onComplete</code>信号或者<code>onError</code>信号所终止。<br>下面这张图表示了<code>Mono</code>的抽象模型(整体和<code>Flux</code>差不多,只不过这里只会发出<code>0-1</code>个元素)：</p><p><img src="/2021/02/25/spring-reactive-webflux/mono.jpg"></p><h3 id="4-Mono-API"><a href="#4-Mono-API" class="headerlink" title="4. Mono API"></a>4. Mono API</h3><p><code>Mono</code>和<code>Flux</code>都是实现<code>org.reactivestreams.Publisher</code>接口的抽象类。</p><p><code>Mono</code>代表<code>0-1</code>个元素的发布者(<code>Publisher</code>)。</p><ul><li><code>Mono</code>里面有很多<code>API</code>：<ul><li>**just()**：可以指定序列中包含的全部元素。创建出来的 <code>Mono</code>序列在发布这些元素之后会自动结束。</li><li>**empty()**：创建一个不包含任何元素，只发布结束消息的序列。</li><li>**justOrEmpty(Optional&lt;? extends T&gt; data)**：从一个<code>Optional</code>对象或可能为<code>null</code>的对象中创建<code>Mono</code>。只有<code>Optional</code>对象中包含值或对象不为<code>null</code>时，<code>Mono</code>序列才产生对应的元素。</li><li>**error(Throwable error)**：创建一个只包含错误消息的序列。</li><li>**never()**：创建一个不包含任何消息通知的序列。</li><li>**delay(Duration duration)<strong>和</strong>delayMillis(long duration)**：创建一个<code>Mono</code>序列，在指定的延迟时间之后，产生数字 <code>0</code> 作为唯一值。</li><li>**fromCallable()<strong>、</strong>fromCompletionStage()<strong>、</strong>fromFuture()<strong>、</strong>fromRunnable()<strong>和</strong>fromSupplier()**：分别从 <code>Callable</code>、<code>CompletionStage</code>、<code>CompletableFuture</code>、<code>Runnable</code>和<code>Supplier</code>中创建<code>Mono</code>。</li><li>**ignoreElements(Publisher source)**：创建一个<code>Mono</code>序列，忽略作为源的<code>Publisher</code>中的所有元素，只产生结束消息。</li><li>**create()**：通过<code>create()</code>方法来使用<code>MonoSink</code>来创建<code>Mono</code>。</li></ul></li><li><code>API</code>使用案例如下所示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonoTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mono</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过just直接赋值</span></span><br><span class="line">        Mono.just(<span class="string">&quot;my name is charles&quot;</span>).subscribe(log::info);</span><br><span class="line">        <span class="comment">// empty 创建空mono</span></span><br><span class="line">        Mono.empty().subscribe();</span><br><span class="line">        <span class="comment">// ustOrEmpty 只有 Optional 对象中包含值或对象不为 null 时，Mono 序列才产生对应的元素。</span></span><br><span class="line">        Mono.justOrEmpty(<span class="literal">null</span>).subscribe(System.out::println);</span><br><span class="line">        Mono.justOrEmpty(<span class="string">&quot;测试justOrEmpty&quot;</span>).subscribe(System.out::println);</span><br><span class="line">        Mono.justOrEmpty(Optional.of(<span class="string">&quot;测试justOrEmpty&quot;</span>)).subscribe(System.out::println);</span><br><span class="line">        <span class="comment">// error 创建一个只包含错误消息的序列。</span></span><br><span class="line">        Mono.error(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error&quot;</span>)).subscribe(System.out::println, System.err::println);</span><br><span class="line">        <span class="comment">// never 创建一个不包含任何消息通知的序列。</span></span><br><span class="line">        Mono.never().subscribe(System.out::println);</span><br><span class="line">        <span class="comment">// 延迟生成0</span></span><br><span class="line">        Mono.delay(Duration.ofMillis(<span class="number">2</span>)).map(String::valueOf).subscribe(log::info);</span><br><span class="line">        <span class="comment">// 通过fromRunnable创建，并实现异常处理</span></span><br><span class="line">        Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread run&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;thread run error&quot;</span>);</span><br><span class="line">        &#125;).subscribe(System.out::println, System.err::println);</span><br><span class="line">        <span class="comment">// 通过Callable</span></span><br><span class="line">        Mono.fromCallable(() -&gt; <span class="string">&quot;callback function&quot;</span>).subscribe(log::info);</span><br><span class="line">        <span class="comment">// future</span></span><br><span class="line">        Mono.fromFuture(CompletableFuture.completedFuture(<span class="string">&quot;from future&quot;</span>)).subscribe(log::info);</span><br><span class="line">        <span class="comment">// 通过runnable</span></span><br><span class="line">        Mono&lt;Void&gt; runnableMono = Mono.fromRunnable(() -&gt; log.warn(Thread.currentThread().getName()));</span><br><span class="line">        runnableMono.subscribe();</span><br><span class="line">        <span class="comment">// 通过使用 Supplier</span></span><br><span class="line">        Mono.fromSupplier(() -&gt; <span class="keyword">new</span> <span class="title class_">Date</span>().toString()).subscribe(log::info);</span><br><span class="line">        <span class="comment">// flux中</span></span><br><span class="line">        Mono.from(Flux.just(<span class="string">&quot;from&quot;</span>, <span class="string">&quot;flux&quot;</span>)).subscribe(log::info);  <span class="comment">// 只返回flux第一个</span></span><br><span class="line">        <span class="comment">//通过 create()方法来使用 MonoSink 来创建 Mono。</span></span><br><span class="line">        Mono.create(sink -&gt; sink.success(<span class="string">&quot;测试create&quot;</span>)).subscribe(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/02/25/spring-reactive-webflux/monotest.jpg"></p><h3 id="5-Flux-API"><a href="#5-Flux-API" class="headerlink" title="5. Flux API"></a>5. Flux API</h3><p><code>Mono</code>和<code>Flux</code>都是实现<code>org.reactivestreams.Publisher</code>接口的抽象类。</p><p><code>Flux</code>表示连续序列，和<code>Mono</code>的创建方法有些不同，<code>Mono</code>是<code>Flux</code>的简化版，<code>Flux</code>可以用来表示流。</p><ul><li><code>Flux API</code>：<ul><li>**just()**：可以指定序列中包含的全部元素。</li><li>**range()**：可以用来创建连续数值。</li><li>**empty()**：创建一个不包含任何元素。</li><li>**error(Throwable error)**：创建一个只包含错误消息的序列。</li><li>**fromIterable()**：通过迭代器创建如list，set</li><li>**fromStream()**：通过流创建</li><li>**fromArray(T[])**：通过列表创建 如 String[], Integer[]</li><li>**merge()**：通过将两个flux合并得到新的flux</li><li>**interval()**：每隔一段时间生成一个数字，从1开始递增</li></ul></li><li><code>API</code>使用案例如下所示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FluxTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flux</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 通过just赋值</span></span><br><span class="line">        Flux&lt;Integer&gt; intFlux = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 以6开始，取4个值：6,7,8,9</span></span><br><span class="line">        Flux&lt;Integer&gt; rangeFlux = Flux.range(<span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 通过merge合并</span></span><br><span class="line">        Flux&lt;Integer&gt; intMerge = Flux.merge(intFlux, rangeFlux);</span><br><span class="line">        intMerge.subscribe(System.out::print);</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 通过fromArray构建</span></span><br><span class="line">        Flux.fromArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;).subscribe(System.out::print);</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 通过流和迭代器创建</span></span><br><span class="line">        Flux&lt;String&gt; strFluxFromStream = Flux.fromStream(Stream.of(<span class="string">&quot; just&quot;</span>, <span class="string">&quot; test&quot;</span>, <span class="string">&quot; reactor&quot;</span>, <span class="string">&quot; Flux&quot;</span>, <span class="string">&quot; and&quot;</span>, <span class="string">&quot; Mono&quot;</span>));</span><br><span class="line">        Flux&lt;String&gt; strFluxFromList = Flux.fromIterable(Arrays.asList(<span class="string">&quot; just&quot;</span>, <span class="string">&quot; test&quot;</span>, <span class="string">&quot; reactor&quot;</span>, <span class="string">&quot; Flux&quot;</span>, <span class="string">&quot; and&quot;</span>, <span class="string">&quot; Mono&quot;</span>));</span><br><span class="line">        <span class="comment">// 通过merge合并</span></span><br><span class="line">        Flux&lt;String&gt; strMerge = Flux.merge(strFluxFromStream, strFluxFromList);</span><br><span class="line">        strMerge.subscribe(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 通过interval创建流数据</span></span><br><span class="line">        Flux.interval(Duration.ofMillis(<span class="number">100</span>)).map(String::valueOf)</span><br><span class="line">            .subscribe(System.out::print);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123456789</span><br><span class="line">13579</span><br><span class="line"> just <span class="built_in">test</span> reactor Flux and Mono just <span class="built_in">test</span> reactor Flux and Mono</span><br><span class="line">012345678910111213141516171819</span><br></pre></td></tr></table></figure><h3 id="6-subscribe方法"><a href="#6-subscribe方法" class="headerlink" title="6. subscribe方法"></a>6. subscribe方法</h3><p>subscribe()方法表示对数据流的订阅动作，subscribe()方法有多个重载的方法，最多可以传入四个参数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">subscribe</span> <span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 测试Mono</span></span><br><span class="line">    Mono.just(<span class="number">1</span>).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 测试Flux</span></span><br><span class="line">    Flux.just(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>).subscribe(System.out::println);</span><br><span class="line">    <span class="comment">// 测试2个参数的subscribe方法</span></span><br><span class="line">    Flux.just(<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>).map(chr -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;j&#x27;</span>== chr) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;test 2 parameters&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> String.valueOf(chr);</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(System.out::println,    <span class="comment">// 参数1,接受内容</span></span><br><span class="line">                   err -&gt; log.error(err.getMessage())); <span class="comment">// 参数2,对err处理的lambda函数</span></span><br><span class="line">    <span class="comment">// 测试3个参数的subscribe方法</span></span><br><span class="line">    Flux.just(<span class="string">&quot;你&quot;</span>, <span class="string">&quot;我&quot;</span>, <span class="string">&quot;他&quot;</span>, <span class="string">&quot;它&quot;</span>, <span class="string">&quot;ta&quot;</span>)</span><br><span class="line">        .subscribe(System.out::print,   <span class="comment">// 参数1,接受内容</span></span><br><span class="line">                   System.err::println, <span class="comment">// 参数2,对err处理的lambda函数</span></span><br><span class="line">                   () -&gt; System.out.println(<span class="string">&quot;complete for 3&quot;</span>));<span class="comment">// 参数3,完成subscribe之后执行的lambda函数</span></span><br><span class="line">    <span class="comment">// 测试4个参数的subscribe方法</span></span><br><span class="line">    Flux.interval(Duration.ofMillis(<span class="number">100</span>))</span><br><span class="line">        .map(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;fake a mistake&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> String.valueOf(i);</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(info -&gt; log.info(<span class="string">&quot;info: &#123;&#125;&quot;</span>, info), <span class="comment">// 参数1,接受内容</span></span><br><span class="line">                   err -&gt; log.error(<span class="string">&quot;error: &#123;&#125;&quot;</span>, err.getMessage()),<span class="comment">// 参数2,对err处理的lambda函数</span></span><br><span class="line">                   () -&gt; log.info(<span class="string">&quot;Done&quot;</span>),     <span class="comment">// 参数3,完成subscribe之后执行的lambda函数</span></span><br><span class="line">                   sub -&gt; sub.request(<span class="number">10</span>));  <span class="comment">// 参数4,Subscription操作,设定从源头获取元素的个数</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/02/25/spring-reactive-webflux/fluxtest.jpg"></p><h3 id="7-使用StepVerifier测试响应式异步代码"><a href="#7-使用StepVerifier测试响应式异步代码" class="headerlink" title="7. 使用StepVerifier测试响应式异步代码"></a>7. 使用StepVerifier测试响应式异步代码</h3><p>通过expectNext执行类似断言的功能，如果断言不符合实际情况，就会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StepVerifier</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用StepVerifier测试Flux，正常</span></span><br><span class="line">    <span class="type">Flux</span> <span class="variable">flux</span> <span class="operator">=</span> Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    StepVerifier.create(flux)</span><br><span class="line">                <span class="comment">// 测试下一个期望的数据元素</span></span><br><span class="line">                .expectNext(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">                <span class="comment">// 测试下一个元素是否为完成信号</span></span><br><span class="line">                .expectComplete()</span><br><span class="line">                .verify();</span><br><span class="line">    <span class="comment">// 使用StepVerifier测试Mono，报错</span></span><br><span class="line">    Mono&lt;String&gt; mono = Mono.just(<span class="string">&quot;charles&quot;</span>).log();</span><br><span class="line">    StepVerifier.create(mono)</span><br><span class="line">                .expectNext(<span class="string">&quot;char&quot;</span>)</span><br><span class="line">                .verifyComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.AssertionError: expectation <span class="string">&quot;expectNext(char)&quot;</span> failed (expected value: char; actual value: charles)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>参考连接：<code>https://mp.weixin.qq.com/s/O1VGS7d1TLQhgrCaQ-UQCw</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringReactive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringReactive </tag>
            
            <tag> WebFlux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口幂等性设计及实例</title>
      <link href="/2021/02/17/spring-boot-idempotent.html"/>
      <url>/2021/02/17/spring-boot-idempotent.html</url>
      
        <content type="html"><![CDATA[<p><strong>幂等性</strong>：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。<br><code>select</code>和<code>delete</code>操作具有天然幂等性：<code>select</code>多次结果总是一致，<code>delete</code>第一次执行后继续再执行也不会对数据有影响；<br>一般没有幂等性而出现异常的操作：<code>insert</code>操作，<code>update</code>操作，混合类型操作(同时包含增删改等)。<span id="more"></span></p><h3 id="1-使用幂等的场景"><a href="#1-使用幂等的场景" class="headerlink" title="1. 使用幂等的场景"></a>1. 使用幂等的场景</h3><ol><li>前端重复提交：前端瞬时点击多次造成表单重复提交；</li><li>接口超时重试：接口可能会因为某些原因而调用失败，出于容错性考虑会加上失败重试的机制。如果接口调用一半，再次调用就会因为脏数据的存在而出现异常。</li><li>消息重复消费：在使用消息中间件来处理消息队列，且手动<code>ack</code>确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。被其他消费者重新消费时就会导致结果异常，如数据库重复数据，数据库数据冲突，资源重复等。</li><li>请求重发：网络抖动引发的<code>nginx</code>重发请求，造成重复调用；</li></ol><h3 id="2-幂等性设计"><a href="#2-幂等性设计" class="headerlink" title="2. 幂等性设计"></a>2. 幂等性设计</h3><ol><li><code>update</code>操作<ul><li>根据唯一业务<code>id</code>去更新数据。</li><li>使用乐观锁(增加版本号或修改时间字段)。</li></ul></li><li><code>insert</code>操作<ul><li>若该操作具有唯一业务号，则可通过数据库层面的唯一&#x2F;联合唯一索引来限制重复数据；或通过分布式锁来保证接口幂等性。</li><li>若该操作没有唯一业务号，可以使用<code>Token</code>机制，保证幂等性。</li></ul></li><li>混合操作（一个接口包含多种操作）<ul><li>使用<code>Token</code>机制，或使用<code>Token</code> + 分布式锁的方案来解决幂等性问题。</li></ul></li></ol><h3 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h3><h4 id="3-1-Token机制实现"><a href="#3-1-Token机制实现" class="headerlink" title="3.1 Token机制实现"></a>3.1 Token机制实现</h4><p>通过<code>Token</code> 机制实现接口的幂等性，这是一种比较通用性的实现方法。</p><p>具体流程步骤：</p><ol><li>客户端会先发送一个请求去获取<code>Token</code>，服务端会生成一个全局唯一的<code>ID</code>作为<code>Token</code>保存在<code>Redis</code>中，同时把这个<code>ID</code>返回给客户端；</li><li>客户端第二次调用业务请求的时候必须携带这个<code>Token</code>；</li><li>服务端会校验这个 <code>Token</code>，如果校验成功，则执行业务，并删除<code>Redis</code>中的 <code>Token</code>；</li><li>如果校验失败，说明<code>Redis</code>中已经没有对应的 <code>Token</code>，则表示重复操作，直接返回指定的结果给客户端。</li></ol><h4 id="3-2-基于MySQL实现"><a href="#3-2-基于MySQL实现" class="headerlink" title="3.2 基于MySQL实现"></a>3.2 基于MySQL实现</h4><p>通过<code>MySQL</code>唯一索引的特性实现接口的幂等性。</p><p>具体流程步骤：</p><ol><li>建立一张去重表，其中某个字段需要建立唯一索引；</li><li>客户端去请求服务端，服务端会将这次请求的一些信息插入这张去重表中；</li><li>因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑；</li><li>如果插入失败，则代表已经执行过当前请求，直接返回。</li></ol><h4 id="3-3-基于Redis实现"><a href="#3-3-基于Redis实现" class="headerlink" title="3.3 基于Redis实现"></a>3.3 基于Redis实现</h4><p>通过<code>Redis</code>的<code>SETNX</code>命令实现接口的幂等性。</p><blockquote><p><code>SETNX key value</code>：当且仅当<code>key</code>不存在时将<code>key</code>的值设为<code>value</code>；若给定的<code>key</code>已经存在，则<code>SETNX</code>不做任何动作。设置成功时返回<code>1</code>，否则返回<code>0</code>。</p></blockquote><p>具体流程步骤：</p><ol><li>客户端先请求服务端，会拿到一个能代表这次请求业务的唯一字段；</li><li>将该字段以<code>SETNX</code>的方式存入<code>Redis</code>中，并根据业务设置相应的超时时间；</li><li>如果设置成功，证明这是第一次请求，则执行后续的业务逻辑；</li><li>如果设置失败，则代表已经执行过当前请求，直接返回。</li></ol><h3 id="4-实例：自定义注解实现API幂等处理（基于Redis实现）"><a href="#4-实例：自定义注解实现API幂等处理（基于Redis实现）" class="headerlink" title="4. 实例：自定义注解实现API幂等处理（基于Redis实现）"></a>4. 实例：自定义注解实现API幂等处理（基于Redis实现）</h3><h4 id="4-1-引入redis支持"><a href="#4-1-引入redis支持" class="headerlink" title="4.1 引入redis支持"></a>4.1 引入redis支持</h4><ol><li><p><code>pom.xml</code>引入<code>Redis</code>的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 排除lettuce包，使用jedis代替--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aop切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件<code>application.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line">    port: 6379</span><br><span class="line">    password: 123456</span><br><span class="line">    #Redis数据库索引（默认为0）</span><br><span class="line">    database: 0</span><br><span class="line">    #连接池最大连接数（使用负值表示没有限制）</span><br><span class="line">    jedis:</span><br><span class="line">      pool:</span><br><span class="line">        max-active: 50</span><br><span class="line">        #连接池最大阻塞等待时间（使用负值表示没有限制）</span><br><span class="line">        max-wait: -1</span><br><span class="line">        #连接池中的最大空闲连接</span><br><span class="line">        max-idle: 20</span><br><span class="line">        #连接池中的最小空闲连接</span><br><span class="line">        min-idle: 2</span><br><span class="line">    #连接超时时间（毫秒）</span><br><span class="line">    timeout: 5000</span><br></pre></td></tr></table></figure></li><li><p>测试<code>Redis</code>连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String &gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">simpleTest</span><span class="params">()</span> &#123;</span><br><span class="line">        ValueOperations&lt;String,String&gt; valueOperations = redisTemplate.opsForValue();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;RedisTemplateTest-simpleTest-001&quot;</span>;</span><br><span class="line">        valueOperations.set(key,key+key);</span><br><span class="line">        System.out.println(valueOperations.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-2-编码实现"><a href="#4-2-编码实现" class="headerlink" title="4.2 编码实现"></a>4.2 编码实现</h4><ol><li>添加幂等异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理幂等相关异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : Charles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2021/3/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotentException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">IdempotentException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义幂等注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义幂等注解</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : Charles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2021/3/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Idempotent &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀属性，作为redis缓存Key的一部分。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">prefix</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;idempotent_&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要的参数名数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] keys();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 幂等过期时间（秒），即：在此时间段内，对API进行幂等处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">expire</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提示错误码，也可自定义为字符串直接提醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">errorCode</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">1001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>幂等切面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.LocalVariableTableParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisCallback;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.commands.JedisCommands;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.params.SetParams;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 幂等切面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : Charles</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2021/3/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisTemplate.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdempotentAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SUCCESS</span> <span class="operator">=</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String,String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切入点,根据自定义Idempotent实际路径进行调整</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.example.demo.Idempotent)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeIdempotent</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;executeIdempotent()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 获取参数对象列表</span></span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">      <span class="comment">//获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line">        <span class="comment">// 得到方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        <span class="comment">// 获取参数数组</span></span><br><span class="line">        String[] parameters = <span class="keyword">new</span> <span class="title class_">LocalVariableTableParameterNameDiscoverer</span>().getParameterNames(method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取幂等注解</span></span><br><span class="line">        <span class="type">Idempotent</span> <span class="variable">idempotent</span> <span class="operator">=</span> method.getAnnotation(Idempotent.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化springEL表达式解析器实例</span></span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        <span class="comment">// 初始化解析内容上下文</span></span><br><span class="line">        <span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line">        <span class="comment">// 把参数名和参数值放入解析内容上下文里</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加解析对象目标</span></span><br><span class="line">                context.setVariable(parameters[i], args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析定义key对应的值，拼接成key</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">idempotentKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(idempotent.prefix() + <span class="string">&quot;:&quot;</span> + methodName);</span><br><span class="line">        <span class="keyword">for</span> (String s : idempotent.keys()) &#123;</span><br><span class="line">            <span class="comment">// 解析对象</span></span><br><span class="line">            <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(s);</span><br><span class="line">            idempotentKey.append(<span class="string">&quot;:&quot;</span>).append(expression.getValue(context));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 setnx 确保只有一个接口能够正常访问</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(</span><br><span class="line">            (RedisCallback&lt;String&gt;) connection -&gt; (</span><br><span class="line">                (JedisCommands) connection.getNativeConnection()</span><br><span class="line">            ).set(</span><br><span class="line">                idempotentKey.toString(),</span><br><span class="line">                idempotentKey.toString(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">SetParams</span>().nx().ex(idempotent.expire())</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;API幂等处理, key=&quot;</span> + idempotentKey);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IdempotentException</span>(<span class="string">&quot;API幂等处理, key=&quot;</span> + idempotentKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-幂等注解的使用"><a href="#4-3-幂等注解的使用" class="headerlink" title="4.3 幂等注解的使用"></a>4.3 幂等注解的使用</h4><ol><li><p>接口添加<code>@Idempotent</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Idempotent(prefix=&quot;idempotent&quot;, keys=&#123;&quot;#id&quot;, &quot;#str&quot;&#125;, expire=5)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApi</span><span class="params">(Integer id, String str)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;测试幂等API:&quot;</span> + id + str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>连续调用API测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:8080/test?id=1002&amp;str=TestIdempotentParameterString&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>测试结果</p></li></ol><p>第一次调用<code>/test</code>，会正常返回<code>测试幂等API:1002TestIdempotentParameterString</code>；<br>并且在<code>5</code>秒内，<code>Redis</code>会存在<code>key</code>为<code>idempotent:testApi:1002:TestIdempotentParameterString</code>的唯一值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys &quot;idempotent:testApi:1002:TestIdempotentParameterString&quot;</span><br><span class="line">1) &quot;idempotent:testApi:1002:TestIdempotentParameterString&quot;</span><br></pre></td></tr></table></figure><p>再次调用<code>/test</code>，会返回异常。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-03-01T06:42:14.282+00:00&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/test&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;API幂等处理, key=idempotent:testApi:1002:TestIdempotentParameterString&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;requestId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b42b9639-8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;trace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;com.example.demo.IdempotentException: API幂等处理, key=idempotent:testApi:1002:TestIdempotentParameterString\r\n\tat com.example.demo.IdempotentAspect.around ... 中间省略 ... (FastThreadLocalRunnable.java:30)\r\n\t\tat java.lang.Thread.run(Thread.java:748)\r\n&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 幂等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Nginx常用配置详解</title>
      <link href="/2020/12/29/env-nginx.html"/>
      <url>/2020/12/29/env-nginx.html</url>
      
        <content type="html"><![CDATA[<p>Nginx 的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于Nginx安装目录下的<code>conf</code>目录下。</p><p>Nginx配置文件中每个指令必须有<code>;</code>结束。以<code>#</code>开头的行会被当做注释。</p><p>配置文件通常命名为<code>nginx.conf</code>并且默认放置在<code>/usr/local/nginx/conf</code>，<code>/etc/nginx</code>，或<code>/usr/local/etc/nginx</code>。</p><span id="more"></span><h3 id="1-Nginx配置文件结构"><a href="#1-Nginx配置文件结构" class="headerlink" title="1. Nginx配置文件结构"></a>1. Nginx配置文件结构</h3><ul><li>Nginx配置文件常用到的几个部分：main（全局设置），server（主机设置），upstream（上游服务器设置，主要为反向代理、负载均衡相关配置），location（URL匹配特定位置后的设置）</li><li>每部分包含若干个指令。<ul><li>main模块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>events模块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>http模块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>upstream模块：使nginx跨越单机的限制，完成网络数据的接收、处理和转发，该指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；</li><li>server模块：主要用于指定虚拟主机域名、IP和端口；</li><li>location模块：配置请求的路由，以及各种页面的处理情况（比如，根目录“&#x2F;”,“&#x2F;images”,等等）。</li></ul></li><li>他们之间的关系式：<ul><li>server继承main，location继承server；</li><li>upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...                           # main(全局)模块</span><br><span class="line"></span><br><span class="line">events &#123;                      # events模块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">http &#123;                        # http模块</span><br><span class="line">    ...</span><br><span class="line">    upstream &#123;                # upstream模块</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;                  # server模块</span><br><span class="line">        ...</span><br><span class="line">        location [PATTERN] &#123;  # location模块</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Nginx配置文件详解"><a href="#2-Nginx配置文件详解" class="headerlink" title="2. Nginx配置文件详解"></a>2. Nginx配置文件详解</h3><h4 id="2-1-全局模块"><a href="#2-1-全局模块" class="headerlink" title="2.1 全局模块"></a>2.1 全局模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># ------------------------------ 全局模块 start ------------------------------</span><br><span class="line"># user             www www;               # 配置用户或者组，默认为nobody nobody。</span><br><span class="line"></span><br><span class="line"># worker_processes 1;                     # 允许生成的进程数，默认为1，建议设置为等于CPU总核心数。</span><br><span class="line"></span><br><span class="line"># pid              /nginx/pid/nginx.pid;  # 指定nginx进程pid文件存放地址。</span><br><span class="line"></span><br><span class="line">error_log          /usr/local/nginx/logs/error.log info; # 全局错误日志路径，级别，[ debug|info|notice|warn|error|crit|alert|emerg ]。</span><br><span class="line">                                                         # 这个设置可以放入全局块，http块，server块</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 65535;   # 指定进程可以打开的最大描述符。</span><br><span class="line">                              # 工作模式与连接数上限：这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="line">                              # 现在在linux 2.6内核下开启文件打开数为65535。因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="line"># ------------------------------ 全局模块 end ------------------------------</span><br><span class="line">events &#123; ... &#125; # events块</span><br><span class="line">http &#123; ... &#125;   # http块</span><br></pre></td></tr></table></figure><h4 id="2-2-events模块"><a href="#2-2-events模块" class="headerlink" title="2.2 events模块"></a>2.2 events模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># ------------------------------ events模块 start ------------------------------</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;  # 参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; </span><br><span class="line">                # epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br><span class="line">                # nginx针对不同的操作系统，有不同的事件模型：</span><br><span class="line">                #    1.标准事件模型：Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br><span class="line">                #    2.高效事件模型：Kqueue，Epoll，/dev/poll，Eventport</span><br><span class="line">                #        Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br><span class="line">                #        Epoll：使用于Linux内核2.6版本及以后的系统。</span><br><span class="line">                #        /dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br><span class="line">                #        Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br><span class="line">    </span><br><span class="line">    worker_connections 65535;   # 单个进程最大连接数（最大连接数=连接数*进程数）。</span><br><span class="line">                                # 根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br><span class="line"></span><br><span class="line">    accept_mutex on;            # 网路连接序列化，防止惊群现象发生，默认:on</span><br><span class="line">    multi_accept on;            # 一个进程是否同时接受多个网络连接，默认:off</span><br><span class="line">    keepalive_timeout 60;       # keepalive超时时间。</span><br><span class="line"></span><br><span class="line">    client_header_buffer_size 4k;   # 客户端请求头部的缓冲区大小。</span><br><span class="line">                                    # 分页大小可以用shell命令getconf PAGESIZE取得，如：[root@centos ~]# getconf PAGESIZE # 返回4096。</span><br><span class="line">                                    # 但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br><span class="line"></span><br><span class="line">    open_file_cache max=65535 inactive=60s;   # 为打开文件指定缓存，默认是关闭的。max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line"></span><br><span class="line">    open_file_cache_valid 80s;      # 检查open_file_cache中缓存项目的有效信息的时间间隔。</span><br><span class="line">                                    # 默认值:60；使用字段:http, server, location</span><br><span class="line"></span><br><span class="line">    open_file_cache_min_uses 1;     # 指定在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态。</span><br><span class="line">                                    # 如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br><span class="line">                                    # 默认值:1；使用字段:http, server, location</span><br><span class="line"></span><br><span class="line">    open_file_cache_errors on;      #　指定是否在搜索一个文件时记录cache错误[ on | off ]，默认值:off</span><br><span class="line">&#125;</span><br><span class="line"># ------------------------------ events模块 end ------------------------------</span><br><span class="line"></span><br><span class="line">http &#123; ... &#125;   # http块</span><br></pre></td></tr></table></figure><h4 id="2-2-http模块"><a href="#2-2-http模块" class="headerlink" title="2.2 http模块"></a>2.2 http模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">... # 全局块</span><br><span class="line">events &#123; ... &#125; # events块</span><br><span class="line"># ------------------------------ http模块 start ------------------------------</span><br><span class="line">http &#123;      </span><br><span class="line">    # 设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line"></span><br><span class="line">    include       mime.types;                # 文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application/octet-stream;  # 默认文件类型，默认为text/plain</span><br><span class="line">    #charset      utf-8;                     # 默认编码</span><br><span class="line"></span><br><span class="line">    server_names_hash_bucket_size 128;  # 服务器名字的hash表大小</span><br><span class="line">                                        # 保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br><span class="line"></span><br><span class="line">    client_header_buffer_size 32k;  # 客户端请求头部的缓冲区大小。   </span><br><span class="line">                                    # 这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line"></span><br><span class="line">    large_client_header_buffers 4 64k;  # 客户请求头缓冲大小。</span><br><span class="line">                                        # nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br><span class="line"></span><br><span class="line">    client_max_body_size 8m;  # 设定通过nginx上传文件的大小</span><br><span class="line"></span><br><span class="line">    sendfile on;    # 允许sendfile方式（高效文件传输模式）传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">                    # 指定nginx是否调用sendfile函数（zero copy方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br><span class="line"></span><br><span class="line">    autoindex on;   # 开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line"></span><br><span class="line">    tcp_nopush on;  # 此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br><span class="line"></span><br><span class="line">    tcp_nodelay on; # 该参数最核心的功能，就是把小包组成成大包，提高带宽利用率也就是著名的nagle算法</span><br><span class="line"></span><br><span class="line">    keepalive_timeout 120;   # 长连接超时时间，单位是秒</span><br><span class="line"></span><br><span class="line">    # FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    # gzip模块设置</span><br><span class="line">    gzip on;                # 开启gzip压缩输出</span><br><span class="line">    gzip_min_length 1k;     # 最小压缩文件大小</span><br><span class="line">    gzip_buffers 4 16k;     # 压缩缓冲区</span><br><span class="line">    gzip_http_version 1.0;  # 压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_comp_level 2;      # 压缩等级</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml; # 压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    # limit_zone crawler $binary_remote_addr 10m; # 开启限制IP连接数的时候需要使用</span><br><span class="line">    </span><br><span class="line">    upstream &#123; ... &#125; # upstream模块</span><br><span class="line">    server &#123; ... &#125;   # server模块</span><br><span class="line">&#125;</span><br><span class="line"># ------------------------------ http模块 end ------------------------------</span><br></pre></td></tr></table></figure><h4 id="2-3-upstream模块"><a href="#2-3-upstream模块" class="headerlink" title="2.3 upstream模块"></a>2.3 upstream模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">... # 全局块</span><br><span class="line">events &#123; ... &#125; # events块</span><br><span class="line">http &#123;</span><br><span class="line">    ...        # http块</span><br><span class="line"># ------------------------------ upstream模块 start ------------------------------</span><br><span class="line">    upstream www.test.com &#123;    # upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br><span class="line">        server 192.168.80.121:80 weight=3;</span><br><span class="line">        server 192.168.80.122:80 weight=2;</span><br><span class="line">        server 192.168.80.123:80 weight=3;</span><br><span class="line">    &#125;</span><br><span class="line">    # nginx的upstream目前支持4种方式的分配: ①轮询（默认），②weight，③ip_hash，④第三方</span><br><span class="line">        # 轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br><span class="line">        # weight：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br><span class="line">            # 例如： upstream bakend &#123;</span><br><span class="line">            #           server 192.168.0.14 weight=10;</span><br><span class="line">            #           server 192.168.0.15 weight=10;</span><br><span class="line">            #       &#125;</span><br><span class="line">        # ip_hash：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br><span class="line">            # 例如： upstream bakend &#123;</span><br><span class="line">            #           ip_hash;</span><br><span class="line">            #           server 192.168.0.14:88;</span><br><span class="line">            #           server 192.168.0.15:80;</span><br><span class="line">            #        &#125;</span><br><span class="line">        # fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br><span class="line">            # 例如： upstream backend &#123;</span><br><span class="line">            #           server server1;</span><br><span class="line">            #           server server2;</span><br><span class="line">            #           fair;</span><br><span class="line">            #        &#125;</span><br><span class="line">        # url_hash（第三方）：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br><span class="line">            # 例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br><span class="line">            # upstream backend &#123;</span><br><span class="line">            #     server squid1:3128;</span><br><span class="line">            #     server squid2:3128;</span><br><span class="line">            #     hash $request_uri;</span><br><span class="line">            #     hash_method crc32;</span><br><span class="line">            # &#125;</span><br><span class="line">    # tips:</span><br><span class="line">    # upstream bakend&#123;  # 定义负载均衡设备的Ip及设备状态</span><br><span class="line">    #    ip_hash;</span><br><span class="line">    #    server 127.0.0.1:9090 down;</span><br><span class="line">    #    server 127.0.0.1:8080 weight=2;</span><br><span class="line">    #    server 127.0.0.1:6060 max_fails=10 fail_timeout=60s;</span><br><span class="line">    #    server 127.0.0.1:7070 backup;</span><br><span class="line">    # &#125;</span><br><span class="line">    # 在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><span class="line"></span><br><span class="line">    # 每个设备的状态设置为:</span><br><span class="line">    #     1.down表示单前的server暂时不参与负载</span><br><span class="line">    #     2.weight为weight越大，负载的权重就越大。</span><br><span class="line">    #     3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br><span class="line">    #                  fail_timeout:max_fails次失败后，暂停的时间。</span><br><span class="line">    #     4.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><span class="line"></span><br><span class="line">    # nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br><span class="line">    # client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br><span class="line">    # client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br><span class="line">    # location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br><span class="line"></span><br><span class="line">    server &#123; ... &#125;   # server模块</span><br><span class="line">&#125;</span><br><span class="line"># ------------------------------ upstream模块 end ------------------------------</span><br></pre></td></tr></table></figure><h4 id="2-3-server模块"><a href="#2-3-server模块" class="headerlink" title="2.3 server模块"></a>2.3 server模块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">... # 全局块</span><br><span class="line">events &#123; ... &#125; # events块</span><br><span class="line">http &#123;</span><br><span class="line">    ...              # http块</span><br><span class="line">    upstream &#123; ... &#125; # upstream模块</span><br><span class="line"></span><br><span class="line">    # ------------------------------ server模块 start ------------------------------</span><br><span class="line"></span><br><span class="line">    server &#123;    # 虚拟主机的配置</span><br><span class="line">        listen 80;      # 监听端口</span><br><span class="line">        server_name www.test.com test.com;  # 监听地址，域名可以有多个，用空格隔开</span><br><span class="line">        index index.html index.htm;       # 指定网站初始页</span><br><span class="line">        root /data/www/test;                   # 指定网站根目录</span><br><span class="line">        charset utf-8;</span><br><span class="line">        rewrite ^(.*)$ https://www.test.com$1 permanent;  # URL重写</span><br><span class="line"></span><br><span class="line">        access_log  /usr/local/nginx/logs/host.access.log; # 定义本虚拟主机的访问日志</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        location ...&#123; ... &#125;  # location模块</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # ------------------------------ server模块 end ------------------------------</span><br><span class="line"></span><br><span class="line">    # include /etc/nginx/conf.d/*.conf;  # 导入其他server配置</span><br></pre></td></tr></table></figure><ul><li>URL重写（rewrite）配置及信息详解：<ul><li>语法：<code>rewrite &lt;regex&gt; &lt;replacement&gt; [flag];</code></li><li><code>regex</code>：perl兼容正则表达式语句进行规则匹配</li><li><code>replacement</code>：将正则匹配的内容替换成replacement</li><li><code>flag</code> rewrite支持的flag标记<ul><li><code>last</code>:本条规则匹配完成后，继续向下匹配新的location URI规则</li><li><code>break</code>:本条规则匹配完成即终止，不再匹配后面的任何规则</li><li><code>redirect</code>:返回302临时重定向，浏览器地址会显示跳转后的URL地址</li><li><code>permanent</code>:返回301永久重定向，浏览器地址栏会显示跳转后的URL地址</li></ul></li><li>使用位置：server, location, if</li></ul></li></ul><h4 id="2-4-location模块"><a href="#2-4-location模块" class="headerlink" title="2.4 location模块"></a>2.4 location模块</h4><p>语法：<code>location  [ = | ~ | ~* | ^~ | @]  /uri/  &#123; configuration &#125;</code>。<br>匹配模式分为两种：普通字符串（literal string）和正则表达式（regular expression），其中 ~ 和 ~* 用于正则表达式， 其他前缀和无任何前缀都用于普通字符串。</p><ul><li>前缀含义：<ul><li><code>=</code>：&#x3D;开头表示精确前缀匹配，只有完全匹配才能生效。</li><li><code>~</code>：~开头表示区分大小写的正则匹配。</li><li><code>~*</code>：~*开头表示不区分大小写的正则匹配。</li><li><code>^~</code>：^~开头表示普通字符串匹配上以后不再进行正则匹配。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">... # 全局块</span><br><span class="line">events &#123; ... &#125; # events块</span><br><span class="line">http &#123;</span><br><span class="line">    ...              # http块</span><br><span class="line">    upstream &#123; ... &#125; # upstream模块</span><br><span class="line">    server &#123;    # 虚拟主机的配置</span><br><span class="line">        listen 80;      # 监听端口</span><br><span class="line">        server_name www.test.com test.com;  # 监听地址</span><br><span class="line"></span><br><span class="line">        # ------------------------------ location模块 start ------------------------------</span><br><span class="line">        ### alias: 别名配置</span><br><span class="line">        location /test/ &#123;</span><br><span class="line">            alias  /usr/local/;  # 在匹配到location配置的URL路径后，指向alias配置的路径</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* /img/(.+\.(gif|jpg|jpeg|png|bmp|swf)) &#123;</span><br><span class="line">            alias  /usr/local/images/$1;    # 请求中只要能匹配到正则，比如/img/test.png或者/resource/img/test.png，都会转换为请求/usr/local/images/test.png。</span><br><span class="line">        &#125;</span><br><span class="line">        ### root: 根路径配置</span><br><span class="line">        location /test/ &#123;</span><br><span class="line">            root  /usr/local/;  # 用于访问文件系统，在匹配到location配置的URL路径后，指向root配置的路径，并把请求路径附加到其后</span><br><span class="line">        &#125;</span><br><span class="line">        ### proxy_pass: 反向代理配置</span><br><span class="line">        location /test/ &#123;</span><br><span class="line">            proxy_pass  http://127.0.0.1:8080/;  # 用于代理请求，适用于前后端负载分离或多台机器、服务器负载分离的场景</span><br><span class="line">        &#125;</span><br><span class="line">        ### JS和CSS缓存时间设置</span><br><span class="line">        location ~ .*.(js|css)?$ &#123;</span><br><span class="line">            expires 1h;  # JS和CSS缓存时间设置</span><br><span class="line">        &#125;</span><br><span class="line">        ### 反向代理的其他配置</span><br><span class="line">        location / &#123;             # 对 &quot;/&quot; 启用反向代理</span><br><span class="line">            proxy_pass http://127.0.0.1:88;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line"></span><br><span class="line">            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             </span><br><span class="line">            # 以下是一些反向代理的配置，可选。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            client_max_body_size 10m;     # 允许客户端请求的最大单文件字节数</span><br><span class="line">            client_body_buffer_size 128k; # 缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">            proxy_intercept_errors on;    # 表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br><span class="line">            proxy_connect_timeout 90;     # 后端服务器连接的超时时间_发起握手等候响应超时时间</span><br><span class="line">            proxy_send_timeout 90;        # 后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            proxy_read_timeout 90;        # 连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            proxy_buffer_size 4k;         # 设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">            proxy_buffers 4 32k;          # proxy_buffers缓冲区，网页平均在32k以下的设置，设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br><span class="line">            proxy_busy_buffers_size 64k;  # 高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">            proxy_temp_file_write_size 64k; # 设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br><span class="line">                                            # 设定缓存文件夹大小大于这个值将从upstream服务器传</span><br><span class="line">        &#125;</span><br><span class="line">        # ------------------------------ location模块 end ------------------------------</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Nginx日志配置"><a href="#3-Nginx日志配置" class="headerlink" title="3. Nginx日志配置"></a>3. Nginx日志配置</h3><p>Nginx日志主要分为两种：<code>access_log(访问日志)</code>和<code>error_log(错误日志)</code>。</p><ol><li><strong>访问日志</strong>可以记录用户的IP地址、浏览器的信息，请求的处理时间等信息。<ul><li><code>access_log指令</code>的作用域：http，server，location，limit_except。</li></ul></li><li><strong>错误日志</strong>记录了访问出错的信息，可以帮助我们定位错误的原因。<ul><li><code>error_log指令</code>的作用域：main， http, mail, stream, server, location</li></ul></li></ol><h4 id="3-1-Nginx访问日志access-log"><a href="#3-1-Nginx访问日志access-log" class="headerlink" title="3.1 Nginx访问日志access_log"></a>3.1 Nginx访问日志<code>access_log</code></h4><p>访问日志主要记录客户端的请求。客户端向Nginx服务器发起的每一次请求都记录在这里。<br>客户端IP，浏览器信息，referer，请求处理时间，请求URL等都可以在访问日志中得到。<br>可以通过log_format指令定义具体要记录哪些信息。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 关闭访问日志</span><br><span class="line">access_log off; </span><br><span class="line"># 设置访问日志</span><br><span class="line"># access_log  path  [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];</span><br></pre></td></tr></table></figure><ul><li><code>path</code>：指定日志的存放位置。</li><li><code>format</code>：指定日志的格式。默认使用预定义的combined。</li><li><code>buffer</code>：用来指定日志写入时的缓存大小。默认是64k。</li><li><code>gzip</code>：日志写入前先进行压缩。压缩率可以指定，从1到9数值越大压缩比越高，同时压缩的速度也越慢。默认是1。</li><li><code>flush</code>：设置缓存的有效时间。如果超过flush指定的时间，缓存中的内容将被清空。</li><li><code>if条件判断</code>：如果指定的条件计算为0或空字符串，那么该请求不会写入日志。</li></ul><h5 id="3-1-1-使用log-format自定义日志格式"><a href="#3-1-1-使用log-format自定义日志格式" class="headerlink" title="3.1.1 使用log_format自定义日志格式"></a>3.1.1 使用log_format自定义日志格式</h5><p>Nginx预定义了名为combined日志格式，如果没有明确指定日志格式默认使用该格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_format combined <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &#x27;</span><span class="string">&#x27;&quot;$request&quot; $status $body_bytes_sent &#x27;</span><span class="string">&#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果不想使用Nginx预定义的格式，可以通过log_format指令来自定义:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_format name [escape=default|json] string ...;</span><br></pre></td></tr></table></figure><ul><li>name 格式名称。在access_log指令中引用。</li><li>escape 设置变量中的字符编码方式是json还是default，默认是default。</li><li>string 要定义的日志格式内容。该参数可以有多个。参数中可以使用Nginx变量。</li></ul><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">access_log  /usr/local/nginx/logs/access.log  main;</span><br></pre></td></tr></table></figure><ul><li>日志格式设定常用Nginx变量：<ul><li><code>$remote_addr</code> &#x2F; <code>$http_x_forwarded_for</code>：用以记录客户端的ip地址；</li><li><code>$remote_user</code>：用来记录客户端用户名称；</li><li><code>$time_local</code>： 用来记录访问时间与时区；</li><li><code>$request</code>： 用来记录请求的url与http协议；</li><li><code>$status</code>： 用来记录请求状态；成功是200，</li><li><code>$body_bytes_sent</code>：记录发送给客户端文件主体内容大小；</li><li><code>$http_referer</code>：用来记录从那个页面链接访问过来的；</li><li><code>$http_user_agent</code>：记录客户浏览器的相关信息；</li></ul></li></ul><h4 id="3-2-Nginx错误日志error-log"><a href="#3-2-Nginx错误日志error-log" class="headerlink" title="3.2 Nginx错误日志error_log"></a>3.2 Nginx错误日志<code>error_log</code></h4><p>错误日志在Nginx中是通过error_log指令实现的。该指令记录服务器和请求处理过程中的错误信息。</p><p>语法：<code>error_log  file  [level];</code>，默认是：<code>error_log  logs/error.log  error;</code>；<br>级别有：<code>[ debug|info|notice|warn|error|crit|alert|emerg ]</code>。</p><p>基本用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log  /usr/local/nginx/logs/error.log  info;</span><br></pre></td></tr></table></figure><h4 id="3-3-通过open-log-file-cache指令来设置日志文件描述符缓存"><a href="#3-3-通过open-log-file-cache指令来设置日志文件描述符缓存" class="headerlink" title="3.3 通过open_log_file_cache指令来设置日志文件描述符缓存"></a>3.3 通过<code>open_log_file_cache</code>指令来设置日志文件描述符缓存</h4><p>Nginx中通过<code>access_log</code>和<code>error_log</code>指令配置访问日志和错误日志，通过<code>log_format</code>我们可以自定义日志格式。</p><p>如果日志文件路径中使用了变量，我们可以通过<code>open_log_file_cache</code>指令来设置缓存，提升性能。它可以配置在http、server、location作用域中。</p><ul><li>语法: <code>open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</code><ul><li><code>max</code> 设置缓存中最多容纳的文件描述符数量，如果被占满，采用LRU算法将描述符关闭。</li><li><code>inactive</code> 设置缓存存活时间，默认是10s。</li><li><code>min_uses</code> 在inactive时间段内，日志文件最少使用几次，该日志文件描述符记入缓存，默认是1次。</li><li><code>valid</code>：设置多久对日志文件名进行检查，看是否发生变化，默认是60s。</li><li><code>off</code>：不使用缓存。默认为off。</li></ul></li></ul><p>基本用法: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</span><br></pre></td></tr></table></figure><h3 id="4-Nginx配置文件实例："><a href="#4-Nginx配置文件实例：" class="headerlink" title="4. Nginx配置文件实例："></a>4. Nginx配置文件实例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">user  cmuser;</span><br><span class="line">worker_processes  2;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  8096;</span><br><span class="line">    multi_accept        on;</span><br><span class="line">    use                 epoll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">worker_rlimit_nofile 40000;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /data/runtime/nginx/logs/access.log  main;</span><br><span class="line">    error_log   /data/runtime/nginx/logs/error.log   error;</span><br><span class="line"></span><br><span class="line">    sendfile           on;</span><br><span class="line">    tcp_nopush         on;</span><br><span class="line">    tcp_nodelay        on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  15;</span><br><span class="line"></span><br><span class="line">    # ------------ www.test.com的访问配置 --------------------</span><br><span class="line">    upstream www.test.com &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server 10.104.60.165:8100;</span><br><span class="line">        server 10.104.60.166:8100;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen  80;</span><br><span class="line">        server_name  www.test.com;</span><br><span class="line">        charset utf-8;</span><br><span class="line">        rewrite ^(.*)$ https://www.test.com$1 permanent;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;                           # 配置SSL证书</span><br><span class="line">        listen 443;</span><br><span class="line">        server_name www.test.com;</span><br><span class="line">        ssl on;                            </span><br><span class="line">        ssl_certificate sslkey/_.test.com_bundle.crt;</span><br><span class="line">        ssl_certificate_key sslkey/_.test.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">        # 上传文件的路径配置</span><br><span class="line">        location /uploadFile/ &#123;</span><br><span class="line">            alias /mnt/newdatadrive/nfs_client/upload/;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://www.test.com;</span><br><span class="line">            proxy_redirect  off;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            client_max_body_size 10m;</span><br><span class="line">            client_body_buffer_size 256k;</span><br><span class="line">            proxy_connect_timeout 90;</span><br><span class="line">            proxy_send_timeout 90;</span><br><span class="line">            proxy_read_timeout 90;</span><br><span class="line">            proxy_buffer_size 8k;</span><br><span class="line">            proxy_buffers 4 64k;</span><br><span class="line">            proxy_busy_buffers_size 64k;</span><br><span class="line">            proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # ------------------ 静态文件夹 -----------------</span><br><span class="line">    server &#123;</span><br><span class="line">            listen  80;</span><br><span class="line">            server_name  static.test.com;</span><br><span class="line">            charset utf-8;</span><br><span class="line">            location / &#123;</span><br><span class="line">                root /mnt/newdatadrive/static_files;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">            listen 443;</span><br><span class="line">            server_name static.test.com;</span><br><span class="line">            ssl on;</span><br><span class="line">            ssl_certificate sslkey/_.test.com_bundle.crt;</span><br><span class="line">            ssl_certificate_key sslkey/_.test.com.key;</span><br><span class="line">            ssl_session_timeout 5m;</span><br><span class="line">            ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">            ssl_ciphers AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;</span><br><span class="line">            ssl_prefer_server_ciphers on;</span><br><span class="line">    </span><br><span class="line">            location / &#123;</span><br><span class="line">                root /mnt/newdatadrive/static_files;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # ------------------ 引入外部其他配置 -----------------</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附-Nginx启动命令"><a href="#附-Nginx启动命令" class="headerlink" title="附. Nginx启动命令"></a>附. Nginx启动命令</h3><p>运行可执行文件就可以启动<code>nginx</code>，可以使用<code>-c</code>参数指定配置文件，比如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>如果nginx已经启动，可以使用-s参数的可执行命令来控制：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nginx -s [reload | stop | quit | reopen]</span><br><span class="line"></span><br><span class="line"><span class="comment"># stop — 直接关闭 nginx</span></span><br><span class="line"><span class="comment"># quit — 会在处理完当前正在的请求后退出，也叫优雅关闭</span></span><br><span class="line"><span class="comment"># reload — 重新加载配置文件，相当于重启</span></span><br><span class="line"><span class="comment"># reopen — 重新打开日志文件</span></span><br></pre></td></tr></table></figure><p>比如，重载配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Centos 8 私人Git服务器搭建(Gogs)</title>
      <link href="/2020/11/25/env-centos8-git-gogs.html"/>
      <url>/2020/11/25/env-centos8-git-gogs.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建gogs用户"><a href="#1-创建gogs用户" class="headerlink" title="1. 创建gogs用户"></a>1. 创建gogs用户</h3><p>为Gogs创建一个MySQL用户<code>gogs</code> <span id="more"></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">先创建一个MySQL用户</span></span><br><span class="line">use mysql;</span><br><span class="line">create user &#x27;gogs&#x27;@&#x27;localhost&#x27; identified by &#x27;J5p&quot;;~OVazNl%y)?&#x27;;</span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="language-bash">再进行授权</span></span><br><span class="line">grant all privileges on *.* to &#x27;gogs&#x27;@&#x27;%&#x27;  IDENTIFIED BY &#x27;J5p&quot;;~OVazNl%y)?&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>为Gogs创建一个系统用户<code>git</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">创建一个用户</span></span><br><span class="line">[root@localhost ~]# useradd -mU git -s /bin/bash</span><br><span class="line">[root@localhost ~]# passwd git</span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换到git用户</span></span><br><span class="line">[root@localhost ~]# su git</span><br><span class="line">[git@localhost ~]$ cd /home/git</span><br></pre></td></tr></table></figure><h3 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2. 下载安装"></a>2. 下载安装</h3><p>下载Gogs二进制安装包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.gogs.io/0.12.3/gogs_0.12.3_linux_amd64.tar.gz</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压安装包</span></span><br><span class="line">tar -zxvf gogs_0.12.3_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>使用Gogs脚本创建gogs数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 切换目录到gogs脚本文件夹</span><br><span class="line">cd <span class="operator">/</span>home<span class="operator">/</span>git<span class="operator">/</span>gogs<span class="operator">/</span>scripts<span class="operator">/</span></span><br><span class="line"></span><br><span class="line"># 使用mysql.sql创建gogs数据库，这里会要求输入密码</span><br><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">&lt;</span> mysql.sql</span><br><span class="line"></span><br><span class="line"># 假如执行这条命令会报错【ERROR <span class="number">1115</span> (<span class="number">42000</span>) <span class="keyword">at</span> line <span class="number">2</span>: <span class="literal">Unknown</span> <span class="type">character</span> <span class="keyword">set</span>: <span class="string">&#x27;utf8mb4&#x27;</span>】的话继续执行下面这个可选操作,在重新执行上面的命令。</span><br><span class="line"># 修改mysql.sql</span><br><span class="line">vim mysql.sql</span><br><span class="line"><span class="comment">/*************** 原文 ***************/</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> gogs;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> gogs <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br><span class="line"><span class="comment">/*************** 修改为 *************/</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> gogs;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> gogs <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci;</span><br><span class="line"><span class="comment">/*************** 结束 ***************/</span></span><br></pre></td></tr></table></figure><p>开放端口：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3000/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>启动Gogs服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/git/gogs/gogs web</span><br></pre></td></tr></table></figure><p>访问Gogs网站 <code>http://你的服务器IP:3000</code></p><p><img src="/2020/11/25/env-centos8-git-gogs/up-84af5c842f2a6e3ec51ac831999ade1802c.webp"></p><p>填写正确的配置信息，点击 “<code>立即安装</code>”</p><h3 id="3-配置开机自启动"><a href="#3-配置开机自启动" class="headerlink" title="3. 配置开机自启动"></a>3. 配置开机自启动</h3><p>配置Gogs服务自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">关闭gogs服务</span></span><br><span class="line">ctrl + c </span><br><span class="line"><span class="meta"># </span><span class="language-bash">切换到root用户</span></span><br><span class="line">su root</span><br><span class="line">cp /home/git/gogs/scripts/systemd/gogs.service /usr/lib/systemd/system/</span><br><span class="line">systemctl enable gogs.service</span><br><span class="line">systemctl start gogs.service</span><br></pre></td></tr></table></figure><p>若CentOS 8开机启动gogs失败，先禁用SELinux:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将SELinux属性设置为Disabled，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">This file controls the state of SELinux on the system.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">SELINUX= can take one of these three values:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">   enforcing - SELinux security policy is enforced.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">   permissive - SELinux prints warnings instead of enforcing.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">   disabled - No SELinux policy is loaded.</span></span><br><span class="line">SELINUX=disabled</span><br><span class="line"><span class="meta"># </span><span class="language-bash">SELINUXTYPE= can take one of these three values:</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">   targeted - Targeted processes are protected,</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">   minimum - Modification of targeted policy. Only selected processes are protected.</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">   mls - Multi Level Security protection.</span></span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure><p>重启系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> Git </tag>
            
            <tag> Gogs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」使用Nexus搭建Maven私服（CentOS 8）</title>
      <link href="/2020/11/25/env-centos8-nexus.html"/>
      <url>/2020/11/25/env-centos8-nexus.html</url>
      
        <content type="html"><![CDATA[<p><strong>Maven私服</strong> 就是在内网架设一个<code>Maven仓库服务器</code>，在代理远程仓库的同时维护本地仓库。<br>当我们需要下载一些构件（artifact）时，如果本地仓库没有，再去私服下载，私服没有，再去中央仓库下载。<span id="more"></span></p><p><strong>Nexus</strong>是一个专门的 Maven仓库管理软件。它提供了强大的仓库管理功能，构件搜索功能；<br>它占用较少的内存，基于REST，基于简单文件系统而非数据库。</p><h3 id="1-安装Nexus服务"><a href="#1-安装Nexus服务" class="headerlink" title="1. 安装Nexus服务"></a>1. 安装Nexus服务</h3><h4 id="1-1-前置条件：jdk1-8环境"><a href="#1-1-前置条件：jdk1-8环境" class="headerlink" title="1.1 前置条件：jdk1.8环境 "></a>1.1 前置条件：<code>jdk1.8环境 </code></h4><h4 id="1-2-下载Nexus"><a href="#1-2-下载Nexus" class="headerlink" title="1.2 下载Nexus"></a>1.2 下载Nexus</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://sonatype-download.global.ssl.fastly.net/repository/repositoryManager/3/nexus-3.18.1-01-unix.tar.gz</span><br></pre></td></tr></table></figure><p>下载失败的话，可以试试这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">百度云: https://pan.baidu.com/s/16IfFUtL3W0YGciS-XPlPfQ</span><br><span class="line">提取码: naxi </span><br></pre></td></tr></table></figure><h4 id="1-3-安装Nexus"><a href="#1-3-安装Nexus" class="headerlink" title="1.3 安装Nexus"></a>1.3 安装Nexus</h4><p>解压到安装目录（<code>/data/apps/nexus/</code>），会得到两个文件夹：nexus-3.18.1-01（nexus 服务目录）、sonatype-work（私有库目录）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir -p /data/apps/nexus/</span><br><span class="line">[root@localhost ~]# mv nexus-3.18.1-01-unix.tar.gz /data/apps/nexus/nexus-3.18.1-01-unix.tar.gz</span><br><span class="line">[root@localhost ~]# cd /data/apps/nexus/</span><br><span class="line">[root@localhost nexus]# tar -zvxf nexus-3.18.1-01-unix.tar.gz</span><br><span class="line">[root@localhost nexus]# ls</span><br><span class="line">nexus-3.18.1-01  nexus-3.18.1-01-unix.tar.gz  sonatype-work</span><br></pre></td></tr></table></figure><p>进入 nexus-3.18.1-01 文件夹，其中 etc&#x2F;nexus-default.properties 文件配置端口（默认为 8081）和 work 目录信息，可以按需修改。</p><h4 id="1-4-开放端口并启动服务"><a href="#1-4-开放端口并启动服务" class="headerlink" title="1.4 开放端口并启动服务"></a>1.4 开放端口并启动服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost nexus-3.18.1-01]# firewall-cmd --zone=public --add-port=8081/tcp --permanent &amp;&amp; firewall-cmd --reload</span><br><span class="line">[root@localhost nexus-3.18.1- /data/apps/nexus/nexus-3.18.1-01/bin</span><br><span class="line">[root@localhost bin]# ./nexus start</span><br><span class="line">WARNING: ************************************************************</span><br><span class="line">WARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!</span><br><span class="line">WARNING: ************************************************************</span><br><span class="line">Starting nexus</span><br></pre></td></tr></table></figure><p>首次启动，初始账号为：<code>admin</code>，查看初始密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# cat /data/apps/nexus/sonatype-work/nexus3/admin.password</span><br><span class="line">e6c47f75-dc91-4f87-a2a9-0188df6e4b7c</span><br></pre></td></tr></table></figure><h3 id="2-配置Nexus"><a href="#2-配置Nexus" class="headerlink" title="2. 配置Nexus"></a>2. 配置Nexus</h3><h4 id="2-1-登录Nexus"><a href="#2-1-登录Nexus" class="headerlink" title="2.1 登录Nexus"></a>2.1 登录Nexus</h4><p>Nexus服务启动以后，使用浏览器访问<code>http://IP:8081/</code>，并用初始账号密码登录，登陆后会让我们先修改初始密码。</p><p><img src="/2020/11/25/env-centos8-nexus/up-502db1f338b345d6fd3148a090e2fd2fe12.webp"></p><p>仓库浏览在左侧菜单栏<code>Browse</code>，这里有多种仓库：</p><ol><li><code>maven-central</code>：maven 中央库，默认从 <a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a> 拉取 jar</li><li><code>maven-releases</code>：私库发行版 jar，初次安装请将 Deployment policy 设置为 Allow redeploy</li><li><code>maven-snapshots</code>：私库快照（调试版本）jar</li><li><code>maven-public</code>：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地 maven 基础配置 settings.xml 或项目 pom.xml 中使用</li></ol><ul><li>仓库类型说明：<ul><li><code>group</code>：这是一个仓库聚合的概念，用户仓库地址选择 Group 的地址，即可访问 Group 中配置的，用于方便开发人员自己设定的仓库。maven-public 就是一个 Group 类型的仓库，内部设置了多个仓库，访问顺序取决于配置顺序，3.x 默认为 Releases、Snapshots、Central，当然你也可以自己设置。</li><li><code>hosted</code>：私有仓库，内部项目的发布仓库，专门用来存储我们自己生成的 jar 文件</li><li><code>snapshots</code>：本地项目的快照仓库</li><li><code>releases</code>： 本地项目发布的正式版本</li><li><code>proxy</code>：代理类型，从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的 Configuration 页签下 Remote Storage 属性的值即被代理的远程仓库的路径），如可配置阿里云 maven 仓库</li><li><code>central</code>：中央仓库</li></ul></li></ul><h4 id="2-2-设置"><a href="#2-2-设置" class="headerlink" title="2.2 设置"></a>2.2 设置</h4><ol><li>配置Releases版本可重复上传: <code>Deployment pollcy --&gt; Allow redeploy</code>。</li></ol><p><img src="/2020/11/25/env-centos8-nexus/up-0c975f956016a64ea320c944c072af7411e.webp"></p><ol start="2"><li>增加一个代理仓库，使用的是阿里云公共仓库。首先点击<code>Create repository</code>按钮开始创建一个仓库，类型选择 maven2（proxy）。</li></ol><p><img src="/2020/11/25/env-centos8-nexus/up-7f1d30bc0b032cf43278b9074ca9aee21dc.webp"></p><ol start="3"><li>配置阿里云地址<code>http://maven.aliyun.com/nexus/content/groups/public/</code>，并创建。</li></ol><p><img src="/2020/11/25/env-centos8-nexus/up-c6a3ab35342767a6a95ef40073278967a11.webp"></p><ol start="4"><li>阿里云代理仓库创建完毕后，我们编辑<code>maven-public</code>，将其添加到放入<code>group</code>中，并调整优先级，然后保存。</li></ol><p><img src="/2020/11/25/env-centos8-nexus/up-bf6e3f140adb09aeddfd2f6f6366740263b.webp"></p><ol start="5"><li>点击maven-public条目的<code>copy</code>按钮即可拷贝私服地址</li></ol><p><img src="/2020/11/25/env-centos8-nexus/up-8419fbf8913733269363b199c0260abae0b.webp"></p><h3 id="3-Maven配置使用私服"><a href="#3-Maven配置使用私服" class="headerlink" title="3. Maven配置使用私服"></a>3. Maven配置使用私服</h3><h4 id="3-1-使用配置（下载依赖）"><a href="#3-1-使用配置（下载依赖）" class="headerlink" title="3.1 使用配置（下载依赖）"></a>3.1 使用配置（下载依赖）</h4><p>两种方式：①通过<code>Maven</code>的<code>setting.xml</code>文件配置（全局模式），②通过<code>项目</code>的<code>pom.xml</code>文件配置（项目独享模式）。</p><blockquote><p>注意：若<code>pom.xml</code>和<code>setting.xml</code>同时配置了，以<code>pom.xml</code>为准。</p></blockquote><ol><li>全局模式：通过<code>Maven</code>的<code>setting.xml</code>文件配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--镜像名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--*指的是访问任何仓库都使用我们的私服--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.2.100:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>项目独享模式：通过<code>项目</code>的<code>pom.xml</code>文件配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-nexus<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.2.100:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-2-发布配置（发布依赖）"><a href="#3-2-发布配置（发布依赖）" class="headerlink" title="3.2 发布配置（发布依赖）"></a>3.2 发布配置（发布依赖）</h4><ol><li>修改<code>setting.xml</code>文件，指定<code>releases</code>和<code>snapshots server</code>的用户名和密码：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在发布依赖项目的<code>pom.xml</code>文件中加入<code>distributionManagement</code>节点（这里<code>repository id</code>需要和上一步里的<code>server id</code>名称保持一致）：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Releases<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.2.100:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.2.100:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>执行<code>mvn deploy</code>命令发布。</li><li>登录<code>Nexus</code>，查看对应的仓库就能看到发布的依赖包了。</li></ol><blockquote><p>发布到的仓库说明：<br>①若项目版本号末尾带有<code>-SNAPSHOT</code>，则会发布到<code>snapshots</code>快照版本仓库。<br>②若项目版本号末尾带有<code>-RELEASES</code>或什么都不带，则会发布到<code>releases</code>正式版本仓库。</p></blockquote><h3 id="4-设置Nexus开机自启"><a href="#4-设置Nexus开机自启" class="headerlink" title="4. 设置Nexus开机自启"></a>4. 设置Nexus开机自启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nexus.service</span><br></pre></td></tr></table></figure><p><code>nexus.service</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unitt]</span><br><span class="line">Description=nexus service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/data/apps/nexus/nexus-3.18.1-01/bin/nexus start</span><br><span class="line">ExecReload=/data/apps/nexus/nexus-3.18.1-01/bin/nexus restart</span><br><span class="line">ExecStop=/data/apps/nexus/nexus-3.18.1-01/bin/nexus stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">开启开机启动</span></span><br><span class="line">systemctl enable nexus.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl start nexus.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止服务</span></span><br><span class="line">systemctl stop nexus.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> Nexus </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Tomcat9安装及多实例多应用配置(CentOS 8)</title>
      <link href="/2020/11/20/env-centos8-tomcat9.html"/>
      <url>/2020/11/20/env-centos8-tomcat9.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Tomcat9安装"><a href="#1-Tomcat9安装" class="headerlink" title="1. Tomcat9安装"></a>1. Tomcat9安装</h3><p>使用wget获取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/apache/tomcat/tomcat-9/v9.0.41/bin/apache-tomcat-9.0.41.tar.gz</span><br></pre></td></tr></table></figure><p>下载之后如果没有进入别的文件夹，压缩包一般是在&#x2F;root下面。进入&#x2F;root下面进行解压：<span id="more"></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xzf apache-tomcat-9.0.41.tar.gz</span><br></pre></td></tr></table></figure><p>然后复制到指定的文件夹下(在&#x2F;data&#x2F;apps下面创建了一个tomcat的文件夹)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/apps</span><br><span class="line">mv apache-tomcat-9.0.41 /data/apps/tomcat</span><br></pre></td></tr></table></figure><p>然后配置jvm内存参数（也可以不用配置）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /data/apps/tomcat/bin/setenv.sh</span><br></pre></td></tr></table></figure><p>在setenv.sh中写入如下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&#x27;-Djava.security.egd=file:/dev/./urandom -server -Xms512m -Xmx1024m -Dfile.encoding=UTF-8&#x27;</span><br></pre></td></tr></table></figure><p>开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">开放8080端口</span></span><br><span class="line">firewall-cmd --add-port=8080/tcp --permanent &amp;&amp; firewall-cmd --reload</span><br><span class="line"><span class="meta">#</span><span class="language-bash">重新加载防火墙规则</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>启动&#x2F;停用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">启动</span></span><br><span class="line">cd /data/apps/tomcat/bin &amp;&amp; sh startup.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">停用</span></span><br><span class="line">cd /data/apps/tomcat/bin &amp;&amp; sh shutdown.sh</span><br></pre></td></tr></table></figure><p>通过浏览器访问 【ip】:8080</p><h3 id="2-Tomcat多实例配置"><a href="#2-Tomcat多实例配置" class="headerlink" title="2. Tomcat多实例配置"></a>2. Tomcat多实例配置</h3><p>Tomcat多实例部署的好处在于升级方便，配置及安装文件间互不影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    安装路径                       实例位置</span><br><span class="line">【CATALINA_HOME】            【CATALINA_BASE】</span><br><span class="line">        |————bin     &lt;-------------|</span><br><span class="line">        |————lib     &lt;-------------|</span><br><span class="line">                                   |————（conf,webapps,logs,temp,work）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建一个实例存放路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/runtime/tomcat-instance</span><br></pre></td></tr></table></figure><p>新建两个tomcat实例，把安装路径下的<code>conf,webapps,logs,temp,work</code>文件拷贝到实例中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /data/runtime/tomcat-instance</span><br><span class="line">mkdir tomcat1 tomcat2</span><br><span class="line"><span class="meta"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="built_in">cd</span> /data/apps/tomcat/</span></span><br><span class="line">cp conf/ webapps/ temp/ logs/ work/ -rt /data/runtime/tomcat-instance/tomcat1</span><br><span class="line">cp conf/ webapps/ temp/ logs/ work/ -rt /data/runtime/tomcat-instance/tomcat2</span><br></pre></td></tr></table></figure><p>新建 Tomcat实例启动&#x2F;停止脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/runtime/tomcat-instance</span><br><span class="line">vim tomcat1.sh</span><br><span class="line">vim tomcat2.sh</span><br></pre></td></tr></table></figure><p>tomcat1.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/data/runtime/tomcat-instance/tomcat1</span><br><span class="line">export CATALINA_HOME=/data/apps/tomcat</span><br><span class="line">export CATALINA_PID=$CATALINA_BASE/CATALINA_PID</span><br><span class="line">export JAVA_OPTS=&quot;-server -Xms256m -Xmx512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m&quot;</span><br><span class="line"></span><br><span class="line">sname=tomcat1</span><br><span class="line">mark=$CATALINA_BASE/temp</span><br><span class="line">pid=`ps -ef | grep &quot;$mark&quot; | grep -v &quot;grep $mark&quot; | awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">function start()</span><br><span class="line">&#123;</span><br><span class="line">  if [ -f &quot;$CATALINA_PID&quot; ]; then</span><br><span class="line">    rm -rf $CATALINA_PID</span><br><span class="line">  fi</span><br><span class="line">  echo &quot;$sname start ......&quot;</span><br><span class="line"><span class="meta">  $</span><span class="language-bash">CATALINA_HOME/bin/catalina.sh start 2&gt;/dev/null</span></span><br><span class="line">  pid=`ps -ef | grep &quot;$mark&quot; | grep -v &quot;grep $mark&quot; | awk -F &quot; &quot; &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">  echo &quot;PID:                   $pid&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function stop()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;$sname stop ......&quot;</span><br><span class="line">  if [ $pid ]; then</span><br><span class="line">    kill -9 $pid</span><br><span class="line">    rm -f $CATALINA_PID</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function status()</span><br><span class="line">&#123;</span><br><span class="line">  if [ $pid ]; then</span><br><span class="line">    echo &quot;$sname run ......&quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;$sname stop ......&quot;</span><br><span class="line">  fi</span><br><span class="line">  echo `ps -ef | grep &quot;$CATALINA_BASE&quot; | grep -v &quot;grep $CATALINA_BASE&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">  start</span><br><span class="line">  ;;</span><br><span class="line">stop)</span><br><span class="line">  stop</span><br><span class="line">  ;;</span><br><span class="line">restart)</span><br><span class="line">  stop</span><br><span class="line">  start</span><br><span class="line">  ;;</span><br><span class="line">status)</span><br><span class="line">  status</span><br><span class="line">  ;;</span><br><span class="line">*)</span><br><span class="line">  echo &quot;Option in (start|stop|restart|status)&quot;</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>tomcat2.sh参考tomcat1.sh</p><p>赋予权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 tomcat1.sh tomcat2.sh</span><br></pre></td></tr></table></figure><p>配置实例<code>server.xml</code>端口</p><ul><li>Server Port：该端口用于监听关闭tomcat的shutdown命令，默认为8005</li><li>Connector Port：该端口用于监听HTTP的请求，默认为8080</li><li>AJP Port：该端口用于监听AJP（ Apache JServ Protocol ）协议上的请求，通常用于整合Apache Server等其他HTTP服务器，默认为8009</li><li>Redirect Port：重定向端口，出现在Connector配置中，如果该Connector仅支持非SSL的普通http请求，那么该端口会把 https 的请求转发到这个Redirect Port指定的端口，默认为8443；</li></ul><p>这里<code>tomcat1</code>实例保持默认，把<code>tomcat2</code>实例的<code>Server Port</code>改为了<code>8006</code>，<code>Connector Port</code>改为了 <code>8081</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /data/runtime/tomcat-instance/tomcat2</span><br><span class="line">vim conf/server.xml</span><br><span class="line"><span class="meta"># </span><span class="language-bash">8081端口</span></span><br><span class="line">firewall-cmd --add-port=8081/tcp --permanent &amp;&amp; firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>分别在 tomcat1、tomcat2 的 webapps&#x2F;ROOT 目录下放入了页面文件。</p><p>启动两个实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/runtime/tomcat-instance</span><br><span class="line">./tomcat1.sh start</span><br><span class="line">./tomcat2.sh start</span><br></pre></td></tr></table></figure><p>通过浏览器：<code>【ip】:8080/</code>，<code>【ip】:8081/</code>，如：192.168.2.100:8080</p><h3 id="3-nginx使用https代理tomcat"><a href="#3-nginx使用https代理tomcat" class="headerlink" title="3. nginx使用https代理tomcat"></a>3. nginx使用https代理tomcat</h3><p>修改nginx配置文件，在server中添加如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /tomcat1/ &#123;</span><br><span class="line">     proxy_pass http://127.0.0.1:8080/;</span><br><span class="line">          proxy_set_header   Host     $host:$server_port;</span><br><span class="line">          proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">          proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header   Scheme  $scheme;</span><br><span class="line">&#125;</span><br><span class="line">location /tomcat2/ &#123;</span><br><span class="line">     proxy_pass http://127.0.0.1:8081/;</span><br><span class="line">          proxy_set_header   Host     $host:$server_port;</span><br><span class="line">          proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">          proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">          proxy_set_header   Scheme  $scheme;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过浏览器访问：<code>【ip】/tomcat1/</code>，<code>【ip】/tomcat2/</code>，如：192.168.2.100&#x2F;tomcat1&#x2F;</p><ul><li>tips: <code>Tomcat</code>默认上传到服务器中文件的权限是<code>- -rw-r-----</code>640权限，其他人不可读。<br>到<code>Tomcat</code>中<code>bin</code>目录下面，修改<code>catalina.sh</code>中<code>UMASK=&quot;0027&quot;</code>为<code>UMASK=&quot;0022&quot;</code>。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">Set UMASK unless it has been overridden</span></span><br><span class="line">if [ -z &quot;$UMASK&quot; ]; then</span><br><span class="line">    UMASK=&quot;0022&quot;</span><br><span class="line">fi</span><br><span class="line">umask $UMASK</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> Tomcat9 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」CentOS 8 安装和配置 NFS 服务器</title>
      <link href="/2020/08/10/env-centos8-nfs.html"/>
      <url>/2020/08/10/env-centos8-nfs.html</url>
      
        <content type="html"><![CDATA[<p>网络文件系统（NFS）是一个分布式文件系统协议，它允许你通过网络共享远程文件夹。</p><p>NFS 协议默认是不加密的，不提供用户身份鉴别。服务端通过限定客户端的 IP 地址和端口来限制访问。<span id="more"></span></p><ul><li>NFS 特点：<ul><li>基于TCP&#x2F;IP协议，服务于linux之间资源共享</li><li>将远程主机上共享资源挂载到本地目录，使得像使用本地文件一样方便。</li></ul></li></ul><h3 id="1-建立-NFS-服务器"><a href="#1-建立-NFS-服务器" class="headerlink" title="1. 建立 NFS 服务器"></a>1. 建立 NFS 服务器</h3><h4 id="1-1-安装-NFS-服务端（CentOS8中默认安装了nfs-utils软件包）"><a href="#1-1-安装-NFS-服务端（CentOS8中默认安装了nfs-utils软件包）" class="headerlink" title="1.1 安装 NFS 服务端（CentOS8中默认安装了nfs-utils软件包）"></a>1.1 安装 NFS 服务端（CentOS8中默认安装了nfs-utils软件包）</h4><ol><li>用rpm检查是否有nfs-utils的包已安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep nfs-utils</span><br><span class="line">nfs-utils-2.3.3-31.el8.x86_64</span><br></pre></td></tr></table></figure><ol start="2"><li>如果没有安装 执行如下命令安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dnf install nfs-utils</span><br></pre></td></tr></table></figure><ol start="3"><li>启用并启动 NFS 服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl enable --now nfs-server</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/nfs-server.service → /usr/lib/systemd/system/nfs-server.service.</span><br></pre></td></tr></table></figure><ol start="4"><li>默认情况下，在 CentOS8 上，NFS3 和 NFS4 都可以用，NFS2 被禁用。想要验证，运行下面的cat命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/fs/nfsd/versions</span><br><span class="line">-2 +3 +4 +4.1 +4.2</span><br></pre></td></tr></table></figure><p>NFS 服务器配置选项在<code>/etc/nfsmount.conf</code>和<code>/etc/nfs.conf</code>文件中。默认的设置足够满足我们的要求。</p><h4 id="1-2-创建文件系统"><a href="#1-2-创建文件系统" class="headerlink" title="1.2 创建文件系统"></a>1.2 创建文件系统</h4><ol><li>创建共享目录，并开放目录权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /nfs_database</span><br><span class="line">[root@localhost ~]# chmod 777 /nfs_database</span><br><span class="line">[root@localhost ~]# cd /nfs_database/ &amp;&amp; echo &quot;this is nfs database test !!&quot; &gt; nfs_test.txt</span><br><span class="line">cd /nfs_database/ &amp;&amp; echo &quot;this is nfs database test chmod 777 /nfs_database&quot; &gt; nfs_test.txt</span><br><span class="line">[root@localhost nfs_database]# ls</span><br><span class="line">nfs_test.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>编辑NFS服务程序配置文件(允许IP地址<code>192.168.2.*</code>的所有主机访问NFS共享资源文件夹)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/exports</span><br><span class="line">/nfs_database 192.168.2.* (rw,no_root_squash,async) </span><br></pre></td></tr></table></figure><p>配置完成后，使nfs配置生效，使用exportfs实用程序有选择地导出目录，而无需重新启动NFS服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">使用exportfs实用程序有选择地导出目录，而无需重新启动NFS服务</span></span><br><span class="line">[root@localhost ~]# exportfs -rv</span><br><span class="line"><span class="meta">#</span><span class="language-bash">查看当前配置为nfs共享的目录及其状态</span></span><br><span class="line">[root@localhost ~]# exportfs -v</span><br></pre></td></tr></table></figure><table><thead><tr><th>NFS配置文件参数</th><th>作用</th></tr></thead><tbody><tr><td>ro</td><td>只读（read only）</td></tr><tr><td>rw</td><td>读写（read write）</td></tr><tr><td>root_squash</td><td>当NFS客户端以root管理员访问时，映射为NFS服务器匿名用户</td></tr><tr><td>no_root_squash</td><td>当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员</td></tr><tr><td>all_squash</td><td>表示客户机所有用户访问时，映射为NFS服务器匿名用户</td></tr><tr><td>sync</td><td>同时将数据写入到内存与硬盘中，保证不丢失数据</td></tr><tr><td>async</td><td>优先将数据保存到内存，然后再写入硬盘，效率更高，但可能丢失数据</td></tr></tbody></table><ol start="3"><li>启动和启用rpcbind服务程序</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">安装rpcbind</span></span><br><span class="line">[root@localhost ~]# yum install -y rpcbind</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启并启用rpc服务程序</span></span><br><span class="line">[root@localhost ~]# systemctl restart rpcbind &amp;&amp; systemctl enable rpcbind</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启并启用NFS服务程序</span></span><br><span class="line">[root@localhost ~]# systemctl restart nfs-server &amp;&amp; systemctl enable nfs-server</span><br></pre></td></tr></table></figure><h4 id="1-3-防火墙设置"><a href="#1-3-防火墙设置" class="headerlink" title="1.3 防火墙设置"></a>1.3 防火墙设置</h4><p>将该服务添加到防火墙中进行放行。</p><p>部署nfs服务不仅需要nfs服务软件包，还需要rpc-bind服务和mountd服务。<br>因为nfs服务需要向客户端广播地址和端口信息，nfs客户端需要使用mount对远程nfs服务器目录进行挂载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=nfs</span><br><span class="line">success</span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=rpc-bind</span><br><span class="line">success</span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=mountd</span><br><span class="line">success</span><br><span class="line">[root@localhost ~]# firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure><h3 id="2-客户端配置"><a href="#2-客户端配置" class="headerlink" title="2. 客户端配置"></a>2. 客户端配置</h3><ol><li>查询远程nfs服务器是否能够连通</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# showmount -e 192.168.2.100</span><br><span class="line">Export list for 192.168.2.100:</span><br><span class="line">/nfs_database (everyone)</span><br></pre></td></tr></table></figure><table><thead><tr><th>showmount参数</th><th>作用</th></tr></thead><tbody><tr><td>-e</td><td>显示NFS服务器共享列表</td></tr><tr><td>-a</td><td>显示本地挂载的文件资源情况</td></tr><tr><td>-v</td><td>显示版本号</td></tr></tbody></table><ol start="2"><li>创建本地nfs专用共享目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /nfs_database</span><br><span class="line">[root@localhost ~]# chmod 777 /nfs_database</span><br></pre></td></tr></table></figure><ol start="3"><li>将远程nfs服务器共享目录挂载到本地创建的nfs共享目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -t nfs 192.168.2.100:/nfs_database /nfs_database</span><br></pre></td></tr></table></figure><ul><li>mount参数：<ul><li><code>-t</code>：使用TCP协议</li><li><code>nfs</code>：nfs服务</li><li><code>192.168.2.100:/nfs_database</code>：远程nfs服务器资源共享目录</li><li><code>/nfs-database</code>：本地资源共享目录</li></ul></li></ul><ol start="4"><li>本机查看共享文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /nfs_database</span><br><span class="line">[root@localhost nfs_database]# ll</span><br><span class="line">总用量 4</span><br><span class="line">-rw-r--r-- 1 root root 50 12月 17 14:52 nfs_test.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SpringBoot 整合 FastDFS</title>
      <link href="/2020/08/02/spring-boot-fastdfs.html"/>
      <url>/2020/08/02/spring-boot-fastdfs.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-在maven项目pom-xml中添加依赖"><a href="#1-在maven项目pom-xml中添加依赖" class="headerlink" title="1. 在maven项目pom.xml中添加依赖"></a>1. 在maven项目pom.xml中添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.tobato<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.27.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="2-在application-yml中添加配置"><a href="#2-在application-yml中添加配置" class="headerlink" title="2. 在application.yml中添加配置"></a>2. 在application.yml中添加配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#FDFS配置</span><br><span class="line">fdfs:</span><br><span class="line">  so-timeout: 5000 #上传的超时时间</span><br><span class="line">  connect-timeout: 2000 #连接超时时间</span><br><span class="line">  thumb-image:             #缩略图生成参数</span><br><span class="line">    width: 150</span><br><span class="line">    height: 150</span><br><span class="line">  tracker-list:            #TrackerList参数,支持多个</span><br><span class="line">  - 192.168.2.100:22122</span><br></pre></td></tr></table></figure><h3 id="3-编写FastDFS工具类"><a href="#3-编写FastDFS工具类" class="headerlink" title="3. 编写FastDFS工具类"></a>3. 编写FastDFS工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastDfsUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThumbImageConfig thumbImageConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FastFileStorageClient fastFileStorageClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FdfsWebServer fdfsWebServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastDfsUtil</span><span class="params">(ThumbImageConfig thumbImageConfig, FastFileStorageClient fastFileStorageClient, FdfsWebServer fdfsWebServer)</span> &#123;</span><br><span class="line">        FastDfsUtil.thumbImageConfig = thumbImageConfig;</span><br><span class="line">        FastDfsUtil.fastFileStorageClient = fastFileStorageClient;</span><br><span class="line">        FastDfsUtil.fdfsWebServer = fdfsWebServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> multipartFile 文件对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回文件地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> qbanxiaoli</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 上传文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">uploadFile</span><span class="params">(MultipartFile multipartFile)</span> &#123;</span><br><span class="line">        <span class="type">StorePath</span> <span class="variable">storePath</span> <span class="operator">=</span> fastFileStorageClient.uploadFile(multipartFile.getInputStream(), multipartFile.getSize(), FilenameUtils.getExtension(multipartFile.getOriginalFilename()), <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> storePath.getFullPath();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-编写测试Controller"><a href="#4-编写测试Controller" class="headerlink" title="4. 编写测试Controller"></a>4. 编写测试Controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图片并保存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">uploadFile</span><span class="params">(MultipartFile[] file, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="keyword">if</span> (file != <span class="literal">null</span> &amp;&amp; file.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">saveFile</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; file.length; i++) &#123;</span><br><span class="line">                <span class="type">MultipartFile</span> <span class="variable">partFile</span> <span class="operator">=</span> file[i];</span><br><span class="line">                <span class="comment">// 保存文件</span></span><br><span class="line">                saveFile = FastDfsUtil.uploadFile(partFile);;</span><br><span class="line">                saveFile = <span class="string">&quot;http://192.168.2.100/&quot;</span> + saveFile;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(<span class="string">&quot;data&quot;</span>, saveFile);</span><br><span class="line">            map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;图片上传成功:&quot;</span> + saveFile);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;图片上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-编写前端页面代码"><a href="#5-编写前端页面代码" class="headerlink" title="5. 编写前端页面代码"></a>5. 编写前端页面代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        图片上传：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input-file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/png,image/jpeg,image/gif,image/jpg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        图片回显：</span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;upload-file&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/lib/jquery-3.5.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&#x27;#input-file&#x27;</span>).<span class="title function_">on</span>(<span class="string">&quot;change&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> file = <span class="variable language_">this</span>.<span class="property">files</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">    formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file);</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 开始上传</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fileUpload</span>(<span class="string">&quot;/upload&quot;</span>, formData);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 测试读取图片(本地显示)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span></span><br><span class="line"><span class="language-javascript">    fileReader.<span class="title function_">readAsDataURL</span>(file);</span></span><br><span class="line"><span class="language-javascript">    fileReader.<span class="property">onloadend</span> = <span class="keyword">function</span>(<span class="params">fEvent</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> src = fEvent.<span class="property">target</span>.<span class="property">result</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(src);</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#upload-file&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, src);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">fileUpload</span>(<span class="params">url, formData</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: url,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&#x27;POST&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">cache</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: formData,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">processData</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">contentType</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">res</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">xhr, type, errorThrown</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;照片上传失败&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-浏览器访问页面测试"><a href="#6-浏览器访问页面测试" class="headerlink" title="6. 浏览器访问页面测试"></a>6. 浏览器访问页面测试</h3><p><img src="https://oscimg.oschina.net/oscnet/up-83d0d727e478c0a4832f661f79076b4128d.JPEG"></p><blockquote><p>demo源码地址：<a href="https://gitee.com/chaoo/fastdfs-demo.git">https://gitee.com/chaoo/fastdfs-demo.git</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> FastDFS </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Centos8 安装 FastDFS 6.06</title>
      <link href="/2020/08/02/env-centos8-fastdfs.html"/>
      <url>/2020/08/02/env-centos8-fastdfs.html</url>
      
        <content type="html"><![CDATA[<p>FastDFS是一款开源的分布式文件系统，功能主要包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了文件大容量存储和高性能访问的问题。FastDFS特别适合以文件为载体的在线服务，如图片、视频、文档等等。<span id="more"></span></p><p>FastDFS为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性。FastDFS可以看做是基于文件的key value存储系统，key为文件ID，value为文件内容，因此称作分布式文件存储服务更为合适。</p><ul><li>FastDFS特点如下： <ol><li>分组存储，简单灵活；</li><li>对等结构，不存在单点；</li><li>文件ID由FastDFS生成，作为文件访问凭证。FastDFS不需要传统的name server或meta server；</li><li>大、中、小文件均可以很好支持，可以存储海量小文件；</li><li>一台storage支持多块磁盘，支持单盘数据恢复；</li><li>提供了nginx扩展模块，可以和nginx无缝衔接；</li><li>支持多线程方式上传和下载文件，支持断点续传；</li><li>存储服务器上可以保存文件附加属性。</li></ol></li></ul><p><a href="https://github.com/happyfish100/fastdfs">【官方GitHub地址】</a></p><h3 id="1-准备安装文件"><a href="#1-准备安装文件" class="headerlink" title="1. 准备安装文件"></a>1. 准备安装文件</h3><ul><li>安装文件：fastdfs,libfastcommon,fastdfs-nginx-module</li><li>文件存放位置：&#x2F;usr&#x2F;local&#x2F;src</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget -c &quot;https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz&quot; -O fastdfs-6.06.tar.gz</span><br><span class="line">wget -c &quot;https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz&quot; -O libfastcommon-1.0.43.tar.gz</span><br><span class="line">wget -c &quot;https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz&quot; -O fastdfs-nginx-module-1.22.tar.gz</span><br><span class="line">wget -c http://nginx.org/download/nginx-1.18.0.tar.gz</span><br></pre></td></tr></table></figure><h3 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2. 编译安装"></a>2. 编译安装</h3><p>准备编译环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vim -y</span><br><span class="line">tar -zxvf libfastcommon-1.0.43.tar.gz</span><br><span class="line">tar -zxvf fastdfs-6.06.tar.gz</span><br><span class="line">tar -zxvf fastdfs-nginx-module-1.22.tar.gz</span><br></pre></td></tr></table></figure><h4 id="2-1-编译安装libfatscommon"><a href="#2-1-编译安装libfatscommon" class="headerlink" title="2.1 编译安装libfatscommon"></a>2.1 编译安装libfatscommon</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/libfastcommon-1.0.43</span><br><span class="line">./make.sh &amp;&amp; ./make.sh install</span><br></pre></td></tr></table></figure><p>检查(出现libfastcommon.so即成功)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/lib64|grep libfastcommon</span><br><span class="line">ls /usr/lib|grep libfastcommon</span><br></pre></td></tr></table></figure><h4 id="2-2-编译安装fastdfs"><a href="#2-2-编译安装fastdfs" class="headerlink" title="2.2 编译安装fastdfs"></a>2.2 编译安装fastdfs</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/fastdfs-6.06</span><br><span class="line">./make.sh &amp;&amp; ./make.sh install</span><br></pre></td></tr></table></figure><p>检查</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/bin|grep fdfs</span><br></pre></td></tr></table></figure><h3 id="3-配置Tracker-FastFDS跟踪器"><a href="#3-配置Tracker-FastFDS跟踪器" class="headerlink" title="3. 配置Tracker(FastFDS跟踪器)"></a>3. 配置Tracker(FastFDS跟踪器)</h3><ol><li>启用并修改配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/fdfs/</span><br><span class="line">cp tracker.conf.sample tracker.conf</span><br><span class="line">vim /etc/fdfs/tracker.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">配置文件生效</span></span><br><span class="line">disabled = false</span><br><span class="line"><span class="meta"># </span><span class="language-bash">提供服务端口</span></span><br><span class="line">port = 22122</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Tracker 数据和日志目录地址（根目录必须存在，子目录会自动创建）</span></span><br><span class="line">base_path = /fastdfs/tracker</span><br><span class="line"><span class="meta"># </span><span class="language-bash">HTTP 服务端口 默认8080，建议修改防止冲突</span></span><br><span class="line">http.server_port = 8080</span><br></pre></td></tr></table></figure><ol start="3"><li>创建Tracker基础数据目录，即base_path对应的目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /fastdfs/tracker</span><br></pre></td></tr></table></figure><ol start="4"><li>启动Tracker服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl start fdfs_trackerd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启</span></span><br><span class="line">systemctl restart fdfs_trackerd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看服务状态</span></span><br><span class="line">systemctl status fdfs_trackerd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">检查服务是否启动</span></span><br><span class="line">ps -ef | grep fdfs</span><br><span class="line"><span class="meta"># </span><span class="language-bash">22122端口正在被监听，则算Tracker服务安装成功</span></span><br><span class="line">netstat -tulnp | grep fdfs</span><br><span class="line"><span class="meta"># </span><span class="language-bash">关闭</span></span><br><span class="line">systemctl stop fdfs_trackerd</span><br></pre></td></tr></table></figure><ol start="5"><li>设置开机启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable fdfs_trackerd.service</span><br></pre></td></tr></table></figure><h3 id="4-配置Storage-FastFDS存储器"><a href="#4-配置Storage-FastFDS存储器" class="headerlink" title="4. 配置Storage(FastFDS存储器)"></a>4. 配置Storage(FastFDS存储器)</h3><ol><li>启用并修改配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/fdfs/</span><br><span class="line">cp storage.conf.sample storage.conf</span><br><span class="line">vim /etc/fdfs/storage.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Storage 数据和日志目录地址（根目录必须存在，子目录会自动创建）</span></span><br><span class="line">base_path = /fastdfs/storage/base</span><br><span class="line"><span class="meta"># </span><span class="language-bash">逐一配置 store_path_count 个路径，索引号基于 0</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果不配置，那就和base_path一样</span></span><br><span class="line">store_path0 = /fastdfs/storage</span><br><span class="line"><span class="meta"># </span><span class="language-bash">tracker_server 的列表，多个时，每个写一行（会主动连接 tracker_server）</span></span><br><span class="line">tracker_server = ip:22122</span><br><span class="line"><span class="meta"># </span><span class="language-bash">HTTP 服务端口 默认8888，建议修改防止冲突</span></span><br><span class="line">http.server_port = 8888</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Tracker基础数据目录，即base_path对应的目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">对应base_path</span></span><br><span class="line">mkdir -p  /fastdfs/storage/base</span><br><span class="line"><span class="meta"># </span><span class="language-bash">对应store_path0，有多个要创建多个</span></span><br><span class="line">mkdir -p  /fastdfs/storage</span><br></pre></td></tr></table></figure><ol start="3"><li>启动Storage服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl start fdfs_storaged</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启</span></span><br><span class="line">systemctl restart fdfs_storaged</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看服务状态</span></span><br><span class="line">systemctl status fdfs_storaged</span><br><span class="line"><span class="meta"># </span><span class="language-bash">检查服务是否启动</span></span><br><span class="line">ps -ef | grep fdfs</span><br><span class="line"><span class="meta"># </span><span class="language-bash">22122端口正在被监听，则算Tracker服务安装成功</span></span><br><span class="line">netstat -tulnp | grep fdfs</span><br><span class="line"><span class="meta"># </span><span class="language-bash">关闭</span></span><br><span class="line">systemctl stop fdfs_storaged</span><br></pre></td></tr></table></figure><ol start="4"><li>查看Storage和Tracker是否在通信</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure><ol start="5"><li>设置开机自启</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable fdfs_storaged.service</span><br></pre></td></tr></table></figure><h3 id="5-客户端配置"><a href="#5-客户端配置" class="headerlink" title="5. 客户端配置"></a>5. 客户端配置</h3><ol><li>启用修改Client配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/fdfs/</span><br><span class="line">cp client.conf.sample client.conf</span><br><span class="line">vim /etc/fdfs/client.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">Client 的数据和日志目录</span></span><br><span class="line">base_path= /fastdfs/client</span><br><span class="line"><span class="meta"># </span><span class="language-bash">Tracker 端口</span></span><br><span class="line">tracker_server=ip:22122</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Client基础数据目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /fastdfs/client</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-配置Nginx模块"><a href="#6-配置Nginx模块" class="headerlink" title="6. 配置Nginx模块"></a>6. 配置Nginx模块</h3><p>安装配置fastfds-nginx-module模块</p><ol><li>进入 &#x2F;usr&#x2F;local&#x2F;src&#x2F;fastdfs-nginx-module-1.22&#x2F;src&#x2F;</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/fastdfs-nginx-module-1.22/src/</span><br></pre></td></tr></table></figure><ol start="2"><li>编辑配置文件（FastDFS 服务脚本设置的 bin 目录是 &#x2F;usr&#x2F;local&#x2F;bin， 但实际命令安装在 &#x2F;usr&#x2F;bin&#x2F; 下）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim config</span><br><span class="line"><span class="meta"># </span><span class="language-bash">将config文件中的/usr/local替换成/usr</span></span><br><span class="line">:%s+/usr/local+/usr</span><br></pre></td></tr></table></figure><ol start="3"><li>进入 nginx 解压目录，添加fastdfs-nginx-module</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt/newdatadrive/apps/nginx-1.18.0</span><br><span class="line">./configure --add-module=/mnt/newdatadrive/apps/fastdfs/fastdfs-nginx-module-1.22/src/ --with-http_stub_status_module</span><br></pre></td></tr></table></figure><p>若是SSL(https)，没有SSL证书忽略此步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-module=/mnt/newdatadrive/apps/fastdfs/fastdfs-nginx-module-1.22/src/ --with-http_ssl_module</span><br></pre></td></tr></table></figure><ol start="4"><li>编译安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><ol start="5"><li>复制并修改fastdfs-ngin-module中的配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/src/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf /etc/fdfs/</span><br><span class="line">vi /etc/fdfs/mod_fastdfs.conf</span><br><span class="line"></span><br><span class="line">connect_timeout=10</span><br><span class="line">tracker_server=ip:22122</span><br><span class="line">url_have_group_name = true</span><br><span class="line">store_path0=/fastdfs/storage</span><br></pre></td></tr></table></figure><ol start="6"><li>进入fastdfd源码conf目录，将http.conf，mime.types两个文件拷贝到&#x2F;etc&#x2F;fdfs&#x2F;目录下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src/fastdfs-6.06/conf/</span><br><span class="line">cp http.conf mime.types /etc/fdfs/</span><br></pre></td></tr></table></figure><ol start="7"><li>创建一个软连接，在&#x2F;fastdfs&#x2F;storage文件存储目录下创建软连接，将其链接到实际存放数据 的目录（可以省略）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /fastdfs/storage/data/ /fastdfs/storage/data/M00</span><br></pre></td></tr></table></figure><ol start="8"><li>编辑Nginx配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;# 建议修改，防止冲突</span><br><span class="line">    server_name  ip;</span><br><span class="line">    location ~/group([0-9])/M00 &#123;</span><br><span class="line">            root  /fastdfs/storage/data;</span><br><span class="line">            ngx_fastdfs_module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>启动Ngnix</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><h3 id="7-测试"><a href="#7-测试" class="headerlink" title="7. 测试"></a>7. 测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">下载测试图片到本地</span></span><br><span class="line">cd /usr/local/src</span><br><span class="line">wget -c &quot;https://www.caimei365.com/img/base/placeholder.png&quot; -O test.png</span><br><span class="line">/usr/bin/fdfs_upload_file /etc/fdfs/client.conf /usr/local/src/test.png</span><br><span class="line"><span class="meta"># </span><span class="language-bash">得到返回文件名</span></span><br><span class="line">group1/M00/00/00/wKgCZF_YlreAcZCZAAHolZLymZE514.png</span><br></pre></td></tr></table></figure><p>与ip拼接后浏览器访问：<a href="http://192.168.2.100/group1/M00/00/00/wKgCZF_YlreAcZCZAAHolZLymZE514.png">http://192.168.2.100/group1/M00/00/00/wKgCZF_YlreAcZCZAAHolZLymZE514.png</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> FastDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」CentOS 8 常用软件安装(MySQL Nginx SVN Redis)</title>
      <link href="/2020/07/18/env-centos8-apps.html"/>
      <url>/2020/07/18/env-centos8-apps.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-CentOS-8-安装（MySQL8-0-x2F-MySQL5-7"><a href="#1-CentOS-8-安装（MySQL8-0-x2F-MySQL5-7" class="headerlink" title="1. CentOS 8 安装（MySQL8.0&#x2F;MySQL5.7)"></a>1. CentOS 8 安装（MySQL8.0&#x2F;MySQL5.7)</h3><h4 id="1-1-安装-MySQL-8-0"><a href="#1-1-安装-MySQL-8-0" class="headerlink" title="1.1 安装 MySQL 8.0"></a>1.1 安装 MySQL 8.0</h4><h5 id="1-1-1-使用最新的包管理器安装MySQL"><a href="#1-1-1-使用最新的包管理器安装MySQL" class="headerlink" title="1.1.1 使用最新的包管理器安装MySQL"></a>1.1.1 使用最新的包管理器安装MySQL</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install @mysql</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="1-1-2-配置表大小写不敏感"><a href="#1-1-2-配置表大小写不敏感" class="headerlink" title="1.1.2 配置表大小写不敏感"></a>1.1.2 配置表大小写不敏感</h5><p>在首次启动之前要配置表大小写不敏感，这是和 MySQL 7 不一样的地方。</p><p>mysql的配置文件是 &#x2F;etc&#x2F;my.cnf，它 include 了 &#x2F;etc&#x2F;my.cnf.d 目录下的配置，所以在 &#x2F;etc&#x2F;my.cnf.d&#x2F;mysql-server.cnf 配置文件里<code>[mysqld]</code>下面的配置<code>lower_case_table_names=1</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure><h5 id="1-1-3-设置开机启动"><a href="#1-1-3-设置开机启动" class="headerlink" title="1.1.3 设置开机启动"></a>1.1.3 设置开机启动</h5><p>安装完成后，运行以下命令来启动MySQL服务并使它在开机时自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now mysqld</span><br></pre></td></tr></table></figure><p>检查MySQL服务器是否正在运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><h5 id="1-1-4-添加密码及安全设置"><a href="#1-1-4-添加密码及安全设置" class="headerlink" title="1.1.4 添加密码及安全设置"></a>1.1.4 添加密码及安全设置</h5><p>运行mysql_secure_installation脚本，该脚本执行一些与安全性相关的操作并设置MySQL根密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>步骤如下：</p><ol><li>要求你配置VALIDATE PASSWORD component（验证密码组件）： 输入y ，回车进入该配置<ul><li>选择密码验证策略等级， 我这里选择0 （low），回车</li><li>输入新密码两次</li><li>确认是否继续使用提供的密码？输入y ，回车</li><li>移除匿名用户？ 输入y ，回车</li><li>不允许root远程登陆？ 我这里需要远程登陆，所以输入n ，回车</li></ul></li><li>移除test数据库？ 输入y ，回车</li><li>重新载入权限表？ 输入y ，回车</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mysql_secure_installation</span><br><span class="line"></span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line">Connecting to MySQL using a blank password.</span><br><span class="line"></span><br><span class="line">VALIDATE PASSWORD COMPONENT can be used to test passwords</span><br><span class="line">and improve security. It checks the strength of password</span><br><span class="line">and allows the users to set only those passwords which are</span><br><span class="line">secure enough. Would you like to setup VALIDATE PASSWORD component?</span><br><span class="line"></span><br><span class="line">Press y|Y for Yes, any other key for No: y</span><br><span class="line"></span><br><span class="line">There are three levels of password validation policy:</span><br><span class="line">LOW    Length &gt;= 8</span><br><span class="line">MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</span><br><span class="line">STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary                  file</span><br><span class="line"></span><br><span class="line">Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 0</span><br><span class="line">Please set the password for root here.</span><br><span class="line"></span><br><span class="line">New password: </span><br><span class="line">Re-enter new password: </span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 100 </span><br><span class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&#x27;localhost&#x27;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : n</span><br><span class="line"></span><br><span class="line"> ... skipping.</span><br><span class="line">By default, MySQL comes with a database named &#x27;test&#x27; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : n</span><br><span class="line"></span><br><span class="line"> ... skipping.</span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">All done! </span><br></pre></td></tr></table></figure><h5 id="1-1-5-配置远程登陆用户"><a href="#1-1-5-配置远程登陆用户" class="headerlink" title="1.1.5 配置远程登陆用户"></a>1.1.5 配置远程登陆用户</h5><ol><li>本机登录MySQL:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p&lt;上面步骤中设置的密码&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建用户和授权</li></ol><p>在mysql8.0创建用户和授权和之前不太一样了，其实严格上来讲，也不能说是不一样,只能说是更严格,mysql8.0需要先创建用户和设置密码,然后才能授权；<br>将root用户的host字段设为’%’，意为接受root所有IP地址的登录请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#先创建一个用户</span><br><span class="line">use mysql;</span><br><span class="line">create user &#x27;developer&#x27;@&#x27;%&#x27; identified by &#x27;05bZ/OxTB:X+yd%1&#x27;;</span><br><span class="line"> </span><br><span class="line">#再进行授权</span><br><span class="line">grant all privileges on *.* to &#x27;developer&#x27;@&#x27;%&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br><span class="line"># 若用SQLyog连接MySQL8.0出现错误2058，执行如下命令</span><br><span class="line">ALTER USER &#x27;developer&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;05bZ/OxTB:X+yd%1&#x27;;</span><br></pre></td></tr></table></figure><ol start="3"><li>开放防火墙端口3306</li></ol><p>MySQL默认监听3306端口，设置完成后输入exit退出mysql，回到终端shell界面，接着开启系统防火墙的3306端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h5 id="1-1-6-关闭MySQL主机查询dns"><a href="#1-1-6-关闭MySQL主机查询dns" class="headerlink" title="1.1.6 关闭MySQL主机查询dns"></a>1.1.6 关闭MySQL主机查询dns</h5><p>MySQL会反向解析远程连接地址的dns记录，如果MySQL主机无法连接外网，则dns可能无法解析成功，导致第一次连接MySQL速度很慢，所以在配置中可以关闭该功能。<br><a href="https://www.cnblogs.com/liruning/p/7111015.html">参考文档</a><br>打开<code>/etc/my.cnf</code>文件，添加以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure><h5 id="1-1-7-重启服务"><a href="#1-1-7-重启服务" class="headerlink" title="1.1.7 重启服务"></a>1.1.7 重启服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><p>本机测试安装后，MySQL8.0默认已经是utf8mb4字符集，所以字符集不再修改。</p><h4 id="1-2-CentOS-8-安装配置-MySQL-5-7"><a href="#1-2-CentOS-8-安装配置-MySQL-5-7" class="headerlink" title="1.2 CentOS 8 安装配置 MySQL 5.7"></a>1.2 CentOS 8 安装配置 MySQL 5.7</h4><h5 id="1-2-1-添加MySQL存储库"><a href="#1-2-1-添加MySQL存储库" class="headerlink" title="1.2.1 添加MySQL存储库"></a>1.2.1 添加MySQL存储库</h5><p>禁用MySQL默认的存储库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnf remove @mysql</span><br><span class="line">dnf module reset mysql &amp;&amp;  dnf module disable mysql</span><br></pre></td></tr></table></figure><p>CentOS 8没有MySQL5.7存储库，创建一个新的存储库文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/yum.repos.d/mysql-community.repo</span><br></pre></td></tr></table></figure><p>将以下数据粘贴到文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[mysql57-community]</span><br><span class="line">name=MySQL 5.7 Community Server</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-5.7-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[mysql-connectors-community]</span><br><span class="line">name=MySQL Connectors Community</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-connectors-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line"></span><br><span class="line">[mysql-tools-community]</span><br><span class="line">name=MySQL Tools Community</span><br><span class="line">baseurl=http://repo.mysql.com/yum/mysql-tools-community/el/7/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure><h5 id="1-2-2-在CentOS-8-上安装MySQL-5-7"><a href="#1-2-2-在CentOS-8-上安装MySQL-5-7" class="headerlink" title="1.2.2 在CentOS 8 上安装MySQL 5.7"></a>1.2.2 在CentOS 8 上安装MySQL 5.7</h5><p>禁用MySQL 8 存储库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --disable mysql80-community</span><br></pre></td></tr></table></figure><p>然后启用MySQL 5.7存储库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf config-manager --enable mysql57-community</span><br></pre></td></tr></table></figure><p>然后在CentOS 8 上安装MySQL 5.7：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnf install mysql-community-server</span><br></pre></td></tr></table></figure><p>按y开始安装。</p><p>安装完成后检查软件包的转速详细信息，以确认它是5.7。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi mysql-community-server </span><br></pre></td></tr></table></figure><h5 id="1-2-3-在CentOS-8-x2F-RHEL-8上配置MySQL-5-7"><a href="#1-2-3-在CentOS-8-x2F-RHEL-8上配置MySQL-5-7" class="headerlink" title="1.2.3 在CentOS 8 &#x2F; RHEL 8上配置MySQL 5.7"></a>1.2.3 在CentOS 8 &#x2F; RHEL 8上配置MySQL 5.7</h5><p>安装后，启动mysqld服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now mysqld.service</span><br></pre></td></tr></table></figure><p>2.2 –复制为root用户生成的随机密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;A temporary password&#x27;  /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>若没有生成临时密码，执行下面命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /var/lib/mysql</span><br><span class="line">systemctl restart mysqld</span><br><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br><span class="line">2020-12-11T09:41:41.459519Z 1 [Note] A temporary password is generated for root@localhost: #4q0R3/#qmC0</span><br></pre></td></tr></table></figure><p>运行mysql_secure_installation脚本，该脚本执行一些与安全性相关的操作并设置MySQL根密码，<br>可以参考【<em><strong>1.1.3 添加密码及安全设置</strong></em>】及之后的操作。</p><h3 id="2-CentOS-8-安装配置-Nginx"><a href="#2-CentOS-8-安装配置-Nginx" class="headerlink" title="2. CentOS 8 安装配置 Nginx"></a>2. CentOS 8 安装配置 Nginx</h3><h4 id="2-1-下载安装"><a href="#2-1-下载安装" class="headerlink" title="2.1 下载安装"></a>2.1 下载安装</h4><p>官网下载：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a><br>或者直接在linux执行命令：<code>wget http://nginx.org/download/nginx-1.18.0.tar.gz</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br><span class="line"><span class="meta"># </span><span class="language-bash">解压缩</span></span><br><span class="line">tar -zxvf nginx-1.18.0.tar.gz</span><br><span class="line">cd nginx-1.18.0/</span><br><span class="line"><span class="meta"># </span><span class="language-bash">执行配置【没有SSL证书】</span></span><br><span class="line">./configure</span><br><span class="line"><span class="meta"># </span><span class="language-bash"> 执行配置【有SSL证书】</span></span><br><span class="line">./configure --prefix=/usr/local/nginx --with-http_ssl_module</span><br><span class="line"><span class="meta"># </span><span class="language-bash">编译安装(默认安装在/usr/local/nginx)</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>防火墙配置，nginx默认监听80端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>SSL (sslkey存放路径：<code>/usr/local/nginx/conf</code>)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name 【域名】;</span><br><span class="line">    ssl_certificate      sslkey/_.caimei365.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key  sslkey/_.caimei365.com.key;</span><br><span class="line">    ssl_session_timeout  5m;</span><br><span class="line">    ssl_protocols        TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers          AESGCM:ALL:!DH:!EXPORT:!RC4:+HIGH:!MEDIUM:!LOW:!aNULL:!eNULL;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Nginx验证与配置"><a href="#2-2-Nginx验证与配置" class="headerlink" title="2.2 Nginx验证与配置"></a>2.2 Nginx验证与配置</h4><ul><li>测试配置文件：<code>/usr/local/nginx/sbin/nginx -t</code></li><li>nginx主配置文件：<code>/usr/local/nginx/conf/nginx.conf</code></li><li>nginx日志文件：<code>/usr/local/nginx/logs/access.log</code></li><li>启动Nginx：<code>/usr/local/nginx/sbin/nginx</code></li></ul><p>加入环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>最尾输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$JAVA_HOME/bin:/usr/local/nginx/sbin</span><br></pre></td></tr></table></figure><p>使用<code>source /etc/profile</code>命令使配置文件生效。</p><h4 id="2-3-Centos-8-配置Nginx开机自启动"><a href="#2-3-Centos-8-配置Nginx开机自启动" class="headerlink" title="2.3 Centos 8 配置Nginx开机自启动"></a>2.3 Centos 8 配置Nginx开机自启动</h4><ol><li>进入到&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;目录，编辑nginx.service</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /lib/systemd/system/</span><br><span class="line">[root@localhost system]# vim nginx.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=nginx service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">PrivateTmp=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>[Unit]</code>:服务的说明：<br> - Description:描述服务<br> - After:描述服务类别</li><li><code>[Service]</code>服务运行参数的设置：<br> - Type&#x3D;forking是后台运行的形式<br> - ExecStart为服务的具体运行命令<br> - ExecReload为重启命令<br> - ExecStop为停止命令<br> - PrivateTmp&#x3D;True表示给服务分配独立的临时空间<br> - 注意：<code>[Service]</code>的启动、重启、停止命令全部要求使用绝对路径</li><li><code>[Install]</code>运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3</li></ul></blockquote><ol start="2"><li>加入开机自启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service</span><br></pre></td></tr></table></figure><ol start="3"><li>常用命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动nginx服务</span></span><br><span class="line">systemctl start nginx.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止服务</span></span><br><span class="line">systemctl stop nginx.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重新启动服务</span></span><br><span class="line">systemctl restart nginx.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看所有已启动的服务</span></span><br><span class="line">systemctl list-units --type=service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看服务当前状态</span></span><br><span class="line">systemctl status nginx.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置开机自启动</span></span><br><span class="line">systemctl enable nginx.service</span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止开机自启动</span></span><br><span class="line">systemctl disable nginx.service</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-CentOS-8-安装配置-SVN"><a href="#3-CentOS-8-安装配置-SVN" class="headerlink" title="3. CentOS 8 安装配置 SVN"></a>3. CentOS 8 安装配置 SVN</h3><ol><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">安装SVN</span></span><br><span class="line">[root@localhost ~]# yum -y install subversion</span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建目录</span></span><br><span class="line">[root@localhost ~]# mkdir -p /var/svn/svnrepos</span><br><span class="line"><span class="meta"># </span><span class="language-bash">创建版本库(codes为自定义仓库目录)</span></span><br><span class="line">[root@localhost ~]# svnadmin create /var/svn/svnrepos/codes</span><br></pre></td></tr></table></figure></li><li><p>配置</p><ul><li>authz：负责账号权限的管理，控制账号是否读写权限</li><li>passwd：负责账号和密码的用户名单管理</li><li>svnserve.conf：svn服务器配置文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd /var/svn/svnrepos/codes/conf</span><br><span class="line">[root@localhost conf]# ls</span><br><span class="line">authz  passwd  svnserve.conf</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>添加账户，并赋予读写权限，在authz末尾加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]# vim authz</span><br><span class="line">[/]</span><br><span class="line">admin=rw</span><br><span class="line">test1=rw</span><br><span class="line">test2=rw</span><br></pre></td></tr></table></figure><p>设置账户密码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]# vim passwd</span><br><span class="line">[users]</span><br><span class="line"><span class="meta"># </span><span class="language-bash">harry = harryssecret</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">sally = sallyssecret</span></span><br><span class="line">admin = 123456</span><br><span class="line">test1 = 123456</span><br><span class="line">test2 = 123456</span><br></pre></td></tr></table></figure><p>设置svn服务器配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost conf]# vim svnserve.conf</span><br><span class="line">[general]</span><br><span class="line">anon-access = read</span><br><span class="line">auth-access = write</span><br><span class="line"></span><br><span class="line">password-db = passwd</span><br><span class="line"></span><br><span class="line">authz-db = authz</span><br><span class="line"></span><br><span class="line">realm = My First Repository</span><br></pre></td></tr></table></figure><ol start="3"><li>设置开机自启<br>修改&#x2F;etc&#x2F;sysconfig&#x2F;svnserve 将OPTIONS修改为自己的库版本保存目录（保留引号和-r）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/svnserve</span><br><span class="line">OPTIONS=&quot;-r /var/svn/svnrepos&quot;</span><br></pre></td></tr></table></figure></li></ol><p>开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable svnserve.service</span><br></pre></td></tr></table></figure><ol start="4"><li>启动服务<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svnserve -d -r /var/svn/svnrepos</span><br></pre></td></tr></table></figure></li></ol><p>默认端口是3690<br>需要修改监听端口或者监听IP可以通过修改–listen-port和 –listen-host来进行修改</p><p>可以通过svn协议进行访问：<code>svn://[ip]:[port]/codes</code></p><h3 id="4-CentOS-8-安装和配置-Redis"><a href="#4-CentOS-8-安装和配置-Redis" class="headerlink" title="4. CentOS 8 安装和配置 Redis"></a>4. CentOS 8 安装和配置 Redis</h3><ol><li>Redis版本5.0.x包含在默认的CentOS 8存储库中，查询可用的redis安装包：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dnf list redis</span><br><span class="line">上次元数据过期检查：3:04:47 前，执行于 2020年12月21日 星期一 23时03分10秒。</span><br><span class="line">可安装的软件包</span><br><span class="line">redis.x86_64      5.0.3-2.module_el8.2.0+318+3d7e67ea     AppStream</span><br></pre></td></tr></table></figure><ol start="2"><li>执行安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dnf install redis</span><br></pre></td></tr></table></figure><ol start="3"><li>安装完成后，启用并启动Redis服务：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl enable --now redis</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/redis.service → /usr/lib/systemd/system/redis.service.</span><br></pre></td></tr></table></figure><ol start="4"><li><p>检查Redis服务器是否正在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl status redis</span><br></pre></td></tr></table></figure></li><li><p>配置Redis远程访问</p></li></ol><p>修改Redis配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] vim /etc/redis.conf</span><br><span class="line"><span class="comment"># 查找 /bind 找到：bind 127.0.0.1并注释，使其它ip地址也可访问</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：qwe123</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass qwe123</span><br></pre></td></tr></table></figure><p>防火墙配置，Redis默认监听6379端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent &amp;&amp; firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>重新启动Redis服务以使更改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] systemctl restart redis</span><br></pre></td></tr></table></figure><ol start="6"><li>其他服务器远程访问测试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.2.100 -p 6379 -a qwe123</span><br><span class="line">192.168.2.100:6379&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> Nginx </tag>
            
            <tag> MySQL </tag>
            
            <tag> Redis </tag>
            
            <tag> SVN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Centos8安装部署Node+MongDB+YApi(接口管理)</title>
      <link href="/2020/07/15/env-centos8-yapi.html"/>
      <url>/2020/07/15/env-centos8-yapi.html</url>
      
        <content type="html"><![CDATA[<p>YApi:权限管理、Mock服务、可视化接口管理、数据导入（支持postman），其依赖NodeJS+MongDB。<span id="more"></span></p><h3 id="1-安装NodeJS"><a href="#1-安装NodeJS" class="headerlink" title="1. 安装NodeJS"></a>1. 安装NodeJS</h3><ol><li>下载NodeJS稳定版14.15.1</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir -p /local/node-server</span><br><span class="line">[root@localhost ~]# cd /local/node-server</span><br><span class="line">[root@localhost node-server]# wget https://nodejs.org/dist/v14.15.1/node-v14.15.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压下载好的node包到安装目录下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost node-server]# tar xvf node-v14.15.1-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><ol start="3"><li><code>node -v</code>查看版本号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost node-server]# node -v</span><br><span class="line">bash: node: 未找到命令...</span><br><span class="line">[root@localhost node-server]# /local/node-server/node-v14.15.1-linux-x64/bin/node -v</span><br><span class="line">v14.15.1</span><br></pre></td></tr></table></figure><ol start="4"><li>创建软链接，就可以全局使用node和npm命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost node-server]# ln -s /local/node-server/node-v14.15.1-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line">[root@localhost node-server]# ln -s /local/node-server/node-v14.15.1-linux-x64/bin/npm /usr/local/bin/npm</span><br><span class="line">[root@localhost node-server]# node -v</span><br><span class="line">v14.15.1</span><br><span class="line">[root@localhost node-server]# npm -v</span><br><span class="line">6.14.8</span><br></pre></td></tr></table></figure><h3 id="2-安装MongDB"><a href="#2-安装MongDB" class="headerlink" title="2. 安装MongDB"></a>2. 安装MongDB</h3><ol><li>创建yum源文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/yum.repos.d/mongodb-org-4.2.repo</span><br><span class="line"><span class="meta"># </span><span class="language-bash">输入如下内容</span></span><br><span class="line">[mongodb-org-4.2]  </span><br><span class="line">name=MongoDB Repository  </span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/  </span><br><span class="line">gpgcheck=1  </span><br><span class="line">enabled=1  </span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc</span><br></pre></td></tr></table></figure><ol start="2"><li>安装mongodb</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install mongodb-org</span><br></pre></td></tr></table></figure><ol start="3"><li>查看安装目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# whereis mongod</span><br><span class="line">mongod: /usr/bin/mongod /etc/mongod.conf /usr/share/man/man1/mongod.1</span><br></pre></td></tr></table></figure><ol start="4"><li>编辑配置文件<code>/etc/mongod.conf</code>(根据自己需要进行修改bindip地址，可监听127.0.0.1或内网地址。如果需要绑定多个ip )</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/mongod.conf</span><br><span class="line">bindIp: 127.0.0.1,192.168.2.101</span><br></pre></td></tr></table></figure><ol start="4"><li>启动Mongodb</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">启动mongodb</span></span><br><span class="line">systemctl start mongod.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止mongodb</span></span><br><span class="line">systemctl stop mongod.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">查询 mongodb 状态：</span></span><br><span class="line">systemctl status mongod.service</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置为开机启动</span></span><br><span class="line">systemctl enable mongod.service</span><br></pre></td></tr></table></figure><p>如果在不同服务器下访问或者修改端口需要配置防火墙或者阿里云服务器安全组件 默认为27017 如修改可在&#x2F;etc&#x2F;mongod.conf下修改端口，<br>到此安装完成。</p><ol start="5"><li>启动 mongo shell</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mongo</span><br><span class="line">MongoDB shell version v4.2.11</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb</span><br><span class="line"><span class="meta"># </span><span class="language-bash">其他信息省略...</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">bye</span><br></pre></td></tr></table></figure><h3 id="3-安装YApi"><a href="#3-安装YApi" class="headerlink" title="3. 安装YApi"></a>3. 安装YApi</h3><ol><li>开始安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir yapi &amp;&amp; cd yapi</span><br><span class="line">wget http://registry.npm.taobao.org/yapi-vendor/download/yapi-vendor-1.9.2.tgz</span><br><span class="line">tar -zxvf yapi-vendor-1.9.2.tgz</span><br></pre></td></tr></table></figure><ol start="2"><li>拷贝依赖package至vendors</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yapi]# ll</span><br><span class="line">drwxr-xr-x. 9 root root    4096 11月 20 16:18 package</span><br><span class="line">-rw-r--r--. 1 root root 9403779 5月  29 14:14 yapi-vendor-1.9.2.tgz</span><br><span class="line">[root@localhost yapi]# mv package vendors</span><br><span class="line">[root@localhost yapi]# ll</span><br><span class="line">drwxr-xr-x. 9 root root    4096 11月 20 16:18 vendors</span><br><span class="line">-rw-r--r--. 1 root root 9403779 5月  29 14:14 yapi-vendor-1.9.2.tgz</span><br></pre></td></tr></table></figure><ol start="3"><li>安装依赖</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yapi]# cd vendors/</span><br><span class="line">[root@localhost vendors]# npm install --production --registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ol start="4"><li>拷贝配置并修改(MongoDB地址、端口、用户)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vendors]# cd ../</span><br><span class="line">[root@localhost yapi]# cp vendors/config_example.json ./config.json</span><br><span class="line">[root@localhost yapi]# vim config.json</span><br></pre></td></tr></table></figure><ol start="5"><li>安装服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yapi]# cd vendors/</span><br><span class="line">[root@localhost vendors]# npm run install-server</span><br><span class="line">初始化管理员账号成功,账号名：&quot;admin@admin.com&quot;，密码：&quot;ymfe.org&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li>启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vendors]# node server/app.js</span><br><span class="line">log: -------------------------------------swaggerSyncUtils constructor-----------------------------------------------</span><br><span class="line">log: 服务已启动，请打开下面链接访问: </span><br><span class="line">http://127.0.0.1:3000/</span><br></pre></td></tr></table></figure><ol start="7"><li>安装pm管理服务启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost vendors]# npm install pm2 -g</span><br><span class="line"><span class="meta"># </span><span class="language-bash">配置服务启动项</span></span><br><span class="line">[root@localhost vendors]# pm2 start &quot;/local/yapi/vendors/server/app.js&quot; --name yapi</span><br><span class="line"><span class="meta"># </span><span class="language-bash">查看服务信息</span></span><br><span class="line">[root@localhost vendors]# pm2 info yapi</span><br><span class="line"><span class="meta"># </span><span class="language-bash">停止服务</span></span><br><span class="line">[root@localhost vendors]# pm2 stop yapi</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启服务</span></span><br><span class="line">[root@localhost vendors]# pm2 restart yapi</span><br></pre></td></tr></table></figure><blockquote><p>若找不到pm2命令，可先把node安装路径&#x2F;bin添加到环境变量。</p></blockquote><ol start="8"><li>设置开机启动</li></ol><p>运行 pm2 startup，即在&#x2F;etc&#x2F;init.d&#x2F;目录下生成pm2-root的启动脚本，且自动将pm2-root设为服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 startup</span><br></pre></td></tr></table></figure><p>运行 pm2 save，会将当前pm2所运行的应用保存在&#x2F;root&#x2F;.pm2&#x2F;dump.pm2下，当开机重启时，运行pm2-root服务脚本，并且到&#x2F;root&#x2F;.pm2&#x2F;dump.pm2下读取应用并启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 save</span><br></pre></td></tr></table></figure><ol start="9"><li>还可以配合IDEA插件<code>Api Generator</code>使用<ul><li>Preferences → Plugins → Marketplace → 搜索“Api Generator” → 安装该插件 → 重启IDE</li><li><a href="http://forgus.vicp.io/2019/10/28/Api_Generator_introduction/">Api Generator使用教程</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> YApi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Shell」Shell脚本部署Java应用</title>
      <link href="/2020/06/10/env-shell-java.html"/>
      <url>/2020/06/10/env-shell-java.html</url>
      
        <content type="html"><![CDATA[<p>Shell脚本部署Java应用</p><span id="more"></span><h3 id="1-根据PID获取进程信息"><a href="#1-根据PID获取进程信息" class="headerlink" title="1. 根据PID获取进程信息"></a>1. 根据PID获取进程信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Function: 根据用户输入的PID，过滤出该PID所有的信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line">read -p &quot;请输入要查询的PID: &quot; P</span><br><span class="line">n=`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $11&#125;&#x27;|wc -l`</span><br><span class="line">if [ $n -eq 0 ];then</span><br><span class="line"> echo &quot;该PID不存在！&quot;</span><br><span class="line"> exit</span><br><span class="line">fi</span><br><span class="line">echo &quot;--------------------------------&quot;</span><br><span class="line">echo &quot;进程PID: $P&quot;</span><br><span class="line">echo &quot;进程命令：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $11&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;进程所属用户: `ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $1&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;CPU占用率：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $3&#125;&#x27;`%&quot;</span><br><span class="line">echo &quot;内存占用率：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $4&#125;&#x27;`%&quot;</span><br><span class="line">echo &quot;进程开始运行的时刻：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $9&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;进程运行的时间：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $10&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;进程状态：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $8&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;进程虚拟内存：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $5&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;进程共享内存：`ps -aux| awk &#x27;$2~/^&#x27;$P&#x27;$/&#123;print $6&#125;&#x27;`&quot;</span><br><span class="line">echo &quot;--------------------------------&quot;</span><br></pre></td></tr></table></figure><blockquote><p>若执行出现权限不够，为shell文件增加执行权限:<code>chmod +x test.sh</code></p></blockquote><h3 id="2-使用Shell脚本部署Jar包"><a href="#2-使用Shell脚本部署Jar包" class="headerlink" title="2. 使用Shell脚本部署Jar包"></a>2. 使用Shell脚本部署Jar包</h3><p>将跳板机上(或本地服务器)的jar包文件拷贝到发布服务器，然后通过发布服务器上的脚本实现旧jar包的备份，新jar包的启动。</p><ul><li>实现部署的操作：拷贝jar包到服务器 -&gt; 备份旧服务jar包 -&gt; 启动新服务jar包</li><li>使用命令：<code>./begin.sh demo-0.0.1-SNAPSHOT.jar</code></li></ul><ol start="2"><li>跳板机(本地服务器)的脚本begin.sh</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">fileName=$1</span><br><span class="line">if [ -z &quot;$fileName&quot; ]; then</span><br><span class="line">    echo &quot;文件名不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line">echo &quot;开始拷贝jar文件【$fileName】到192.168.2.100&quot;</span><br><span class="line">scp $fileName cmuser@192.168.2.100:/usr/local/test/$fileName.prev</span><br><span class="line">echo &quot;文件传输结束，准备启动192.168.2.100的部署脚本&quot;</span><br><span class="line">ssh cmuser@192.168.2.100 /usr/local/test/demo-deploy.sh $fileName</span><br></pre></td></tr></table></figure><p>通过上面的跳板机上的代码，我们知道跳板机最终会调用发布服务器上<code>/usr/local/test/demo-deploy.sh</code>这个shell脚本命令。</p><ol start="3"><li>发布服务器脚本demo-deploy.sh</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line">echo &quot;服务器开始部署服务&quot;</span><br><span class="line">projectname=&quot;demo&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打开文件所属的目录，不然远程执行会找不到当前目录</span></span><br><span class="line">cd /usr/local/test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">新的jar包会当成参数传过来</span></span><br><span class="line">newJar=$1</span><br><span class="line">echo &quot;新的jar为：$newJar&quot; </span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果新的jar包为空则退出</span></span><br><span class="line">if [ -z &quot;$newJar&quot; ]; then</span><br><span class="line">    echo &quot;新的jar不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取旧的jar包名称，当然可能是空的，也可能跟当前名称一致</span></span><br><span class="line">oldJar=$(ps -ef | grep $&#123;projectname&#125;|grep -v &#x27;demo-deploy.sh&#x27;|grep -v grep|awk &#x27;&#123;print $10&#125;&#x27;|cut -d &#x27;/&#x27; -f 2)</span><br><span class="line">echo &quot;当前运行的旧的jar包为：$oldJar&quot; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果新的jar包为空则退出</span></span><br><span class="line">if [ -z &quot;$oldJar&quot; ]; then</span><br><span class="line">    echo &quot;没有启动的demo服务&quot;</span><br><span class="line">else</span><br><span class="line">    # 如果旧的进程还在就将旧的进程杀掉</span><br><span class="line">    oldId=`ps -ef|grep $&#123;projectname&#125;|grep -v &quot;$0&quot;|grep -v &quot;grep&quot;|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    echo &quot;$oldId&quot;</span><br><span class="line">    echo &quot;kill old process start ...&quot;</span><br><span class="line">    for id in $oldId</span><br><span class="line">    do</span><br><span class="line">        kill -9 $id</span><br><span class="line">        echo &quot;killed $id&quot;</span><br><span class="line">    done</span><br><span class="line">    echo &quot;kill old process end&quot;</span><br><span class="line">    # 获取当前时间戳</span><br><span class="line">    suffix=&quot;.bak-&quot;`date &#x27;+%s%3N&#x27;`;</span><br><span class="line">    echo $suffix;</span><br><span class="line">    # 将旧的jar包进行备份</span><br><span class="line">    mv $oldJar $&#123;oldJar&#125;$&#123;suffix&#125;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">开始启动新的进程</span></span><br><span class="line">mv $&#123;1&#125;.prev $&#123;1&#125;</span><br><span class="line">nohup java -jar $&#123;1&#125; &gt; run.txt 2&gt;&amp;1 &amp;</span><br><span class="line">echo &quot;服务启动查看进程:&quot;</span><br><span class="line">echo `ps -ef | grep $&#123;projectname&#125;|grep -v &#x27;demo-deploy.sh&#x27;|grep -v grep`</span><br></pre></td></tr></table></figure><ol start="4"><li>演示<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">跳板机</span></span><br><span class="line">[cmuser@localhost test]$ ./begin.sh demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">开始拷贝jar文件【demo-0.0.1-SNAPSHOT.jar】到192.168.2.100</span><br><span class="line">cmuser@192.168.2.100&#x27;s password: </span><br><span class="line">demo-0.0.1-SNAPSHOT.jar                                                                                                                                                                                 100%   20MB  11.2MB/s   00:01    </span><br><span class="line">文件传输结束，准备启动192.168.2.100的部署脚本</span><br><span class="line">cmuser@192.168.2.100&#x27;s password: </span><br><span class="line">服务器开始部署服务</span><br><span class="line">新的jar为：demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">当前运行的旧的jar包为：demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">2581</span><br><span class="line">kill old process start ...</span><br><span class="line">killed 2581</span><br><span class="line">kill old process end</span><br><span class="line">.bak-20201117</span><br><span class="line">服务启动查看进程:</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">发布服务器(部署前pid:2581)</span></span><br><span class="line">[cmuser@192.168.2.100 test]$ ps -ef | grep demo</span><br><span class="line">cmuser    2581     1 16 17:03 ?        00:00:06 java -jar demo-0.0.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">[cmuser@192.168.2.100 test]$ ll</span><br><span class="line">total 40260</span><br><span class="line">-rw-rw-r--. 1 cmuser  cmuser  20606107 Nov 18 15:45 demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">-rw-rw-r--. 1 cmuser  cmuser  20606111 Nov 18 15:06 demo-0.0.1-SNAPSHOT.jar.bak-1605685530423</span><br><span class="line">-rwxrwxr-x. 1 jenkins jenkins     1356 Nov 17 17:56 demo-deploy.sh</span><br><span class="line">-rwxrwxrwx. 1 jenkins jenkins     1207 Nov 18 15:45 run.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">发布服务器(部署后:2653)</span></span><br><span class="line">[cmuser@192.168.2.100 test]$ ps -ef | grep demo</span><br><span class="line">cmuser    2653     1 59 17:04 ?        00:00:07 java -jar demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Shell」Shell 文本处理</title>
      <link href="/2020/06/09/env-shell-text.html"/>
      <url>/2020/06/09/env-shell-text.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-文件查找命令"><a href="#1-文件查找命令" class="headerlink" title="1. 文件查找命令"></a>1. 文件查找命令</h3><h4 id="1-1-find命令"><a href="#1-1-find命令" class="headerlink" title="1.1 find命令"></a>1.1 find命令</h4><p>语法格式：<code>find 搜索路径 [选项] 搜索内容</code><span id="more"></span></p><table><thead><tr><th>选项</th><th>解析</th></tr></thead><tbody><tr><td>-name</td><td>按照文件名搜索</td></tr><tr><td>-iname</td><td>按照文件名搜索，不区分文件名大小</td></tr><tr><td>-inum</td><td>按照 inode 号搜索</td></tr><tr><td>-type</td><td>根据文件类型(f:文件,d:目录,c:字符设备文件,b:块设备文件,l:链接文件,p:管道文件)搜索</td></tr><tr><td>-size</td><td>根据文件大小(单位:ckMGTP)搜索，<code>-</code>小于，<code>+</code>大于，例如查找&#x2F;etc目录下大于1M的文件：find &#x2F;etc -size +1M</td></tr><tr><td>-mtime</td><td>根据修改时间(单位:smhdw)搜索</td></tr><tr><td>-ctime</td><td>根据创建时间(单位:smhdw)搜索</td></tr><tr><td>-atime</td><td>根据被访问时的时间间隔(单位:smhdw)搜索</td></tr><tr><td>-mmin</td><td>n分钟以(-n:内，+n:外)内修改的文件</td></tr><tr><td>-mindepth</td><td>从n级子目录开始搜索,最多搜索到n-1级子目录</td></tr><tr><td>-depth</td><td>检索深度为 n 的文件，即位于指定目录以下 n 层的文件</td></tr><tr><td>-empty</td><td>检索空文件或空目录</td></tr><tr><td>-perm</td><td>根据文件权限搜索</td></tr><tr><td>-ls</td><td>打印搜索到的文件的详细信息</td></tr><tr><td>-delete</td><td>删除检索到的文件</td></tr><tr><td>-exec</td><td>对搜索的文件常用操作(“-exec”和”-ok”相似，对文件执行特定的操作，”-ok”得到确认命令后，才会执行；-print打印输出)</td></tr></tbody></table><h4 id="1-2-locate命令"><a href="#1-2-locate命令" class="headerlink" title="1.2 locate命令"></a>1.2 locate命令</h4><ol start="2"><li><code>locate</code>命令，不同于find命令是在整块磁盘中搜索，locate命令是在数据库文件中查找<ul><li>find是默认全局匹配，locate则是默认部分匹配</li><li>文件更新后，用updatedb命令把文件更新到数据库(默认是第二天系统才会自动更新到数据库)，否则locate查找不到</li></ul></li></ol><h4 id="1-3-whereis命令"><a href="#1-3-whereis命令" class="headerlink" title="1.3 whereis命令"></a>1.3 whereis命令</h4><ol start="3"><li><code>whereis</code>命令，只能用于程序名的搜索<ul><li>命令参数：二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</li></ul></li></ol><h4 id="1-4-which命令"><a href="#1-4-which命令" class="headerlink" title="1.4 which命令"></a>1.4 which命令</h4><ol start="4"><li><code>which</code>命令，仅查找二进制程序文件</li></ol><h3 id="2-Linux文本处理三剑客"><a href="#2-Linux文本处理三剑客" class="headerlink" title="2. Linux文本处理三剑客"></a>2. Linux文本处理三剑客</h3><p>文本处理三剑客工具<code>grep</code>，<code>sed</code>和<code>awk</code>都是基于行处理的，它们会一行行读入数据，处理完一行之后再处理下一行。</p><h4 id="2-1-文件处理三剑客之grep"><a href="#2-1-文件处理三剑客之grep" class="headerlink" title="2.1 文件处理三剑客之grep"></a>2.1 文件处理三剑客之grep</h4><p><code>grep</code>命令，用于查找文件里符合条件的字符串。</p><ul><li>语法格式：<ul><li>语法1：<code>grep [option] [ pattern] [file1, file2..]</code></li><li>语法2：<code>command | grep [option] [pattern]</code></li></ul></li></ul><table><thead><tr><th>选项(option)</th><th>解析</th></tr></thead><tbody><tr><td>-v</td><td>不显示匹配行信息</td></tr><tr><td>-i</td><td>搜索时忽略大小写</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-r</td><td>递归搜索</td></tr><tr><td>-E</td><td>支持扩展正则表达式</td></tr><tr><td>-F</td><td>不按正则表达式匹配，按照字符串字面意思匹配</td></tr><tr><td>-c</td><td>只显示匹配行总数</td></tr><tr><td>-w</td><td>匹配整词</td></tr><tr><td>-x</td><td>匹配整行</td></tr><tr><td>-l</td><td>只显示文件名，不显示内容</td></tr><tr><td>-s</td><td>不显示错误信息</td></tr></tbody></table><ul><li><code>grep</code>和<code>egrep</code><ul><li><code>grep</code>默认不支持扩展正则表达式，只支持基础正则表达式</li><li>使用<code>grep-E</code>可以支持扩展正则表达式使用</li><li><code>egrep</code>可以支持扩展正则表达式，与<code>grep-E</code>等价</li></ul></li></ul><h4 id="2-2-文件处理三剑客之sed"><a href="#2-2-文件处理三剑客之sed" class="headerlink" title="2.2 文件处理三剑客之sed"></a>2.2 文件处理三剑客之sed</h4><p><code>sed</code>（Stream Editor），流编辑器。对标准输出或文件逐行进行处理</p><ul><li>语法格式：<ul><li>语法1：<code>stdout |sed [option] &quot;pattern command&quot;</code></li><li>语法2：<code>sed [option] &quot;pattern command&quot; file</code></li></ul></li></ul><h5 id="2-2-1-sed选项"><a href="#2-2-1-sed选项" class="headerlink" title="2.2.1 sed选项"></a>2.2.1 sed选项</h5><table><thead><tr><th>选项(option)</th><th>解析</th></tr></thead><tbody><tr><td>-n</td><td>只打印模式匹配行</td></tr><tr><td>-e</td><td>直接在命令行进行sed编辑，默认选项</td></tr><tr><td>-f</td><td>编辑动作保存在文件中，指定文件执行</td></tr><tr><td>-r</td><td>支持扩展正则表达式</td></tr><tr><td>-i</td><td>直接修改文件内容</td></tr></tbody></table><h5 id="2-2-2-sed匹配模式"><a href="#2-2-2-sed匹配模式" class="headerlink" title="2.2.2 sed匹配模式"></a>2.2.2 sed匹配模式</h5><table><thead><tr><th>匹配模式(pattern)</th><th>解析</th></tr></thead><tbody><tr><td>10command</td><td>匹配到第10行</td></tr><tr><td>10,20command</td><td>匹配从第10行开始，到第20行结束10，</td></tr><tr><td>10,+5command</td><td>匹配从第10行开始，到第16行结束</td></tr><tr><td>&#x2F;pattern1&#x2F;command</td><td>匹配到pattern1的行</td></tr><tr><td>&#x2F;pattern1&#x2F;,&#x2F;pattern2&#x2F;command</td><td>匹配到pattern1的行开始，到匹配到patern2的行结束</td></tr><tr><td>10,&#x2F;pattern1&#x2F;command</td><td>匹配从第10行开始，到匹配到pettern1的行结束</td></tr><tr><td>&#x2F;pattern1&#x2F;,10command</td><td>匹配到pattern1的行开始，到第10行匹配结束</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">打印test.txt文件的第17行</span></span><br><span class="line">sed -n &quot;17p&quot; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印文件的10到20行</span></span><br><span class="line">sed -n &quot;10,20p&quot; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印test.txt文件中从第10行开始，往后面加5行</span></span><br><span class="line">sed -n &quot;10,+5p&quot; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印test.txt文件中以root开头的行</span></span><br><span class="line">sed -n &quot;/^root/p&quot; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印test.txt文件中第一个匹配到以ftp开头的行，到mail开头的行结束</span></span><br><span class="line">sed -n &quot;/^ftp/,/^mail/p&quot; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印test.txt文件中从第4行开始匹配，直到以hdfs开头的行结束</span></span><br><span class="line">sed -n &quot;4,/^hdfs/p&quot; test.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印test.txt文件中匹配root的行，直到第10行结束</span></span><br><span class="line">sed -n &quot;/root/,10p&quot;test.txt</span><br></pre></td></tr></table></figure><h5 id="2-2-3-sed中的编辑命令"><a href="#2-2-3-sed中的编辑命令" class="headerlink" title="2.2.3 sed中的编辑命令"></a>2.2.3 sed中的编辑命令</h5><table><thead><tr><th>编辑命令</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>p</td><td>查询</td><td>打印</td></tr><tr><td>&#x3D;</td><td>查询</td><td>只显示行号</td></tr><tr><td>a</td><td>增加</td><td>行后追加</td></tr><tr><td>i</td><td>增加</td><td>行前追加</td></tr><tr><td>r</td><td>增加</td><td>外部文件读入，行后追加</td></tr><tr><td>w</td><td>增加</td><td>匹配行写入外部文件</td></tr><tr><td>d</td><td>删除</td><td>删除</td></tr><tr><td>s&#x2F;old&#x2F;new</td><td>修改</td><td>将行内第一个old替换为new</td></tr><tr><td>s&#x2F;old&#x2F;new&#x2F;g</td><td>修改</td><td>将行内全部的old替换为new</td></tr><tr><td>s&#x2F;old&#x2F;new&#x2F;2g</td><td>修改</td><td>将行内从第2个old开始到剩下所有的old替换为new</td></tr><tr><td>s&#x2F;old&#x2F;new&#x2F;ig</td><td>修改</td><td>将行内全部的old替换为new，忽略大小写</td></tr></tbody></table><p><strong>反向引用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost test]$ cat abc.txt</span><br><span class="line">First Line</span><br><span class="line">Second haha</span><br><span class="line">[cmuser@localhost test]$ sed -i &#x27;s/Sec..d/&amp;s/g&#x27; abc.txt</span><br><span class="line">[cmuser@localhost test]$ cat abc.txt</span><br><span class="line">First Line</span><br><span class="line">Seconds haha</span><br><span class="line">[cmuser@localhost test]$ sed -i &#x27;s/\(Sec..ds\)/\10/g&#x27; abc.txt</span><br><span class="line">[cmuser@localhost test]$ cat abc.txt</span><br><span class="line">First Line</span><br><span class="line">Seconds0 haha</span><br><span class="line">[cmuser@localhost test]$ sed -i &#x27;s/\(Sec\)...../\1FFFFFFFFFF/g&#x27; abc.txt</span><br><span class="line">[cmuser@localhost test]$ cat abc.txt</span><br><span class="line">First Line</span><br><span class="line">SecFFFFFFFFFF haha</span><br></pre></td></tr></table></figure><ul><li><p><code>&amp;</code>和<code>\1</code>引用模式匹配到的整个串</p><ul><li>两者区别在于只能表示匹配到的完整字符串，只能引用整个字符串；而<code>\1</code>可以使用<code>()</code>匹配到的字符</li></ul></li><li><p>sed中引用变量时注意事项：</p><ol><li>匹配模式中存在变量，则建议使用双引号</li><li>sed中需要引入自定义变量时，如果外面使用单引号，则自定义变量也必须使用单引号</li></ol></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost test]$ old_str=First</span><br><span class="line">[cmuser@localhost test]$ new_str=One</span><br><span class="line">[cmuser@localhost test]$ sed -i &quot;s/$old_str&quot;/&quot;$new_str/g&quot; abc.txt</span><br><span class="line">[cmuser@localhost test]$ cat abc.txt</span><br><span class="line">One Line</span><br><span class="line">SecFFFFFFFFFF haha</span><br></pre></td></tr></table></figure><h5 id="2-2-4-sed实例"><a href="#2-2-4-sed实例" class="headerlink" title="2.2.4 sed实例"></a>2.2.4 sed实例</h5><ol><li>sed查找文件内容（处理一个MySQL配置文件my.cnf的文本，示例如下；编写脚本实现以下功能：输出文件有几个段，并且针对每个段可以统计配置参数总个数）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@caimeidev1 test]$ vim test1.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">FILE_NAME=/etc/my.cnf</span><br><span class="line"></span><br><span class="line">function get_all_segments &#123;</span><br><span class="line">    echo &quot;`sed -n &#x27;/\[.*\]/p&#x27; $FILE_NAME |sed -e &#x27;s/\[//g&#x27; -e &#x27;s/\]//g&#x27;`&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function count_items_in_segment &#123;</span><br><span class="line">    echo &quot;`sed -n &#x27;/\[&#x27;$1&#x27;\]/,/\[.*\]/p&#x27; $FILE_NAME  | grep -v ^# |grep -v ^$ |grep -v &quot;\[.*\]&quot; |wc -l `&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">num=0</span><br><span class="line">for seg in `get_all_segments`</span><br><span class="line">do</span><br><span class="line">    num=`expr $num + 1`</span><br><span class="line">    items_count=`count_items_in_segment $seg`</span><br><span class="line">    echo &quot;$num:$seg  $items_count&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ol><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[jenkins@caimeidev1 test]$ ./test1.sh</span><br><span class="line">1:mysqld  9</span><br><span class="line">2:mysqld_safe  2</span><br><span class="line">3:mysql  1</span><br><span class="line">4:client  1</span><br></pre></td></tr></table></figure><ol start="2"><li>sed删除和修改文件内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">删除文件中的所有注释行和空行</span></span><br><span class="line">sed -i &#x27;/[:blank:]*#/d;/^$/d&#x27; nginx.conf</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在配置文件中所有不以<span class="comment">#开头的行前面添加*符号，注意：以#开头的行不添加</span></span></span><br><span class="line">sed -i &#x27;s/^[^#]/\*&amp;/g&#x27; nginx.conf</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改/etc/passwd中第1行中第1个root为ROOT</span></span><br><span class="line">sed -i &#x27;1s/root/ROOT/&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改/etc/passwd中第5行到第10行中所有的/sbin/nologin为/bin/bash</span></span><br><span class="line">sed -i &#x27;5,10s/\/sbin\/nologin/\/bin\/bash/g&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改/etc/passwd中匹配到/sbin/nologin的行，将匹配到行中的login改为大写的LOGIN</span></span><br><span class="line">sed -i &#x27;/\/sbin\/nologin/s/login/LOGIN/g&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改/etc/passwd中从匹配到以root开头的行，到匹配到行中包含mail的所有行。修改内为将这些所有匹配到的行中的bin改为HADOOP</span></span><br><span class="line">sed -i &#x27;/^root/,/mail/s/bin/HADOOP/g&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改/etc/passwd中从匹配到以root开头的行，到第15行中的所有行，修改内容为将这些行中的nologin修改为SPARK</span></span><br><span class="line">sed -i &#x27;/^root/,15s/nologin/SPARK/g&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">修改/etc/passwd中从第15行开始，到匹配到以yarn开头的所有行，修改内容为将这些行中的bin换位BIN</span></span><br><span class="line">sed -i &#x27;15,/^yarn/s/bin/BIN/g&#x27; passwd </span><br></pre></td></tr></table></figure><ol start="3"><li>sed追加文件内容（a:在匹配行后面追加，i:在匹配行前面追加，r:将文件内容追加到匹配行后面，w:将匹配行写入指定文件）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">a:在匹配行后面追加</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(1)、passwd文件第10行后面追加<span class="string">&quot;Add Line Behind&quot;</span></span></span><br><span class="line">sed -i &#x27;10a Add Line Begind&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(2)、passwd文件第10行到第20行，每一行后面都追加<span class="string">&quot;Test Line Behind&quot;</span></span></span><br><span class="line">sed -i &#x27;10,20a Test Line Behind&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(3)、passwd文件匹配到/bin/bash的行后面追加<span class="string">&quot;Insert Line For /bin/bash Behind&quot;</span></span></span><br><span class="line">sed -i &#x27;/\/bin\/bash/a Insert Line For /bin/bash Behind&#x27; passwd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">i:在匹配行前面追加</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(1)、passwd文件匹配到以yarn开头的行，在匹配行前面追加<span class="string">&quot;Add Line Before&quot;</span></span></span><br><span class="line">sed -i &#x27;/^yarn/i Add Line Before&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(2)、passwd文件每一行前面都追加<span class="string">&quot;Insert Line Before Every Line&quot;</span></span></span><br><span class="line">sed -i &#x27;i Insert Line Before Every Line&#x27; passwd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">r:将文件内容追加到匹配行后面</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(1)、将/etc/fstab文件的内容追加到passwd文件的第20行后面</span></span><br><span class="line">sed -i &#x27;20r /etc/fstab&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(2)、将/etc/inittab文件内容追加到passwd文件匹配/bin/bash行的后面</span></span><br><span class="line">sed -i &#x27;/\/bin\/bash/r /etc/inittab&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(3)、将/etc/vconsole.conf文件内容追加到passwd文件中特定行后面，匹配以ftp开头的行，到第18行的所有行</span></span><br><span class="line">sed -i &#x27;//,18r /etc/vconsole.conf&#x27; passwd</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">w:将匹配行写入指定文件</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">(1)、将passwd文件匹配到/bin/bash的行追加到/tmp/sed.txt文件中</span></span><br><span class="line">sed -i &#x27;/\/bin\/bash/w /tmp/sed.txt&#x27; passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">(2)、将passwd文件从第10行开始，到匹配到hdfs开头的所有行内容追加到/tmp/sed-1.txt</span></span><br><span class="line">sed -i &#x27;10,/^hdfs/w /tmp/sed-1.txt&#x27; passwd</span><br></pre></td></tr></table></figure><h4 id="2-3-文件处理三剑客之awk"><a href="#2-3-文件处理三剑客之awk" class="headerlink" title="2.3 文件处理三剑客之awk"></a>2.3 文件处理三剑客之awk</h4><p><code>awk</code>是一个文本处理工具，通常用于处理数据并生成结果报告</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN&#123;&#125; pattern&#123;commands&#125;END&#123;&#125;&#x27; file_name</span><br><span class="line">standard output | awk &#x27;BEGIN&#123;&#125;pattern&#123;commands&#125;END&#123;&#125;&#x27;</span><br></pre></td></tr></table></figure><table><thead><tr><th>语法格式</th><th>解析</th></tr></thead><tbody><tr><td>BEGIN{}</td><td>正式处理数据之前执行</td></tr><tr><td>pattern</td><td>匹配模式</td></tr><tr><td>{commands}</td><td>处理命令，可能多行</td></tr><tr><td>END{}</td><td>处理完所有匹配数据后执行</td></tr></tbody></table><h5 id="2-3-1-awk内置变量"><a href="#2-3-1-awk内置变量" class="headerlink" title="2.3.1 awk内置变量"></a>2.3.1 awk内置变量</h5><table><thead><tr><th>内置变量</th><th>解析</th></tr></thead><tbody><tr><td>$0</td><td>打印行所有信息</td></tr><tr><td>$1~$n</td><td>打印行的第1到n个字段的信息</td></tr><tr><td>NF</td><td>Number Field 处理行的字段个数</td></tr><tr><td>NR</td><td>Number Row 处理行的行号，从1开始计数</td></tr><tr><td>FNR</td><td>File Number Row 多文件处理时，每个文件单独记录行号，都是从0康凯斯</td></tr><tr><td>FS</td><td>Field Separator 字段分割符，不指定时默认以空格或tab键分割</td></tr><tr><td>RS</td><td>Row Separator 行分隔符，不指定时以回车分割\n</td></tr><tr><td>OFS</td><td>Output Filed Separator 输出字段分隔符。</td></tr><tr><td>ORS</td><td>Output Row Separator 输出行分隔符</td></tr><tr><td>FILENAME</td><td>处理文件的文件名</td></tr><tr><td>ARGC</td><td>命令行参数个数</td></tr><tr><td>ARGV</td><td>命令行参数数组</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost test]$ awk &#x27;&#123;print $0&#125;&#x27; abc.txt</span><br><span class="line">One Line</span><br><span class="line">SecFFFFFFFFFF haha</span><br><span class="line">[cmuser@localhost test]$ awk &#x27;&#123;print $1&#125;&#x27; abc.txt</span><br><span class="line">One</span><br><span class="line">SecFFFFFFFFFF</span><br><span class="line">[cmuser@localhost test]$ awk &#x27;&#123;print NR&#125;&#x27; abc.txt</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="2-3-2-awk格式化输出之printf"><a href="#2-3-2-awk格式化输出之printf" class="headerlink" title="2.3.2 awk格式化输出之printf"></a>2.3.2 awk格式化输出之printf</h5><table><thead><tr><th>格式符</th><th>解析</th></tr></thead><tbody><tr><td>%s</td><td>打印字符串</td></tr><tr><td>%d</td><td>打印10进制数</td></tr><tr><td>%f</td><td>打印浮点数</td></tr><tr><td>%x</td><td>打印16进制数</td></tr><tr><td>%o</td><td>打印8进制数</td></tr><tr><td>%e</td><td>打印数字的科学计数法格式</td></tr><tr><td>%c</td><td>打印单个字符的ASCII码</td></tr></tbody></table><table><thead><tr><th>修饰符</th><th>解析</th></tr></thead><tbody><tr><td>-</td><td>左对齐</td></tr><tr><td>+</td><td>右对齐</td></tr><tr><td>#</td><td>显示8进制在前面加o，显示16进制在前面加0x</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">1、以字符串格式打印/etc/passwd中的第7个字段，以<span class="string">&quot;:&quot;</span>作为分隔符</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf &quot;%s\n&quot;,$7&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">2、以10进制格式打印/etc/passwd中的第3个字段，以<span class="string">&quot;:&quot;</span>作为分隔符</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf &quot;%d\n&quot;,$3&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">3、以浮点数格式打印/etc/passwd中的第3个字段，以<span class="string">&quot;:&quot;</span>作为分隔符</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf &quot;%0.3f\n&quot;,$3&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">4、以16进制数格式打印/etc/passwd中的第3个字段，以<span class="string">&quot;:&quot;</span>作为分隔符</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf &quot;%#x\n&quot;,$3&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">5、以8进制数格式打印/etc/passwd中的第3个字段，以<span class="string">&quot;:&quot;</span>作为分隔符</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf &quot;%#o\n&quot;,$3&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">6、以科学计数法格式打印/etc/passwd中的第3个字段，以<span class="string">&quot;:&quot;</span>作为分隔符</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;printf &quot;%e\n&quot;,$3&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><h5 id="2-3-3-awk模式匹配的两种用法"><a href="#2-3-3-awk模式匹配的两种用法" class="headerlink" title="2.3.3 awk模式匹配的两种用法"></a>2.3.3 awk模式匹配的两种用法</h5><ul><li><code>awk</code>模式匹配：<ol><li><code>RegExp</code>：按正则表达式匹配</li><li><code>关系运算匹配</code>：按关系运算匹配</li></ol></li></ul><ol><li>RegExp(正则表达式匹配)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">匹配/etc/passwd文件行中含有root字符串的所有行</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;/root/&#123;print $0&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">匹配/etc/passwd文件行中以yarn开头的所有行</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;/^yarn/&#123;print $0&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><ol start="2"><li>运算符匹配(<code>&lt;</code>:小于，<code>&gt;</code>:大于，<code>&lt;=</code>:小于等于，<code>&gt;=</code>:大于等于，<code>==</code>:等于，<code>!=</code>:不等于，<code>~</code>:匹配正则表达式，<code>!~</code>:不匹配正则表达式)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd文件中第3个字段小于50的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$3&lt;50&#123;print $0&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd文件中第3个字段大于50的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$3&gt;50&#123;print $0&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd文件中第7个字段为/bin/bash的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$7==&quot;/bin/bash&quot;&#123;print $0&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd文件中第7个字段不为/bin/bash的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$7!=&quot;/bin/bash&quot;&#123;print $0&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd中第3个字段包含3个以上数字的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$3~/[0-9]&#123;3,&#125;/&#123;print $0&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><ol start="3"><li>布尔运算符匹配(<code>||</code>:或，<code>&amp;&amp;</code>:与，<code>!</code>:非)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd文件中包含hdfs或yarn的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$1==&quot;hdfs&quot; || $1==&quot;yarn&quot; &#123;print $0&#125;&#x27; /etc/passwd</span><br><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，匹配/etc/passwd文件中第3个字段小于50并且第4个字段大于50的所有行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;$3&lt;50 &amp;&amp; $4&gt;50 &#123;print $0&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><h5 id="2-3-4-awk表达式用法"><a href="#2-3-4-awk表达式用法" class="headerlink" title="2.3.4 awk表达式用法"></a>2.3.4 awk表达式用法</h5><table><thead><tr><th>运算符</th><th>解析</th></tr></thead><tbody><tr><td><code>+</code></td><td>加</td></tr><tr><td><code>/</code></td><td>除</td></tr><tr><td><code>%</code></td><td>模</td></tr><tr><td><code>^</code>或<code>**</code></td><td>乘方</td></tr><tr><td><code>++x</code></td><td>在返回x变量之前，×变量加1</td></tr><tr><td><code>X++</code></td><td>在返回x变量之后，×变量加1</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">使用awk计算/etc/services中的空白行数量</span></span><br><span class="line">awk &#x27;/^$/&#123;sum++&#125;END&#123;print sum&#125;&#x27; /etc/services</span><br></pre></td></tr></table></figure><h5 id="2-3-5-awk动作中的条件及循环语句"><a href="#2-3-5-awk动作中的条件及循环语句" class="headerlink" title="2.3.5 awk动作中的条件及循环语句"></a>2.3.5 awk动作中的条件及循环语句</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">以:为分隔符，只打印/etc/passwd中第3个字段的数值在50-100范围内的行信息</span></span><br><span class="line">awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;</span><br><span class="line">    if($3&lt;50)&#123; </span><br><span class="line">        printf &quot;%-20s%-20s%-5d\n&quot;,&quot;小于50的UID&quot;,$1,$3</span><br><span class="line">    &#125; else if($3&gt;100) &#123;</span><br><span class="line">        printf &quot;%-20s%-20s%-5d\n&quot;,&quot;大 于100的UID&quot;,$1,$3</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        printf &quot;%-20s%-20s%-5d\n&quot;,&quot;大于50 小于100的UID&quot;,$1,$3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27; /etc/passwd</span><br></pre></td></tr></table></figure><h5 id="2-3-6-awk中的字符串函数"><a href="#2-3-6-awk中的字符串函数" class="headerlink" title="2.3.6 awk中的字符串函数"></a>2.3.6 awk中的字符串函数</h5><table><thead><tr><th>函数名</th><th>解析</th></tr></thead><tbody><tr><td>length(str)</td><td>计算长度</td></tr><tr><td>index(str1,str2)</td><td>返回在str1中查询到的str2的位置</td></tr><tr><td>tolower(str)</td><td>小写转换</td></tr><tr><td>toupper(str)</td><td>大写转换</td></tr><tr><td>split(str,arr,fs)</td><td>分隔字符串，并保存到数组中</td></tr><tr><td>match(str,RE)</td><td>返回正则表达式匹配到的子串的位置</td></tr><tr><td>substr(str,m,n)</td><td>截取子串，从m个字符开始，截取n位。n若不指定，则默认截取到字符串尾</td></tr><tr><td>sub(RE,RepStr,str)</td><td>替换查找到的第一个子串</td></tr><tr><td>gsub(RE,RepStr,str)</td><td>替换查找到的所有子串</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">搜索字符串<span class="string">&quot;I have a dream&quot;</span>中出现<span class="string">&quot;ea&quot;</span>子串的位置</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;I hava a dream&quot;;location=index(str,&quot;ea&quot;);print location&#125;</span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;I hava a dream&quot;;location=match(str,&quot;ea&quot;);print location&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">将字符串<span class="string">&quot;Hadoop is a bigdata Framawork&quot;</span>全部转换为小写</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;Hadoop is a bigdata Framework&quot;;print tolower(str)&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">将字符串<span class="string">&quot;Hadoop is a bigdata Framawork&quot;</span>全部转换为大写</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;Hadoop is a bigdata Framework&quot;;print toupper(str)&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">将字符串<span class="string">&quot;Hadoop Kafka Spark Storm HDFS YARN Zookeeper&quot;</span>，按照空格为分隔符，分隔每部分保存到数组array中</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;Hadoop Kafka Spark Storm HDFS YARN Zookeeper&quot;;split(str,arr,&quot; &quot;);for(a in arr) print arr[a]&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">搜索字符串<span class="string">&quot;Tranction 2345 Start:Select * from master&quot;</span>第一个数字出现的位置</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;Tranction 2345 Start:Select * from master&quot;;location=match(str,/[0-9]/);print location&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">截取字符串<span class="string">&quot;transaction start&quot;</span>的子串，截取条件从第4个字符开始，截取5位</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;transaction start&quot;;print substr(str,4,5)&#125;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">替换字符串<span class="string">&quot;Tranction 243 Start,Event ID:9002&quot;</span>中第一个匹配到的数字串为$符号</span></span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;Tranction 243 Start,Event ID:9002&quot;;count=sub(/[0-9]+/,&quot;$&quot;,str);print count,str&#125;&#x27;</span><br><span class="line">awk &#x27;BEGIN&#123;str=&quot;Tranction 243 Start,Event ID:9002&quot;;count=gsub(/[0-9]+/,&quot;$&quot;,str);print count,str&#125;&#x27;</span><br></pre></td></tr></table></figure><h5 id="2-3-7-awk的常用选项"><a href="#2-3-7-awk的常用选项" class="headerlink" title="2.3.7 awk的常用选项"></a>2.3.7 awk的常用选项</h5><table><thead><tr><th>选项</th><th>解析</th></tr></thead><tbody><tr><td>-v</td><td>参数传递</td></tr><tr><td>-f</td><td>指定脚本文件</td></tr><tr><td>-F</td><td>指定分隔符</td></tr><tr><td>-V</td><td>查看awk的版本号</td></tr></tbody></table><h5 id="2-3-8-awk中数组的用法"><a href="#2-3-8-awk中数组的用法" class="headerlink" title="2.3.8 awk中数组的用法"></a>2.3.8 awk中数组的用法</h5><p>在awk中，使用数组时，不仅可以使用1.2…n作为数组下标，也可以使用字符串作为数组下标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">打印元素：</span></span><br><span class="line">echo $&#123;array[2]&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印元素个数：</span></span><br><span class="line">echo $&#123;#array[@]&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打印元素长度：</span></span><br><span class="line">echo $&#123;#array[3]&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">给元素赋值：</span></span><br><span class="line">array[3]=&quot;Li&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">删除元素：</span></span><br><span class="line">unset array[2];unset array</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">分片访问：</span></span><br><span class="line">echo $&#123;array[@]:1:3&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">元素内容替换：</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">&#123;array[@]/e/E&#125;只替换第一个e；</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">tarray[@]//e/E&#125;替换所有的e</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">数组的遍历：</span></span><br><span class="line">for a in array </span><br><span class="line">do</span><br><span class="line">echo $a </span><br><span class="line">done </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">使用字符串作为数组下标</span></span><br><span class="line">array[&quot;var1&quot;]=&quot;Jin&quot;</span><br><span class="line">array[&quot;var2&quot;]=&quot;Hao&quot;</span><br><span class="line">array[&quot;var3&quot;]=&quot;Fang&quot;</span><br><span class="line">for(a in array)</span><br><span class="line">print array[a]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">统计主机上所有的TCP连接状态数，按照每个TCP状态分类</span></span><br><span class="line">netstat -an | grep tcp | awk &#x27;&#123;array[$6]++&#125; END&#123;for(a in array) print a,array[a]&#125;&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Shell」Shell 函数的用法</title>
      <link href="/2020/06/08/env-shell-function.html"/>
      <url>/2020/06/08/env-shell-function.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Shell-函数定义"><a href="#1-Shell-函数定义" class="headerlink" title="1. Shell 函数定义"></a>1. Shell 函数定义</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function name() &#123;</span><br><span class="line">    # 函数要执行的代码</span><br><span class="line">    [return value]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的简化写法可以省略<code>function</code>或<code>()</code>之一，不过还是推荐标准写法，才能做到做到“见名知意”。<span id="more"></span></p><h3 id="2-Shell函数调用"><a href="#2-Shell函数调用" class="headerlink" title="2. Shell函数调用"></a>2. Shell函数调用</h3><p>调用 Shell 函数时可以给它传递参数，也可以不传递。如果不传递参数，直接给出函数名字即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name</span><br></pre></td></tr></table></figure><p>如果传递参数，那么多个参数之间以空格分隔：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name param1 param2 param3</span><br></pre></td></tr></table></figure><ul><li>不管是哪种形式，函数名字后面都不需要带括号。</li><li>和其它编程语言不同的是，Shell 函数在定义时不能指明参数，但是在调用时却可以传递参数，并且给它传递什么参数它就接收什么参数。</li><li>Shell 也不限制定义和调用的顺序，你可以将定义放在调用的前面，也可以反过来，将定义放在调用的后面。</li></ul><p>定义一个函数，计算所有参数的和：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost ~]$ #!/bin/bash</span><br><span class="line">[cmuser@localhost ~]$ function getsum()&#123;</span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">local</span> <span class="built_in">sum</span>=0</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="variable">$@</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">        ((<span class="built_in">sum</span>+=n))</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">return</span> <span class="variable">$sum</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line">[cmuser@localhost ~]$ getsum 10 20 55 15</span><br><span class="line">[cmuser@localhost ~]$ echo $?</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="3-Shell函数参数"><a href="#3-Shell函数参数" class="headerlink" title="3. Shell函数参数"></a>3. Shell函数参数</h3><p>函数参数是 Shell 位置参数的一种，在函数内部可以使用<code>$n</code>来接收，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数，依次类推。</p><p>除了<code>$n</code>，还有另外三个比较重要的变量：</p><ul><li><code>$#</code>可以获取传递的参数的个数；</li><li><code>$@</code>或者<code>$*</code>可以一次性获取所有的参数。</li></ul><p>使用 $n 来接收函数参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost ~]$ #!/bin/bash</span><br><span class="line"><span class="meta"># </span><span class="language-bash">定义函数</span></span><br><span class="line">[cmuser@localhost ~]$ function show()&#123;</span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;Tutorial: <span class="variable">$1</span>&quot;</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;URL: <span class="variable">$2</span>&quot;</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;Author: &quot;</span><span class="variable">$3</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;Total <span class="variable">$#</span> parameters&quot;</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">调用函数</span></span><br><span class="line">[cmuser@localhost ~]$ show test www.test.com Tom</span><br><span class="line">Tutorial: test</span><br><span class="line">URL: www.test.com</span><br><span class="line">Author: Tom</span><br><span class="line">Total 3 parameters</span><br></pre></td></tr></table></figure><p>使用 $@ 来遍历函数参数，计算所有参数的和：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost ~]$ #!/bin/bash</span><br><span class="line"><span class="meta"># </span><span class="language-bash">定义函数</span></span><br><span class="line">[cmuser@localhost ~]$ function getsum()&#123;</span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">local</span> <span class="built_in">sum</span>=0</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="variable">$@</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">        ((<span class="built_in">sum</span>+=n))</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">echo</span> <span class="variable">$sum</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">return</span> 0</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">调用函数</span></span><br><span class="line">[cmuser@localhost ~]$ echo $(getsum 10 20 55 15)</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="4-Shell函数返回值"><a href="#4-Shell函数返回值" class="headerlink" title="4. Shell函数返回值"></a>4. Shell函数返回值</h3><p>Shell中的<code>return</code>返回值表示的是函数的退出状态：返回值为<code>0</code>表示函数执行成功了，返回值为<code>非 0 </code>表示函数执行失败（出错）了。if、while、for 等语句都是根据函数的退出状态来判断条件是否成立。</p><p>Shell 函数的返回值只能是一个介于<code>0~255</code>之间的整数，其中只有<code>0</code>表示成功，其它值都表示失败。</p><p>如果函数体中没有return语句，那么使用默认的退出状态，也就是最后一条命令的退出状态。更加严谨的写法为：<code>return $?</code>。<br>$?是一个特殊变量，用来获取上一个命令的退出状态，或者上一个函数的返回值。</p><ul><li>如何得到函数的处理结果？<ol><li>借助全局变量，将得到的结果赋值给全局变量；</li><li>在函数内部使用 <code>echo</code>、<code>printf</code> 命令将结果输出，在函数外部使用<code>$()</code>或者<code>`</code>捕获结果。</li></ol></li></ul><p>具体来定义一个函数 getsum，计算从 m 加到 n 的和，并使用以上两种解决方案。</p><ol><li>【实例1】将函数处理结果赋值给一个全局变量。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost ~]$ #!/bin/bash</span><br><span class="line">[cmuser@localhost ~]$ sum=0                # 全局变量</span><br><span class="line">[cmuser@localhost ~]$ function getsum()&#123;</span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">for</span>((i=<span class="variable">$1</span>; i&lt;=<span class="variable">$2</span>; i++)); <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">        ((<span class="built_in">sum</span>+=i))</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">return</span> $?                            <span class="comment"># 返回上一条命令的退出状态</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line">[cmuser@localhost ~]$ getsum 1 100</span><br><span class="line">[cmuser@localhost ~]$ echo &quot;The sum is $sum&quot; # 输出全局变量</span><br><span class="line">The sum is 5050</span><br></pre></td></tr></table></figure><ol start="2"><li>【实例2】在函数内部使用 echo 输出结果。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost ~]$ function getsum()&#123;</span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">local</span> <span class="built_in">sum</span>=0                         <span class="comment"># 局部变量</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">for</span>((i=<span class="variable">$1</span>; i&lt;=<span class="variable">$2</span>; i++)); <span class="keyword">do</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">        ((<span class="built_in">sum</span>+=i))</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">echo</span> <span class="variable">$sum</span></span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">    <span class="built_in">return</span> $?</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">&#125;</span></span><br><span class="line">[cmuser@localhost ~]$ echo &quot;The sum is &quot;$(getsum 1 100)</span><br><span class="line">The sum is 5050</span><br></pre></td></tr></table></figure>代码中总共执行了两次 <code>echo</code> 命令，但是却只输出一次，这是因为<code>$()</code>捕获了第一个 <code>echo</code> 的输出结果，它并没有真正输出到终端上。除了<code>$()</code>，你也可以使用<code>`</code>来捕获 <code>echo</code> 的输出结果。</li></ol><h3 id="5-Shell函数库的使用"><a href="#5-Shell函数库的使用" class="headerlink" title="5. Shell函数库的使用"></a>5. Shell函数库的使用</h3><p>shell函数库实质为一个脚本，脚本内包含了多个函数（函数具有普遍适用性），经常使用的重复代码封装成库函数文件。</p><p>库函数一般不直接执行，而是由其他脚本调用，库函数文件名的后缀是任意的，但一般使用<code>.lib</code>，库文件通常没有可执行权限。</p><p>第一行一般使用#!&#x2F;bin&#x2F;echo，输出警告信息，避免用户执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost test]$ vim base.lib </span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/usr/bin/echo</span></span><br><span class="line"></span><br><span class="line">add()&#123;</span><br><span class="line">    echo &quot;$(expr $1 + $2)&quot;</span><br><span class="line">&#125;</span><br><span class="line">reduce()&#123;</span><br><span class="line">    echo &quot;$(expr $1 - $2)&quot;</span><br><span class="line">&#125;</span><br><span class="line">multiple()&#123;</span><br><span class="line">    echo &quot;$(expr $1 \* $2)&quot;</span><br><span class="line">&#125;</span><br><span class="line">divide()&#123;</span><br><span class="line">    echo &quot;$(expr $1 / $2)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost test]$ vim calculate.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">加载函数库文件</span></span><br><span class="line">source ./base</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">调用函数，传入参数</span></span><br><span class="line">add $1 $2</span><br><span class="line">reduce $1 $2</span><br><span class="line">multiple $1 $2</span><br><span class="line">divide $1 $2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[cmuser@localhost test]$ sh calculate.sh 40 5</span><br><span class="line">45</span><br><span class="line">35</span><br><span class="line">200</span><br><span class="line">8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Shell」Shell 变量的用法与数学运算</title>
      <link href="/2020/06/07/env-shell-variable.html"/>
      <url>/2020/06/07/env-shell-variable.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-变量替换"><a href="#1-变量替换" class="headerlink" title="1. 变量替换"></a>1. 变量替换</h3><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td><code>$&#123;变量#匹配规则&#125;</code></td><td>从变量<strong>开头</strong>进行规则匹配，将符合<strong>最短</strong>的数据删除</td></tr><tr><td><code>$&#123;变量##匹配规则&#125;</code></td><td>从变量<strong>开头</strong>进行规则匹配，将符合<strong>最长</strong>的数据删除【贪婪模式】</td></tr><tr><td><code>$&#123;变量%匹配规则&#125;</code></td><td>从变量<strong>尾部</strong>进行规则匹配，将符合<strong>最短</strong>的数据删除</td></tr><tr><td><code>$&#123;变量%%匹配规则&#125;</code></td><td>从变量<strong>尾部</strong>进行规则匹配，将符合<strong>最长</strong>的数据删除【贪婪模式】</td></tr><tr><td><code>$&#123;变量/旧字符串/新字符串&#125;</code></td><td>变量内容符合旧字符串，则<strong>第一个</strong>旧字符串会被新字符串取代</td></tr><tr><td><code>$&#123;变量//旧字符串/新字符串&#125;</code></td><td>变量内容符合旧字符串，则<strong>全部的</strong>旧字符串会被新字符串取代</td></tr></tbody></table><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[chao@localhost ~]$ var1=&quot;I love you, Do you love me&quot;</span><br><span class="line">[chao@localhost ~]$ echo $var1</span><br><span class="line">I love you, Do you love me</span><br><span class="line"><span class="meta"># </span><span class="language-bash">头部匹配删除</span></span><br><span class="line">[chao@localhost ~]$ var2=$&#123;var1#*ov&#125;</span><br><span class="line">[chao@localhost ~]$ echo $var2</span><br><span class="line">e you, Do you love me</span><br><span class="line">[chao@localhost ~]$ var3=$&#123;var1##*ov&#125;  # 贪婪模式</span><br><span class="line">[chao@localhost ~]$ echo $var3</span><br><span class="line">e me</span><br><span class="line"><span class="meta"># </span><span class="language-bash">尾部匹配删除</span></span><br><span class="line">[chao@localhost ~]$ var4=$&#123;var1%ov*&#125;</span><br><span class="line">[chao@localhost ~]$ echo $var4</span><br><span class="line">I love you, Do you l</span><br><span class="line">[chao@localhost ~]$ var5=$&#123;var1%%ov*&#125;  # 贪婪模式</span><br><span class="line">[chao@localhost ~]$ echo $var5</span><br><span class="line">I l</span><br><span class="line"><span class="meta"># </span><span class="language-bash">替换</span></span><br><span class="line">[chao@localhost ~]$ var6=$&#123;var1/love/hate&#125;</span><br><span class="line">[chao@localhost ~]$ echo $var6</span><br><span class="line">I hate you, Do you love me</span><br><span class="line">[chao@localhost ~]$ var7=$&#123;var1//love/hate&#125;</span><br><span class="line">[chao@localhost ~]$ echo $var7</span><br><span class="line">I hate you, Do you hate me</span><br></pre></td></tr></table></figure><h3 id="2-字符串相关操作"><a href="#2-字符串相关操作" class="headerlink" title="2. 字符串相关操作"></a>2. 字符串相关操作</h3><ol><li>计算字符串的长度</li></ol><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>&#96;$</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Shell」Shell 编程入门</title>
      <link href="/2020/06/06/env-shell-base.html"/>
      <url>/2020/06/06/env-shell-base.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Shell概述"><a href="#1-Shell概述" class="headerlink" title="1. Shell概述"></a>1. Shell概述</h3><ol><li>Shell简介<ul><li>shell是操作系统提供给我们用户来访问系统资源的一个<strong>接口</strong>。</li><li>shell同时还是一个Linux下的<strong>命令行解释器</strong>，类似Windows下的cmd。</li><li>shell 同时还是解释型的脚本语言：运行时翻译，执行一条语句翻译一条，每次执行程序都需要进行解释。<span id="more"></span></li></ul></li><li>Shell的发展<ul><li>shell有多个版本：Bourne Shell，C Shell，Korn Shell，Bash Shell。现在广泛使用的是 Bash Shell，也就是Linux中默认内嵌的Shell。</li></ul></li><li>Shell脚本<ul><li><code>Shell脚本</code>(shell script)，是一种为Shell编写的脚本程序。</li></ul></li></ol><h3 id="2-Shell变量基础"><a href="#2-Shell变量基础" class="headerlink" title="2. Shell变量基础"></a>2. Shell变量基础</h3><h4 id="2-1-Shell变量的分类"><a href="#2-1-Shell变量的分类" class="headerlink" title="2.1 Shell变量的分类"></a>2.1 Shell变量的分类</h4><ol><li>用户自定义变量：由用户自己定义，修改和使用的变量</li><li>Shell环境变量：用于<strong>设置shell的运行环境</strong>，只要少数的环境变量可以修改其值。环境变量也是可以自定义的。</li><li>位置参数变量：通过命令行给脚本传递参数，<strong>变量名已经固定</strong>，不能自定义。</li><li>内部参数变量：是<strong>bash中已经定义好的变量</strong>，变量名不能自定义，变量作用也是固定的。</li></ol><h4 id="2-2-变量赋值与设置"><a href="#2-2-变量赋值与设置" class="headerlink" title="2.2 变量赋值与设置"></a>2.2 变量赋值与设置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">赋值有两种格式</span></span><br><span class="line">var1=value</span><br><span class="line">var2=`command`      # 注意：command是可以执行的命令</span><br><span class="line"><span class="meta"># </span><span class="language-bash">清除变量 与 设置只读</span></span><br><span class="line">unset var1          # 清除var1变量</span><br><span class="line">readonly var2       # 设置var2变量为只读</span><br><span class="line"><span class="meta"># </span><span class="language-bash">变量的引用有两种方式（使用时加美元符号）</span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">var1               <span class="comment"># $变量名</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">&#123;var1&#125;             <span class="comment"># $&#123;变量名&#125;</span></span></span><br></pre></td></tr></table></figure><h4 id="2-3-位置参数变量"><a href="#2-3-位置参数变量" class="headerlink" title="2.3 位置参数变量"></a>2.3 位置参数变量</h4><p>位置参数变量是一种特殊的shell变量，用于从命令行向脚本中传递参数。<br>$0表示脚本的名称，$1表示第一个参数，$2表示第二个参数，依次下去代表第几个参数，<br>但是从第十个参数位开始表示方法有所改变，需要加大括号，例如：${10}，${11}</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chao@localhost ~]$ ls anaconda-ks.cfg install.log install.log.syslog</span><br></pre></td></tr></table></figure><blockquote><p><code>$0</code>的值就是<code>ls</code>命令本身，<code>$1</code>的值就是<code>anaconda-ks.cfg</code>这个文件，<code>$2</code>是<code>install.log</code>文件，<code>$3</code>是<code>install.log.syslog</code>文件</p></blockquote><table><thead><tr><th>位置参数变量</th><th>作 用</th></tr></thead><tbody><tr><td>$n</td><td>n 为数字，$0 代表命令本身，$1〜$9 代表第 1〜9 个参数，10 以上的参数需要用大括号包含， 如${10}</td></tr><tr><td>$*</td><td>这个变量代表命令行中所有的参数，把所有的参数看成一个整体</td></tr><tr><td>$@</td><td>这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区别对待</td></tr><tr><td>$#</td><td>这个变量代表命令行中所有参数的个数</td></tr></tbody></table><p>位置参数变量要用于向命令或程序脚本中传递信息，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[chao@localhost ~]$ vi count.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1 + $num2))</span><br><span class="line">echo $sum</span><br><span class="line"></span><br><span class="line">[chao@localhost ~]$ ./count.sh 11 22</span><br><span class="line">33</span><br></pre></td></tr></table></figure><h4 id="2-4-Shell环境变量"><a href="#2-4-Shell环境变量" class="headerlink" title="2.4 Shell环境变量"></a>2.4 Shell环境变量</h4><ul><li>Shell 变量的作用域可以分为三种：<ul><li>有的变量只能在函数内部使用，这叫做局部变量（local variable）；</li><li>有的变量可以在当前 Shell 进程中使用，这叫做全局变量（global variable），在 Shell 中定义的变量，默认就是全局变量；</li><li>而有的变量还可以在子进程中使用，这叫做环境变量（environment variable）。<br>全局变量只在当前 Shell 进程中有效，对其它 Shell 进程和子进程都无效。如果使用export命令将全局变量导出，那么它就在所有的子进程中也有效了，这称为“环境变量”。</li></ul></li></ul><h4 id="2-5-内置参数变量"><a href="#2-5-内置参数变量" class="headerlink" title="2.5 内置参数变量"></a>2.5 内置参数变量</h4><p>内部参数分为两类：命令行参数，与进程相关的内部参数</p><ol><li><p>命令行参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="language-bash">@   <span class="comment"># 表示传递给脚本或函数的所有参数。被双引号引用时，与$*有所不同。</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">*   <span class="comment"># 表示传递给脚本或函数的所有参数</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">0   <span class="comment"># 表示命令行输入的脚本名称</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash"><span class="comment">#   # 表示命令行上的参数个数</span></span></span><br></pre></td></tr></table></figure><blockquote><p> 注意： $@和$*不加引号时,二者都是返回传入的参数,但加了引号后$*把参数作为一个字符串整体(单字符串)返回, $@把每个参数作为一个一个字符串返回</p></blockquote></li><li><p>与进程相关的内部参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="language-bash">?   <span class="comment"># 表示上一个命令执行的返回结果</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">$   <span class="comment"># 表示当前程序运行的 PID</span></span> </span><br><span class="line"><span class="meta">$</span><span class="language-bash">!   <span class="comment"># 表示获取上一个在后台工作进程的PID</span></span></span><br><span class="line"><span class="meta">$</span><span class="language-bash">_   <span class="comment"># 表示获取在此之前执行命令或脚本的最后一个参数</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="3-退出状态码"><a href="#3-退出状态码" class="headerlink" title="3. 退出状态码"></a>3. 退出状态码</h3><p><code>exit</code>是一个Shell内置命令，用来退出当前Shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。<br><code>exit</code>命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。<br><code>exit</code>退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败，可以根据退出状态来判断具体出现了什么错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[chao@localhost ~]$ vi test.sh</span><br><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;befor exit&quot;</span><br><span class="line">exit 8</span><br><span class="line">echo &quot;after exit&quot;</span><br><span class="line"></span><br><span class="line">[chao@localhost ~]$ bash ./test.sh</span><br><span class="line">befor exit</span><br><span class="line">[chao@localhost ~]$ echo $?</span><br><span class="line">8</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Linux常用命令整理</title>
      <link href="/2020/06/05/env-linux.html"/>
      <url>/2020/06/05/env-linux.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-常用基础命令"><a href="#1-常用基础命令" class="headerlink" title="1. 常用基础命令"></a>1. 常用基础命令</h3><ol><li><p>文件管理</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls          # 显示指定工作目录下的内容及属性信息</span><br><span class="line">cp          # 复制文件或目录</span><br><span class="line">mkdir       # 创建目录</span><br><span class="line">mv          # 移动或改名文件</span><br><span class="line">pwd         # 显示当前路径</span><br></pre></td></tr></table></figure></li><li><p>文档编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat         # 在终端设备上显示文件内容</span><br><span class="line">echo        # 输出字符串或提取Shell变量的值</span><br><span class="line">rm          # 移除文件或目录</span><br><span class="line">tail        # 查看文件尾部内容</span><br><span class="line">rmdir       # 删除空目录</span><br></pre></td></tr></table></figure></li><li><p>系统管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">startx      # 初始化X-windows</span><br><span class="line">rpm         # RPM软件包管理器</span><br><span class="line">find        # 查找和搜索文件</span><br><span class="line">vmstat      # 显示虚拟内存状态</span><br><span class="line">uname       # 显示系统信息</span><br></pre></td></tr></table></figure></li><li><p>磁盘管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df          # 显示磁盘空间使用情况</span><br><span class="line">fdisk       # 磁盘分区</span><br><span class="line">hdparm      # 显示与设定硬盘参数</span><br><span class="line">lsblk       # 查看系统的磁盘</span><br><span class="line">vgextend    # 扩展卷组</span><br></pre></td></tr></table></figure></li><li><p>文件传输</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tftp        # 上传及下载文件</span><br><span class="line">curl        # 文件传输工具</span><br><span class="line">fsck        # 检查并修复Linux文件系统</span><br><span class="line">ftpwho      # 显示ftp会话信息</span><br><span class="line">lprm        # 删除打印队列中的打印任务</span><br></pre></td></tr></table></figure></li><li><p>网络通讯</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh         # 安全连接客户端</span><br><span class="line">netstat     # 显示网络状态</span><br><span class="line">ping        # 测试主机间网络连通性</span><br><span class="line">ifconfig    # 显示或设置网络设备</span><br><span class="line">dhclient    # 动态获取或释放IP地址</span><br></pre></td></tr></table></figure></li><li><p>设备管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount       # 文件系统挂载</span><br><span class="line">MAKEDEV     # 建立设备</span><br><span class="line">setleds     # 设定键盘上方三个 LED 的状态</span><br><span class="line">lspci       # 显示当前设备所有PCI总线信息</span><br><span class="line">sensors     # 检测服务器内部温度及电压</span><br></pre></td></tr></table></figure></li><li><p>备份压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zipinfo     # 查看压缩文件信息</span><br><span class="line">gzip        # 压缩和解压文件</span><br><span class="line">zip         # 压缩文件</span><br><span class="line">unarj       # 解压.arj文件</span><br><span class="line">unzip       # 解压缩zip文件</span><br></pre></td></tr></table></figure></li><li><p>其他命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">chsh        # 查看和修改当前登录的Shell</span><br><span class="line">export      # 查看和设置Shell环境变量</span><br><span class="line">read        # 读取从键盘或文件输入的数据</span><br><span class="line">expr        # 四则远算和字符串运算</span><br><span class="line">tmux        # 一个窗口操作多个会话</span><br><span class="line">alias       # 给命令定义别名</span><br><span class="line">history     # 显示与操纵历史命令</span><br><span class="line">xargs       # 一个给其他命令传递参数的过滤器</span><br><span class="line">time        # 测量命令的执行时间或者系统资源的使用情况</span><br><span class="line">sleep       # 让程序暂停或休眠一段时间</span><br><span class="line">file        # 查看文件信息或类型</span><br><span class="line">ln          # 创建文件链接</span><br><span class="line">du          # 查看文件夹和文件的磁盘占用情况</span><br><span class="line">bzip2       # 压缩和解压文件（.bz2文件）</span><br><span class="line">dd          # 复制（拷贝）文件，并对原文件进行转换</span><br><span class="line">grep        # 文本搜索工具（可使用正则表达式）</span><br><span class="line">cut         # 剪切文件中的数据</span><br><span class="line">wc          # 计算单个文件中的字数、单词数和字节数</span><br><span class="line">split       # 切割（拆分）文件</span><br><span class="line">paste       # 合并（拼接）文件</span><br><span class="line">Vim         # 替换文本内容</span><br><span class="line">sed         # 替换、删除、更新文件中的内容</span><br><span class="line">hash        # 显示与清除命令运行时查询的哈希表</span><br><span class="line">wait        # 等待指令</span><br><span class="line">bc          # 浮点运算</span><br><span class="line">rmmod       # 删除模块</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-命令实例"><a href="#2-命令实例" class="headerlink" title="2. 命令实例"></a>2. 命令实例</h3><ol><li><p>系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arch                    # 显示机器的处理器架构(1) </span><br><span class="line">uname -m                # 显示机器的处理器架构(2) </span><br><span class="line">uname -r                # 显示正在使用的内核版本 </span><br><span class="line">dmidecode -q            # 显示硬件系统部件 - (SMBIOS / DMI) </span><br><span class="line">hdparm -i /dev/hda      # 罗列一个磁盘的架构特性 </span><br><span class="line">hdparm -tT /dev/sda     # 在磁盘上执行测试性读取操作 </span><br><span class="line">cat /proc/cpuinfo       # 显示CPU info的信息 </span><br><span class="line">cat /proc/interrupts    # 显示中断 </span><br><span class="line">cat /proc/meminfo       # 校验内存使用 </span><br><span class="line">cat /proc/swaps         # 显示哪些swap被使用 </span><br><span class="line">cat /proc/version       # 显示内核的版本 </span><br><span class="line">cat /proc/net/dev       # 显示网络适配器及统计 </span><br><span class="line">cat /proc/mounts        # 显示已加载的文件系统 </span><br><span class="line">lspci -tv               # 罗列 PCI 设备 </span><br><span class="line">lsusb -tv               # 显示 USB 设备 </span><br><span class="line">date                    # 显示系统日期 </span><br><span class="line">cal 2007                # 显示2007年的日历表 </span><br><span class="line">date 041217002007.00    # 设置日期和时间 - 月日时分年.秒 </span><br><span class="line">clock -w                # 将时间修改保存到 BIOS </span><br></pre></td></tr></table></figure></li><li><p>关机 (系统的关机、重启以及登出)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now               # 关闭系统(1) </span><br><span class="line">init 0                        # 关闭系统(2) </span><br><span class="line">telinit 0                     # 关闭系统(3) </span><br><span class="line">shutdown -h hours:minutes &amp;   # 按预定时间关闭系统 </span><br><span class="line">shutdown -c                   # 取消按预定时间关闭系统 </span><br><span class="line">shutdown -r now               # 重启(1) </span><br><span class="line">reboot                        # 重启(2) </span><br><span class="line">logout                        # 注销 </span><br></pre></td></tr></table></figure></li><li><p>文件和目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cd /home                # 进入 &#x27;/ home&#x27; 目录&#x27; </span><br><span class="line">cd ..                   # 返回上一级目录 </span><br><span class="line">cd ../..                # 返回上两级目录 </span><br><span class="line">cd                      # 进入个人的主目录 </span><br><span class="line">cd ~user1               # 进入个人的主目录 </span><br><span class="line">cd -                    # 返回上次所在的目录 </span><br><span class="line">pwd                     # 显示工作路径 </span><br><span class="line">ls                      # 查看目录中的文件 </span><br><span class="line">ls -F                   # 查看目录中的文件 </span><br><span class="line">ls -l                   # 显示文件和目录的详细资料 </span><br><span class="line">ls -a                   # 显示隐藏文件 </span><br><span class="line">ls *[0-9]*              # 显示包含数字的文件名和目录名 </span><br><span class="line">tree                    # 显示文件和目录由根目录开始的树形结构(1) </span><br><span class="line">lstree                  # 显示文件和目录由根目录开始的树形结构(2) </span><br><span class="line">mkdir dir1              # 创建一个叫做 &#x27;dir1&#x27; 的目录&#x27; </span><br><span class="line">mkdir dir1 dir2         # 同时创建两个目录 </span><br><span class="line">mkdir -p /tmp/dir1/dir2 # 创建一个目录树 </span><br><span class="line">rm -f file1             # 删除一个叫做 &#x27;file1&#x27; 的文件&#x27; </span><br><span class="line">rmdir dir1              # 删除一个叫做 &#x27;dir1&#x27; 的目录&#x27; </span><br><span class="line">rm -rf dir1             # 删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容 </span><br><span class="line">rm -rf dir1 dir2        # 同时删除两个目录及它们的内容 </span><br><span class="line">mv dir1 new_dir         # 重命名/移动 一个目录 </span><br><span class="line">cp file1 file2          # 复制一个文件 </span><br><span class="line">cp dir/* .              # 复制一个目录下的所有文件到当前工作目录 </span><br><span class="line">cp -a /tmp/dir1 .       # 复制一个目录到当前工作目录 </span><br><span class="line">cp -a dir1 dir2         # 复制一个目录 </span><br><span class="line">ln -s file1 lnk1        # 创建一个指向文件或目录的软链接 </span><br><span class="line">ln file1 lnk1           # 创建一个指向文件或目录的物理链接 </span><br><span class="line">touch -t 0712250000 file1   # 修改一个文件或目录的时间戳 - (YYMMDDhhmm) </span><br></pre></td></tr></table></figure></li><li><p>文件搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find / -name file1                           # 从 &#x27;/&#x27; 开始进入根文件系统搜索文件和目录 </span><br><span class="line">find / -user user1                           # 搜索属于用户 &#x27;user1&#x27; 的文件和目录 </span><br><span class="line">find /home/user1 -name \*.bin                # 在目录 &#x27;/ home/user1&#x27; 中搜索带有&#x27;.bin&#x27; 结尾的文件 </span><br><span class="line">find /usr/bin -type f -atime +100            # 搜索在过去100天内未被使用过的执行文件 </span><br><span class="line">find /usr/bin -type f -mtime -10             # 搜索在10天内被创建或者修改过的文件 </span><br><span class="line">find / -name \*.rpm -exec chmod 755 &#x27;&#123;&#125;&#x27; \;  # 搜索以 &#x27;.rpm&#x27; 结尾的文件并定义其权限 </span><br><span class="line">find / -xdev -name \*.rpm                    # 搜索以 &#x27;.rpm&#x27; 结尾的文件，忽略光驱、捷盘等可移动设备 </span><br><span class="line">locate \*.ps                                 # 寻找以 &#x27;.ps&#x27; 结尾的文件 - 先运行 &#x27;updatedb&#x27; 命令 </span><br><span class="line">whereis halt                                 # 显示一个二进制文件、源码或man的位置 </span><br><span class="line">which halt                                   # 显示一个二进制文件或可执行文件的完整路径 </span><br></pre></td></tr></table></figure></li><li><p>挂载一个文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/hda2 /mnt/hda2             # 挂载一个叫做hda2的盘 - 确定目录 &#x27;/ mnt/hda2&#x27; 已经存在 </span><br><span class="line">umount /dev/hda2                      # 卸载一个叫做hda2的盘 - 先从挂载点 &#x27;/ mnt/hda2&#x27; 退出 </span><br><span class="line">fuser -km /mnt/hda2                   # 当设备繁忙时强制卸载 </span><br><span class="line">umount -n /mnt/hda2                   # 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 </span><br><span class="line">mount /dev/fd0 /mnt/floppy            # 挂载一个软盘 </span><br><span class="line">mount /dev/cdrom /mnt/cdrom           # 挂载一个cdrom或dvdrom </span><br><span class="line">mount /dev/hdc /mnt/cdrecorder        # 挂载一个cdrw或dvdrom </span><br><span class="line">mount /dev/hdb /mnt/cdrecorder        # 挂载一个cdrw或dvdrom </span><br><span class="line">mount -o loop file.iso /mnt/cdrom     # 挂载一个文件或ISO镜像文件 </span><br><span class="line">mount -t vfat /dev/hda5 /mnt/hda5     # 挂载一个Windows FAT32文件系统 </span><br><span class="line">mount /dev/sda1 /mnt/usbdisk          # 挂载一个usb 捷盘或闪存设备 </span><br><span class="line">mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share  # 挂载一个windows网络共享 </span><br></pre></td></tr></table></figure></li><li><p>磁盘空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df -h                   # 显示已经挂载的分区列表 </span><br><span class="line">ls -lSr |more           # 以尺寸大小排列文件和目录 </span><br><span class="line">du -sh dir1             # 估算目录 &#x27;dir1&#x27; 已经使用的磁盘空间&#x27; </span><br><span class="line">du -sk * | sort -rn     # 以容量大小为依据依次显示文件和目录的大小 </span><br><span class="line">rpm -q -a --qf &#x27;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#x27; | sort -k1,1n                  # 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) </span><br><span class="line">dpkg-query -W -f=&#x27;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#x27; | sort -k1,1n  # 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) </span><br></pre></td></tr></table></figure></li><li><p>用户和群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">groupadd group_name                        # 创建一个新用户组 </span><br><span class="line">groupdel group_name                        # 删除一个用户组 </span><br><span class="line">groupmod -n new_group_name old_group_name  # 重命名一个用户组 </span><br><span class="line">useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1  # 创建一个属于 &quot;admin&quot; 用户组的用户 </span><br><span class="line">useradd user1                              # 创建一个新用户 </span><br><span class="line">userdel -r user1                           # 删除一个用户 ( &#x27;-r&#x27; 排除主目录) </span><br><span class="line">usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1    # 修改用户属性 </span><br><span class="line">passwd                                     # 修改口令 </span><br><span class="line">passwd user1                               # 修改一个用户的口令 (只允许root执行) </span><br><span class="line">chage -E 2005-12-31 user1                  # 设置用户口令的失效期限 </span><br><span class="line">pwck                                       # 检查 &#x27;/etc/passwd&#x27; 的文件格式和语法修正以及存在的用户 </span><br><span class="line">grpck                                      # 检查 &#x27;/etc/passwd&#x27; 的文件格式和语法修正以及存在的群组 </span><br><span class="line">newgrp group_name                          #登陆进一个新的群组以改变新创建文件的预设群组 </span><br></pre></td></tr></table></figure></li><li><p>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ls -lh                      # 显示权限 </span><br><span class="line">ls /tmp | pr -T5 -W$COLUMNS # 将终端划分成5栏显示 </span><br><span class="line">chmod ugo+rwx directory1    # 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 </span><br><span class="line">chmod go-rwx directory1     # 删除群组(g)与其他人(o)对目录的读写执行权限 </span><br><span class="line">chown user1 file1           # 改变一个文件的所有人属性 </span><br><span class="line">chown -R user1 directory1   # 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 </span><br><span class="line">chgrp group1 file1          # 改变文件的群组 </span><br><span class="line">chown user1:group1 file1    # 改变一个文件的所有人和群组属性 </span><br><span class="line">find / -perm -u+s           # 罗列一个系统中所有使用了SUID控制的文件 </span><br><span class="line">chmod u+s /bin/file1        # 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 </span><br><span class="line">chmod u-s /bin/file1        # 禁用一个二进制文件的 SUID位 </span><br><span class="line">chmod g+s /home/public      # 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 </span><br><span class="line">chmod g-s /home/public      # 禁用一个目录的 SGID 位 </span><br><span class="line">chmod o+t /home/public      # 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 </span><br><span class="line">chmod o-t /home/public      # 禁用一个目录的 STIKY 位 </span><br></pre></td></tr></table></figure></li><li><p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chattr +a file1         # 只允许以追加方式读写文件 </span><br><span class="line">chattr +c file1         # 允许这个文件能被内核自动压缩/解压 </span><br><span class="line">chattr +d file1         # 在进行文件系统备份时，dump程序将忽略这个文件 </span><br><span class="line">chattr +i file1         # 设置成不可变的文件，不能被删除、修改、重命名或者链接 </span><br><span class="line">chattr +s file1         # 允许一个文件被安全地删除 </span><br><span class="line">chattr +S file1         # 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 </span><br><span class="line">chattr +u file1         # 若文件被删除，系统会允许你在以后恢复这个被删除的文件 </span><br><span class="line">lsattr                  # 显示特殊的属性 </span><br></pre></td></tr></table></figure></li><li><p>打包和压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bunzip2 file1.bz2                       # 解压一个叫做 &#x27;file1.bz2&#x27;的文件 </span><br><span class="line">bzip2 file1                             # 压缩一个叫做 &#x27;file1&#x27; 的文件 </span><br><span class="line">gunzip file1.gz                         # 解压一个叫做 &#x27;file1.gz&#x27;的文件 </span><br><span class="line">gzip file1                              # 压缩一个叫做 &#x27;file1&#x27;的文件 </span><br><span class="line">gzip -9 file1                           # 最大程度压缩 </span><br><span class="line">rar a file1.rar test_file               # 创建一个叫做 &#x27;file1.rar&#x27; 的包 </span><br><span class="line">rar a file1.rar file1 file2 dir1        # 同时压缩 &#x27;file1&#x27;, &#x27;file2&#x27; 以及目录 &#x27;dir1&#x27; </span><br><span class="line">rar x file1.rar                         # 解压rar包 </span><br><span class="line">unrar x file1.rar                       # 解压rar包 </span><br><span class="line">tar -cvf archive.tar file1              # 创建一个非压缩的 tarball </span><br><span class="line">tar -cvf archive.tar file1 file2 dir1   # 创建一个包含了 &#x27;file1&#x27;, &#x27;file2&#x27; 以及 &#x27;dir1&#x27;的档案文件 </span><br><span class="line">tar -tf archive.tar                     # 显示一个包中的内容 </span><br><span class="line">tar -xvf archive.tar                    # 释放一个包 </span><br><span class="line">tar -xvf archive.tar -C /tmp            # 将压缩包释放到 /tmp目录下 </span><br><span class="line">tar -cvfj archive.tar.bz2 dir1          # 创建一个bzip2格式的压缩包 </span><br><span class="line">tar -xvfj archive.tar.bz2               # 解压一个bzip2格式的压缩包 </span><br><span class="line">tar -cvfz archive.tar.gz dir1           # 创建一个gzip格式的压缩包 </span><br><span class="line">tar -xvfz archive.tar.gz                # 解压一个gzip格式的压缩包 </span><br><span class="line">zip file1.zip file1                     # 创建一个zip格式的压缩包 </span><br><span class="line">zip -r file1.zip file1 file2 dir1       # 将几个文件和目录同时压缩成一个zip格式的压缩包 </span><br><span class="line">unzip file1.zip                         # 解压一个zip格式压缩包 </span><br></pre></td></tr></table></figure></li><li><p>RPM 包 - （Fedora, Redhat及类似系统）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh package.rpm                    # 安装一个rpm包 </span><br><span class="line">rpm -ivh --nodeeps package.rpm          # 安装一个rpm包而忽略依赖关系警告 </span><br><span class="line">rpm -U package.rpm                      # 更新一个rpm包但不改变其配置文件 </span><br><span class="line">rpm -F package.rpm                      # 更新一个确定已经安装的rpm包 </span><br><span class="line">rpm -e package_name.rpm                 # 删除一个rpm包 </span><br><span class="line">rpm -qa                                 # 显示系统中所有已经安装的rpm包 </span><br><span class="line">rpm -qa | grep httpd                    # 显示所有名称中包含 &quot;httpd&quot; 字样的rpm包 </span><br><span class="line">rpm -qi package_name                    # 获取一个已安装包的特殊信息 </span><br><span class="line">rpm -qg &quot;System Environment/Daemons&quot;    # 显示一个组件的rpm包 </span><br><span class="line">rpm -ql package_name                    # 显示一个已经安装的rpm包提供的文件列表 </span><br><span class="line">rpm -qc package_name                    # 显示一个已经安装的rpm包提供的配置文件列表 </span><br><span class="line">rpm -q package_name --whatrequires      # 显示与一个rpm包存在依赖关系的列表 </span><br><span class="line">rpm -q package_name --whatprovides      # 显示一个rpm包所占的体积 </span><br><span class="line">rpm -q package_name --scripts           # 显示在安装/删除期间所执行的脚本l </span><br><span class="line">rpm -q package_name --changelog         # 显示一个rpm包的修改历史 </span><br><span class="line">rpm -qf /etc/httpd/conf/httpd.conf      # 确认所给的文件由哪个rpm包所提供 </span><br><span class="line">rpm -qp package.rpm -l                  # 显示由一个尚未安装的rpm包提供的文件列表 </span><br><span class="line">rpm --import /media/cdrom/RPM-GPG-KEY   # 导入公钥数字证书 </span><br><span class="line">rpm --checksig package.rpm              # 确认一个rpm包的完整性 </span><br><span class="line">rpm -qa gpg-pubkey                      # 确认已安装的所有rpm包的完整性 </span><br><span class="line">rpm -V package_name                     # 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 </span><br><span class="line">rpm -Va                                 # 检查系统中所有已安装的rpm包- 小心使用 </span><br><span class="line">rpm -Vp package.rpm                     # 确认一个rpm包还未安装 </span><br><span class="line">rpm2cpio package.rpm | cpio --extract --make-directories *bin*  # 从一个rpm包运行可执行文件 </span><br><span class="line">rpm -ivh /usr/src/redhat/RPMS/`arch`/package.rpm    # 从一个rpm源码安装一个构建好的包 </span><br><span class="line">rpmbuild --rebuild package_name.src.rpm # 从一个rpm源码构建一个 rpm 包 </span><br></pre></td></tr></table></figure></li><li><p>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install package_name            # 下载并安装一个rpm包 </span><br><span class="line">yum localinstall package_name.rpm   # 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 </span><br><span class="line">yum update package_name.rpm         # 更新当前系统中所有安装的rpm包 </span><br><span class="line">yum update package_name             # 更新一个rpm包 </span><br><span class="line">yum remove package_name             # 删除一个rpm包 </span><br><span class="line">yum list                            # 列出当前系统中安装的所有包 </span><br><span class="line">yum search package_name             # 在rpm仓库中搜寻软件包 </span><br><span class="line">yum clean packages                  # 清理rpm缓存删除下载的包 </span><br><span class="line">yum clean headers                   # 删除所有头文件 </span><br><span class="line">yum clean all                       # 删除所有缓存的包和头文件 </span><br></pre></td></tr></table></figure></li><li><p>DEB 包 (Debian, Ubuntu 以及类似系统)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i package.deb         # 安装/更新一个 deb 包 </span><br><span class="line">dpkg -r package_name        # 从系统删除一个 deb 包 </span><br><span class="line">dpkg -l                     # 显示系统中所有已经安装的 deb 包 </span><br><span class="line">dpkg -l | grep httpd        # 显示所有名称中包含 &quot;httpd&quot; 字样的deb包 </span><br><span class="line">dpkg -s package_name        # 获得已经安装在系统中一个特殊包的信息 </span><br><span class="line">dpkg -L package_name        # 显示系统中已经安装的一个deb包所提供的文件列表 </span><br><span class="line">dpkg --contents package.deb # 显示尚未安装的一个包所提供的文件列表 </span><br><span class="line">dpkg -S /bin/ping           # 确认所给的文件由哪个deb包提供 </span><br></pre></td></tr></table></figure></li><li><p>APT 软件工具 (Debian, Ubuntu 以及类似系统) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get install package_name        # 安装/更新一个 deb 包 </span><br><span class="line">apt-cdrom install package_name      # 从光盘安装/更新一个 deb 包 </span><br><span class="line">apt-get update                      # 升级列表中的软件包 </span><br><span class="line">apt-get upgrade                     # 升级所有已安装的软件 </span><br><span class="line">apt-get remove package_name         # 从系统删除一个deb包 </span><br><span class="line">apt-get check                       # 确认依赖的软件仓库正确 </span><br><span class="line">apt-get clean                       # 从下载的软件包中清理缓存 </span><br><span class="line">apt-cache search searched-package   # 返回包含所要搜索字符串的软件包名称 </span><br></pre></td></tr></table></figure></li><li><p>查看文件内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat file1                   # 从第一个字节开始正向查看文件的内容 </span><br><span class="line">tac file1                   # 从最后一行开始反向查看一个文件的内容 </span><br><span class="line">more file1                  # 查看一个长文件的内容 </span><br><span class="line">less file1                  # 类似于 &#x27;more&#x27; 命令，但是它允许在文件中和正向操作一样的反向操作 </span><br><span class="line">head -2 file1               # 查看一个文件的前两行 </span><br><span class="line">tail -2 file1               # 查看一个文件的最后两行 </span><br><span class="line">tail -f /var/log/messages   # 实时查看被添加到一个文件中的内容 </span><br></pre></td></tr></table></figure></li><li><p>文本处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt  # 合并一个文件的详细说明文本，并将简介写入一个新文件中 </span><br><span class="line">cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt # 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 </span><br><span class="line">grep Aug /var/log/messages                  # 在文件 &#x27;/var/log/messages&#x27;中查找关键词&quot;Aug&quot; </span><br><span class="line">grep ^Aug /var/log/messages                 # 在文件 &#x27;/var/log/messages&#x27;中查找以&quot;Aug&quot;开始的词汇 </span><br><span class="line">grep [0-9] /var/log/messages                # 选择 &#x27;/var/log/messages&#x27; 文件中所有包含数字的行 </span><br><span class="line">grep Aug -R /var/log/*                      # 在目录 &#x27;/var/log&#x27; 及随后的目录中搜索字符串&quot;Aug&quot; </span><br><span class="line">sed &#x27;s/stringa1/stringa2/g&#x27; example.txt     # 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; </span><br><span class="line">sed &#x27;/^$/d&#x27; example.txt                     # 从example.txt文件中删除所有空白行 </span><br><span class="line">sed &#x27;/ *#/d; /^$/d&#x27; example.txt             # 从example.txt文件中删除所有注释和空白行 </span><br><span class="line">echo &#x27;esempio&#x27; | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27; # 合并上下单元格内容 </span><br><span class="line">sed -e &#x27;1d&#x27; result.txt                      # 从文件example.txt 中排除第一行 </span><br><span class="line">sed -n &#x27;/stringa1/p&#x27;                        # 查看只包含词汇 &quot;string1&quot;的行 </span><br><span class="line">sed -e &#x27;s/ *$//&#x27; example.txt                # 删除每一行最后的空白字符 </span><br><span class="line">sed -e &#x27;s/stringa1//g&#x27; example.txt          # 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 </span><br><span class="line">sed -n &#x27;1,5p;5q&#x27; example.txt                # 查看从第一行到第5行内容 </span><br><span class="line">sed -n &#x27;5p;5q&#x27; example.txt                  # 查看第5行 </span><br><span class="line">sed -e &#x27;s/00*/0/g&#x27; example.txt              # 用单个零替换多个零 </span><br><span class="line">cat -n file1                                # 标示文件的行数 </span><br><span class="line">cat example.txt | awk &#x27;NR%2==1&#x27;             # 删除example.txt文件中的所有偶数行 </span><br><span class="line">echo a b c | awk &#x27;&#123;print $1&#125;&#x27;               # 查看一行第一栏 </span><br><span class="line">echo a b c | awk &#x27;&#123;print $1,$3&#125;&#x27;            # 查看一行的第一和第三栏 </span><br><span class="line">paste file1 file2                           # 合并两个文件或两栏的内容 </span><br><span class="line">paste -d &#x27;+&#x27; file1 file2                    # 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 </span><br><span class="line">sort file1 file2                            # 排序两个文件的内容 </span><br><span class="line">sort file1 file2 | uniq                     # 取出两个文件的并集(重复的行只保留一份) </span><br><span class="line">sort file1 file2 | uniq -u                  # 删除交集，留下其他的行 </span><br><span class="line">sort file1 file2 | uniq -d                  # 取出两个文件的交集(只留下同时存在于两个文件中的文件) </span><br><span class="line">comm -1 file1 file2                         # 比较两个文件的内容只删除 &#x27;file1&#x27; 所包含的内容 </span><br><span class="line">comm -2 file1 file2                         # 比较两个文件的内容只删除 &#x27;file2&#x27; 所包含的内容 </span><br><span class="line">comm -3 file1 file2                         # 比较两个文件的内容只删除两个文件共有的部分 </span><br></pre></td></tr></table></figure></li><li><p>字符设置和文件格式转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dos2unix filedos.txt fileunix.txt       # 将一个文本文件的格式从MSDOS转换成UNIX </span><br><span class="line">unix2dos fileunix.txt filedos.txt       # 将一个文本文件的格式从UNIX转换成MSDOS </span><br><span class="line">recode ..HTML &lt; page.txt &gt; page.html    # 将一个文本文件转换成html </span><br><span class="line">recode -l | more                        # 显示所有允许的转换格式 </span><br></pre></td></tr></table></figure></li><li><p>文件系统分析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">badblocks -v /dev/hda1  # 检查磁盘hda1上的坏磁块 </span><br><span class="line">fsck /dev/hda1          # 修复/检查hda1磁盘上linux文件系统的完整性 </span><br><span class="line">fsck.ext2 /dev/hda1     # 修复/检查hda1磁盘上ext2文件系统的完整性 </span><br><span class="line">e2fsck /dev/hda1        # 修复/检查hda1磁盘上ext2文件系统的完整性 </span><br><span class="line">e2fsck -j /dev/hda1     # 修复/检查hda1磁盘上ext3文件系统的完整性 </span><br><span class="line">fsck.ext3 /dev/hda1     # 修复/检查hda1磁盘上ext3文件系统的完整性 </span><br><span class="line">fsck.vfat /dev/hda1     # 修复/检查hda1磁盘上fat文件系统的完整性           # </span><br><span class="line">fsck.msdos /dev/hda1    # 修复/检查hda1磁盘上dos文件系统的完整性 </span><br><span class="line">dosfsck /dev/hda1       # 修复/检查hda1磁盘上dos文件系统的完整性 </span><br></pre></td></tr></table></figure></li><li><p>初始化一个文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkfs /dev/hda1                  # 在hda1分区创建一个文件系统 </span><br><span class="line">mke2fs /dev/hda1                # 在hda1分区创建一个linux ext2的文件系统 </span><br><span class="line">mke2fs -j /dev/hda1             # 在hda1分区创建一个linux ext3(日志型)的文件系统 </span><br><span class="line">mkfs -t vfat 32 -F /dev/hda1    # 创建一个 FAT32 文件系统 </span><br><span class="line">fdformat -n /dev/fd0            # 格式化一个软盘 </span><br><span class="line">mkswap /dev/hda3                # 创建一个swap文件系统 </span><br></pre></td></tr></table></figure></li><li><p>SWAP文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/hda3            # 创建一个swap文件系统 </span><br><span class="line">swapon /dev/hda3            # 启用一个新的swap文件系统 </span><br><span class="line">swapon /dev/hda2 /dev/hdb3  # 启用两个swap分区 </span><br></pre></td></tr></table></figure></li><li><p>备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dump -0aj -f /tmp/home0.bak /home                               # 制作一个 &#x27;/home&#x27; 目录的完整备份 </span><br><span class="line">dump -1aj -f /tmp/home0.bak /home                               # 制作一个 &#x27;/home&#x27; 目录的交互式备份 </span><br><span class="line">restore -if /tmp/home0.bak                                      # 还原一个交互式备份 </span><br><span class="line">rsync -rogpav --delete /home /tmp                               # 同步两边的目录 </span><br><span class="line">rsync -rogpav -e ssh --delete /home ip_address:/tmp             # 通过SSH通道rsync </span><br><span class="line">rsync -az -e ssh --delete ip_addr:/home/public /home/local      # 通过ssh和压缩将一个远程目录同步到本地目录 </span><br><span class="line">rsync -az -e ssh --delete /home/local ip_addr:/home/public      # 通过ssh和压缩将本地目录同步到远程目录 </span><br><span class="line">dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr &#x27;dd of=hda.gz&#x27;   # 通过ssh在远程主机上执行一次备份本地磁盘的操作 </span><br><span class="line">dd if=/dev/sda of=/tmp/file1                                    # 备份磁盘内容到一个文件 </span><br><span class="line">tar -Puf backup.tar /home/user                                  # 执行一次对&#x27;/home/user&#x27;目录的交互式备份操作 </span><br><span class="line">( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr &#x27;cd /home/share/ &amp;&amp; tar x -p&#x27;           # 通过ssh在远程目录中复制一个目录内容 </span><br><span class="line">( tar c /home ) | ssh -C user@ip_addr &#x27;cd /home/backup-home &amp;&amp; tar x -p&#x27;                    # 通过ssh在远程目录中复制一个本地目录 </span><br><span class="line">tar cf - . | (cd /tmp/backup ; tar xf - )                       # 本地将一个目录复制到另一个地方，保留原有权限及链接 </span><br><span class="line">find /home/user1 -name &#x27;*.txt&#x27; | xargs cp -av --target-directory=/home/backup/ --parents    # 从一个目录查找并复制所有以 &#x27;.txt&#x27; 结尾的文件到另一个目录 </span><br><span class="line">find /var/log -name &#x27;*.log&#x27; | tar cv --files-from=- | bzip2 &gt; log.tar.bz2                   # 查找所有以&#x27;.log&#x27;结尾的文件并做成一个bzip包 </span><br><span class="line">dd if=/dev/hda of=/dev/fd0 bs=512 count=1                       # 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 </span><br><span class="line">dd if=/dev/fd0 of=/dev/hda bs=512 count=1                       # 从已经保存到软盘的备份中恢复MBR内容 </span><br></pre></td></tr></table></figure></li><li><p>网络 - （以太网和WIFI无线）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0           # 显示一个以太网卡的配置 </span><br><span class="line">ifup eth0               # 启用一个 &#x27;eth0&#x27; 网络设备 </span><br><span class="line">ifdown eth0             # 禁用一个 &#x27;eth0&#x27; 网络设备 </span><br><span class="line">ifconfig eth0 192.168.1.1 netmask 255.255.255.0   # 控制IP地址 </span><br><span class="line">ifconfig eth0 promisc   # 设置 &#x27;eth0&#x27; 成混杂模式以嗅探数据包 (sniffing) </span><br><span class="line">dhclient eth0           # 以dhcp模式启用 &#x27;eth0&#x27; </span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Docker」Docker容器与镜像的使用</title>
      <link href="/2020/05/07/docker-image.html"/>
      <url>/2020/05/07/docker-image.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Docker客户端"><a href="#1-Docker客户端" class="headerlink" title="1. Docker客户端"></a>1. Docker客户端</h2><p>docker客户端非常简单，我们可以直接输入<code>docker</code>命令来查看到Docker客户端的所有命令选项。<span id="more"></span></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker</span><br></pre></td></tr></table></figure><p>可以通过命令<code>docker &lt;command&gt; --help</code>更深入的了解指定的Docker命令使用方法。<br>例如我们要查看<code>docker stats</code>指令的具体使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker stats --help</span><br><span class="line">Usage:docker stats [OPTIONS] [CONTAINER...]</span><br><span class="line">Display a live stream of container(s) resource usage statistics</span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all containers (default shows just running)</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-stream       Disable streaming stats and only pull the first result</span><br><span class="line">      --no-trunc        Do not truncate output</span><br></pre></td></tr></table></figure><h2 id="2-Docker镜像-Image-使用"><a href="#2-Docker镜像-Image-使用" class="headerlink" title="2. Docker镜像(Image)使用"></a>2. Docker镜像(Image)使用</h2><p>当运行容器时，使用的镜像如果在本地中不存在，docker就会自动从docker镜像仓库中下载，默认是从<a href="https://hub.docker.com/">Docker Hub</a>公共镜像源下载。</p><ol><li>查看现有的镜像(Image)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        10 months ago       13.3kB</span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li>各个选项说明:<ul><li>REPOSTITORY：表示镜像的仓库源</li><li>TAG：镜像的标签(同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本)</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul></li></ul></blockquote><ol start="2"><li>获取一个新的镜像<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker pull &lt;REPOSITORY:TAG&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>使用 REPOSTITORY:TAG 来定义不同的镜像，如ubuntu仓库源15.10的版本：<code>ubuntu:15.10</code>。</p></blockquote><h3 id="2-1-查找镜像"><a href="#2-1-查找镜像" class="headerlink" title="2.1 查找镜像"></a>2.1 查找镜像</h3><p>我们可以从<a href="https://hub.docker.com/">Docker Hub</a>网站来搜索镜像。<br>也可以使用<code>docker search</code>命令来搜索镜像。比如我们需要一个httpd的镜像来作为我们的web服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker search httpd</span><br><span class="line">NAME                                    DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">httpd                                   The Apache HTTP Server Project                  3248                [OK]                </span><br><span class="line">centos/httpd                                                                            33                                      [OK]</span><br></pre></td></tr></table></figure><blockquote><ul><li>NAME：镜像仓库源的名称</li><li>DESCRIPTION：镜像的描述</li><li>OFFICIAL：是否docker官方发布</li></ul></blockquote><h3 id="2-2-创建镜像"><a href="#2-2-创建镜像" class="headerlink" title="2.2 创建镜像"></a>2.2 创建镜像</h3><ul><li>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。<ol><li>使用<code>Dockerfile</code>指令来创建一个新的镜像</li><li>从已经创建的容器中更新镜像，并且提交这个镜像</li></ol></li></ul><ol><li><p>需要创建一个Dockerfile文件，文件名必须是Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# vim Dockerfile</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum -y install httpd</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">RUN yum -y install elinks</span><br><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure></li><li><p>构建镜像，使用<code>docker build</code>进行镜像的构建，最后需要指定Dockerfile文件所在路径；</p><ul><li>看到最后输出两条Successfully则构建成功。</li><li>它会根据文件中写的内容，使用centos镜像实例化一个容器，进入容器中执行三个yum命令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker build -t jenkins/centos-http-net /home/jenkins</span><br><span class="line">Successfully built 09266c896243</span><br><span class="line">Successfully tagged jenkins/centos-http-net:latest</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看已经构建好的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        10 months ago       13.3kB</span><br><span class="line">jenkins/centos-http-net   latest    09266c896243   10 seconds ago   581MB</span><br></pre></td></tr></table></figure></li><li><p>镜像构建过程<br>在构建命令执行时输出的一大堆信息中，是执行Dockerfile中的每一行，最关键的几行信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Step 1/5 : FROM centos  # 调用centos</span><br><span class="line"> 5e35e350aded   # centos镜像id</span><br><span class="line">  </span><br><span class="line">Step 2/5 : RUN yum install httpd -y</span><br><span class="line"> Running in a16ddf07c140  # 运行一个临时容器来执行install httpd</span><br><span class="line">Removing intermediate container a16ddf07c140  # 完成后删除临时的容器id</span><br><span class="line"> b51207823459  # 生成一个镜像</span><br><span class="line">  </span><br><span class="line">Step 3/5 : RUN yum install net-tools -y</span><br><span class="line"> Running in 459c8823018a # 运行一个临时容器执行install net-tools</span><br><span class="line">Removing intermediate container 459c8823018a # 完成后删除临时容器id</span><br><span class="line"> 5b6c30a532d4  # 再生成一个镜像</span><br><span class="line"> </span><br><span class="line">Step 4/5 : RUN yum install elinks -y</span><br><span class="line"> Running in a2cb490f9b2f  # 运行一个临时容器执行install elinks</span><br><span class="line">Removing intermediate container a2cb490f9b2f # 完成后删除临时容器id</span><br><span class="line"> 24ba4735814b # 生成一个镜像</span><br><span class="line"> </span><br><span class="line">Step 5/5 : CMD [&quot;/bin/bash&quot;]</span><br><span class="line"> Running in 792333c88ba8  # 运行临时容器，执行/bin/bash</span><br><span class="line">Removing intermediate container 792333c88ba8  # 完成后删除临时容器id</span><br><span class="line"> 09266c896243  # 生成镜像</span><br><span class="line">Successfully built 09266c896243  # 最终成功后的镜像id就是最后生成的镜像id</span><br></pre></td></tr></table></figure><p>每一步生成一个镜像，都属于一个docker commit的执行结果<br>在这个过程中一共生成了三个镜像层，都会被存储在graph中，包括层与层之间的关系，查看docker images中生成的镜像id是否为最后生成的镜像id，FROM和CMD都不算做镜像层</p></li></ol><p>通过<code>docker history</code>也可以看到简单的构建过程，看到的是三个yum就是形成的三个镜像层</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker history chai/centos-http-net:latest </span><br><span class="line">IMAGE         CREATED          CREATED BY                                      SIZE    COMMENT</span><br><span class="line">09266c896243  17 minutes ago   /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">24ba4735814b  17 minutes ago   /bin/sh -c yum install elinks -y                121MB               </span><br><span class="line">5b6c30a532d4  18 minutes ago   /bin/sh -c yum install net-tools -y             112MB               </span><br><span class="line">b51207823459  18 minutes ago   /bin/sh -c yum install httpd -y                 145MB               </span><br><span class="line">5e35e350aded  4 months ago     /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;     4 months ago     /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  </span><br><span class="line">&lt;missing&gt;     4 months ago     /bin/sh -c #(nop) ADD file:45a381049c52b5664…   203MB</span><br></pre></td></tr></table></figure><h2 id="3-Docker容器-Container"><a href="#3-Docker容器-Container" class="headerlink" title="3. Docker容器(Container)"></a>3. Docker容器(Container)</h2><p>镜像(Image)的概念更多偏向于一个环境包，这个环境包可以移动到任意的Docker平台中去运行；<br>而容器(Container)就是你运行环境包的实例，换句话说container是images的一种具体表现形式。</p><ul><li>容器相关命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker container ls，列出现在正在运行的容器</span><br><span class="line">docker container ls -a，列出所有的容器，包括没有在运行的</span><br><span class="line">docker ps -a，列出所有的容器，包括没有在运行的</span><br><span class="line">docker run -it centos，交互式运行容器的方法，这样的话运行之后contianer不会退出，但是这个对话关闭这个，contianer还是就会退出了</span><br><span class="line">docker container rm container_id，可以删除一个容器（注意，这里的id可以是完整的容器id，也可以是缩写，只要是可以和别的id区分开的就可以了）</span><br><span class="line">docker rm container_id，默认就是去删除container的，所以是和docker container rm id是一样的</span><br><span class="line">docker images，和docker image ls是一样的，显示本机的所有镜像</span><br><span class="line">docker image rm image_id，删除image，可以是image_id或者image_name</span><br><span class="line">docker rmi id，是和docker image rm id一样的，是简写</span><br><span class="line">docker container ls -aq，只会显示出容器的id，在批量删除容器的时候有用</span><br><span class="line">docker rm $(docker container ls -aq)，删除所有的容器</span><br><span class="line">docker rm $(docker ps -aq)，也是删除所有的容器</span><br><span class="line">docker rm $(docker container ls -f &quot;status=exited&quot; -q)，删除所有不在运行的容器</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-Dockerfile文件语法"><a href="#4-Dockerfile文件语法" class="headerlink" title="4. Dockerfile文件语法"></a>4. Dockerfile文件语法</h2><p>常用构建镜像指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM  # 指定base镜像</span><br><span class="line">MAINTAINER # 指定镜像作者，后面根任意字符串</span><br><span class="line">COPY # 把文件从host复制到镜像内</span><br><span class="line">  COPY src dest</span><br><span class="line">  COPY [&quot;src&quot;,&quot;dest&quot;]</span><br><span class="line">  src:只能是文件</span><br><span class="line">ADD # 用法和COPY一样，唯一不同时src可以是压缩包，表示解压缩到dest位置，src也可以是目录</span><br><span class="line">ENV # 设置环境变量可以被接下来的镜像层引用，并且会加入到镜像中</span><br><span class="line">  ENV MY_VERSION 1.3</span><br><span class="line">  RUN yum -y install http-$MY_VERSION</span><br><span class="line"><span class="meta">  # </span><span class="language-bash">当进入该镜像的容器中<span class="built_in">echo</span> <span class="variable">$MY_VERSION</span>会输出1.3</span></span><br><span class="line">EXPOSE # 指定容器中的进程监听的端口（接口），会在docker ps -a中的ports中显示</span><br><span class="line">  EXPOSE 80</span><br><span class="line">VOLUME # 容器卷，后面会讲到，把host的路径mount到容器中</span><br><span class="line">  VOLUME /root/htdocs /usr/local/apahce2/htdocs</span><br><span class="line">WORKDIR # 为后续的镜像层设置工作路径</span><br><span class="line">        # 如果不设置，Dockerfile文件中的每一条命令都会返回到初始状态</span><br><span class="line">        # 设置一次后，会一直在该路经执行之后的分层，需要WORKDIR /回到根目录</span><br><span class="line">CMD # 启动容器后默认运行的命令，使用构建完成的镜像实例化为容器时，进入后默认执行的命令</span><br><span class="line">    # 这个命令会被docker run启动命令替代</span><br><span class="line">    # 如：docker -it --rm centos echo &quot;hello&quot;</span><br><span class="line">    # echo &quot;hello&quot;会替代CMD运行的命令</span><br><span class="line">  CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off&quot;]  # 该镜像实例化后的容器，进入后运行nginx启动服务</span><br><span class="line">ENTRYPOINT # 容器启动时运行的命令，不会被docker run的启动命令替代</span><br></pre></td></tr></table></figure><h3 id="4-1-RUN-x2F-CMD-x2F-ENTRYPOINT区别"><a href="#4-1-RUN-x2F-CMD-x2F-ENTRYPOINT区别" class="headerlink" title="4.1 RUN&#x2F;CMD&#x2F;ENTRYPOINT区别"></a>4.1 RUN&#x2F;CMD&#x2F;ENTRYPOINT区别</h3><ol><li><code>RUN</code>：执行命令并创建新的镜像层，主要用于安装软件包</li><li><code>ENTRYPOINT</code>和<code>CMD</code>都算作是启动指令，也就是必须启动容器才会去执行的指令，一般用来启动运行程序使用；当ENTRYPOINT和CMD同时存在时，ENTRYPOINT生效。</li><li><code>ENTRYPOINT</code>和<code>CMD</code>使用格式：<ul><li>shell格式： 会始终调用一个shell程序去执行命令，如<code>ENTRYPOINT echo &quot;hello $name&quot;</code></li><li>exec格式：<code>CMD [&quot;命令&quot;, &quot;选项&quot;, &quot;参数&quot;]</code>、<code>ENTRYPOINT [&quot;命令&quot;, &quot;选项&quot;, &quot;参数&quot;]</code><ul><li>exec格式下无法去调用ENV定义的变量，如果非要让exec格式去读取变量的话，它的命令的位置就要使用一个shell环境。因为变量的读取就是使用shell去读取的。如：ENTRYPOINT [“&#x2F;bin&#x2F;sh”, “-c”, “echo hello,$变量名”]</li><li>当使用exec格式时，ENTRYPOINT的第一个参数被识别为命令，CMD的参数按顺序变为ENTRYPOINT命令的参数</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Docker」Docker简介与安装（Linux环境centos）</title>
      <link href="/2020/05/06/docker-install.html"/>
      <url>/2020/05/06/docker-install.html</url>
      
        <content type="html"><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于Go语言并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似于app）,更重要的是容器性能开销极低。<span id="more"></span></p><h3 id="1-Docker解决的问题"><a href="#1-Docker解决的问题" class="headerlink" title="1. Docker解决的问题"></a>1. Docker解决的问题</h3><ul><li>解决运行环境和配置问题，方便发布，方便做持续集成。<ul><li>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</li><li><code>Docker</code>主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。</li><li>使用<code>Docker</code>可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</li></ul></li><li>使用<code>Docker</code>的好处：<ul><li>部署方便且安全，隔离性好，快速回滚，成本低</li></ul></li><li><code>Docker</code>的应用场景：<ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li></ul></li></ul><h3 id="2-Docker架构"><a href="#2-Docker架构" class="headerlink" title="2. Docker架构"></a>2. Docker架构</h3><p>Docker使用客户端-服务器(C&#x2F;S)架构模式，使用远程API来管理和创建Docker容器。<br>Docker容器通过Docker镜像(Images)来创建，容器与镜像的关系类似于面向对象编程中的对象与类。</p><ul><li>Docker镜像(Images)<ul><li>用于创建Docker容器(Container)的模板。</li></ul></li><li>Docker容器(Container)<ul><li>独立运行的一个或一组应用。</li></ul></li><li>Docker客户端(Client)<ul><li>通过命令行或者其他工具使用<a href="https://docs.docker.com/reference/api/docker_remote_api">Docker API</a>与Docker的守护进程通信。</li></ul></li><li>Docker主机(Host)<ul><li>一个物理或者虚拟的机器用于执行Docker守护进程和容器。</li></ul></li><li>Docker仓库(Registry)<ul><li>用来保存镜像(Images)，可以理解为代码控制中的代码仓库，<a href="https://hub.docker.com/">Docker Hub</a>提供了庞大的镜像集合供使用。</li></ul></li><li>Docker Machine<ul><li>一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker。</li></ul></li></ul><h3 id="3-CentOS下安装Docker"><a href="#3-CentOS下安装Docker" class="headerlink" title="3. CentOS下安装Docker"></a>3. CentOS下安装Docker</h3><p>要求CentOS 6.5或更高的版本，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。<br>这里演示环境CentOS 8.2。</p><ul><li>添加Docker存储库<ul><li>首先，必须添加一个外部存储库以获得Docker CE。这里使用官方的Docker CE CentOS存储库。</li></ul></li></ul><ol><li><p>下载docker-ce的repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"><span class="meta">  % </span><span class="language-bash">Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  1919  100  1919    0     0   3408      0 --:--:-- --:--:-- --:--:--  3402</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# yum install https://download.docker.com/linux/fedora/32/x86_64/stable/Packages/containerd.io-1.3.7-3.1.fc32.x86_64.rpm</span><br></pre></td></tr></table></figure></li><li><p>安装docker-ce</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# yum install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>启动docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>检查docker服务是否正常运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# systemctl status docker</span><br></pre></td></tr></table></figure></li><li><p>测试运行 hello-world</p><ul><li>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# docker run hello-world</span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:8c5aeeb6a5f3ba4883347d3747a7249f491766ca1caa47e5da5dfcf6b9b717c0</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Jenkins」Jenkins自动部署Jar到远程服务器</title>
      <link href="/2020/04/10/jenkins-shell.html"/>
      <url>/2020/04/10/jenkins-shell.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-配置远程服务器SSH免密登录"><a href="#1-配置远程服务器SSH免密登录" class="headerlink" title="1. 配置远程服务器SSH免密登录"></a>1. 配置远程服务器SSH免密登录</h3><ol><li>本地客户端生成公私钥（一路回车默认即可），会在用户目录.ssh文件夹下创建公私钥<span id="more"></span></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[localuser@localhost .ssh]$ ssh-keygen</span><br><span class="line">[localuser@localhost .ssh]$ ls</span><br><span class="line">id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><ol start="2"><li>上传公钥到服务器，这里远程服务器地址为：192.168.2.200，用户为：testuser</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub testuser@192.168.2.200</span><br></pre></td></tr></table></figure><p>上面这条命令会在远程服务器的<code>~/.ssh</code>目录生成<code>authorized_keys</code>，里面是id_rsa.pub(公钥)内容。</p><blockquote><p>若目标服务器已经存在了<code>authorized_keys</code>，则可拷贝公钥内容追加到<code>authorized_keys</code>内容的末尾。</p></blockquote><ol start="3"><li>测试免密登录，本地客户端通过ssh连接远程服务器，就可以免密登录了。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[localuser@localhost ~]$ ssh testuser@192.168.2.200</span><br><span class="line">Last login: Tue Nov 17 20:57:25 2020 from 192.168.2.202</span><br><span class="line">[testuser@caimeidev1 ~]$ exit</span><br><span class="line">logout</span><br><span class="line">Connection to 192.168.2.200 closed.</span><br></pre></td></tr></table></figure><h3 id="2-登录Jenkins客户端并配置"><a href="#2-登录Jenkins客户端并配置" class="headerlink" title="2. 登录Jenkins客户端并配置"></a>2. 登录Jenkins客户端并配置</h3><p>先安装插件：<code>Git Paramater</code>，这里只演示部署，因为已在本地打好包推送到了git服务器。</p><ol><li>新建Item， 输入任务名称：<code>MavenTest</code>(自己定义)，选择自由项目，点击<code>确定</code>。</li><li>勾选<code>This project is parameterized</code>(参数化构建)<ul><li>选择<code>Choice Parameter</code>,添加打包环境参数(名称：buildEnv，选项：beta和prod)；</li><li>选择<code>Git Parameter</code>,定义参数名称:<code>gitBranch</code>，参数类型选择<code>分支</code>；</li><li><img src="/2020/04/10/jenkins-shell/up-60e4e7fe99f99698de5e5488e94b969eccb.webp"></li></ul></li><li>源码管理，选择Git，填写仓库地址(<code>Repository URL</code>)和选择凭据(<code>Credentials</code>)。<ul><li><img src="/2020/04/10/jenkins-shell/up-499a162af32384b469b4b80cc0632f54f73.webp"></li></ul></li><li>构建环境，勾选<code>Add timestamps to the Console Output</code>，加上时间戳。</li><li>Post Steps，选择执行shell脚本Execute shell，输入：<ul><li><img src="/2020/04/10/jenkins-shell/up-3551b07c426b8380a725353feb341453c0b.webp"></li></ul></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/jenkins/shell</span><br><span class="line"><span class="meta"># </span><span class="language-bash">对应两个构建参数<span class="variable">$buildEnv</span>，<span class="variable">$gitBranch</span></span></span><br><span class="line">./demo-deploy-$buildEnv.sh demo-0.0.1-SNAPSHOT.jar  $&#123;gitBranch&#125;</span><br></pre></td></tr></table></figure><h3 id="3-编写部署脚本"><a href="#3-编写部署脚本" class="headerlink" title="3. 编写部署脚本"></a>3. 编写部署脚本</h3><p>可参考<a href="https://my.oschina.net/chaoo/blog/4721418">shell脚本部署Java应用</a></p><ol><li>本地客户端</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[localuser@localhost ~]$ cd /home/jenkins/shell</span><br><span class="line"><span class="meta"># </span><span class="language-bash">推送不同服务器用不同shell脚本，beta:demo-deploy-beta.sh，product:demo-deploy-prod.sh，对应<span class="variable">$buildEnv</span>参数</span></span><br><span class="line">[localuser@localhost ~]$ vim demo-deploy-beta.sh</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line">fileName=$1</span><br><span class="line">gitBranch=$2</span><br><span class="line">if [ -z &quot;$fileName&quot; ]; then</span><br><span class="line">    echo &quot;文件名不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line">echo &quot;准备发布【$gitBranch】分支，到【Beta：192.168.2.200】&quot;</span><br><span class="line">echo &quot;开始拷贝jar文件【$fileName】到远程服务器&quot;</span><br><span class="line">scp /home/jenkins/root/workspace/MavenTest/target/$fileName testuser@192.168.2.200:/usr/local/test/$fileName.prev</span><br><span class="line"><span class="meta"># </span><span class="language-bash">捕获上一条命令的输出$? (<span class="keyword">if</span> 0 正常 <span class="keyword">else</span> 错误)</span></span><br><span class="line">if [ &quot;$?&quot; == &quot;0&quot; ]; then</span><br><span class="line">    echo &quot;文件传输结束，准备启动远程服务器的部署脚本&quot;</span><br><span class="line">    ssh testuser@192.168.2.200 /usr/local/test/demo-deploy.sh  $fileName</span><br><span class="line">else</span><br><span class="line">   echo &quot;拷贝文件错误&quot;</span><br><span class="line">   exit 0</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加执行权限</span></span><br><span class="line">[localuser@localhost ~]$ chmod +x demo-deploy-beta.sh</span><br></pre></td></tr></table></figure><ol start="2"><li>远程服务器<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[localuser@localhost ~]$ cd /usr/local/test</span><br><span class="line">[localuser@localhost ~]$ vim demo-deploy.sh</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/env bash</span></span><br><span class="line">echo &quot;服务器开始部署服务&quot;</span><br><span class="line">projectname=&quot;demo-0.0.1-SNAPSHOT&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">打开文件所属的目录，不然远程执行会找不到当前目录</span></span><br><span class="line">cd /usr/local/test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">新的jar包会当成参数传过来</span></span><br><span class="line">newJar=$1</span><br><span class="line">echo &quot;新的jar为：$newJar&quot; </span><br><span class="line"><span class="meta"># </span><span class="language-bash">如果新的jar包为空则退出</span></span><br><span class="line">if [ -z &quot;$newJar&quot; ]; then</span><br><span class="line">    echo &quot;新的jar不能为空&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">获取旧的jar包名称，当然可能是空的，也可能跟当前名称一致</span></span><br><span class="line">oldJar=$(ps -ef | grep $&#123;projectname&#125;|grep -v &#x27;demo-deploy.sh&#x27;|grep -v grep|awk &#x27;&#123;print $10&#125;&#x27;|cut -d &#x27;/&#x27; -f 2)</span><br><span class="line">echo &quot;当前运行的旧的jar包为：$oldJar&quot; </span><br><span class="line"><span class="meta">#</span><span class="language-bash">如果新的jar包为空则退出</span></span><br><span class="line">if [ -z &quot;$oldJar&quot; ]; then</span><br><span class="line">    echo &quot;没有启动的demo服务&quot;</span><br><span class="line">else</span><br><span class="line">    # 如果旧的进程还在就将旧的进程杀掉</span><br><span class="line">    oldId=`ps -ef|grep $&#123;projectname&#125;|grep -v &quot;$0&quot;|grep -v &quot;grep&quot;|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">    echo &quot;$oldId&quot;</span><br><span class="line">    echo &quot;kill old process start ...&quot;</span><br><span class="line">    for id in $oldId</span><br><span class="line">    do</span><br><span class="line">        kill -9 $id</span><br><span class="line">        echo &quot;killed $id&quot;</span><br><span class="line">    done</span><br><span class="line">    echo &quot;kill old process end&quot;</span><br><span class="line">    # 获取当前时间</span><br><span class="line">    suffix=&quot;.bak-&quot;`date &#x27;+%s%3N&#x27;`;</span><br><span class="line">    echo $suffix;</span><br><span class="line">    # 将旧的jar包进行备份</span><br><span class="line">    mv $oldJar $&#123;oldJar&#125;$&#123;suffix&#125;</span><br><span class="line">fi</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">开始启动新的进程</span></span><br><span class="line">mv $&#123;1&#125;.prev $&#123;1&#125;</span><br><span class="line">nohup java -jar $&#123;1&#125; &gt; run.txt 2&gt;&amp;1 &amp;</span><br><span class="line">echo &quot;服务启动查看进程:&quot;</span><br><span class="line">echo `ps -ef | grep $&#123;projectname&#125;|grep -v &#x27;demo-deploy.sh&#x27;|grep -v grep`</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">添加执行权限</span></span><br><span class="line">[localuser@localhost ~]$ chmod +x demo-deploy.sh</span><br></pre></td></tr></table></figure><h3 id="4-部署测试"><a href="#4-部署测试" class="headerlink" title="4. 部署测试"></a>4. 部署测试</h3><p><code>Build with Parameters</code> -&gt; 选择要部署的<code>git分支$&#123;gitBranch&#125;</code>和<code>环境参数$&#123;buildEnv&#125;</code></p><p><img src="/2020/04/10/jenkins-shell/up-66c8b64a303730fb9c192fd57f769efdd5d.webp"></p><p>构建完成后点击<code>Build History</code>(构建历史)里的构建版本号，点击<code>控制台输出</code>查看日志</p><p><img src="/2020/04/10/jenkins-shell/up-3b4db51b047564d03e104526cc387f2a883.webp"></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Jenkins」使用Maven构建Java应用程序</title>
      <link href="/2020/04/08/jenkins-maven.html"/>
      <url>/2020/04/08/jenkins-maven.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-添加git凭据"><a href="#1-添加git凭据" class="headerlink" title="1. 添加git凭据"></a>1. 添加git凭据</h3><p>若安装Jenkins时安装的推荐插件，git已经默认安装了，我们添加git凭据：</p><ol><li><code>系统管理(Manage Jenkins)</code> -&gt; <code>Manage Credentials</code> -&gt; <code>全局</code> -&gt; <code>添加凭据</code>。<ul><li>类型选择<code>SSH Username with private key</code>，往下滑到<code>Private Key</code>，并勾选<code>Enter directly</code>，在<code>Enter directly</code>的key区域点击<code>Add</code>，粘贴本机<code>git私钥</code>，点击确定。</li><li>类型选择<code>Username with password</code>，填写git用户名和密码，点击确定。<span id="more"></span></li></ul></li></ol><blockquote><p>本机Git私钥获取：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat .ssh/id_rsa</span><br></pre></td></tr></table></figure><blockquote><p>git公钥私钥生成详细细节参考<a href="https://my.oschina.net/chaoo/blog/4709339">物理机安装CentOS 8.0</a>的安装配置Git。</p></blockquote><h3 id="2-Jenkins配置Maven与Publish-Over-SSH插件"><a href="#2-Jenkins配置Maven与Publish-Over-SSH插件" class="headerlink" title="2. Jenkins配置Maven与Publish Over SSH插件"></a>2. Jenkins配置<code>Maven</code>与<code>Publish Over SSH</code>插件</h3><ol><li>在插件管理搜索<code>Maven</code>，找到<code>Maven Integration</code>并勾选，然后点击<code>直接安装</code>。</li><li>接下来同样方法安装<code>Publish Over SSH</code>插件(用来通过<code>ssh命令</code>发送Maven的构建)。</li><li>配置全局变量，添加要部署的远程用户：<ul><li><code>系统管理(Manage Jenkins)</code> -&gt; 点击<code>Configure System</code> -&gt; 往下滑到<code>SSH Server</code>；</li><li>在<code>SSH Servers</code>这里点击<code>新增</code>，填写用户信息(Name:此配置名，HostNmae:要连接的SSH主机名或IP地址，UserName:远程用户名)；</li><li>点击<code>高级</code>配置密码，勾选<code>Use password authentication, or use a different key</code>，在<code>Passphrase / Password</code>输入远程用户密码；</li><li>点击<code>Test Configuration</code>测试能否连通，最后点击<code>保存</code>。</li></ul></li><li>配置mavne的jenkins本地仓库：<ul><li><code>系统管理(Manage Jenkins)</code> -&gt; 点击<code>Configure System</code> -&gt; 找到<code>Maven项目配置</code>；</li><li><code>Local Maven Repository</code> -&gt; 选择<code>Local to the workspace</code> -&gt; <code>保存</code>。</li></ul></li><li>全局工具配置：<ul><li><code>系统管理(Manage Jenkins)</code> -&gt; 点击<code>Global Tool Configuration</code>；</li><li><code>Maven配置</code> -&gt; <code>默认setting/全局setting</code>选择<code>Settings file in filesystem</code> -&gt; 填写本机安装Maven的setting路径，如<code>/usr/local/apache-maven-3.6.3/conf/settings.xml</code></li><li><code>JDK</code> -&gt; <code>JDK安装</code> -&gt; <code>新增JDK</code> -&gt; <code>JAVA_HOME</code>填写java安装目录，如<code>/usr/lib/jvm/java-openjdk</code></li><li><code>Git</code> -&gt; <code>Git installations</code> -&gt; <code>Path to Git executable</code>填写<code>/usr/bin/git</code>(可用which -a git查看)</li><li><code>Maven</code> -&gt; <code>Maven安装</code> -&gt; <code>新增Maven</code> -&gt; <code>MAVEN_HOME</code>填写Maven安装目录，如<code>/usr/local/apache-maven-3.6.3</code></li></ul></li></ol><h3 id="3-使用Maven构建Java应用程序"><a href="#3-使用Maven构建Java应用程序" class="headerlink" title="3. 使用Maven构建Java应用程序"></a>3. 使用Maven构建Java应用程序</h3><ol><li>新建Item， 输入任务名称，选择Maven项目，点击“确定”</li><li>源码管理，选择Git，填写仓库地址(<code>Repository URL</code>)和选择凭据(<code>Credentials</code>)</li><li>构建环境，勾选<code>Add timestamps to the Console Output</code>，加上时间戳</li><li>Build，<code>Goals and options</code>根据自己情况自行修改：<code>clean package -pl demo -am -Dmaven.test.skip=true -P beta</code><ul><li>-pl 选项后可跟随{groupId}:{artifactId}或者所选模块的相对路径(多个模块以逗号分隔)，这里只想打包demo模块</li><li>-am 表示同时处理选定模块所依赖的模块</li><li>-P 打包的环境</li></ul></li><li>Post Steps，发布步骤，这里可以选择执行shell脚本Execute shell（发布到和Jenkins是同一台服务器），Send files or execute commands over SSH（不同服务器）。</li></ol><h3 id="4-Maven构建配置【Post-Steps】"><a href="#4-Maven构建配置【Post-Steps】" class="headerlink" title="4. Maven构建配置【Post Steps】"></a>4. Maven构建配置【Post Steps】</h3><ol><li>若发布到和Jenkins是同一台服务器，下拉框列表选择<code>Execute shell</code>，然后填写shell脚本；</li><li>若不在同一服务器，下拉框选择<code>Send files or execute commands over SSH</code>，配置<code>SSH Server</code><ul><li><code>Source files</code>填写Maven本地打包后Jar包路径，如：<code>target/demo-0.0.1-SNAPSHOT.jar</code></li><li><code>Remove prefix</code>去除前缀，如：<code>target/</code></li><li><code>Remote directory</code>拷贝到Linux服务器的路径，如：<code>/home/jenkins/test</code></li><li><code>Exec command</code>Jar包拷贝后，执行脚本运行Jar包。</li></ul></li><li>shell脚本详情(填写时去掉注释)：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">后台执行</span></span><br><span class="line">BUILD_ID=DONTKILLME</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">进入到项目</span></span><br><span class="line">cd /home/jenkins/test</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">找到原进程,<span class="built_in">kill</span></span></span><br><span class="line">Project_name=test</span><br><span class="line">pid=$(ps -ef | grep java| grep $Project_name|awk -F &#x27;[ ]+&#x27; &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">kill -9 $pid</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">启动jar</span></span><br><span class="line">nohup java -jar $Project_name.jar &gt; run.txt &amp;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Jenkins」声明式流水线Jenkins Pipeline</title>
      <link href="/2020/04/06/jenkins-pipeline.html"/>
      <url>/2020/04/06/jenkins-pipeline.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Jenkins-Pipeline-基本概念"><a href="#1-Jenkins-Pipeline-基本概念" class="headerlink" title="1. Jenkins Pipeline 基本概念"></a>1. Jenkins Pipeline 基本概念</h3><p>流水线是用户定义的一个CD流水线模型 。流水线的代码定义了整个的构建过程, 他通常包括构建, 测试和交付应用程序的阶段 。<br><code>Jenkins Pipeline</code>（或简称为”Pipeline”）是一套插件，将持续交付的实现和实施集成到Jenkins中。<br>持续交付<code>Pipeline</code>自动化的表达了这样一种流程：将基于版本控制管理的软件持续的交付。<br>Jenkins Pipeline 的定义通常被写入到一个<code>Jenkinsfile</code>文本文件中，该文件可以被放入项目的源代码控制库中。</p><span id="more"></span><h3 id="2-Jenkinsfile-基础语法"><a href="#2-Jenkinsfile-基础语法" class="headerlink" title="2.Jenkinsfile 基础语法"></a>2.Jenkinsfile 基础语法</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pipeline <span class="punctuation">&#123;</span>                <span class="comment">// 特定语法，pipeline 块定义了整个流水线中完成的所有的工作</span></span><br><span class="line">    agent any             <span class="comment">// agent为整个流水线分配一个执行器 (在节点上)和工作区</span></span><br><span class="line">    stages <span class="punctuation">&#123;</span>              <span class="comment">// 所有流程（状态）的外层块，仅有一个</span></span><br><span class="line">        stage(&#x27;Build&#x27;) <span class="punctuation">&#123;</span>  <span class="comment">// 每个stage为一流程，定义名称</span></span><br><span class="line">            steps <span class="punctuation">&#123;</span>       <span class="comment">// 步骤块，内部包含具体操作</span></span><br><span class="line">                sh &#x27;make&#x27; <span class="comment">// sh操作，其引号间的文字会当成shell直接执行</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        stage(&#x27;Test&#x27;)<span class="punctuation">&#123;</span></span><br><span class="line">            steps <span class="punctuation">&#123;</span></span><br><span class="line">                sh &#x27;make check&#x27;</span><br><span class="line">                junit &#x27;reports<span class="comment">/**/</span>*.xml&#x27;  <span class="comment">//junit使用匹配的定义测试xml进行单元测试</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        stage(&#x27;Deploy&#x27;) <span class="punctuation">&#123;</span></span><br><span class="line">            steps <span class="punctuation">&#123;</span></span><br><span class="line">                sh &#x27;make publish&#x27;</span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-创建-Hello-World-流水线"><a href="#3-创建-Hello-World-流水线" class="headerlink" title="3.创建 Hello World 流水线"></a>3.创建 Hello World 流水线</h3><ol><li><p>登录<code>Jenkins</code>，新建任务(New Item)，选择<code>流水线</code>，输入工程名称<code>Hello Pipeline</code>，确定。</p></li><li><p>填写描述，勾选<code>参数化构建过程(This project is parameterized)</code>。</p></li><li><p>添加参数，选择<code>字符参数(String parameter)</code>，并设置这个字符串参数(名称,默认值,描述)，这样我们在Jenkinsfile中就可以取到这个值了。</p></li><li><p>向下滑动到<code>流水线</code>，定义选择<code>Pipeline script</code>，脚本输入如下内容，然后保存。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pipeline <span class="punctuation">&#123;</span></span><br><span class="line">    agent any</span><br><span class="line">    environment <span class="punctuation">&#123;</span>                <span class="comment">//环境变量</span></span><br><span class="line">        GREETING=<span class="string">&quot;Hello&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    stages<span class="punctuation">&#123;</span></span><br><span class="line">        stage(&#x27;打招呼&#x27;) <span class="punctuation">&#123;</span></span><br><span class="line">            steps<span class="punctuation">&#123;</span></span><br><span class="line">                sh &#x27;echo <span class="string">&quot;$GREETING $TITLE&quot;</span>&#x27;</span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line">   post <span class="punctuation">&#123;</span>                        <span class="comment">//构建完成后置操作</span></span><br><span class="line">        aborted <span class="punctuation">&#123;</span>                <span class="comment">//如果构建中断，则执行</span></span><br><span class="line">            echo &#x27;构建被中止!&#x27;</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">        success <span class="punctuation">&#123;</span>                <span class="comment">//构建成功执行</span></span><br><span class="line">            echo &#x27;构建成功!&#x27;</span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">       failure <span class="punctuation">&#123;</span>                 <span class="comment">//构建失败执行</span></span><br><span class="line">           echo &#x27;构建失败!&#x27;</span><br><span class="line">       <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>点击<code>Build with Parameters(参数化构建)</code>，然后<code>开始构建</code>。</p></li><li><p>构建完成输出界面：<br><img src="/2020/04/06/jenkins-pipeline/up-e49f9a3240d011242cd6093b055cf6709c7.webp" alt="构建完成输出界面" title="构建完成输出界面"></p></li><li><p>把鼠标放在打招呼下边的绿色框上，点出现的<code>logs</code>，可以看到输出了预期的值。</p></li><li><p>找到左下角的<code>Build History(构建历史)</code>的构建版本号，如当前是<code>#1</code>，点进去，选择<code>Console Output</code>查看详细的执行日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">成功Console Output</span></span><br><span class="line">Started by user charles</span><br><span class="line">Running in Durability level: MAX_SURVIVABILITY</span><br><span class="line">[Pipeline] Start of Pipeline</span><br><span class="line">[Pipeline] node</span><br><span class="line">Running on Jenkins in /home/jenkins/root/workspace/Hello Pipeline</span><br><span class="line">[Pipeline] &#123;</span><br><span class="line">[Pipeline] withEnv</span><br><span class="line">[Pipeline] &#123;</span><br><span class="line">[Pipeline] stage</span><br><span class="line">[Pipeline] &#123; (打招呼)</span><br><span class="line">[Pipeline] sh</span><br><span class="line">+ echo &#x27;Hello Jenkins Pipeline&#x27;</span><br><span class="line">Hello Jenkins Pipeline</span><br><span class="line">[Pipeline] &#125;</span><br><span class="line">[Pipeline] // stage</span><br><span class="line">[Pipeline] stage</span><br><span class="line">[Pipeline] &#123; (Declarative: Post Actions)</span><br><span class="line">[Pipeline] echo</span><br><span class="line">构建成功!</span><br><span class="line">[Pipeline] &#125;</span><br><span class="line">[Pipeline] // stage</span><br><span class="line">[Pipeline] &#125;</span><br><span class="line">[Pipeline] // withEnv</span><br><span class="line">[Pipeline] &#125;</span><br><span class="line">[Pipeline] // node</span><br><span class="line">[Pipeline] End of Pipeline</span><br><span class="line">Finished: SUCCESS</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Jenkins」安装Jenkins（Linux环境centos）</title>
      <link href="/2020/04/04/jenkins-install.html"/>
      <url>/2020/04/04/jenkins-install.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载Jenkins"><a href="#1-下载Jenkins" class="headerlink" title="1. 下载Jenkins"></a>1. 下载Jenkins</h3><p>这里选择清华大学的Jenkins镜像源站下载稳定<code>2.249.3</code>版本(war包)<br><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/2.249.3/">https://mirrors.tuna.tsinghua.edu.cn/jenkins/war-stable/2.249.3/</a></p><span id="more"></span><p>创建Jenkins用户来操作Jenkins：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -mU jenkins -s /bin/bash  # 创建jenkins用户并添加同名组、创建用户目录,默认shell为bash</span><br><span class="line">sudo passwd jenkins                    # 重置密码</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">su jenkins                             # 切换用户</span><br><span class="line">cd ~                                   # 进入/home/jenkins目录</span><br></pre></td></tr></table></figure><p>将<strong>jenkins.war</strong>上传到<code>/home/jenkins</code>下</p><h3 id="2-启动Jenkins"><a href="#2-启动Jenkins" class="headerlink" title="2. 启动Jenkins"></a>2. 启动Jenkins</h3><p>后台运行Jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -DJENKINS_HOME=/home/jenkins/root -jar /home/jenkins/jenkins.war --httpPort=8888 &amp;</span><br></pre></td></tr></table></figure><p>我这里的主机IP：<code>192.168.2.100</code>，端口号指定了<code>8888</code>，防火墙需要开放<code>8888</code>端口。</p><ul><li><p><code>Centos6/7</code> 配置<code>iptables</code>规则：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">编辑配置文件</span></span><br><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在文件中间添加iptables规则</span></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPT</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启防火墙</span></span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure></li><li><p><code>Centos8</code> 配置<code>firewalld</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=8888/tcp                          # 查询端口是否开放</span><br><span class="line">firewall-cmd --add-port=8888/tcp --permanent             #永久添加8080端口例外(全局)</span><br><span class="line">systemctl stop firewalld.service             #停止防火墙</span><br><span class="line">systemctl start firewalld.service            #启动防火墙</span><br></pre></td></tr></table></figure></li></ul><p>访问 Jenkins生成更新目录，我这里访问：<code>192.168.2.100:8888</code>。<br>等待初始化完成出现<code>解锁Jenkins</code>时，先不急填密码，先把插件源换掉，这样提升安装速度和降低失败率。</p><h3 id="3-修改默认插件源"><a href="#3-修改默认插件源" class="headerlink" title="3. 修改默认插件源"></a>3. 修改默认插件源</h3><p>若一直停留在Please wait while Jenkins is getting ready to work页面，那么可能是你的网络连不到Jenkins官方仓库上。<br>可以先进入<code>/home/jenkins/root</code>目录，打开<code>hudson.model.UpdateCenter.xml</code>将<code>url</code>中的<br><code>https://updates.jenkins.io/update-center.json</code>更改为清华大学的镜像地址:<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/https:\/\/updates.jenkins.io\/update-center.json/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins\/updates\/update-center.json/g&quot; /home/jenkins/root/hudson.model.UpdateCenter.xml</span><br></pre></td></tr></table></figure><p>重启Jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep jenkins   #定位Jenkins的进程号pid</span><br><span class="line">kill -9 &lt;pid&gt;         #杀jenkins进程</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启Jenkins</span></span><br><span class="line">nohup java -DJENKINS_HOME=/home/jenkins/root -jar /home/jenkins/jenkins.war --httpPort=8888 &amp;</span><br></pre></td></tr></table></figure><p>修改默认Jenkins插件源与连接检测位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#x27; /home/jenkins/root/updates/default.json</span><br><span class="line">sed -i &#x27;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#x27; /home/jenkins/root/updates/default.json</span><br></pre></td></tr></table></figure><p>重启Jenkins，使插件源生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep jenkins   #定位Jenkins的进程号pid</span><br><span class="line">kill -9 &lt;pid&gt;         #杀jenkins进程</span><br><span class="line"><span class="meta"># </span><span class="language-bash">重启Jenkins</span></span><br><span class="line">nohup java -DJENKINS_HOME=/home/jenkins/root -jar /home/jenkins/jenkins.war --httpPort=8888 &amp;</span><br></pre></td></tr></table></figure><h3 id="4-解锁Jenkins并创建管理员用户"><a href="#4-解锁Jenkins并创建管理员用户" class="headerlink" title="4. 解锁Jenkins并创建管理员用户"></a>4. 解锁Jenkins并创建管理员用户</h3><ol><li>解锁Jenkins<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /home/jenkins/root/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure></li></ol><p>复制输出的密码，访问<code>192.168.2.100:8888</code>，粘贴到管理员密码框中，继续。<br>安装推荐的插件就可以。</p><ol start="2"><li><p>创建管理员用户<br>等待插件安装完成 -&gt; 创建新管理员账户 -&gt; 一路保存并完成。</p></li><li><p>重启Jenkins<br>因为更新了管理员用户，需要重启下Jenkins服务。</p></li><li><p>登录Jenkins<br>访问<code>192.168.2.100:8888</code>，输入刚才创建的账号与密码登录。</p></li></ol><h3 id="5-设置开机启动Jenkins"><a href="#5-设置开机启动Jenkins" class="headerlink" title="5. 设置开机启动Jenkins"></a>5. 设置开机启动Jenkins</h3><ol><li>到<code>/home/jenkins/shell</code>目录下创建启动脚本<code>jenkins.sh</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /home/jenkins/shell</span><br><span class="line">vim  jenkins.sh</span><br></pre></td></tr></table></figure><p>脚本<code>jenkins.sh</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/usr/bin/bash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">导入环境变量</span></span><br><span class="line">export JENKINS_HOME=/home/jenkins/</span><br><span class="line"></span><br><span class="line">cd $JENKINS_HOME</span><br><span class="line"></span><br><span class="line">pid=`ps -ef | grep jenkins.war | grep -v &#x27;grep&#x27;| awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">if [ &quot;$1&quot; = &quot;start&quot; ];then</span><br><span class="line">if [ -n &quot;$pid&quot; ];then</span><br><span class="line">    echo &#x27;jenkins is running...&#x27;</span><br><span class="line">else</span><br><span class="line">    # java启动服务 配置java安装根路径,和启动war包存的根路径</span><br><span class="line">    nohup java -DJENKINS_HOME=$JENKINS_HOME/root -jar $JENKINS_HOME/jenkins.war --httpPort=8888 &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    echo &quot;服务启动查看进程:&quot;</span><br><span class="line">    echo `ps -ef | grep jenkins.war | grep -v &#x27;jenkins.sh&#x27;|grep -v grep`</span><br><span class="line">fi</span><br><span class="line">elif [ &quot;$1&quot; = &quot;stop&quot; ];then</span><br><span class="line">    exec ps -ef | grep jenkins | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;| xargs kill -9</span><br><span class="line">    echo &#x27;jenkins is stop...&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;Please input like this:&quot;./jenkins.sh start&quot; or &quot;./jenkins stop&quot;&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol start="2"><li>切换root用户，并添加可执行权限</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br><span class="line"><span class="meta"># </span><span class="language-bash">添加可执行权限</span></span><br><span class="line">chmod +x /home/jenkins/shell/jenkins.sh</span><br></pre></td></tr></table></figure><ol start="3"><li>到 &#x2F;lib&#x2F;systemd&#x2F;system 服务注册目录下创建 jenkins.service</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Jenkins</span><br><span class="line">After=network.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">User=jenkins</span><br><span class="line">Group=jenkins</span><br><span class="line">ExecStart=/home/jenkins/shell/jenkins.sh start</span><br><span class="line">ExecReload=/home/jenkins/shell/jenkins.sh reload</span><br><span class="line">ExecStop=/home/jenkins/shell/jenkins.sh stop</span><br><span class="line">PrivateTmp=true</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ol start="4"><li>设置开机启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">刷新配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta"># </span><span class="language-bash">设置开机启动</span></span><br><span class="line">systemctl enable jenkins.service</span><br></pre></td></tr></table></figure><ol start="5"><li>查看设置开机启动的服务列表</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type=service</span><br></pre></td></tr></table></figure><blockquote><p>到此，安装Jenkins已全部完成。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Linux </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」物理机安装CentOS 8</title>
      <link href="/2020/03/15/env-centos8.html"/>
      <url>/2020/03/15/env-centos8.html</url>
      
        <content type="html"><![CDATA[<p>CentOS 8 所需的最低硬件配置:</p><ul><li>2GB RAM</li><li>64位x86 &#x2F; 2GHz或以上的 CPU</li><li>20GB 硬盘空间<span id="more"></span></li></ul><h3 id="1-下载-CentOS-8-ISO-文件"><a href="#1-下载-CentOS-8-ISO-文件" class="headerlink" title="1. 下载 CentOS 8 ISO 文件"></a>1. 下载 CentOS 8 ISO 文件</h3><p>在 CentOS 官方网站 <a href="https://www.centos.org/download/">https://www.centos.org/download/</a> 下载 CentOS 8 ISO 文件。</p><h3 id="2-创建-CentOS-8-启动介质（USB-或-DVD）"><a href="#2-创建-CentOS-8-启动介质（USB-或-DVD）" class="headerlink" title="2. 创建 CentOS 8 启动介质（USB 或 DVD）"></a>2. 创建 CentOS 8 启动介质（USB 或 DVD）</h3><p>下载 CentOS 8 ISO 文件之后，将 ISO 文件烧录到 USB 移动硬盘或 DVD 光盘中，作为启动介质。<br>常用的烧录工具如：UltraISO。<br>然后重启系统，在 BIOS 中设置为从上面烧录好的启动介质启动。</p><h3 id="3-选择“安装-CentOS-Linux-8-0”选项"><a href="#3-选择“安装-CentOS-Linux-8-0”选项" class="headerlink" title="3. 选择“安装 CentOS Linux 8.0”选项"></a>3. 选择“安装 CentOS Linux 8.0”选项</h3><p>当系统从 CentOS 8 ISO 启动介质启动之后，就可以看到启动选择界面。选择“Install CentOS Linux 8”（安装 CentOS Linux 8）选项并按回车。</p><h3 id="4-安装错误处理"><a href="#4-安装错误处理" class="headerlink" title="4. 安装错误处理"></a>4. 安装错误处理</h3><p>实体机安装，写入镜像到U盘会出现找不到U盘的情况，报错是：<code>/dev/root does not exist</code>。<br>界面尾部出现 <code>dracut:/#</code> 时，键入 <code>ls /dev</code> 查看启动U盘所在盘符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dracut:/# ls /dev</span><br></pre></td></tr></table></figure><p><img src="/2020/03/15/env-centos8/up-e46cee7c94277328598af51d821b95afaea.webp"></p><p>前缀<code>sd</code>表示磁盘，如sda、sdb、sdc；sda后面的4表示磁盘a的分区，因为物理机磁盘删除了分区，是未分区状态，所以sda4就是U盘了。<br>确定好sda是启动U盘后，键入 <code>reboot</code> 重启。<br>进入到开机系统选择界面，根据提示 按键盘 <code>e</code> 或 <code>tab</code>。<br>界面会出现：<code>initrd=initrd.img inst.stage2=hd:LABEL=CentOSx86_64 rd.live.check quiet</code>，<br>修改为U盘的分区（sda4）：<code>initrd=initrd.img inst.stage2=hd:/dev/sda4 quiet</code>。<br>然后保存后按<code>回车键</code>安装。</p><h3 id="5-开始安装CentOS-8"><a href="#5-开始安装CentOS-8" class="headerlink" title="5. 开始安装CentOS 8"></a>5. 开始安装CentOS 8</h3><p>根据图像安装向导的引导进行配置。<br>设置<code>root</code>用户的密码，创建一个本地用户。<br>在安装完成后，安装向导会提示重启系统。</p><blockquote><p>注意：重启完成后，记得要把安装介质断开，并将 BIOS 的启动介质设置为硬盘。</p></blockquote><p>同意 <code>CentOS 8</code> 的许可证，使用刚创建的本地用户登录。<br>开始使用 <code>CentOS LinuxStart Using CentOS Linux</code>。</p><h3 id="6-安装配置JDK"><a href="#6-安装配置JDK" class="headerlink" title="6. 安装配置JDK"></a>6. 安装配置JDK</h3><p>使用 yum 直接安装，环境变量会自动配置好。</p><ol><li><p>检查 yum 中有没有 java1.8 包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list java-1.8*</span><br></pre></td></tr></table></figure></li><li><p>开始安装java1.8</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk* -y</span><br></pre></td></tr></table></figure></li><li><p>用验证<code>java -version</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ java -version</span><br><span class="line">openjdk version &quot;1.8.0_272&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_272-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.272-b10, mixed mode)</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-安装配置Git"><a href="#7-安装配置Git" class="headerlink" title="7. 安装配置Git"></a>7. 安装配置Git</h3><ol><li><p>使用Yum安装Git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></li><li><p>用验证<code>git --version</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ git --version</span><br><span class="line">git version 2.18.4</span><br></pre></td></tr></table></figure></li><li><p>配置Git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ git config --global user.name &quot;yourname&quot;</span><br><span class="line">[root@localhost ~]$ git config --global user.email &quot;youremail@email.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>验证配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ git config --list</span><br><span class="line">user.name=yourname</span><br><span class="line">user.email=youremail@email.com</span><br></pre></td></tr></table></figure></li><li><p>生成git授权证书<br>键入命令<code>ssh-keygen -t rsa -C &quot;youremail@email.com&quot;</code>一路回车键就好:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ ssh-keygen -t rsa -C &quot;youremail@email.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>拷贝公钥(私钥:<code>id_rsa</code>，公钥:<code>id_rsa.pub</code>)到git服务器，如gitee添加SSH公钥。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ cd ~/.ssh/</span><br><span class="line">[root@localhost .ssh]# ls</span><br><span class="line">id_rsa  id_rsa.pub</span><br><span class="line">[root@localhost .ssh]# cat id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQD8blWzO+L+H8h8GkNOEEfLBQGCszU= youremail@email.com</span><br></pre></td></tr></table></figure></li><li><p>添加公钥完成后进行测试SSH链接(gitee为例)<br>键入命令<code>ssh -T git@gitee.com</code>，根据提示键入<code>yes</code>确认，当终端提示<code>hi/welcome/successfully</code>等表示链接成功。</p></li></ol><h3 id="8-安装配置Maven"><a href="#8-安装配置Maven" class="headerlink" title="8. 安装配置Maven"></a>8. 安装配置Maven</h3><ol><li><p>下载并解压Maven</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.zip</span><br><span class="line">[root@localhost ~]# unzip apache-maven-3.6.3-bin.zip</span><br><span class="line"><span class="meta"># </span><span class="language-bash">把maven安装到/usr/local/下</span></span><br><span class="line">[root@localhost apache-maven-3.6.3]# mv apache-maven-3.6.3 /usr/local/apache-maven-3.6.3</span><br><span class="line">[root@localhost ~]# cd /usr/local/apache-maven-3.6.3</span><br><span class="line">[root@localhost apache-maven-3.6.3]# pwd</span><br><span class="line">/usr/local/apache-maven-3.6.3</span><br></pre></td></tr></table></figure></li><li><p>修改系统配置<code>/etc/profile</code>，添加Maven环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost apache-maven-3.6.3]# vim /etc/profile</span><br><span class="line"><span class="meta"># </span><span class="language-bash">在文件末尾添加：</span></span><br><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.6.3</span><br><span class="line">export PATH=$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li></ol><p>重新加载系统配置：<code>. /etc/profile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost apache-maven-3.6.3]# . /etc/profile</span><br></pre></td></tr></table></figure><ol start="3"><li>验证Maven<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost apache-maven-3.6.3]# mvn -version</span><br><span class="line">Apache Maven 3.6.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)</span><br><span class="line">Maven home: /usr/local/apache-maven-3.6.3</span><br><span class="line">Java version: 1.8.0_272, vendor: Red Hat, Inc., runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.272.b10-1.el8_2.x86_64/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;4.18.0-193.el8.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-Centos8开放防火墙端口"><a href="#9-Centos8开放防火墙端口" class="headerlink" title="9. Centos8开放防火墙端口"></a>9. Centos8开放防火墙端口</h3><ol><li>查看防火墙某个端口是否开放</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-port=3306/tcp</span><br></pre></td></tr></table></figure><ol start="2"><li>开放防火墙端口3306</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="3"><li>查看防火墙状态</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><ol start="4"><li>关闭防火墙</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><ol start="5"><li>打开防火墙</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure><ol start="6"><li>开放一段端口</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent</span><br></pre></td></tr></table></figure><ol start="7"><li>查看开放的端口列表</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure><ol start="8"><li>重启防火墙</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload  # 重启防火墙(修改配置后要重启防火墙)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「环境配置」Redis与MySQL多实例配置</title>
      <link href="/2020/02/11/env-redis-mysql.html"/>
      <url>/2020/02/11/env-redis-mysql.html</url>
      
        <content type="html"><![CDATA[<p>最近由于工作的需要，需要在同一台服务器上搭建两个<code>Redis</code>与<code>MySQL</code>的实例。<br>多实例：就是在一台机器上面开启多个不同的端口(如<code>Redis</code>用<code>6379</code>&#x2F;<code>6380</code>，<code>MySQL</code>用<code>3306</code>&#x2F;<code>3307</code>等)，运行多个服务进程；公用一套安装程序，使用不同的配置文件，数据文件。</p><span id="more"></span><h3 id="1-Redis多实例配置"><a href="#1-Redis多实例配置" class="headerlink" title="1. Redis多实例配置"></a>1. Redis多实例配置</h3><h4 id="1-1-查看主机Redis信息"><a href="#1-1-查看主机Redis信息" class="headerlink" title="1.1 查看主机Redis信息"></a>1.1 查看主机Redis信息</h4><ol><li>用<code>ps</code>命令查看<code>Redis</code>进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] ps -ef |grep redis</span><br><span class="line">root      1706     1  0  2019 ?        04:12:09 /usr/local/bin/redis-server *:6379                    </span><br><span class="line">root     18174  2560  0 15:35 pts/0    00:00:00 grep redis</span><br></pre></td></tr></table></figure><ol start="2"><li>查找配置文件位置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] locate redis.conf</span><br><span class="line">/etc/redis.conf</span><br></pre></td></tr></table></figure><h4 id="1-2-拷贝配置文件并修改"><a href="#1-2-拷贝配置文件并修改" class="headerlink" title="1.2 拷贝配置文件并修改"></a>1.2 拷贝配置文件并修改</h4><ol><li>拷贝<code>redis.conf</code>并命名为<code>redis6380.conf</code>，并修改参数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] <span class="built_in">cp</span> /etc/redis.conf /etc/redis6380.conf</span><br><span class="line">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class="line"><span class="comment"># 查找 /pidfile 找到pid位置</span></span><br><span class="line"><span class="comment"># pidfile /var/run/redis.pid        #修改pid，每个实例需要运行在不同的pid</span></span><br><span class="line">pidfile /var/run/redis6380.pid</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查找 /port 6379 找到端口位置</span></span><br><span class="line"><span class="comment"># port 6379                         #修改端口</span></span><br><span class="line">port 6380</span><br><span class="line"><span class="comment">#                      </span></span><br><span class="line"><span class="comment"># 查找 /dir 找到数据目录位置</span></span><br><span class="line"><span class="comment"># dir /mnt/newdatadrive/data/redis  #修改数据存放目录</span></span><br><span class="line"><span class="built_in">dir</span> /mnt/newdatadrive/data/redis6380</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 已开启Redis持久化</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><ol start="2"><li>准备上面配置的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] <span class="built_in">mkdir</span> –p /mnt/newdatadrive/data/redis6380</span><br><span class="line">[root@localhost ~] <span class="built_in">cp</span> /var/run/redis.pid /var/run/redis6380.pid</span><br></pre></td></tr></table></figure><h4 id="1-3-启动测试"><a href="#1-3-启动测试" class="headerlink" title="1.3 启动测试"></a>1.3 启动测试</h4><ol><li>启动<code>6380</code>端口<code>Redis</code>服务，并查看<code>Redis</code>进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /usr/local/bin/redis-server /etc/redis6380.conf</span><br><span class="line">[root@localhost ~] ps -ef |grep redis</span><br><span class="line">root      1706     1  0  2019 ?        04:12:00 /usr/local/bin/redis-server *:6379         </span><br><span class="line">root     15967     1  0 12:16 ?        00:00:00 /usr/local/bin/redis-server *:6380             </span><br><span class="line">root     15994  8014  0 12:16 pts/2    00:00:00 grep redis</span><br></pre></td></tr></table></figure><ol start="2"><li>测试登录<code>Redis</code>客户端</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt; QUIT     <span class="comment">#退出</span></span><br></pre></td></tr></table></figure><ol start="3"><li>停止<code>6380</code>端口的<code>Redis</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6380 shutdown</span><br></pre></td></tr></table></figure><h4 id="1-4-Redis数据迁移"><a href="#1-4-Redis数据迁移" class="headerlink" title="1.4 Redis数据迁移"></a>1.4 Redis数据迁移</h4><ol><li>登录原<code>Redis</code>客户端(<code>6379</code>)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6379</span><br><span class="line">127.0.0.1:6379&gt; SAVE             <span class="comment">#数据备份</span></span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET <span class="built_in">dir</span>   <span class="comment">#查看Redis数据目录</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/mnt/newdatadrive/data/redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; QUIT             <span class="comment">#退出</span></span><br></pre></td></tr></table></figure><ol start="2"><li>拷贝数据文件<code>appendonly.aof</code>和<code>dump.rdb</code>到<code>6380</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看6379的数据文件</span></span><br><span class="line">[root@localhost ~] <span class="built_in">cd</span> /mnt/newdatadrive/data/redis &amp;&amp; ll</span><br><span class="line">total 55176</span><br><span class="line">-rw-r--r-- 1 root root 55411226 Feb 11 09:25 appendonly.aof</span><br><span class="line">-rw-r--r-- 1 root root  1017181 Feb 11 12:28 dump.rdb</span><br><span class="line"><span class="comment"># 拷贝到6380</span></span><br><span class="line">[root@localhost ~] \<span class="built_in">cp</span> /mnt/newdatadrive/data/redis/appendonly.aof /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br><span class="line">[root@localhost ~] \<span class="built_in">cp</span> /mnt/newdatadrive/data/redis/dump.rdb /mnt/newdatadrive/data/redis6380/dump.rdb</span><br></pre></td></tr></table></figure><ol start="3"><li>启动<code>6380</code>端口<code>Redis</code>服务，导入<code>AOF</code>数据文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /usr/local/bin/redis-server /etc/redis6380.conf</span><br><span class="line">[root@localhost ~] redis-cli -p 6380 --pipe &lt; /mnt/newdatadrive/data/redis6380/appendonly.aof</span><br></pre></td></tr></table></figure><ol start="4"><li>登录<code>Redis</code>查看数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6380</span><br><span class="line">127.0.0.1:6380&gt;   <span class="comment">#输入具体命令查看数据</span></span><br></pre></td></tr></table></figure><h4 id="1-5-配置远程可访问"><a href="#1-5-配置远程可访问" class="headerlink" title="1.5 配置远程可访问"></a>1.5 配置远程可访问</h4><ol><li>修改配置文件<code>redis6380.conf</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] vim /etc/redis6380.conf</span><br><span class="line"><span class="comment"># 查找 /bind 找到：bind 127.0.0.1并注释，其它ip地址也可访问</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查找 /requirepass 去掉注释#，并把foobared 替换为密码，例如：password123456</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line">requirepass password123456</span><br></pre></td></tr></table></figure><ol start="2"><li>开启防火墙的端口号规则（安全组），将<code>6380</code>端口号开通</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 6380 -j ACCEPT</span><br></pre></td></tr></table></figure><ol start="3"><li>修改完成后，要在服务里重启<code>Redis</code>服务才能使设置生效</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/redis-server /etc/redis6380.conf</span><br></pre></td></tr></table></figure><ol start="4"><li>测试远程访问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zc&gt; redis-cli -h 192.168.111.226 -p 6380 -a password123456</span><br><span class="line">192.168.111.226:6380&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>停止<code>6380</code>的<code>Redis</code>服务也需要密码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] redis-cli -p 6380 -a password123456 shutdown</span><br></pre></td></tr></table></figure><h3 id="2-MySQL多实例配置"><a href="#2-MySQL多实例配置" class="headerlink" title="2. MySQL多实例配置"></a>2. MySQL多实例配置</h3><h4 id="2-1-查看主机MySQL信息"><a href="#2-1-查看主机MySQL信息" class="headerlink" title="2.1 查看主机MySQL信息"></a>2.1 查看主机MySQL信息</h4><ol><li>查看现有<code>MySQL</code>数据库实例占用端口</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] netstat -anp | grep mysqld</span><br><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      1089/mysqld         </span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     20497    1089/mysqld          /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure><blockquote><p><strong>须先关闭单实例，跟多实例会有冲突</strong></p><ul><li>备份数据：<code>[root@localhost ~] mysqldump -P 3306 -u root -p --all-databases &gt; /home/backup/data3306.bak</code></li><li>停止单实例服务：<code>[root@localhost ~] service mysqld stop</code></li></ul></blockquote><ol start="2"><li>查找配置文件位置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] locate my.cnf</span><br><span class="line">/etc/my.cnf</span><br><span class="line">/etc/my.cnf.d</span><br></pre></td></tr></table></figure><h4 id="2-2-添加一个3307端口的实例"><a href="#2-2-添加一个3307端口的实例" class="headerlink" title="2.2 添加一个3307端口的实例"></a>2.2 添加一个3307端口的实例</h4><ol><li>拷贝<code>my.cnf</code>并命名为<code>my3307.cnf</code>，并修改参数，主要修改port,sockt,datadir</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] <span class="built_in">cp</span> /etc/my.cnf /etc/my3307.cnf</span><br><span class="line">[root@localhost ~] vi /etc/my3307.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># server端字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">user=root</span><br><span class="line"><span class="comment"># 修改端口</span></span><br><span class="line">port=3307</span><br><span class="line"><span class="comment"># 修改数据存放目录</span></span><br><span class="line">datadir=/var/lib/mysql3307</span><br><span class="line"><span class="comment"># 客户端连接socket</span></span><br><span class="line">socket=/var/lib/mysql/mysql3307.sock</span><br><span class="line"><span class="comment"># 修改日志文件</span></span><br><span class="line">log-error=/var/log/mysqld3307.log</span><br><span class="line"><span class="comment"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class="line">pid-file=/var/run/mysqld/mysqld3307.pid</span><br><span class="line"><span class="comment"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class="line">explicit_defaults_for_timestamp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># skip_grant_tables</span></span><br><span class="line">[mysql]</span><br><span class="line">socket=/var/lib/mysql/mysql3307.sock</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql.server]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql_safe]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line">socket=/var/lib/mysql/mysql3307.sock</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化数据库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入host避免反解析报错</span></span><br><span class="line">[root@localhost ~] <span class="built_in">echo</span> <span class="string">&quot;127.0.0.1   `hostname`&quot;</span> &gt;&gt; /etc/hosts &amp;&amp; <span class="built_in">cat</span> /etc/hosts</span><br><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --initialize-insecure</span><br></pre></td></tr></table></figure><ol start="3"><li>启动<code>3307</code>端口<code>MySQL</code>服务，并查看<code>MySQL</code>进程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3307.cnf --user=root &amp;</span><br></pre></td></tr></table></figure><ol start="4"><li>登录<code>MySQL</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多实例为root增加密码</span></span><br><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock password <span class="string">&#x27;123qwe&#x27;</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">[root@localhost ~] mysql -S /var/lib/mysql/mysql3307.sock -p</span><br></pre></td></tr></table></figure><ol start="5"><li>停止本实例<code>MySQL</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3307.sock shutdown</span><br></pre></td></tr></table></figure><h4 id="2-3-再添加一个3308端口的实例"><a href="#2-3-再添加一个3308端口的实例" class="headerlink" title="2.3 再添加一个3308端口的实例"></a>2.3 再添加一个3308端口的实例</h4><ol><li>拷贝<code>my.cnf</code>并命名为<code>my3308.cnf</code>，并修改参数，主要修改port,sockt,datadir</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] <span class="built_in">cp</span> /etc/my.cnf /etc/my3308.cnf</span><br><span class="line">[root@localhost ~] vi /etc/my3308.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># server端字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_general_ci</span><br><span class="line">user=root</span><br><span class="line"><span class="comment"># 修改端口</span></span><br><span class="line">port=3308</span><br><span class="line"><span class="comment"># 修改数据存放目录</span></span><br><span class="line">datadir=/var/lib/mysql3308</span><br><span class="line"><span class="comment"># 客户端连接socket</span></span><br><span class="line">socket=/var/lib/mysql/mysql3308.sock</span><br><span class="line"><span class="comment"># 修改日志文件</span></span><br><span class="line">log-error=/var/log/mysqld3308.log</span><br><span class="line"><span class="comment"># 修改pid，每个实例需要运行在不同的pid</span></span><br><span class="line">pid-file=/var/run/mysqld/mysqld3308.pid</span><br><span class="line"><span class="comment"># 解决问题：TIMESTAMP with implicit DEFAULT value is deprecated</span></span><br><span class="line">explicit_defaults_for_timestamp=<span class="literal">true</span></span><br><span class="line"><span class="comment"># skip_grant_tables</span></span><br><span class="line">[mysql]</span><br><span class="line">socket=/var/lib/mysql/mysql3308.sock</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql.server]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql_safe]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[client]</span><br><span class="line">socket=/var/lib/mysql/mysql3308.sock</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure><ol start="2"><li>初始化数据库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --initialize-insecure</span><br></pre></td></tr></table></figure><ol start="3"><li>启动<code>3308</code>端口<code>MySQL</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqld --defaults-file=/etc/my3308.cnf --user=root &amp;</span><br></pre></td></tr></table></figure><ol start="4"><li>登录<code>MySQL</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多实例为root增加密码</span></span><br><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock password <span class="string">&#x27;123qwe&#x27;</span></span><br><span class="line"><span class="comment"># 登录</span></span><br><span class="line">[root@localhost ~] mysql -S /var/lib/mysql/mysql3308.sock -p</span><br></pre></td></tr></table></figure><ol start="5"><li>停止本实例<code>MySQL</code>服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] mysqladmin -u root -S /var/lib/mysql/mysql3308.sock shutdown</span><br></pre></td></tr></table></figure><h4 id="2-4-实例3307开启远程访问"><a href="#2-4-实例3307开启远程访问" class="headerlink" title="2.4 实例3307开启远程访问"></a>2.4 实例3307开启远程访问</h4><ol><li>开启<code>3307</code>端口防火墙</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] /sbin/iptables -I INPUT -p tcp --dport 3307 -j ACCEPT</span><br></pre></td></tr></table></figure><ol start="2"><li>测试远程访问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zc&gt;mysql -h 192.168.111.227 -P 3307 -u root -p</span><br><span class="line">Enter password: ******</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> MySQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「安全认证」基于Shiro前后端分离的认证与授权(三.前端篇)</title>
      <link href="/2020/02/07/authenticate-shiro-vue.html"/>
      <url>/2020/02/07/authenticate-shiro-vue.html</url>
      
        <content type="html"><![CDATA[<p>前两篇我们整合了<code>SpringBoot+Shiro+JWT+Redis</code>实现了登录认证，接口权限控制，接下来将要实现前端 Vue 的动态路由控制。</p><h3 id="1-前端权限控制思路（Vue）"><a href="#1-前端权限控制思路（Vue）" class="headerlink" title="1. 前端权限控制思路（Vue）"></a>1. 前端权限控制思路（Vue）</h3><p>前端的权限控制，不同的权限对应着不同的路由，同时菜单也需根据不同的权限，异步生成。<br>先回顾下整体流程：<span id="more"></span><br><img src="/2020/02/07/authenticate-shiro-vue/auth-global.png"></p><ul><li>登录: 提交账号和密码到服务端签发<code>token</code>，拿到<code>token</code>之后存入浏览器，再携带<code>token</code>(一般放在请求头中)再去获取用户的详细信息(包括用户权限等信息)。</li><li>权限验证：通过用户权限信息 构建 对应权限的路由，通过<code>router.addRoutes</code>动态挂载这些路由。</li></ul><p>接下来将基于 Vue 开源后台模板<a href="https://github.com/PanJiaChen/vue-admin-template">vue-admin-template</a>来演示具体流程，这里只演示重要代码，完整项目移步文章末尾获取源码。</p><h3 id="2-登录"><a href="#2-登录" class="headerlink" title="2. 登录"></a>2. 登录</h3><ol><li>先准备基础的静态路由(<code>src/router/index.js</code>)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> constantRoutes = [</span><br><span class="line">  <span class="comment">// 登陆页面</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/login/index&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 首页</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/dashboard&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;Dashboard&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/dashboard/index&#x27;</span>),</span><br><span class="line">      <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;首页&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;dashboard&#x27;</span> &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/404&#x27;</span>),</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="2"><li>登录页面(src&#x2F;views&#x2F;login&#x2F;index.vue)<code>click</code>事件触发登录操作</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/login&#x27;</span>, <span class="variable language_">this</span>.<span class="property">loginForm</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;); <span class="comment">//登录成功之后重定向到首页</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(err); <span class="comment">//登录失败提示错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>登录逻辑(src&#x2F;store&#x2F;modules&#x2F;user.js)<code>action</code>:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// user login</span></span><br><span class="line">  <span class="title function_">login</span>(<span class="params">&#123; commit &#125;, userInfo</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; account, password &#125; = userInfo</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的login调用api接口请求数据</span></span><br><span class="line">      <span class="title function_">login</span>(&#123; <span class="attr">account</span>: account.<span class="title function_">trim</span>(), <span class="attr">password</span>: password &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;SET_TOKEN&#x27;</span>, data)</span><br><span class="line">        <span class="title function_">setToken</span>(data)</span><br><span class="line">        <span class="title function_">resolve</span>()</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  <span class="title function_">getInfo</span>(<span class="params">&#123; commit, state &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里的getInfo调用api接口请求数据</span></span><br><span class="line">      <span class="title function_">getInfo</span>(state.<span class="property">token</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(<span class="string">&#x27;Verification failed, please Login again.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; nickname, avatar, roles, permissions &#125; = data</span><br><span class="line">        <span class="comment">// 全局储存用户信息</span></span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;SET_NAME&#x27;</span>, nickname)</span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;SET_AVATAR&#x27;</span>, avatar)</span><br><span class="line">        <span class="comment">// 角色信息</span></span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;SET_ROLES&#x27;</span>, roles)</span><br><span class="line">        <span class="comment">// 指令权限信息</span></span><br><span class="line">        <span class="title function_">commit</span>(<span class="string">&#x27;SET_PERMISSIONS&#x27;</span>, permissions)</span><br><span class="line">        <span class="title function_">resolve</span>(data)</span><br><span class="line">      &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>/login</code>与<code>/getInfo</code>接口与返回的数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">POST</span> (<span class="attr">localhost</span>:<span class="number">8282</span>/login)</span><br><span class="line">请求参数: &#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span><br><span class="line">响应: &#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>:<span class="string">&quot;登录成功&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>:<span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhZG1pbiIsInVpZCI6MSwiZXhwIjoxNTgwOTk4MTIzfQ.6jgqt_opjnosASlJ2oSIYZn1Sb2BQO-eUo_6OVTHv50&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------getInfo--------------</span></span><br><span class="line"><span class="variable constant_">GET</span> (<span class="attr">localhost</span>:<span class="number">8282</span>/user/info)</span><br><span class="line"><span class="title class_">Headers</span>: &#123;<span class="string">&quot;X-Token&quot;</span>:<span class="string">&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJhZG1pbiIsInVpZCI6MSwiZXhwIjoxNTgwOTk4MTIzfQ.6jgqt_opjnosASlJ2oSIYZn1Sb2BQO-eUo_6OVTHv50&quot;</span>&#125;</span><br><span class="line">响应: &#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;获取成功&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;account&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">        <span class="string">&quot;nickname&quot;</span>: <span class="string">&quot;超级管理员&quot;</span>,</span><br><span class="line">        <span class="string">&quot;roles&quot;</span>: [<span class="string">&quot;admin&quot;</span>],</span><br><span class="line">        <span class="string">&quot;permissions&quot;</span>: [<span class="string">&quot;user:list&quot;</span>,<span class="string">&quot;user:add&quot;</span>,<span class="string">&quot;user:delete&quot;</span>,<span class="string">&quot;user:update&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>获取用户信息(src&#x2F;permission.js)<ul><li>用户登录成功之后，我们会在全局钩子<code>router.beforeEach</code>中拦截路由，判断是否已获得<code>token</code>，在获得<code>token</code>之后我们就要去获取用户的基本信息 并且根据用户角色动态挂载路由。</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>] <span class="comment">// 白名单</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="title function_">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 判断是否已获得token</span></span><br><span class="line">  <span class="keyword">const</span> hasToken = <span class="title function_">getToken</span>()</span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">path</span> === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> hasRole = store.<span class="property">getters</span>.<span class="property">role</span></span><br><span class="line">      <span class="keyword">if</span> (hasRole) &#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 获取用户角色 [&#x27;admin&#x27;] 或,[&#x27;developer&#x27;,&#x27;editor&#x27;]</span></span><br><span class="line">          <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/getInfo&#x27;</span>)</span><br><span class="line">          <span class="comment">// 动态根据 角色 算出其对应有权限的路由</span></span><br><span class="line">          <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;permission/generateRoutes&#x27;</span>, roles)</span><br><span class="line">          <span class="comment">// 动态挂载路由</span></span><br><span class="line">          router.<span class="title function_">addRoutes</span>(accessRoutes)</span><br><span class="line">          <span class="comment">// addRouter是让挂载的路由生效，但是挂载后&#x27;router.options.routes&#x27;并未刷新(应该是个bug)</span></span><br><span class="line">          <span class="comment">// 所以还需要手动将路由加入&#x27;router.options.routes&#x27;</span></span><br><span class="line">          router.<span class="property">options</span>.<span class="property">routes</span> = constantRoutes.<span class="title function_">concat</span>(accessRoutes)</span><br><span class="line">          <span class="title function_">next</span>()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="keyword">await</span> store.<span class="title function_">dispatch</span>(<span class="string">&#x27;user/resetToken&#x27;</span>)</span><br><span class="line">          <span class="title class_">Message</span>.<span class="title function_">error</span>(error || <span class="string">&#x27;Has Error&#x27;</span>)</span><br><span class="line">          <span class="title function_">next</span>(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line">    <span class="keyword">if</span> (whiteList.<span class="title function_">indexOf</span>(to.<span class="property">path</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-动态挂载路由"><a href="#3-动态挂载路由" class="headerlink" title="3. 动态挂载路由"></a>3. 动态挂载路由</h3><p>主要思路，前端会有一份包含所有路由的路由表。创建<code>Vue</code>实例时会先挂载登录等公共路由；当用户登录之后，通过<code>getInfo(token)</code>获取用户的角色(<code>roles</code>)，动态根据用户的<code>roles</code>算出其对应有权限的路由，再通过<code>router.addRoutes</code>动态挂载路由；使用<code>vuex</code>管理路由表，根据<code>vuex</code>中可访问的路由渲染菜单。但这些控制都只是页面级的，后端接口也需要做权限验证。</p><ol><li>改造一下路由表，添加异步路由列表，将角色添加到元数据<code>meta</code>中：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/user/list&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;User&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;用户管理&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;example&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;UserList&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/user/list&#x27;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;用户列表&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;nested&#x27;</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;edit&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;UserEdit&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/user/form&#x27;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;添加用户&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;form&#x27;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Form1&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/test/index&#x27;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;管理员角色测试&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;form&#x27;</span>, <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/editor&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Form2&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/test/index&#x27;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑角色测试&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;form&#x27;</span>, <span class="attr">roles</span>: [<span class="string">&#x27;editor&#x27;</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/form&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Form3&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/test/index&#x27;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;用户角色测试&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;form&#x27;</span>, <span class="attr">roles</span>: [<span class="string">&#x27;user&#x27;</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/nested&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/nested/menu3&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Nested&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;子菜单权限测试&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;form&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;menu1&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/test/index&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Menu1&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;管理员可见&#x27;</span>, <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>] &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;menu2&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/test/index&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Menu1&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;编辑者可见&#x27;</span>, <span class="attr">roles</span>: [<span class="string">&#x27;editor&#x27;</span>] &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;menu3&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;@/views/test/index&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Menu1&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;普通用户可见&#x27;</span>, <span class="attr">roles</span>: [<span class="string">&#x27;user&#x27;</span>] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>根据前面获取用户信息的代码可发现，通过<code>store.dispatch(&#39;permission/generateRoutes&#39;,roles)</code>来获得有权限的路由，新建<code>src/store/modules/permission.js</code>如下：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; asyncRoutes, constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"><span class="comment">/** 判断用户是否拥有此路由的权限 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPermission</span>(<span class="params">roles, route</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (route.<span class="property">meta</span> &amp;&amp; route.<span class="property">meta</span>.<span class="property">roles</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> roles.<span class="title function_">some</span>(<span class="function"><span class="params">role</span> =&gt;</span> route.<span class="property">meta</span>.<span class="property">roles</span>.<span class="title function_">includes</span>(role))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 递归组装路由表，返回符合用户角色权限的路由列表 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">filterAsyncRoutes</span>(<span class="params">routes, roles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  routes.<span class="title function_">forEach</span>(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = &#123; ...route &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">hasPermission</span>(roles, tmp)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmp.<span class="property">children</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        tmp.<span class="property">children</span> = <span class="title function_">filterAsyncRoutes</span>(tmp.<span class="property">children</span>, roles)</span><br><span class="line">      &#125;</span><br><span class="line">      res.<span class="title function_">push</span>(tmp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">routes</span>: [], <span class="comment">// 所有路由,包括静态路由和动态路由</span></span><br><span class="line">  <span class="attr">addRoutes</span>: [] <span class="comment">// 动态路由</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="attr">SET_ROUTES</span>: <span class="function">(<span class="params">state, routes</span>) =&gt;</span> &#123;</span><br><span class="line">    state.<span class="property">addRoutes</span> = routes</span><br><span class="line">    <span class="comment">// 合并路由</span></span><br><span class="line">    state.<span class="property">routes</span> = constantRoutes.<span class="title function_">concat</span>(routes)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// 生成动态路由</span></span><br><span class="line">  <span class="title function_">generateRoutes</span>(<span class="params">&#123; commit &#125;, roles</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> accessedRoutes</span><br><span class="line">      <span class="keyword">if</span> (roles.<span class="title function_">includes</span>(<span class="string">&#x27;admin&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// &#x27;超级管理员&#x27;拥有所有的路由，这样判断节省加载时间</span></span><br><span class="line">        accessedRoutes = asyncRoutes || []</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 筛选出该角色有权限的路由</span></span><br><span class="line">        accessedRoutes = <span class="title function_">filterAsyncRoutes</span>(asyncRoutes, roles)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">commit</span>(<span class="string">&#x27;SET_ROUTES&#x27;</span>, accessedRoutes)</span><br><span class="line">      <span class="title function_">resolve</span>(accessedRoutes)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-axios-拦截器"><a href="#4-axios-拦截器" class="headerlink" title="4. axios 拦截器"></a>4. axios 拦截器</h3><p>通过<code>request</code>拦截器在每个请求头里面塞入<code>token</code>，好让后端对请求进行权限验证；代码位置:<code>src/utils/request.js</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="comment">// create an axios instance</span></span><br><span class="line"><span class="keyword">const</span> service = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.<span class="property">env</span>.<span class="property">VUE_APP_BASE_API</span>, <span class="comment">// url = base url + request url</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// send cookies when cross-domain requests</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span> <span class="comment">// request timeout</span></span><br><span class="line">&#125;)</span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (store.<span class="property">getters</span>.<span class="property">token</span>) &#123;</span><br><span class="line">      <span class="comment">// 登陆后将token放入headers[&#x27;X-Token&#x27;]中</span></span><br><span class="line">      config.<span class="property">headers</span>[<span class="string">&#x27;X-Token&#x27;</span>] = <span class="title function_">getToken</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure><h3 id="5-指令权限"><a href="#5-指令权限" class="headerlink" title="5. 指令权限"></a>5. 指令权限</h3><p>可以使用全局权限判断函数，实现按钮级别的权限判断。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">&quot;checkPermission(&#x27;user:add&#x27;)&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">&quot;checkPermission(&#x27;user:delete&#x27;)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">&quot;checkPermission(&#x27;user:update&#x27;)&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">v-if</span>=<span class="string">&quot;checkPermission(&#x27;user:list&#x27;)&quot;</span>&gt;</span>查看<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> checkPermission <span class="keyword">from</span> <span class="string">&#x27;@/utils/permission&#x27;</span> <span class="comment">// 权限判断函数</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">checkPermission</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> <span class="title function_">checkPermission</span>(value)</span></span><br><span class="line"><span class="language-javascript">&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>src/utils/permission.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">checkPermission</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> permissions = store.<span class="property">getters</span>.<span class="property">permissions</span></span><br><span class="line">  <span class="keyword">return</span> permissions.<span class="title function_">indexOf</span>(value) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-效果演示："><a href="#6-效果演示：" class="headerlink" title="6. 效果演示："></a>6. 效果演示：</h3><p><img src="/2020/02/07/authenticate-shiro-vue/auth-admin.jpg"></p><blockquote><p>注：搭建到这里的代码在<code>github</code>源码<code>tag</code>的<code>V3.0</code>中。<br>源码地址: <a href="https://github.com/chaooo/springboot-vue-shiro.git">https://github.com/chaooo/springboot-vue-shiro.git</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「安全认证」基于Shiro前后端分离的认证与授权(二.授权篇)</title>
      <link href="/2020/01/21/authenticate-shiro-authorize.html"/>
      <url>/2020/01/21/authenticate-shiro-authorize.html</url>
      
        <content type="html"><![CDATA[<p>前面我们整合了<code>SpringBoot+Shiro+JWT</code>实现了登录认证，但还没有实现权限控制，这是接下来的工作。<span id="more"></span></p><h3 id="1-JWT的Token续签"><a href="#1-JWT的Token续签" class="headerlink" title="1. JWT的Token续签"></a>1. JWT的Token续签</h3><h4 id="1-1-续签思路"><a href="#1-1-续签思路" class="headerlink" title="1.1 续签思路"></a>1.1 续签思路</h4><ol><li>业务逻辑：<ul><li>登录成功后，用户在未过期时间内继续操作，续签token。</li><li>登录成功后，空闲超过过期时间，返回token已失效，重新登录。</li></ul></li><li>实现逻辑：<ol><li>登录成功后将token存储到redis里面(这时候k、v值一样都为token)，并设置过期时间为token过期时间</li><li>当用户请求时token值还未过期，则重新设置redis里token的过期时间。</li><li>当用户请求时token值已过期，但redis中还在，则JWT重新生成token并覆盖v值(这时候k、v值不一样了)，然后设置redis过期时间。</li><li>当用户请求时token值已过期，并且redis中也不存在，则用户空闲超时，返回token已失效，重新登录。</li></ol></li></ol><h4 id="1-2-编码实现"><a href="#1-2-编码实现" class="headerlink" title="1.2 编码实现"></a>1.2 编码实现</h4><ol><li><code>pom.xml</code>引入<code>Redis</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写<code>Redis</code>工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>JwtUtil中增加返回过期秒数的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">/** 设置过期时间: 30分钟 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//... 其他代码省略</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回设置的过期秒数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long 秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getExpireTime</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  EXPIRE_TIME/<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>改写登录逻辑，生成<code>token</code>后存入<code>Redis</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SysService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="comment">// 生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createToken(user);</span><br><span class="line">        <span class="comment">// 为了过期续签，将token存入redis，并设置超时时间</span></span><br><span class="line">        redisUtil.set(token, token, JwtUtil.getExpireTime());</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title function_">login</span><span class="params">(String account, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//处理比对密码</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sysDao.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span>  <span class="variable">salt</span> <span class="operator">=</span> user.getSalt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">md5Password</span> <span class="operator">=</span> Md5Util.md5(password+salt);</span><br><span class="line">            <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">            <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">                <span class="comment">//生成token给用户，并存入redis</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(user);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;(<span class="number">0</span>,<span class="string">&quot;登录成功&quot;</span>, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;( -<span class="number">1</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>改写<code>MyRealm</code>，加入<code>token</code>续签逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;MyRealm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JWT Token续签：</span></span><br><span class="line"><span class="comment">     * 业务逻辑：登录成功后，用户在未过期时间内继续操作，续签token。</span></span><br><span class="line"><span class="comment">     *         登录成功后，空闲超过过期时间，返回token已失效，重新登录。</span></span><br><span class="line"><span class="comment">     * 实现逻辑：</span></span><br><span class="line"><span class="comment">     *    1.登录成功后将token存储到redis里面(这时候k、v值一样都为token)，并设置过期时间为token过期时间</span></span><br><span class="line"><span class="comment">     *    2.当用户请求时token值还未过期，则重新设置redis里token的过期时间。</span></span><br><span class="line"><span class="comment">     *    3.当用户请求时token值已过期，但redis中还在，则JWT重新生成token并覆盖v值(这时候k、v值不一样了)，然后设置redis过期时间。</span></span><br><span class="line"><span class="comment">     *    4.当用户请求时token值已过期，并且redis中也不存在，则用户空闲超时，返回token已失效，重新登录。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tokenRefresh</span><span class="params">(String token, User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheToken</span> <span class="operator">=</span> String.valueOf(redisUtil.get(token));</span><br><span class="line">        <span class="comment">// 过期后会得到&quot;null&quot;值，所以需判断字符串&quot;null&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (cacheToken != <span class="literal">null</span> &amp;&amp; cacheToken.length() != <span class="number">0</span> &amp;&amp; !<span class="string">&quot;null&quot;</span>.equals(cacheToken)) &#123;</span><br><span class="line">            <span class="comment">// 校验token有效性</span></span><br><span class="line">            <span class="keyword">if</span> (!JwtUtil.isVerify(cacheToken)) &#123;</span><br><span class="line">                <span class="comment">// 生成token</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">newToken</span> <span class="operator">=</span> JwtUtil.createToken(user);</span><br><span class="line">                <span class="comment">// 将token存入redis,并设置超时时间</span></span><br><span class="line">                redisUtil.set(token, newToken, JwtUtil.getExpireTime());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重新设置超时时间</span></span><br><span class="line">                redisUtil.expire(token, JwtUtil.getExpireTime());</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;打印存入redis的过期时间：&quot;</span>+redisUtil.getExpire(token));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写认证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;————————身份认证——————————&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> (String) auth.getCredentials();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == token) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;token为空!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密获得username，用于和数据库进行对比</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> JwtUtil.parseTokenAud(token);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sysService.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;用户不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验token是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (!tokenRefresh(token, user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;Token已过期!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user, token,<span class="string">&quot;MyRealm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，JWT的Token续签的功能已经全部实现了。</p><h3 id="2-权限管理"><a href="#2-权限管理" class="headerlink" title="2. 权限管理"></a>2. 权限管理</h3><h4 id="2-1-首先增加三张数据表"><a href="#2-1-首先增加三张数据表" class="headerlink" title="2.1 首先增加三张数据表"></a>2.1 首先增加三张数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 角色表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `role_name` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">  `description` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_role`(`id`,`role_name`,`description`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理角色&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;user&#x27;</span>,<span class="string">&#x27;用户角色&#x27;</span>);</span><br><span class="line"><span class="comment">/** 权限表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_permission`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_permission` (</span><br><span class="line">  `id` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键id&#x27;</span>,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单标题&#x27;</span>,</span><br><span class="line">  `url` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;路径&#x27;</span>,</span><br><span class="line">  `menu_type` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单类型(0:一级菜单; 1:子菜单:2:按钮权限)&#x27;</span>,</span><br><span class="line">  `perms` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单权限编码&#x27;</span>,</span><br><span class="line">  `sort_no` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;菜单排序&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除状态 0正常 1已删除&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `index_prem_sort_no` (`sort_no`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `index_prem_del_flag` (`del_flag`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT COMMENT<span class="operator">=</span><span class="string">&#x27;菜单权限表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_permission`(`id`,`name`,`url`,`menu_type`,`perms`,`sort_no`,`del_flag`) <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;新增用户&#x27;</span>,<span class="string">&#x27;/user/add&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;user:add&#x27;</span>,<span class="number">1</span>,<span class="number">0</span>),(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;删除用户&#x27;</span>,<span class="string">&#x27;/user/delete&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;user:delete&#x27;</span>,<span class="number">2</span>,<span class="number">0</span>),(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;修改用户&#x27;</span>,<span class="string">&#x27;/user/update&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;user:update&#x27;</span>,<span class="number">3</span>,<span class="number">0</span>),(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;查询用户&#x27;</span>,<span class="string">&#x27;/user/list&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;user:list&#x27;</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/** 角色与权限关联表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_permission`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_permission` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `role_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  `permission_id` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `index_group_role_per_id` (`role_id`,`permission_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `index_group_role_id` (`role_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  KEY `index_group_per_id` (`permission_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">6</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT COMMENT<span class="operator">=</span><span class="string">&#x27;角色权限表&#x27;</span>;</span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `sys_role_permission`(`id`,`role_id`,`permission_id`) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">1</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-编码实现"><a href="#2-2-编码实现" class="headerlink" title="2.2 编码实现"></a>2.2 编码实现</h4><ol><li>补全<code>MyRealm</code>中授权验证逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;MyRealm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="comment">//...其他代码省略</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户权限信息，包括角色以及权限。</span></span><br><span class="line"><span class="comment">     * 只有当触发检测用户权限时才会调用此方法，例如checkRole,checkPermissionJwtToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;————权限认证 [ roles、permissions]————&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (principals != <span class="literal">null</span>) &#123;</span><br><span class="line">            user = (User) principals.getPrimaryPrincipal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户拥有的角色，比如“admin/user”</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">role</span> <span class="operator">=</span> sysService.getRoleByRoleid(user.getRoleid());</span><br><span class="line">            simpleAuthorizationInfo.addRole(role);</span><br><span class="line">            log.info(<span class="string">&quot;角色为：&quot;</span>+role);</span><br><span class="line">            <span class="comment">// 用户拥有的权限集合，比如“role:add,user:add”</span></span><br><span class="line">            Set&lt;String&gt; permissions = sysService.getPermissionsByRoleid(user.getRoleid());</span><br><span class="line">            simpleAuthorizationInfo.addStringPermissions(permissions);</span><br><span class="line">            log.info(<span class="string">&quot;权限有：&quot;</span>+permissions.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Service</code>中添加获取角色与权限的方法，DAO与Mapper请移步源码。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SysService</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据roleid查找用户角色名，自定义Realm中调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> roleid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> roles</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String <span class="title function_">getRoleByRoleid</span><span class="params">(Integer roleid)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据roleid查找用户权限，自定义Realm中调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> roleid</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  Set&lt;permissions&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Set&lt;String&gt; <span class="title function_">getPermissionsByRoleid</span><span class="params">(Integer roleid)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SysService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoleByRoleid</span><span class="params">(Integer roleid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysDao.getRoleByRoleid(roleid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">getPermissionsByRoleid</span><span class="params">(Integer roleid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysDao.getPermissionsByRoleid(roleid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>Controller</code>中使用<code>@RequiresPermissions</code>来控制权限</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserApi</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermissions(&quot;user:list&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseVo <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> userService.loadUser();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户更新资料</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequiresPermissions(&quot;user:update&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/user/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseVo <span class="title function_">update</span><span class="params">(User user, HttpServletRequest request)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;X-Token&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> userService.modifyUser(token, user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里的登录认证+授权控制 在<code>github</code>源码<code>tag</code>的<code>V2.0</code>中，后续版本再加入前端动态路由控制等。<br>源码地址: <a href="https://github.com/chaooo/springboot-vue-shiro.git">https://github.com/chaooo/springboot-vue-shiro.git</a><br>仅下载后端认证+授权控制源码:<br><code>git clone --branch V2.0 https://github.com/chaooo/springboot-vue-shiro.git</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「安全认证」基于Shiro前后端分离的认证与授权(一.认证篇)</title>
      <link href="/2020/01/18/authenticate-shiro-login.html"/>
      <url>/2020/01/18/authenticate-shiro-login.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-开始之前"><a href="#1-开始之前" class="headerlink" title="1. 开始之前"></a>1. 开始之前</h3><h4 id="1-1-技术选型"><a href="#1-1-技术选型" class="headerlink" title="1.1 技术选型"></a>1.1 技术选型</h4><p>选用<code>SpringBoot+Shiro+JWT</code>实现登录认证，结合<code>Redis</code>服务实现<code>token</code>的续签，前端选用<code>Vue</code>动态构造路由及更细粒度的操作权限控制。</p><ul><li>前后端分离项目中，我们一般采用的是无状态登录：服务端不保存任何客户端请求者信息，客户端需要自己携带着信息去访问服务端，并且携带的信息可以被服务端辨认。</li><li>而<code>Shiro</code>默认的拦截跳转都是跳转<code>url</code>页面，拦截校验机制恰恰使用的<code>session</code>；而前后端分离后，后端并无权干涉页面跳转。</li><li>因此前后端分离项目中使用<code>Shiro</code>就需要对其进行改造，我们可以在整合<code>Shiro</code>的基础上自定义登录校验，继续整合<code>JWT</code>(或者 oauth2.0 等)，使其成为支持服务端无状态登录，即<code>token</code>登录。</li><li>在<code>Vue</code>项目中，只需要根据登录用户的权限信息动态的加载路由列表就可以动态的构造出访问菜单。<span id="more"></span></li></ul><h4 id="1-2-整体流程"><a href="#1-2-整体流程" class="headerlink" title="1.2 整体流程"></a>1.2 整体流程</h4><ul><li>首次通过<code>post</code>请求将用户名与密码到<code>login</code>进行登入，登录成功后返回<code>token</code>；</li><li>每次请求，客户端需通过<code>header</code>将<code>token</code>带回服务器做<code>JWT Token</code>的校验；</li><li>服务端负责<code>token</code>生命周期的刷新，用户权限的校验；</li></ul><p><img src="/2020/01/18/authenticate-shiro-login/auth-global.png"></p><h3 id="2-SpringBoot-整合-Shiro-JWT"><a href="#2-SpringBoot-整合-Shiro-JWT" class="headerlink" title="2. SpringBoot 整合 Shiro+JWT"></a>2. SpringBoot 整合 Shiro+JWT</h3><p>这里贴出主要逻辑，源码请移步文章末尾获取。</p><ol><li>数据表</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 系统用户表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> sys_user;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sys_user(</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    account <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">    PASSWORD <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">    salt <span class="type">VARCHAR</span>(<span class="number">8</span>) COMMENT <span class="string">&#x27;随机盐&#x27;</span>,</span><br><span class="line">    nickname <span class="type">VARCHAR</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;用户昵称&#x27;</span>,</span><br><span class="line">    roleId <span class="type">INT</span> COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">    createTime <span class="type">DATE</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    updateTime <span class="type">DATE</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    deleteStatus <span class="type">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;是否有效：1有效，2无效&#x27;</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> sys_user_id_pk <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> sys_user_account_uk <span class="keyword">UNIQUE</span>(account)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JWT --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- shiro --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>shiro</code>配置类：构建<code>securityManager</code>环境，及配置<code>shiroFilter</code>并将<code>jwtFilter</code>添加进<code>shiro</code>的拦截器链中，放行登录注册请求。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;securityManager&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultWebSecurityManager <span class="title function_">getManager</span><span class="params">(MyRealm myRealm)</span> &#123;</span><br><span class="line">        <span class="type">DefaultWebSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultWebSecurityManager</span>();</span><br><span class="line">        <span class="comment">// 使用自己的realm</span></span><br><span class="line">        securityManager.setRealm(myRealm);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 关闭shiro自带的session，详情见文档</span></span><br><span class="line"><span class="comment">         * http://shiro.apache.org/session-management.html#SessionManagement-StatelessApplications%28Sessionless%29</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">DefaultSubjectDAO</span> <span class="variable">subjectDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSubjectDAO</span>();</span><br><span class="line">        <span class="type">DefaultSessionStorageEvaluator</span> <span class="variable">defaultSessionStorageEvaluator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSessionStorageEvaluator</span>();</span><br><span class="line">        defaultSessionStorageEvaluator.setSessionStorageEnabled(<span class="literal">false</span>);</span><br><span class="line">        subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator);</span><br><span class="line">        securityManager.setSubjectDAO(subjectDAO);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;shiroFilter&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterFactoryBean <span class="title function_">factory</span><span class="params">(DefaultWebSecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">ShiroFilterFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShiroFilterFactoryBean</span>();</span><br><span class="line">        factoryBean.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">// 拦截器</span></span><br><span class="line">        Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 配置不会被拦截的链接 顺序判断，规则：http://shiro.apache.org/web.html#urls-</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/register&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/unauthorized&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加自己的过滤器并且取名为jwt</span></span><br><span class="line">        Map&lt;String, Filter&gt; filterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        filterMap.put(<span class="string">&quot;jwt&quot;</span>, <span class="keyword">new</span> <span class="title class_">JwtFilter</span>());</span><br><span class="line">        factoryBean.setFilters(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤链定义，从上向下顺序执行，一般将/**放在最为下边</span></span><br><span class="line">        filterChainDefinitionMap.put(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;jwt&quot;</span>);</span><br><span class="line">        <span class="comment">// 未授权返回</span></span><br><span class="line">        factoryBean.setUnauthorizedUrl(<span class="string">&quot;/unauthorized&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加注解支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@DependsOn(&quot;lifecycleBeanPostProcessor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title function_">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultAdvisorAutoProxyCreator</span> <span class="variable">defaultAdvisorAutoProxyCreator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAdvisorAutoProxyCreator</span>();</span><br><span class="line">        <span class="comment">// 强制使用cglib，防止重复代理和可能引起代理出错的问题</span></span><br><span class="line">        <span class="comment">// https://zhuanlan.zhihu.com/p/29161098</span></span><br><span class="line">        defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title function_">lifecycleBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LifecycleBeanPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title function_">authorizationAttributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager securityManager)</span> &#123;</span><br><span class="line">        <span class="type">AuthorizationAttributeSourceAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationAttributeSourceAdvisor</span>();</span><br><span class="line">        advisor.setSecurityManager(securityManager);</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>自定义<code>Realm</code>：继承<code>AuthorizingRealm</code>类，在其中实现登陆验证及权限获取的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;MyRealm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="comment">/** 注入SysService */</span></span><br><span class="line">    <span class="keyword">private</span> SysService sysService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSysService</span><span class="params">(SysService sysService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sysService = sysService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 必须重写此方法，不然Shiro会报错</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(AuthenticationToken token)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token <span class="keyword">instanceof</span> JwtToken;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来进行身份认证，也就是说验证用户输入的账号和密码是否正确，</span></span><br><span class="line"><span class="comment">     * 获取身份验证信息，错误抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;————————身份认证——————————&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> (String) auth.getCredentials();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == token || !JwtUtil.isVerify(token)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;token无效!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解密获得username，用于和数据库进行对比</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> JwtUtil.parseTokenAud(token);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sysService.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == user) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(<span class="string">&quot;用户不存在!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(user, token,<span class="string">&quot;MyRealm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户权限信息，包括角色以及权限。</span></span><br><span class="line"><span class="comment">     * 只有当触发检测用户权限时才会调用此方法，例如checkRole,checkPermissionJwtToken</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;————权限认证 [ roles、permissions]————&quot;</span>);</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        <span class="comment">/* 暂不编写，此处编写后，controller中可以使用@RequiresPermissions来对用户权限进行拦截 */</span></span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>鉴权登录过滤器：继承<code>BasicHttpAuthenticationFilter</code>类,该拦截器需要拦截所有请求除(除登陆、注册等请求)，用于判断请求是否带有<code>token</code>，并获取<code>token</code>的值传递给<code>shiro</code>的登陆认证方法作为参数，用于获取<code>token</code>；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicHttpAuthenticationFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executeLogin(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            unauthorized(response);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> httpServletRequest.getHeader(<span class="string">&quot;X-Token&quot;</span>);</span><br><span class="line">        <span class="type">JwtToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtToken</span>(authorization);</span><br><span class="line">        <span class="comment">// 提交给realm进行登入，如果错误他会抛出异常并被捕获</span></span><br><span class="line">        getSubject(request, response).login(token);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证失败 跳转到 /unauthorized</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unauthorized</span><span class="params">(ServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> (HttpServletResponse) resp;</span><br><span class="line">            httpServletResponse.sendRedirect(<span class="string">&quot;/unauthorized&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对跨域提供支持</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">httpServletRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">httpServletResponse</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, httpServletRequest.getHeader(<span class="string">&quot;Origin&quot;</span>));</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST,OPTIONS,PUT,DELETE&quot;</span>);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, httpServletRequest.getHeader(<span class="string">&quot;Access-Control-Request-Headers&quot;</span>));</span><br><span class="line">        <span class="comment">// 跨域时会首先发送一个option请求，给option请求直接返回正常状态</span></span><br><span class="line">        <span class="keyword">if</span> (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) &#123;</span><br><span class="line">            httpServletResponse.setStatus(HttpStatus.OK.value());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.preHandle(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><code>JwtToken</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtToken</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationToken</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line">    JwtToken(String token) &#123;</span><br><span class="line">        <span class="built_in">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>JWT</code>工具类：利用登陆信息生成<code>token</code>，根据<code>token</code>获取<code>username</code>，<code>token</code>验证等方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">/** 设置过期时间: 30分钟 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/** 服务端的私钥secret,在任何场景都不应该流露出去 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOKEN_SECRET</span> <span class="operator">=</span> <span class="string">&quot;zhengchao&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名，30分钟过期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createToken</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>);</span><br><span class="line">            header.put(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">&quot;aud&quot;</span>, user.getAccount())</span><br><span class="line">                    .withClaim(<span class="string">&quot;uid&quot;</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVerify</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseTokenUid</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">&quot;uid&quot;</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseTokenAud</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">&quot;aud&quot;</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title function_">paraseExpiresTime</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span>  jwt.getExpiresAt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>MD5 加密工具类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Md5Util</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">salt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] HEX_DIGITS = <span class="string">&quot;0123456789ABCDEF&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注册与登录主要逻辑"><a href="#3-注册与登录主要逻辑" class="headerlink" title="3. 注册与登录主要逻辑"></a>3. 注册与登录主要逻辑</h3><p>这里只贴出主要逻辑，<code>DAO</code>和<code>Mapper</code>映射可查看源码，源码请移步文章末尾获取。</p><ol><li>登录<code>Controller</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysApi</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入服务类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SysService sysService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSysService</span><span class="params">(SysService sysService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sysService = sysService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册(用户名，密码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title function_">register</span><span class="params">(String account, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysService.register(account, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title function_">login</span><span class="params">(String account, String password)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysService.login(account, password);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理非法请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/unauthorized&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo <span class="title function_">unauthorized</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>(-<span class="number">1</span>, <span class="string">&quot;Token失效请重新登录!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Service</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SysService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册(用户名，密码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResponseVo&lt;String&gt; <span class="title function_">register</span><span class="params">(String account, String password)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ResponseVo&lt;String&gt; <span class="title function_">login</span><span class="params">(String account, String password)</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据account查找用户，自定义Realm中调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">selectByAccount</span><span class="params">(String account)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SysService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SysDao sysDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入DAO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSysDao</span><span class="params">(SysDao sysDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sysDao = sysDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户注册(用户名，密码)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title function_">register</span><span class="params">(String account, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//检查用户名是否被占用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sysDao.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;( -<span class="number">1</span>, <span class="string">&quot;用户名被占用&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加用户信息</span></span><br><span class="line">        user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="comment">//设置用户名</span></span><br><span class="line">        user.setAccount(account);</span><br><span class="line">        <span class="comment">//密码加密后再保存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> Md5Util.salt();</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5Password</span> <span class="operator">=</span> Md5Util.md5(password+salt);</span><br><span class="line">        user.setPassword(md5Password);</span><br><span class="line">        user.setSalt(salt);</span><br><span class="line">        <span class="comment">//设置注册时间</span></span><br><span class="line">        user.setCreatetime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="comment">//添加到数据库</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> sysDao.insertSelective(user);</span><br><span class="line">        <span class="comment">//返回信息</span></span><br><span class="line">        <span class="keyword">if</span>(row&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成token给用户</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createToken(user);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;(<span class="number">0</span>,<span class="string">&quot;注册成功&quot;</span>, token);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;( -<span class="number">1</span>, <span class="string">&quot;注册失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户登录(用户名，密码)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseVo&lt;String&gt; <span class="title function_">login</span><span class="params">(String account, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//处理比对密码</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> sysDao.selectByAccount(account);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span>  <span class="variable">salt</span> <span class="operator">=</span> user.getSalt();</span><br><span class="line">            <span class="type">String</span> <span class="variable">md5Password</span> <span class="operator">=</span> Md5Util.md5(password+salt);</span><br><span class="line">            <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">            <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">                <span class="comment">//生成token给用户</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createToken(user);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;(<span class="number">0</span>,<span class="string">&quot;登录成功&quot;</span>, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseVo</span>&lt;&gt;( -<span class="number">1</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据account查找用户，自定义Realm中调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> account</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">selectByAccount</span><span class="params">(String account)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sysDao.selectByAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>统一接口返回格式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseVo</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/** 状态码 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="comment">/** 提示信息 */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/** 返回的数据 */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseVo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseVo</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseVo</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：这里的登录认证逻辑在<code>github</code>源码<code>tag</code>的<code>V1.0</code>中，后续版本再加入<code>Token</code>续签和<code>shiro</code>前后端权限管理等。<br>源码地址: <a href="https://github.com/chaooo/springboot-vue-shiro.git">https://github.com/chaooo/springboot-vue-shiro.git</a><br>仅下载认证逻辑源码:<br><code>git clone --branch V1.0 https://github.com/chaooo/springboot-vue-shiro.git</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「安全认证」Shiro安全框架入门</title>
      <link href="/2019/12/22/authenticate-shiro.html"/>
      <url>/2019/12/22/authenticate-shiro.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-初识-Shiro"><a href="#1-初识-Shiro" class="headerlink" title="1. 初识 Shiro"></a>1. 初识 Shiro</h3><p><code>Apache Shiro</code>是一个强大易用的 Java 安全框架，提供了认证、授权、加密、会话管理、与 Web 集成、缓存等。</p><ul><li><p>具体来说，满足对如下元素的支持：</p><ul><li>用户，角色，权限(仅仅是操作权限，数据权限必须与业务需求紧密结合)，资源(url)。</li><li>用户分配角色，角色定义权限。</li><li>访问授权时支持角色或者权限，并且支持多级的权限定义。<span id="more"></span></li></ul></li><li><p>Shiro 作为一个完善的权限框架，可以应用在多种需要进行身份认证和访问授权的场景，例如：<code>独立应用</code>、<code>web应用</code>、<code>spring框架中集成</code>等。</p></li></ul><h3 id="2-Shiro-整体架构"><a href="#2-Shiro-整体架构" class="headerlink" title="2. Shiro 整体架构"></a>2. Shiro 整体架构</h3><p>在 shiro 架构中，有 3 个最主要的组件：<code>Subject</code>，<code>SecurityManager</code>，<code>Realm</code>。</p><p><img src="/2019/12/22/authenticate-shiro/Shiro.png"></p><ol><li><strong><code>Subject</code></strong>(如图上层部分)：”操作用户(<strong>主体</strong>)”，本质上就是当前访问用户的抽象描述。</li><li><strong><code>SecurityManager</code></strong>(如图中层部分)：是 Shiro 架构中最核心的组件(<strong>控制器</strong>)，通过它可以协调其他组件完成用户认证和授权。<ul><li><code>Authenticator</code>：认证器，协调一个或者多个 Realm，从 Realm 指定的数据源取得数据之后进行执行具体的认证。</li><li><code>Authorizer</code>：授权器，用户访问控制授权，决定用户是否拥有执行指定操作的权限。</li><li><code>Session Manager</code>：Session 管理器，Shiro 自己实现了一套 Session 管理机制。</li><li><code>Session DAO</code>：实现了 Session 的操作，主要有增删改查。</li><li><code>CacheManager</code>：缓存管理器，缓存角色数据和权限数据等。</li><li><code>Pluggable Realms</code>：数据库与数据源之间的一个桥梁。Shiro 获取认证信息、权限数据、角色数据 通过 Realms 来获取。</li><li><code>Cryptography</code>：是用来做加解密，能非常快捷的实现数据加密。</li></ul></li><li><strong><code>Realm</code></strong>(如图下层部分)：定义了访问数据的方式，用来连接不同的<strong>数据源</strong>，如：LDAP，关系数据库，配置文件等等。</li></ol><h3 id="3-Shiro-认证与授权"><a href="#3-Shiro-认证与授权" class="headerlink" title="3. Shiro 认证与授权"></a>3. Shiro 认证与授权</h3><h4 id="3-1-Shiro-认证"><a href="#3-1-Shiro-认证" class="headerlink" title="3.1 Shiro 认证"></a>3.1 Shiro 认证</h4><p>「创建<code>SecurityManager</code>」&gt;「主体提交请求」&gt;「<code>SecurityManager</code>调用<code>Authenticator</code>去认证」&gt;「<code>Realm</code>验证」</p><ul><li>操作用户（主体）提交请求到 Security Manager 调用 Authenticator 去认证,Authenticator 通过 Pluggable Realms 去获取认证信息，Pluggable Realms 是从下面的数据源（数据库）中去获取的认证信息，然后用通过 Pluggable Realms 从数据库中获取的认证信息和主体提交过来的认证数据做比对。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shiro认证 测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationTest</span> &#123;</span><br><span class="line">    <span class="comment">// 构建一个简单的数据源</span></span><br><span class="line">    <span class="type">SimpleAccountRealm</span> <span class="variable">simpleAccountRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAccountRealm</span>();</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 参数分别为：用户名，密码，权限...</span></span><br><span class="line">        simpleAccountRealm.addAccount(<span class="string">&quot;chaooo&quot;</span>, <span class="string">&quot;123456&quot;</span>, <span class="string">&quot;admin&quot;</span>,<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证测试方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAuthentication</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1.构建SecurityManager环境</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">defaultSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line">        defaultSecurityManager.setRealm(simpleAccountRealm);</span><br><span class="line">        <span class="comment">// 2. 主体提交认证请求</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">// 3. 调用Subject.login(token)方法开始用户认证流程</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;chaooo&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        　　subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">&quot;用户不存在: %s&quot;</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">&quot;密码不正确: %s&quot;</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConcurrentAccessException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">&quot;用户重复登录: %s&quot;</span>, username), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">        　　logger.error(String.format(<span class="string">&quot;其他账户异常: %s&quot;</span>, username), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-Shiro-授权"><a href="#3-2-Shiro-授权" class="headerlink" title="3.2 Shiro 授权"></a>3.2 Shiro 授权</h4><p>shiro 访问授权有 3 种实现方式：**<code>api</code>调用<strong>，</strong><code>java</code>注解<strong>，</strong><code>jsp</code>标签**。</p><ol><li>通过 api 调用实现:「创建<code>SecurityManager</code>」&gt;「主体授权」&gt;「<code>SecurityManager</code>调用<code>Authorizer</code>授权」&gt;「<code>Realm</code>获取角色权限数据」<ul><li>大体上和认证操作一样，也是通过 Pluggable Realms 从下面的数据源（数据库）中去获取权限数据,角色数据。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在执行访问授权验证之前，必须执行用户认证</span></span><br><span class="line"><span class="comment">// 角色验证</span></span><br><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">　　<span class="comment">//用户属于角色admin</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">　　<span class="comment">//用户不属于角色admin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// subject.checkRoles(&quot;admin&quot;,&quot;user&quot;);同时check多个角色</span></span><br><span class="line"><span class="comment">// 权限验证</span></span><br><span class="line"><span class="type">String</span> <span class="variable">perm</span> <span class="operator">=</span> <span class="string">&quot;log:manage:*&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(subject.isPermitted(perm)) &#123;</span><br><span class="line">　　logger.info(String.format(<span class="string">&quot;用户： %s 拥有权限：%s&quot;</span>, name, perm));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">　　logger.error(String.format(<span class="string">&quot;用户：%s 没有权限：%s&quot;</span>, name, perm));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 spring 框架中可以通过 java 注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermissions(value=&#123;&quot;log:manage:*&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">home</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">　　<span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">　　<span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 JSP 页面中还可以直接使用 jsp 标签</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用shiro标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;log:manage:*&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%=request.getContextPath()%&gt;/user/home&quot;</span>&gt;</span>操作日志审计<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Quickstart"><a href="#3-3-Quickstart" class="headerlink" title="3.3 Quickstart"></a>3.3 Quickstart</h4><ol><li>新建一个<code>Maven</code>项目，<code>pom</code>导入<code>jar</code>包:<code>shiro-all</code>、<code>slf4j-api</code>、<code>slf4j-log4j12</code>、<code>log4j</code>;</li><li><code>classpath</code>下新建<code>shiro.ini</code>配置文件:</li></ol><figure class="highlight ini"><figcaption><span>shiro.ini</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Users and their assigned roles</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setUserDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="comment"># user &#x27;root&#x27; with password &#x27;secret&#x27; and the &#x27;admin&#x27; role</span></span><br><span class="line"><span class="attr">root</span> = secret, admin</span><br><span class="line"><span class="comment"># user &#x27;guest&#x27; with the password &#x27;guest&#x27; and the &#x27;guest&#x27; role</span></span><br><span class="line"><span class="attr">guest</span> = guest, guest</span><br><span class="line"><span class="comment"># user &#x27;chaooo&#x27; with password &#x27;123456&#x27; and roles &#x27;user&#x27; and &#x27;guest&#x27;</span></span><br><span class="line"><span class="attr">chaooo</span> = <span class="number">123456</span>, user, guest</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Each line conforms to the format defined in the</span></span><br><span class="line"><span class="comment"># org.apache.shiro.realm.text.TextConfigurationRealm#setRoleDefinitions JavaDoc</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------------------------------</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="comment"># &#x27;admin&#x27; role has all permissions, indicated by the wildcard &#x27;*&#x27;</span></span><br><span class="line"><span class="attr">admin</span> = *</span><br><span class="line"><span class="comment"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span></span><br><span class="line"><span class="attr">user</span> = user:*</span><br><span class="line"><span class="comment"># The &#x27;goodguy&#x27; role is allowed to &#x27;query&#x27; (action) the user (type) with license plate &#x27;zhangsan&#x27; (instance specific id)</span></span><br><span class="line"><span class="attr">guest</span> = user:query:zhangsan</span><br></pre></td></tr></table></figure><ol start="3"><li>启动运行 Quickstart</li></ol><figure class="highlight java"><figcaption><span>Quickstart.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Quickstart</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(Quickstart.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建SecurityManager环境</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">securityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line">        <span class="type">IniRealm</span> <span class="variable">iniRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IniRealm</span>(<span class="string">&quot;classpath:shiro.ini&quot;</span>);</span><br><span class="line">        securityManager.setRealm(iniRealm);</span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the currently executing user:</span></span><br><span class="line">        <span class="comment">// 获取当前的 Subject</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do some stuff with a Session (no need for a web or EJB container!!!)</span></span><br><span class="line">        <span class="comment">// 测试使用 shiro的Session</span></span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> currentUser.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;someKey&quot;</span>, <span class="string">&quot;aValue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) session.getAttribute(<span class="string">&quot;someKey&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (value.equals(<span class="string">&quot;aValue&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;---&gt; Retrieved the correct value! [&quot;</span> + value + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// let&#x27;s login the current user so we can check against roles and permissions:</span></span><br><span class="line">        <span class="comment">// 测试当前的用户是否已经被认证. 即是否已经登录.</span></span><br><span class="line">        <span class="comment">// 调动 Subject 的 isAuthenticated()</span></span><br><span class="line">        <span class="keyword">if</span> (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">            <span class="comment">// 把用户名和密码封装为 UsernamePasswordToken 对象</span></span><br><span class="line">            <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;chaooo&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="comment">// rememberme</span></span><br><span class="line">            token.setRememberMe(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行登录.</span></span><br><span class="line">                currentUser.login(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若没有指定的账户, 则 shiro 将会抛出 UnknownAccountException 异常.</span></span><br><span class="line">            <span class="keyword">catch</span> (UnknownAccountException uae) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;----&gt; There is no user with username of &quot;</span> + token.getPrincipal());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若账户存在, 但密码不匹配, 则 shiro 会抛出 IncorrectCredentialsException 异常。</span></span><br><span class="line">            <span class="keyword">catch</span> (IncorrectCredentialsException ice) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;----&gt; Password for account &quot;</span> + token.getPrincipal() + <span class="string">&quot; was incorrect!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用户被锁定的异常 LockedAccountException</span></span><br><span class="line">            <span class="keyword">catch</span> (LockedAccountException lae) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;The account for username &quot;</span> + token.getPrincipal() + <span class="string">&quot; is locked.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please contact your administrator to unlock it.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... catch more exceptions here (maybe custom ones specific to your application?</span></span><br><span class="line">            <span class="comment">// 所有认证时异常的父类.</span></span><br><span class="line">            <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">                <span class="comment">//unexpected condition?  error?</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//say who they are:</span></span><br><span class="line">        <span class="comment">//print their identifying principal (in this case, a username):</span></span><br><span class="line">        log.info(<span class="string">&quot;----&gt; User [&quot;</span> + currentUser.getPrincipal() + <span class="string">&quot;] logged in successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test a role:</span></span><br><span class="line">        <span class="comment">// 测试是否有某一个角色. 调用 Subject 的 hasRole 方法.</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.hasRole(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;----&gt; May the Admin be with you!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;----&gt; Hello, mere mortal.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//test a typed permission (not instance-level)</span></span><br><span class="line">        <span class="comment">// 测试用户是否具备某一个行为. 调用 Subject 的 isPermitted() 方法。</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;user:query, edit&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;----&gt; You are permitted to &#x27;query&#x27; and &#x27;edit&#x27; &#x27;user&#x27;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Sorry, you don&#x27;t have permission&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a (very powerful) Instance Level permission:</span></span><br><span class="line">        <span class="comment">// 测试用户是否具备某一个行为. 资源标识符:操作:对象实例ID</span></span><br><span class="line">        <span class="keyword">if</span> (currentUser.isPermitted(<span class="string">&quot;user:query:zhangsan&quot;</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;----&gt; You are permitted to &#x27;delete&#x27; &#x27;user&#x27; &#x27;zhangsan&#x27;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Sorry, you don&#x27;t have permission!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//all done - log out!</span></span><br><span class="line">        <span class="comment">// 执行登出. 调用 Subject 的 Logout() 方法.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;&quot;</span> + currentUser.isAuthenticated());</span><br><span class="line">        currentUser.logout();</span><br><span class="line">        System.out.println(<span class="string">&quot;----&gt;&quot;</span> + currentUser.isAuthenticated());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-在-SpringMVC-框架中集成-Shiro"><a href="#4-在-SpringMVC-框架中集成-Shiro" class="headerlink" title="4. 在 SpringMVC 框架中集成 Shiro"></a>4. 在 SpringMVC 框架中集成 Shiro</h3><h4 id="4-1-配置-Maven-依赖"><a href="#4-1-配置-Maven-依赖" class="headerlink" title="4.1 配置 Maven 依赖"></a>4.1 配置 Maven 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- shiro配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables support for web-based applications. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables AspectJ support for Shiro AOP and Annotations. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables Ehcache-based famework caching. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enables Spring Framework integration. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version.shiro&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>Shiro</code>使用了日志框架<code>slf4j</code>，因此需要对应配置指定的日志实现组件，如：<code>log4j</code>，<code>logback</code>等。<ul><li>在此，以使用<code>log4j</code>为日志实现为例：</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">shiro使用slf4j作为日志框架，所以必需配置slf4j。</span></span><br><span class="line"><span class="comment">同时，使用log4j作为底层的日志实现框架。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-集成-Shiro"><a href="#4-2-集成-Shiro" class="headerlink" title="4.2 集成 Shiro"></a>4.2 集成 Shiro</h4><p>在<code>Spring</code>框架中集成<code>Shiro</code>，本质上是与<code>Spring IoC</code>容器和<code>Spring MVC</code>框架集成。</p><h5 id="4-2-1-Shiro与Spring-IoC容器集成"><a href="#4-2-1-Shiro与Spring-IoC容器集成" class="headerlink" title="4.2.1 Shiro与Spring IoC容器集成"></a>4.2.1 <code>Shiro</code>与<code>Spring IoC</code>容器集成</h5><ul><li><code>Spring IoC</code>容器提供了一个非常重要的功能，就是依赖注入，将<code>Bean</code>的定义以及<code>Bean</code>之间关系的耦合通过容器来处理。</li><li>也就是说，在<code>Spring</code>中集成<code>Shiro</code>时，<code>Shiro</code>中的相应<code>Bean</code>的定义以及他们的关系也需要通过<code>Spring IoC</code>容器实现。</li><li><code>Shiro</code>提供了与<code>Web</code>集成的支持，其通过一个<code>ShiroFilter</code>入口来拦截需要安全控制的<code>URL</code>，然后进行相应的控制。</li><li><code>ShiroFilter</code>类是安全控制的入口点，其负责读取配置（如<code>ini</code>配置文件），然后判断<code>URL</code> 是否需要登录&#x2F;权限等工作。<ul><li>[urls] 部分的配置，其格式是：<code>url = 拦截器[参数], 拦截器[参数]</code></li></ul></li><li><code>shiro</code>中默认的过滤器：</li></ul><table><thead><tr><th>默认拦截器名</th><th>拦截器类与说明（括号里的表示默认值）</th></tr></thead><tbody><tr><td><span style="white-space:nowrap;">身份验证相关</span></td><td></td></tr><tr><td>authc</td><td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter<br>基于表单的拦截器；如”&#x2F;**&#x3D;authc”，如果没有登录会跳到相应的登录页面登录；主要属性：usernameParam：表单提交的用户名参数名（ username）； passwordParam：表单提交的密码参数名（password）； rememberMeParam：表单提交的密码参数名（rememberMe）； loginUrl：登录页面地址（&#x2F;login.jsp）；successUrl：登录成功后的默认重定向地址； failureKeyAttribute：登录失败后错误信息存储 key（shiroLoginFailure）；</td></tr><tr><td>authcBasic</td><td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter<br>Basic HTTP 身份验证拦截器，主要属性：applicationName：弹出登录框显示的信息（application）；</td></tr><tr><td>logout</td><td>org.apache.shiro.web.filter.authc.LogoutFilter<br>退出拦截器，主要属性：redirectUrl：退出成功后重定向的地址（&#x2F;）;示例”&#x2F;logout&#x3D;logout”</td></tr><tr><td>user</td><td>org.apache.shiro.web.filter.authc.UserFilter<br>用户拦截器，用户已经身份验证&#x2F;记住我登录的都可；示例”&#x2F;**&#x3D;user”</td></tr><tr><td>anon</td><td>org.apache.shiro.web.filter.authc.AnonymousFilter<br>匿名拦截器，即不需要登录即可访问；一般用于静态资源过滤；示例”&#x2F;static&#x2F;**&#x3D;anon”</td></tr><tr><td>授权相关</td><td></td></tr><tr><td>roles</td><td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter<br>角色授权拦截器，验证用户是否拥有所有角色；主要属性：loginUrl：登录页面地址（&#x2F;login.jsp）；unauthorizedUrl：未授权后重定向的地址；示例”&#x2F;admin&#x2F;**&#x3D;roles[admin]”</td></tr><tr><td>perms</td><td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter<br>权限授权拦截器，验证用户是否拥有所有权限；属性和 roles 一样；示例”&#x2F;user&#x2F;**&#x3D;perms[“user:create”]”</td></tr><tr><td>port</td><td>org.apache.shiro.web.filter.authz.PortFilter<br>端口拦截器，主要属性：port（80）：可以通过的端口；示例”&#x2F;test&#x3D; port[80]”，如果用户访问该页面是非 80，将自动将请求端口改为 80 并重定向到该 80 端口，其他路径&#x2F;参数等都一样</td></tr><tr><td>rest</td><td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter<br>rest 风格拦截器，自动根据请求方法构建权限字符串（GET&#x3D;read, POST&#x3D;create,PUT&#x3D;update,DELETE&#x3D;delete,HEAD&#x3D;read,TRACE&#x3D;read,OPTIONS&#x3D;read, MKCOL&#x3D;create）构建权限字符串；示例”&#x2F;users&#x3D;rest[user]”，会自动拼出”user:read,user:create,user:update,user:delete”权限字符串进行权限匹配（所有都得匹配，isPermittedAll）；</td></tr><tr><td>ssl</td><td>org.apache.shiro.web.filter.authz.SslFilter<br>SSL 拦截器，只有请求协议是 https 才能通过；否则自动跳转会 https 端口（443）；其他和 port 拦截器一样；</td></tr><tr><td>其他</td><td></td></tr><tr><td>noSessionCreation</td><td>org.apache.shiro.web.filter.session.NoSessionCreationFilter<br>不创建会话拦截器，调用 subject.getSession(false)不会有什么问题，但是如果 subject.getSession(true)将抛出 DisabledSessionException 异常；</td></tr></tbody></table><ul><li><code>URL</code>匹配模式：url 模式使用 Ant 风格模式<ul><li>Ant 路径通配符支持<code>?</code>、<code>*</code>、<code>**</code>，注意通配符匹配不包括目录分隔符“&#x2F;”：</li><li><code>?</code>：匹配一个字符，如&#x2F;admin? 将匹配&#x2F;admin1，但不匹配&#x2F;admin 或&#x2F;admin&#x2F;；</li><li><code>*</code>：匹配零个或多个字符串，如&#x2F;admin 将匹配&#x2F;admin、&#x2F;admin123，但不匹配&#x2F;admin&#x2F;1；</li><li><code>**</code>：匹配路径中的零个或多个路径，如&#x2F;admin&#x2F;** 将匹配&#x2F;admin&#x2F;a 或&#x2F;admin&#x2F;a&#x2F;b</li></ul></li><li><code>URL</code>匹配顺序：URL 权限采取<strong>第一次匹配优先</strong>的方式，即从头开始使用第一个匹配的 url 模式对应的拦截器链。如：<ul><li>&#x2F;bb&#x2F;**&#x3D;filter1</li><li>&#x2F;bb&#x2F;aa&#x3D;filter2</li><li>&#x2F;**&#x3D;filter3</li><li>如果请求的 url 是“&#x2F;bb&#x2F;aa”，因为按照声明顺序进行匹配，那么将使用 filter1 进行拦截，所以通配符一般写在靠后。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;shiroFilter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loginUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/index&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;successUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/home&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;unauthorizedUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/unauthorized.jsp&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- The &#x27;filters&#x27; property is not necessary since any declared javax.servlet.Filter bean  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- defined will be automatically acquired and available via its beanName in chain        --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- definitions, but you can perform instance overrides or name aliases here if you like: --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property name=&quot;filters&quot;&gt;</span></span><br><span class="line"><span class="comment">      &lt;util:map&gt;</span></span><br><span class="line"><span class="comment">          &lt;entry key=&quot;logout&quot; value-ref=&quot;logoutFilter&quot; /&gt;</span></span><br><span class="line"><span class="comment">      &lt;/util:map&gt;</span></span><br><span class="line"><span class="comment">  &lt;/property&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;filterChainDefinitions&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">          # some example chain definitions:</span><br><span class="line">          # /admin/** = authc, roles[admin]</span><br><span class="line">          # /docs/** = authc, perms[document:read]</span><br><span class="line">          /login = anon</span><br><span class="line">          /logout = anon</span><br><span class="line">          /error = anon</span><br><span class="line">          /** = user</span><br><span class="line">          # more URL-to-FilterChain definitions here</span><br><span class="line">      <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Single realm app.  If you have multiple realms, use the &#x27;realms&#x27; property instead. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;realm&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myRealm&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- By default the servlet container sessions will be used.  Uncomment this line</span></span><br><span class="line"><span class="comment">       to use shiro&#x27;s native sessions (see the JavaDoc for more): --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property name=&quot;sessionMode&quot; value=&quot;native&quot;/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lifecycleBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Define the Shiro Realm implementation you want to use to connect to your back-end --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- security datasource: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myRealm&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.realm.jdbc.JdbcRealm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;permissionsLookupEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Enable Shiro Annotations for Spring-configured beans.  Only run after --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- the lifecycleBeanProcessor has run: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;lifecycleBeanPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;securityManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-2-2-与Spring-MVC集成"><a href="#4-2-2-与Spring-MVC集成" class="headerlink" title="4.2.2 与Spring MVC集成"></a>4.2.2 与<code>Spring MVC</code>集成</h5><ul><li>跟在普通<code>Java Web</code>应用中使用<code>Shiro</code>一样，集成<code>Shiro</code>到<code>Spring MVC</code>时，实际上就是通过在<code>web.xml</code>中添加指定<code>Filter</code>实现。配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The filter-name matches name of a &#x27;shiroFilter&#x27; bean inside applicationContext.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- DelegatingFilterProxy作用是自动到Spring 容器查找名字为shiroFilter（filter-name）的bean并把所有Filter 的操作委托给它。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Make sure any request you want accessible to Shiro is filtered. /* catches all --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- requests.  Usually this filter mapping is defined first (before all others) to --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ensure that Shiro works in subsequent filters in the filter chain:             --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Spring</code>中集成<code>Shiro</code>的原理就是：通过在<code>web.xml</code>中配置的<code>Shiro Filter</code>与<code>Spring IoC</code>中定义的相应的<code>Shiro Bean</code>定义建立关系，从而实现在<code>Spring</code>框架集成<code>Shiro</code>。</p></blockquote><h4 id="4-3-数据源配置"><a href="#4-3-数据源配置" class="headerlink" title="4.3 数据源配置"></a>4.3 数据源配置</h4><p>在<code>Shiro</code>中，<code>Realm</code>定义了访问数据的方式，用来连接不同的数据源，如：LDAP，关系数据库，配置文件等。</p><ul><li>以<code>org.apache.shiro.realm.jdbc.JdbcRealm</code>为例，将用户信息存放在关系型数据库中。</li><li>在使用<code>JdbcRealm</code>时，必须要在关系型数据库中存在 3 张表，分别是<ul><li><code>users</code>表，存放认证用户基本信息，在该表中必须存在 2 个字段：<code>username</code>，<code>password</code>。</li><li><code>roles_permissions</code>表，存放角色和权限定义，在该表中必须存在 2 个字段：<code>role_name</code>，<code>permission</code>。</li><li><code>user_roles</code>表，存放用户角色对应关系，在该表中必须存在 2 个字段：<code>username</code>，<code>role_name</code>。</li></ul></li><li>实际上，在更加复杂的应用场景下，通常需要扩展<code>JdbcRealm</code>。</li></ul><h4 id="4-4-认证"><a href="#4-4-认证" class="headerlink" title="4.4 认证"></a>4.4 认证</h4><p>在<code>Shiro</code>中，认证即执行用户登录，读取指定<code>Realm</code>连接的数据源，以验证用户身份的有效性与合法性。</p><ul><li>在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份：<ul><li>principals：身份，即主体的标识属性，可以是任何属性，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名&#x2F;邮箱&#x2F;手机号。</li><li>credentials：证明&#x2F;凭证，即只有主体知道的安全值，如密码&#x2F;数字证书等。</li><li>最常见的 principals 和 credentials 组合就是用户名&#x2F;密码了</li></ul></li><li>身份认证流程：<ol><li>首先调用 Subject.login(token) 进行登录，其会自动委托给 SecurityManager</li><li>SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证；</li><li>Authenticator 才是真正的身份验证者，ShiroAPI 中核心的身份认证入口点，此处可以自定义插入自己的实现；</li><li>Authenticator 可能会委托给相应的 AuthenticationStrategy 进行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证；</li><li>Authenticator 会把相应的 token 传入 Realm，从 Realm 获取身份验证信息，如果没有返回&#x2F;抛出异常表示身份验证失败了。此处可以配置多个 Realm，将按照相应的顺序及策略进行访问。<ul><li>Realm：一般继承 AuthorizingRealm（授权）即可；其继承了 AuthenticatingRealm（即身份验证），而且也间接继承了 CachingRealm（带有缓存实现）</li></ul></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(!subject.isAuthenticated()) &#123;</span><br><span class="line">　　<span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(name, password);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    　　subject.login(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">&quot;用户不存在: %s&quot;</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncorrectCredentialsException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">&quot;密码不正确: %s&quot;</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ConcurrentAccessException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">&quot;用户重复登录: %s&quot;</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">    　　logger.error(String.format(<span class="string">&quot;其他账户异常: %s&quot;</span>, token.getPrincipal()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-授权"><a href="#4-5-授权" class="headerlink" title="4.5 授权"></a>4.5 授权</h4><p>Shiro 作为权限框架，仅仅只能控制对资源的操作权限，并不能完成对数据权限的业务需求。</p><ul><li>而对于 Java Web 环境下 Shiro 授权，包含两个方面的含义。<ul><li>其一，对于前端来说，用户只能看到他对应访问权限的元素。</li><li>其二，当用户执行指定操作（即：访问某个 uri 资源）时，需要验证用户是否具备对应权限。</li></ul></li><li>对于第一点，在 Java Web 环境下，通过 Shiro 提供的 JSP 标签实现。</li><li>对于第二点，与在非 Java Web 环境下一样，需要在后端调用 API 进行权限（或者角色）检验。</li><li>在 Spring 框架中集成 Shiro，还可以直接通过 Java 注解方式实现</li><li><code>Permissions</code>：<ul><li>规则：<code>资源标识符：操作：对象实例ID</code>,即对哪个资源的哪个实例可以进行什么操作.其默认支持通配符权限字符串，: 表示资源&#x2F;操作&#x2F;实例的分割；, 表示操作的分割，* 表示任意资源&#x2F;操作&#x2F;实例。如：<code>user:edit:manager</code><ul><li>也可以使用通配符来定义，如：<code>user:edit:*</code>、<code>user:*:*</code>、<code>user:*:manager</code></li><li>部分省略通配符：缺少的部件意味着用户可以访问所有与之匹配的值，比如：<code>user:edit</code>等价于<code>user:edit:*</code>、<code>user</code>等价于<code>user:*:*</code></li><li>注意：通配符只能从字符串的结尾处省略部件，也就是说<code>user:edit</code>并<strong>不等价</strong>于<code>user:*:edit</code></li></ul></li></ul></li><li>授权流程:<ol><li>首先调用 Subject.isPermitted*&#x2F;hasRole* 接口，其会委托给 SecurityManager，而 SecurityManager 接着会委托给 Authorizer；</li><li>Authorizer 是真正的授权者，如果调用如 isPermitted(“user:view”)，其首先会通过 PermissionResolver 把字符串转换成相应的 Permission 实例；</li><li>在进行授权之前，其会调用相应的 Realm 获取 Subject 相应的角色&#x2F;权限用于匹配传入的角色&#x2F;权限；</li><li>Authorizer 会判断 Realm 的角色&#x2F;权限是否和传入的匹配，如果有多个 Realm，会委托给 ModularRealmAuthorizer 进行循环判断，如果匹配如 isPermitted*&#x2F;hasRole* 会返回 true，否则返回 false 表示授权失败。<ul><li><code>ModularRealmAuthorizer</code>进行多 Realm 匹配流程：<ol><li>首先检查相应的 Realm 是否实现了实现了 Authorizer；</li><li>如果实现了 Authorizer，那么接着调用其相应的<code>isPermitted*/hasRole*</code>接口进行匹配；</li><li>如果有一个 Realm 匹配那么将返回 true，否则返回 false。</li></ol></li></ul></li></ol></li></ul><h5 id="4-5-1-Shiro-标签"><a href="#4-5-1-Shiro-标签" class="headerlink" title="4.5.1 Shiro 标签"></a>4.5.1 Shiro 标签</h5><ol><li><code>&lt;shiro:guest&gt;&lt;/shiro:guest&gt;</code>:用户没有身份验证时显示相应信息，即游客访问信息</li><li><code>&lt;shiro:user&gt;&lt;/shiro:user&gt;</code>:用户已经经过认证&#x2F;记住我登录后显示相应的信息。</li><li><code>&lt;shiro:authenticated&gt;&lt;/shiro:authenticated&gt;</code>:用户已经身份验证通过，即 Subject.login 登录成功，<strong>不是记住我登录的</strong></li><li><code>&lt;shiro:notAuthenticated&gt;&lt;/shiro:notAuthenticated&gt;</code>标签：用户未进行身份验证，即没有调用 Subject.login 进行登录，<strong>包括记住我自动登录</strong>的也属于未进行身份验证。</li><li><code>&lt;shiro:pincipal&gt;&lt;/shiro:pincipal&gt;</code>：<strong>显示用户身份信息</strong>，默认调用<code>Subject.getPrincipal()</code>获取，即 Primary Principal。</li><li>**<code>&lt;shiro:hasRole&gt;&lt;/shiro:hasRole&gt;</code>**标签：如果当前 Subject 有角色将显示 body 体内容</li><li><code>&lt;shiro:hasAnyRoles&gt;&lt;/shiro:hasAnyRoles&gt;</code>标签：如果当前 Subject 有任意一个角色（或的关系）将显示 body 体内容</li><li><code>&lt;shiro:lacksRole&gt;&lt;/shiro:lacksRole&gt;</code>：如果当前 Subject 没有角色将显示 body 体内容</li><li>**<code>&lt;shiro:hasPermission&gt;&lt;/shiro:hasPermission&gt;</code>**：如果当前 Subject 有权限将显示 body 体内容</li><li><code>&lt;shiro:lacksPermission&gt;&lt;/shiro:lacksPermission&gt;</code>：如果当前 Subject 没有权限将显示 body 体内容</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在jsp页面中引入shiro标签库 --&gt;</span></span><br><span class="line">&lt;%@ taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br><span class="line"><span class="comment">&lt;!-- 权限控制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span>&gt;</span>用户管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">&quot;winnebago:drive:eagle5&quot;</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="name">a</span>&gt;</span>操作审计<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4-5-2-调用-API-进行权限（或者角色）检验"><a href="#4-5-2-调用-API-进行权限（或者角色）检验" class="headerlink" title="4.5.2 调用 API 进行权限（或者角色）检验"></a>4.5.2 调用 API 进行权限（或者角色）检验</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">roleAdmin</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line"><span class="type">Subject</span> <span class="variable">currentUser</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"><span class="keyword">if</span>(!currentUser.hasRole(roleAdmin)) &#123;</span><br><span class="line">　　<span class="comment">//todo something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-3-Shiro-权限注解"><a href="#4-5-3-Shiro-权限注解" class="headerlink" title="4.5.3 Shiro 权限注解"></a>4.5.3 Shiro 权限注解</h5><ul><li><code>@RequiresAuthentication</code>：表示当前 Subject 已经通过 login 进行了身份验证；即 Subject. isAuthenticated() 返回 true</li><li><code>@RequiresUser</code>：表示当前 Subject 已经身份验证或者通过记住我登录的。</li><li><code>@RequiresGuest</code>：表示当前 Subject 没有身份验证或通过记住我登录过，即是游客身份。</li><li><code>@RequiresRoles(value=&#123;“admin”, “user”&#125;, logical= Logical.AND)</code>：表示当前 Subject 需要角色 admin 和 user</li><li><code>@RequiresPermissions(value=&#123;“user:a”, “user:b”&#125;, logical= Logical.OR)</code>：表示当前 Subject 需要权限 user:a 或 user:b。</li><li>通过自定义拦截器可以扩展功能，例如：动态 url-角色&#x2F;权限访问控制的实现、根据 Subject 身份信息获取用户信息绑定到 Request（即设置通用数据）、验证码验证、在线用户信息的保存等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeController</span> &#123;</span><br><span class="line">　　<span class="meta">@RequestMapping(&quot;/home&quot;)</span></span><br><span class="line">　　<span class="meta">@RequiresPermissions(value=&#123;&quot;log:manage:*&quot;&#125;)</span></span><br><span class="line">　　<span class="keyword">public</span> ModelAndView <span class="title function_">home</span><span class="params">(HttpServletRequest req)</span> &#123;</span><br><span class="line">　　　　<span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">　　　　<span class="keyword">return</span> mv;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-Spring-集成-Shiro-注意事项"><a href="#4-6-Spring-集成-Shiro-注意事项" class="headerlink" title="4.6 Spring 集成 Shiro 注意事项"></a>4.6 Spring 集成 Shiro 注意事项</h4><ol><li><code>Spring 4.2.0 RELEASE</code><strong><code>+</code></strong> 与 <code>Spring 4.1.9 RELEASE</code>**<code>-</code>**版本，配置方式有所不同。</li><li>虽然<code>shiro</code>的注解定义是在<code>Class</code>级别的，但是实际验证只能支持方法级别：<code>@RequiresAuthentication</code>、<code>@RequiresPermissions</code>、<code>@RequiresRoles</code>。</li></ol><h3 id="5-Shiro-会话管理"><a href="#5-Shiro-会话管理" class="headerlink" title="5. Shiro 会话管理"></a>5. Shiro 会话管理</h3><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管 JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储&#x2F;持久化、容器无关的集群、失效&#x2F;过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。</p><h4 id="5-1-会话相关的-API"><a href="#5-1-会话相关的-API" class="headerlink" title="5.1 会话相关的 API"></a>5.1 会话相关的 API</h4><ul><li>Subject.getSession()：即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；Subject.getSession(false)，如果当前没有创建 Session 则返回 null</li><li>session.getId()：获取当前会话的唯一标识</li><li>session.getHost()：获取当前 Subject 的主机地址</li><li>session.getTimeout() &amp; session.setTimeout(毫秒)：获取&#x2F;设置当前 Session 的过期时间</li><li>session.getStartTimestamp() &amp; session.getLastAccessTime()：获取会话的启动时间及最后访问时间；如果是 JavaSE 应用需要自己定期调用 session.touch() 去更新最后访问时间；如果是 Web 应用，每次进入 ShiroFilter 都会自动调用 session.touch() 来更新最后访问时间。</li><li>session.touch() &amp; session.stop()：更新会话最后访问时间及销毁会话；当 Subject.logout()时会自动调用 stop 方法来销毁会话。如果在 web 中，调用 HttpSession. invalidate()也会自动调用 Shiro Session.stop 方法进行销毁 Shiro 的会话</li><li>session.setAttribute(key, val) &amp; session.getAttribute(key) &amp; session.removeAttribute(key)：设置&#x2F;获取&#x2F;删除会话属性；在整个会话范围内都可以对这些属性进行操作</li></ul><h4 id="5-2-会话监听器"><a href="#5-2-会话监听器" class="headerlink" title="5.2 会话监听器"></a>5.2 会话监听器</h4><p>会话监听器(SessionListiner):会话监听器用于监听会话创建、过期及停止事件</p><h4 id="5-3-SessionDao"><a href="#5-3-SessionDao" class="headerlink" title="5.3 SessionDao"></a>5.3 SessionDao</h4><ul><li>AbstractSessionDAO 提供了 SessionDAO 的基础实现，如生成会话 ID 等</li><li>CachingSessionDAO 提供了对开发者透明的会话缓存的功能，需要设置相应的 CacheManager</li><li>MemorySessionDAO 直接在内存中进行会话维护</li><li>EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。</li></ul><h4 id="5-4-数据表"><a href="#5-4-数据表" class="headerlink" title="5.4 数据表"></a>5.4 数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sessions (</span><br><span class="line">    id <span class="type">varchar</span>(<span class="number">200</span>),</span><br><span class="line">    session <span class="type">varchar</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">constraint</span> pk_sessions <span class="keyword">primary</span> key(id)</span><br><span class="line">) charset<span class="operator">=</span>utf8 ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><h4 id="5-5-会话验证"><a href="#5-5-会话验证" class="headerlink" title="5.5 会话验证"></a>5.5 会话验证</h4><ul><li>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话</li><li>出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web 环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler</li><li>Shiro 也提供了使用 Quartz 会话验证调度器：QuartzSessionValidationScheduler</li></ul><h3 id="6-Shiro-缓存"><a href="#6-Shiro-缓存" class="headerlink" title="6. Shiro 缓存"></a>6. Shiro 缓存</h3><ul><li>CacheManagerAware 接口<ul><li>Shiro 内部相应的组件（DefaultSecurityManager）会自动检测相应的对象（如 Realm）是否实现了 CacheManagerAware 并自动注入相应的 CacheManager。</li></ul></li><li>Realm 缓存 + Shiro 提供了 CachingRealm，其实现了 CacheManagerAware 接口，提供了缓存的一些基础实现； + AuthenticatingRealm 及 AuthorizingRealm 也分别提供了对 AuthenticationInfo 和 AuthorizationInfo 信息的缓<br>存。</li><li>Session 缓存<ul><li>如 SecurityManager 实现了 SessionSecurityManager，其会判断 SessionManager 是否实现了 acheManagerAware 接口，如果实现了会把 CacheManager 设置给它。</li><li>SessionManager 也会判断相应的 SessionDAO（如继承自 CachingSessionDAO）是否实现了 CacheManagerAware，如果实现了会把 CacheManager 设置给它</li><li>设置了缓存的 SessionManager，查询时会先查缓存，如果找不到才查数据库。</li></ul></li><li>RememberMe<ul><li>Shiro 提供了记住我（RememberMe）的功能，比如访问如淘宝等一些网站时，关闭了浏览器，下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问，基本流程如下：<ol><li>首先在登录页面选中 RememberMe 然后登录成功；如果是浏览器登录，一般会把 RememberMe 的 Cookie 写到客户端并保存下来；</li><li>关闭浏览器再重新打开；会发现浏览器还是记住你的；</li><li>访问一般的网页服务器端还是知道你是谁，且能正常访问；</li><li>但是比如我们访问淘宝时，如果要查看我的订单或进行支付时，此时还是需要再进行身份认证的，以确保当前用户还是你。</li></ol></li></ul></li><li>认证和记住我<ul><li>subject.isAuthenticated() 表示用户进行了身份验证登录的，即使有 Subject.login 进行了登录；</li><li>subject.isRemembered()：表示用户是通过记住我登录的，此时可能并不是真正的你（如你的朋友使用你的电脑，或者你的 cookie 被窃取）在访问的</li><li>两者二选一，即 subject.isAuthenticated()&#x3D;&#x3D;true，则 subject.isRemembered()&#x3D;&#x3D;false；反之一样。</li></ul></li><li>建议<ul><li>访问一般网页：如个人在主页之类的，我们使用 user 拦截器即可，user 拦截器只要用户登录(isRemembered() || isAuthenticated())过即可访问成功；</li><li>访问特殊网页：如我的订单，提交订单页面，我们使用 authc 拦截器即可，authc 拦截器会判断用户是否是通过 Subject.login（isAuthenticated()&#x3D;&#x3D;true）登录的，如果是才放行，否则会跳转到登录页面叫你重新登录。</li></ul></li><li>实现<ul><li>如果要自己做 RememeberMe，需要在登录之前这样创建 Token：UsernamePasswordToken(用户名，密码，是否记住我)，且调用 UsernamePasswordToken 的：token.setRememberMe(true); 方法</li></ul></li></ul><blockquote><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/nuccch/p/6775855.html">细说 shiro 之一：shiro 简介</a></li><li><a href="https://www.cnblogs.com/nuccch/p/6775855.html">细说 shiro 之五：在 spring 框架中集成 shiro</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「安全认证」JSON Web Token 入门</title>
      <link href="/2019/11/18/authenticate-jwt.html"/>
      <url>/2019/11/18/authenticate-jwt.html</url>
      
        <content type="html"><![CDATA[<h2 id="JSON-Web-Token"><a href="#JSON-Web-Token" class="headerlink" title="JSON Web Token"></a>JSON Web Token</h2><p>JSON Web Token（缩写 JWT）基于JSON格式信息一种Token令牌，是目前最流行的跨域认证解决方案。</p><span id="more"></span><ul><li>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</li><li>此后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</li><li>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</li></ul><h3 id="1-JWT数据结构"><a href="#1-JWT数据结构" class="headerlink" title="1. JWT数据结构"></a>1. JWT数据结构</h3><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。</p><ul><li>例如：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<code>.</code>eyJhdWQiOiJjaGFvIiwidWlkIjoyOSwiZXhwIjoxNTY3OTM2NzgwfQ<code>.</code>6zvimBNs_MCiov4MOkkUodgKmRFBS2dVhmhIb1MV6m4。</li></ul><p>JWT 的三个部分(<code>Header.Payload.Signature</code>)依次如下:</p><ol><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ol><h4 id="1-1-Header（头部）"><a href="#1-1-Header（头部）" class="headerlink" title="1.1 Header（头部）"></a>1.1 Header（头部）</h4><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>alg</code>：签名的算法（algorithm），默认是 HMAC SHA256（写成<code>HS256</code>）</li><li><code>typ</code>：表示这个令牌（token）的类型（type），JWT令牌统一写为<code>JWT</code>。</li></ul><p>最后，将上面的 JSON 对象使用 <code>Base64URL算法</code>转成字符串。</p><h4 id="1-2-Payload（负载）"><a href="#1-2-Payload（负载）" class="headerlink" title="1.2 Payload（负载）"></a>1.2 Payload（负载）</h4><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段(Reserved claims)，供选用。标准中建议使用这些字段，但不强制。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号，JWT唯一标识，能用于防止JWT重复使用</li></ul><p>除了官方字段，还有公共声明的字段（见：<a href="http://www.iana.org/assignments/jwt/jwt.xhtml">http://www.iana.org/assignments/jwt/jwt.xhtml</a>）也可以定义私有字段，如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p></blockquote><p>这个 JSON 对象也要使用 <code>Base64URL算法</code>转成字符串。</p><h4 id="1-3-Signature（签名）"><a href="#1-3-Signature（签名）" class="headerlink" title="1.3 Signature（签名）"></a>1.3 Signature（签名）</h4><p>Signature 部分是对前两部分的签名，防止数据篡改。该签名信息是通过header和payload，加上secret，通过算法加密生成。</p><ul><li>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<ul><li><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></li></ul></li><li>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</li></ul><h3 id="2-Base64URL算法"><a href="#2-Base64URL算法" class="headerlink" title="2. Base64URL算法"></a>2. Base64URL算法</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com&#x2F;?token&#x3D;xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h3 id="3-JWT-的使用方式及特点"><a href="#3-JWT-的使用方式及特点" class="headerlink" title="3. JWT 的使用方式及特点"></a>3. JWT 的使用方式及特点</h3><ol><li><p>认证原理：</p><ul><li>客户端向服务器申请授权，服务器认证以后，生成一个token字符串并返回给客户端，此后客户端在请求受保护的资源时携带这个token，服务端进行验证再从这个token中解析出用户的身份信息。</li></ul></li><li><p>JWT的使用方式：</p><ul><li>客户端收到服务器返回的JWT，存储在浏览器（Cookie或localStorage）</li><li>此后，客户端每次与服务器通信，都要带上这个JWT。<ol><li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul><li><code>Authorization: &lt;token&gt;</code></li><li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ul></li><li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li></ol></li></ul></li><li><p>对JWT实现token续签的做法：</p><ol><li>额外生成一个refreshToken用于获取新token，refreshToken需存储于服务端，其过期时间比JWT的过期时间要稍长。</li><li>用户携带refreshToken参数请求token刷新接口，服务端在判断refreshToken未过期后，取出关联的用户信息和当前token。</li><li>使用当前用户信息重新生成token，并将旧的token置于黑名单中，返回新的token。</li></ol></li><li><p>JWT 的几个特点</p><ol><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ol></li></ol><h3 id="4-Java中JWT的使用"><a href="#4-Java中JWT的使用" class="headerlink" title="4. Java中JWT的使用"></a>4. Java中JWT的使用</h3><p>java-jwt工具包提供了<strong>JWT算法的封装</strong></p><ol><li>导入java-jwt，选择一种算法（HMAC256为例）<ul><li><strong><code>Algorithm algorithm = Algorithm.HMAC256(&quot;secret&quot;);</code></strong></li><li>算法定义了一个令牌是如何被签名和验证的。</li></ul></li><li>创建一个签名的<code>JWT token</code>（通过调用jwt.create()创建一个JWTCreator实例）<ul><li><strong><code>String token = JWT.create().withIssuer(&quot;auth0&quot;).sign(algorithm);</code></strong></li><li><em>如果Claim不能转换为JSON，或者在签名过程中使用的密钥无效，那么将会抛出<strong>JWTCreationException</strong>异常</em></li></ul></li><li>验证令牌（调用jwt.require()和传递算法实例来创建一个JWTVerifier实例。方法build()返回的实例是可重用的，因此可以定义一次，并使用它来验证不同的标记。最后调用verifier.verify()来验证token）<ul><li><strong><code>JWTVerifier verifier = JWT.require(algorithm).withIssuer(&quot;auth0&quot;).build();</code></strong></li><li><strong><code>verifier.verify(token);</code></strong></li><li><em>如果令牌有一个无效的签名，或者没有满足Claim要求，那么将会抛出<strong>JWTVerificationException</strong>异常</em></li></ul></li><li>jwt时间的验证（当验证一个令牌时，时间验证会自动发生；JWT令牌可能包括可用于验证的DateNumber字段）<ul><li><code>&quot;iat&quot; &lt; TODAY</code>：这个令牌发布了一个过期的时间</li><li><code>&quot;exp&quot; &gt; TODAY</code>：这个令牌还没过期</li><li><code>&quot;nbf&quot; &gt; TODAY</code>：这个令牌已经被使用了</li></ul></li><li>解码一个jwt令牌<ul><li><code>DecodedJWT jwt = JWT.decode(token);</code></li><li><code>jwt.getAlgorithm();</code>:返回jwt的算法值,如果没有定义则返回null</li><li><code>jwt.getType();</code>:返回jwt的类型值，如果没有定义则返回null（多数情况类型值为jwt）</li><li><em>如果令牌有无效的语法，或者消息头或有效负载不是JSONs，那么将会抛出<strong>JWTDecodeException</strong>异常</em></li></ul></li></ol><h3 id="5-Java中JWT的使用实例"><a href="#5-Java中JWT的使用实例" class="headerlink" title="5. Java中JWT的使用实例"></a>5. Java中JWT的使用实例</h3><p>封装一个JWT工具类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT; <span class="comment">//导入java-jwt</span></span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.JWTVerifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.entity.User; <span class="comment">//引入User实体类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">//设置过期时间，这里设置15分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//服务端的私钥secret,在任何场景都不应该流露出去</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TOKEN_SECRET</span> <span class="operator">=</span> <span class="string">&quot;zhengchao&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **User**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **password**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createToken</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置过期时间</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">            <span class="comment">// 私钥和加密算法</span></span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">// 设置头部信息</span></span><br><span class="line">            Map&lt;String, Object&gt; header = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            header.put(<span class="string">&quot;typ&quot;</span>, <span class="string">&quot;JWT&quot;</span>);</span><br><span class="line">            header.put(<span class="string">&quot;alg&quot;</span>, <span class="string">&quot;HS256&quot;</span>);</span><br><span class="line">            <span class="comment">// 返回token字符串</span></span><br><span class="line">            <span class="keyword">return</span> JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">&quot;aud&quot;</span>, user.getName())</span><br><span class="line">                    .withClaim(<span class="string">&quot;uid&quot;</span>, user.getId())</span><br><span class="line">                    .withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检验token是否正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> **token**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isVerify</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="type">JWTVerifier</span> <span class="variable">verifier</span> <span class="operator">=</span> JWT.require(algorithm).build();</span><br><span class="line">            verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出uid信息,用户ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseTokenUid</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">&quot;uid&quot;</span>).asInt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *从token解析出aud信息,用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">parseTokenAud</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="type">DecodedJWT</span> <span class="variable">jwt</span> <span class="operator">=</span> JWT.decode(token);</span><br><span class="line">        <span class="keyword">return</span> jwt.getClaim(<span class="string">&quot;aud&quot;</span>).asString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功后，生成token给浏览器，存储在浏览器（Cookie或localStorage）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtil.createToken(user);</span><br></pre></td></tr></table></figure><p>此后，客户端每次与服务器通信（需权限的资源），都要带上这个JWT。</p><ol><li>一种做法是放在HTTP请求的头信息Authorization字段里面，格式如下：<ul><li><code>Authorization: &lt;token&gt;</code></li><li>需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *</li></ul></li><li>另一种做法是，跨域的时候，JWT就放在POST请求的数据体里面。</li></ol><blockquote><p>jwt 适合做简单的 restful api 认证，颁发一个固定有效期的 jwt，降低 jwt 暴露的风险，尽量不要对 jwt 做服务端的状态管理，这样才能体现出 jwt 无状态的优势。</p></blockquote><h3 id="附：java-jwt已经实现的算法"><a href="#附：java-jwt已经实现的算法" class="headerlink" title="附：java-jwt已经实现的算法"></a>附：java-jwt已经实现的算法</h3><table><thead><tr><th>JWS</th><th>算法</th><th>介绍</th></tr></thead><tbody><tr><td>HS256</td><td>HMAC256</td><td>HMAC with SHA-256</td></tr><tr><td>HS384</td><td>HMAC384</td><td>HMAC with SHA-384</td></tr><tr><td>HS512</td><td>HMAC512</td><td>HMAC with SHA-512</td></tr><tr><td>RS256</td><td>RSA256</td><td>RSASSA-PKCS1-v1_5 with SHA-256</td></tr><tr><td>RS384</td><td>RSA384</td><td>RSASSA-PKCS1-v1_5 with SHA-384</td></tr><tr><td>RS512</td><td>RSA512</td><td>RSASSA-PKCS1-v1_5 with SHA-512</td></tr><tr><td>ES256</td><td>ECDSA256</td><td>ECDSA with curve P-256 and SHA-256</td></tr><tr><td>ES384</td><td>ECDSA384</td><td>ECDSA with curve P-384 and SHA-384</td></tr><tr><td>ES512</td><td>ECDSA512</td><td>ECDSA with curve P-521 and SHA-512</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「安全认证」MD5算法加盐实现用户密码加密</title>
      <link href="/2019/11/15/authenticate-md5.html"/>
      <url>/2019/11/15/authenticate-md5.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-MD5加密算法介绍"><a href="#1-MD5加密算法介绍" class="headerlink" title="1. MD5加密算法介绍"></a>1. MD5加密算法介绍</h3><p>MD5的全称是Message-Digest Algorithm 5（信息-摘要算法 第五版），经MD2、MD3和MD4发展而来的一种加密算法，是典型的消息摘要算法，属Hash算法一类。作用是让大容量信息在用数字签名软件签署私人密匙前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的大整数）。通过MD5算法进行加密获得一个随机长度的信息并产生一个128位的信息摘要。如果将这个128位的二进制摘要信息换算成十六进制，可以得到一个32位的字符串，因此我们加密完成后的16进制的字符串长度为32位。</p><span id="more"></span> <h3 id="2-MD5加密算法特点："><a href="#2-MD5加密算法特点：" class="headerlink" title="2. MD5加密算法特点："></a>2. MD5加密算法特点：</h3><ol><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的。</li><li>容易计算：从原数据计算出MD5值很容易。</li><li>抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</li><li>强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</li></ol><h3 id="3-盐（Salt）"><a href="#3-盐（Salt）" class="headerlink" title="3. 盐（Salt）"></a>3. 盐（Salt）</h3><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p><h3 id="4-java-security-MessageDigest类"><a href="#4-java-security-MessageDigest类" class="headerlink" title="4. java.security.MessageDigest类"></a>4. java.security.MessageDigest类</h3><p>JDK中的java.security.MessageDigest用于为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。</p><ul><li>MessageDigest 通过其getInstance系列静态函数来进行实例化和初始化。</li><li>MessageDigest 对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算并返回结果。</li><li>对于给定数量的更新数据，digest 方法只能被调用一次。digest 方法被调用后，MessageDigest  对象被重新设置成其初始状态。</li></ul><h3 id="5-封装一个MD5加密工具类"><a href="#5-封装一个MD5加密工具类" class="headerlink" title="5. 封装一个MD5加密工具类"></a>5. 封装一个MD5加密工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * md5加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s：待加密字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化MessageDigest的MD5算法对象</span></span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="comment">//通过digest方法返回哈希计算后的字节数组</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = md.digest(s.getBytes(<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="comment">//将字节数组转换为16进制字符串并返回</span></span><br><span class="line">            <span class="keyword">return</span> toHex(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取随即盐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">salt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//利用UUID生成随机盐</span></span><br><span class="line">        <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">        <span class="comment">//返回a2c64597-232f-4782-ab2d-9dfeb9d76932</span></span><br><span class="line">        String[] arr = uuid.toString().split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转换为16进制字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 16进制字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] HEX_DIGITS = <span class="string">&quot;0123456789ABCDEF&quot;</span>.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(bytes.length * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;bytes.length; i++) &#123;</span><br><span class="line">            ret.append(HEX_DIGITS[(bytes[i] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            ret.append(HEX_DIGITS[bytes[i] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-使用封装的MD5工具类完成用户注册-主要代码"><a href="#6-使用封装的MD5工具类完成用户注册-主要代码" class="headerlink" title="6. 使用封装的MD5工具类完成用户注册(主要代码)"></a>6. 使用封装的MD5工具类完成用户注册(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">register</span><span class="params">(String name, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//添加用户信息</span></span><br><span class="line">    user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="comment">//设置用户名</span></span><br><span class="line">    user.setName(name);</span><br><span class="line">    <span class="comment">//密码加密后再保存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> MD5Util.salt();</span><br><span class="line">    <span class="type">String</span> <span class="variable">md5Password</span> <span class="operator">=</span> MD5Util.md5(password+salt);</span><br><span class="line">    <span class="comment">//存入MD5加密后的密码</span></span><br><span class="line">    user.setPassword(md5Password);</span><br><span class="line">    <span class="comment">//随机盐存入数据库，用于登录校验</span></span><br><span class="line">    user.setSalt(salt);</span><br><span class="line">    <span class="comment">//最后将用户数据数据存入数据库</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userDao.insert(user);</span><br><span class="line">    <span class="keyword">return</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-使用封装的MD5工具类完成用户登录-主要代码"><a href="#7-使用封装的MD5工具类完成用户登录-主要代码" class="headerlink" title="7. 使用封装的MD5工具类完成用户登录(主要代码)"></a>7. 使用封装的MD5工具类完成用户登录(主要代码)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">login</span><span class="params">(String name, String password)</span> &#123;</span><br><span class="line">    <span class="comment">//根据用户名在数据库查找用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userDao.selectByName(name);</span><br><span class="line">    <span class="comment">//取出用户信息比对</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbPassword</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">    <span class="type">String</span>  <span class="variable">salt</span> <span class="operator">=</span> user.getSalt();</span><br><span class="line">    <span class="comment">//通过密码+盐 重新生成 MD5密码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">md5Password</span> <span class="operator">=</span> MD5Util.md5(password+salt);</span><br><span class="line">    <span class="keyword">if</span>(md5Password.equals(dbPassword)) &#123;</span><br><span class="line">        <span class="comment">//登录成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-扩展：MessageDigest类常用方法"><a href="#8-扩展：MessageDigest类常用方法" class="headerlink" title="8. 扩展：MessageDigest类常用方法"></a>8. 扩展：MessageDigest类常用方法</h3><h4 id="8-1-构造方法摘要"><a href="#8-1-构造方法摘要" class="headerlink" title="8.1 构造方法摘要"></a>8.1 构造方法摘要</h4><p><code>MessageDigest(String algorithm)</code> –创建具有指定算法名称的MessageDigest 实例对象。</p><ul><li>MessageDigest类是一个工厂类，其构造器是受保护的，不允许直接使用new MessageDigist( )来创建对象，而必须通过其静态方法getInstance( )生成MessageDigest对象。其中传入的参数指定计算消息摘要所使用的算法，常用的有”MD5”，”SHA”等。</li></ul><h4 id="8-2-成员方法摘要："><a href="#8-2-成员方法摘要：" class="headerlink" title="8.2 成员方法摘要："></a>8.2 成员方法摘要：</h4><table><thead><tr><th>返回值</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object</td><td><code>clone()</code></td><td>如果实现是可复制的，则返回一个副本。</td></tr><tr><td>byte[]</td><td><code>digest()</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>byte[]</td><td><code>digest(byte[] input)</code></td><td>使用指定的字节数组对摘要进行最后更新，然后完成摘要计算。</td></tr><tr><td>int</td><td><code>digest(byte[] buf, int offset, int len)</code></td><td>通过执行诸如填充之类的最终操作完成哈希计算。</td></tr><tr><td>String</td><td><code>getAlgorithm()</code></td><td>返回标识算法的独立于实现细节的字符串。</td></tr><tr><td>int</td><td><code>getDigestLength()</code></td><td>返回以字节为单位的摘要长度，如果提供程序不支持此操作并且实现是不可复制的，则返回 0。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm)</code></td><td>生成实现指定摘要算法的 MessageDigest 对象。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, Provider provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>static MessageDigest</td><td><code>getInstance(String algorithm, String provider)</code></td><td>生成实现指定提供程序提供的指定算法的 MessageDigest 对象，如果该算法可从指定的提供程序得到的话。</td></tr><tr><td>Provider</td><td><code>getProvider()</code></td><td>返回此信息摘要对象的提供程序。</td></tr><tr><td>static boolean</td><td><code>isEqual(byte[] digesta, byte[] digestb)</code></td><td>比较两个摘要的相等性。</td></tr><tr><td>void</td><td><code>reset()</code></td><td>重置摘要以供再次使用。</td></tr><tr><td>String</td><td><code>toString()</code></td><td>返回此信息摘要对象的字符串表示形式。</td></tr><tr><td>void</td><td><code>update(byte input)</code></td><td>使用指定的字节更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input)</code></td><td>使用指定的字节数组更新摘要。</td></tr><tr><td>void</td><td><code>update(byte[] input, int offset, int len)</code></td><td>使用指定的字节数组，从指定的偏移量开始更新摘要。</td></tr><tr><td>void</td><td><code>update(ByteBuffer input)</code></td><td>使用指定的 ByteBuffer 更新摘要。</td></tr></tbody></table><blockquote><p>★ 编程思路：java.security包中的MessageDigest类提供了计算消息摘要（即生成散列码）的方法，首先生成对象，执行其update( )方法可以将原始数据传递给该对象，然后执行其digest( )方法即可得到消息摘要。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安全认证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 安全认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并发编程」NIO、Netty及websocket实现</title>
      <link href="/2019/10/20/concurrent-nio-websocket.html"/>
      <url>/2019/10/20/concurrent-nio-websocket.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-BIO-x2F-NIO-x2F-AIO演变"><a href="#1-BIO-x2F-NIO-x2F-AIO演变" class="headerlink" title="1. BIO&#x2F;NIO&#x2F;AIO演变"></a>1. BIO&#x2F;NIO&#x2F;AIO演变</h3><p>Java IO 方式有很多种，基于不同的IO抽象模型和交互方式，可以进行简单区分。</p><table><thead><tr><th>IO类型</th><th>模型</th><th>客户端:线程数</th><th>API使用难度</th><th>调试难度</th><th>可靠性</th><th>吞吐量</th></tr></thead><tbody><tr><td>BIO</td><td>流，同步阻塞</td><td>1:1</td><td>简单</td><td>简单</td><td>很差</td><td>非常低</td></tr><tr><td>伪异步IO</td><td>同步阻塞</td><td>M:N</td><td>简单</td><td>简单</td><td>较差</td><td>中等</td></tr><tr><td>NIO</td><td>同步非阻塞</td><td>M:1</td><td>复杂</td><td>复杂</td><td>较高</td><td>高</td></tr><tr><td>AIO</td><td>异步非阻塞</td><td>M:0,被动回调</td><td>复杂</td><td>复杂</td><td>高</td><td>高</td></tr></tbody></table><span id="more"></span><ol><li>区分同步(synchronous)或异步(asynchronous)<ul><li>同步是一种可靠的有序运行机制，当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步；</li><li>异步则相反，其他任务不需要等待当前调用返回，通常依靠事件、回调等机制来实现任务间次序关系。</li></ul></li><li>区分阻塞(blocking)与非阻塞(non-blocking)<ul><li>在进行阻塞操作时，当前线程会处于阻塞状态，无法从事其他任务，只有当条件就绪才能继续，比如 ServerSocket 新连接建立完毕，或数据读取、写入操作完成；</li><li>非阻塞则是不管 IO 操作是否结束，直接返回，相应操作在后台继续处理</li></ul></li></ol><ul><li>传统的java.io包，它基于流模型实现，<strong>同步阻塞</strong>的交互方式，如File抽象、输入输出流等。好处是代码简单、直观，缺点是IO效率和扩展性局限性</li><li>很多时候，也把java.net下面提供的部分网络API，比如Socket、ServerSocket、HttpURLConnection也归类到同步阻塞IO类库，因为网络通信同样是IO行为。</li><li>伪异步IO：后端通过维护一个消息队列和N个活跃线程, 通过一个<strong>线程池</strong>来处理多个客户端的请求接入，通过线程池，可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入而导致的线程耗尽和宕机。</li><li>JDK4引入了NIO框架(java.nio)，提供了Channel、Selector、Buffer等新的抽象，可以构建<strong>多路复用</strong>的、<strong>同步非阻塞</strong>IO程序，同时提供了更接近操作系统底层的高性能数据操作方式。</li><li>JDK7中，NIO有了进一步的改进，引入了异步非阻塞IO方式，也叫AIO(Asynchronous IO)。异步IO操作基于事件和<strong>回调机制</strong>，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</li></ul><h4 id="1-1-NIO的主要组成部分："><a href="#1-1-NIO的主要组成部分：" class="headerlink" title="1.1 NIO的主要组成部分："></a>1.1 NIO的主要组成部分：</h4><ol><li>Buffer(缓冲区)，高效的数据容器，除了布尔类型，所有原始数据类型都有相应的Buffer实现。<ul><li>Buffer最常见的类型是ByteBuffer，另外还有CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。</li></ul></li><li>Channel(通道)，是NIO中被用来支持批量式IO操作的一种抽象。<ul><li>和流不同，通道是双向的。数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。</li></ul></li><li>Selector(多路复用器)，是NIO实现多路复用的基础，它允许单线程处理多个Channel。<ul><li>Selector是基于底层操作系统机制，不同模式、不同版本都存在区别。</li><li>要使用Selector，得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</li></ul></li></ol><h4 id="1-2-NIO多路复用的过程"><a href="#1-2-NIO多路复用的过程" class="headerlink" title="1.2 NIO多路复用的过程"></a>1.2 NIO多路复用的过程</h4><ol><li>通过Selector.open()创建一个Selector，作为类似调度员的角色。</li><li>创建一个ServerSocketChannel，并绑定监听端口，设置为非阻塞模式</li><li>将Channel向Selector注册，通过指定SelectionKey.OP_ACCEPT，告诉调度员，它关注的是新的连接请求。</li><li>Selector循环阻塞在select操作，当有Channel发生接入请求，就会被唤醒。</li><li>调用selectedKeys方法获取就绪channel集合</li><li>通过SocketChannel和Buffer进行数据操作。</li></ol><h4 id="1-3-AIO"><a href="#1-3-AIO" class="headerlink" title="1.3 AIO"></a>1.3 AIO</h4><ul><li>AIO也叫NIO2.0 是一种非阻塞异步的通信模式。在NIO的基础上引入了新的<strong>异步通道</strong>的概念，并提供了异步文件通道和异步套接字通道的实现。<ul><li>没有采用NIO的多路复用器，而是使用异步通道的概念。</li><li>其read，write方法的返回类型都是Future对象。而Future模型是异步的，其核心思想是：去主函数等待时间。</li><li>AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道的实现。非阻塞，异步。</li></ul></li></ul><h3 id="2-Netty框架"><a href="#2-Netty框架" class="headerlink" title="2. Netty框架"></a>2. Netty框架</h3><p>Netty是一个高性能事件驱动，异步非阻塞的IO开源框架，由Jboss提供，用于建立Tcp等底层的链接，基于Netty可以建立高性能的Http服务器，快速开发高性能、高可靠的网络服务器和客户端程序。支持Http、websocket，tcp，udp等协议。</p><ul><li>Netty使用场景：高性能领域（游戏，大数据分布式计算等）、多线程并发领域（多路复用模型，多线程模型，主从多线程模型）、异步通信领域</li><li>Netty 是一个吸收了多种协议（包括FTP、SMTP、HTTP等各种二进制文本协议）的实现经验，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。</li></ul><h4 id="2-1-Netty的核心概念"><a href="#2-1-Netty的核心概念" class="headerlink" title="2.1 Netty的核心概念"></a>2.1 Netty的核心概念</h4><ol><li>ServerBootstrap，服务器端程序的入口，这是 Netty 为简化网络程序配置和关闭等生命周期管理，所引入的 Bootstrapping 机制。我们通常要做的创建 Channel、绑定端口、注册 Handler 等，都可以通过这个统一的入口，以<strong>Fluent API</strong>等形式完成，相对简化了 API 使用。与之相对应， Bootstrap则是 Client 端的通常入口。</li><li>Channel，作为一个基于 NIO 的扩展框架，Channel 和 Selector 等概念仍然是 Netty 的基础组件，但是针对应用开发具体需求，提供了相对易用的抽象。</li><li>EventLoop，这是 Netty 处理事件的核心机制。例子中使用了 EventLoopGroup。我们在 NIO 中通常要做的几件事情，如注册感兴趣的事件、调度相应的 Handler 等，都是 EventLoop 负责。</li><li>ChannelFuture，这是 Netty 实现异步 IO 的基础之一，保证了同一个 Channel 操作的调用顺序。Netty 扩展了 Java 标准的 Future，提供了针对自己场景的特有Future定义。</li><li>ChannelHandler，这是应用开发者<strong>放置业务逻辑的主要地方</strong>，也是我上面提到的“Separation Of Concerns”原则的体现。</li><li>ChannelPipeline，它是 ChannelHandler 链条的容器，每个 Channel 在创建后，自动被分配一个 ChannelPipeline。在上面的示例中，我们通过 ServerBootstrap 注册了 ChannelInitializer，并且实现了 initChannel 方法，而在该方法中则承担了向 ChannelPipleline 安装其他 Handler 的任务。</li></ol><h4 id="2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？"><a href="#2-2-对比-Java-标准-NIO-类库，Netty是如何实现更高性能的？" class="headerlink" title="2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？"></a>2.2 对比 Java 标准 NIO 类库，Netty是如何实现更高性能的？</h4><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p><ol><li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li><li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li><li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li><li>在通信协议、序列化等其他角度的优化。</li></ol><p>Netty 的设计强调了 “Separation Of Concerns”，通过精巧设计的事件机制，将业务逻辑和无关技术逻辑进行隔离，并通过各种方便的抽象，一定程度上填补了了基础平台和业务开发之间的鸿沟，更有利于在应用开发中普及业界的最佳实践。另外，Netty &gt; java.nio + java. net！</p><p>除了核心的事件机制等，Netty 还额外提供了很多功能，例如：</p><ol><li>从网络协议的角度，Netty 除了支持传输层的 UDP、TCP、SCTP协议，也支持 HTTP(s)、WebSocket 等多种应用层协议，它并不是单一协议的 API。</li><li>在应用中，需要将数据从 Java 对象转换成为各种应用协议的数据格式，或者进行反向的转换，Netty 为此提供了一系列扩展的编解码框架，与应用开发场景无缝衔接，并且性能良好。</li><li>它扩展了 Java NIO Buffer，提供了自己的 ByteBuf 实现，并且深度支持 Direct Buffer 等技术，甚至 hack 了 Java 内部对 Direct Buffer 的分配和销毁等。同时，Netty 也提供了更加完善的 Scatter&#x2F;Gather 机制实现。</li></ol><h3 id="3-基于Netty搭建简单的Http服务"><a href="#3-基于Netty搭建简单的Http服务" class="headerlink" title="3. 基于Netty搭建简单的Http服务"></a>3. 基于Netty搭建简单的Http服务</h3><ol><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code></li><li>代码编写：<code>MyChannelInitializer.java</code>、<code>MyClientHandler.java</code>、<code>NettyServer.java</code></li></ol><blockquote><p>MyChannelInitializer.java：添加了Http的处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        <span class="comment">// 数据解码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpResponseEncoder</span>());</span><br><span class="line">        <span class="comment">// 数据编码操作</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpRequestDecoder</span>());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>MyServerHandler.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            <span class="type">DefaultHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> (DefaultHttpRequest) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;URI:&quot;</span> + request.getUri());</span><br><span class="line">            System.err.println(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpContent) &#123;</span><br><span class="line">            <span class="type">LastHttpContent</span> <span class="variable">httpContent</span> <span class="operator">=</span> (LastHttpContent) msg;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">byteData</span> <span class="operator">=</span> httpContent.content();</span><br><span class="line">            <span class="keyword">if</span> (!(byteData <span class="keyword">instanceof</span> EmptyByteBuf)) &#123;</span><br><span class="line">                <span class="comment">//接收msg消息</span></span><br><span class="line">                <span class="type">byte</span>[] msgByte = <span class="keyword">new</span> <span class="title class_">byte</span>[byteData.readableBytes()];</span><br><span class="line">                byteData.readBytes(msgByte);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(msgByte, StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sendMsg</span> <span class="operator">=</span> <span class="string">&quot;不平凡的岁月终究来自你每日不停歇的刻苦拼搏，每一次真正成长都因看清脚下路而抉择出的生活。&quot;</span>;</span><br><span class="line">        <span class="type">FullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(</span><br><span class="line">                HttpVersion.HTTP_1_1,</span><br><span class="line">                HttpResponseStatus.OK,</span><br><span class="line">                Unpooled.wrappedBuffer(sendMsg.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain;charset=UTF-8&quot;</span>);</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());</span><br><span class="line">        response.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);</span><br><span class="line">        ctx.write(response);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NettyServer.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NettyServer</span>().bing(<span class="number">7397</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bing</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">parentGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">childGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)<span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">MyChannelInitializer</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;http-netty server start done. &quot;</span>);</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            childGroup.shutdownGracefully();</span><br><span class="line">            parentGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>启动<code>NettyServer</code>，<code>Postman</code>访问<code>http://localhost:7397</code>并设置参数</p></blockquote><h3 id="4-WebSocket"><a href="#4-WebSocket" class="headerlink" title="4. WebSocket"></a>4. WebSocket</h3><p>WebSocket是一种H5协议规范，通过握手机制客户端与服务器之间就能够建立一个类似Tcp的连接，从而方便客户端与服务器之间的通信。</p><ul><li>它是一种解决客户端与服务端实时通信而产生的技术：WebSocket本质是一种基于TCP协议，先通过Http&#x2F;Https发一个特殊的Http请求进行握手，握手后会创建一个用于交换数据的TCP链接，之后客户端和服务端使用该TCP链接进行实时通信。当WebSocket的客户端和服务端握手后 建立通信后，就不再需要之前的http请求参与。</li></ul><h4 id="4-1-WebSocket的优点："><a href="#4-1-WebSocket的优点：" class="headerlink" title="4.1 WebSocket的优点："></a>4.1 WebSocket的优点：</h4><ul><li>节省通信开销，之前WebServer实现通信，都使用轮询，需要不停的向服务器发送请求，而HttpRequest的handler很长，请求包含真正的数据可能很小，会占用很多额外的带宽和服务器资源。</li><li>建立连接后，服务器可主动传数据给客户端，客户端也可以随意向服务端传数据。交换数据时所携带的头信息很小。浏览器（客户端）和服务器只需要做一个握手的动作。</li><li>实时通信：WebSocket不仅限于Ajax方式通信。ajax方式需要浏览器发起请求。而WebSocket技术 服务端和客户端可以彼此相互推送信息，从而实现实时通信。</li></ul><h4 id="4-2-WebSocket建立连接过程："><a href="#4-2-WebSocket建立连接过程：" class="headerlink" title="4.2 WebSocket建立连接过程："></a>4.2 WebSocket建立连接过程：</h4><p><code>客户端发起握手请求 ---&gt; 服务端响应请求 ---&gt; 建立连接</code></p><ul><li>详细流程：建立一个WebSocket连接，客户端或浏览器首先向服务器发送一个特殊的Http请求(携带一些附加头信息)Upgrade:websocket，服务端解析附加头信息，产生应答消息，然后响应给客户端，之后客户端就与服务端建立响应的链接。</li></ul><h4 id="4-3-WebSocket生命周期："><a href="#4-3-WebSocket生命周期：" class="headerlink" title="4.3 WebSocket生命周期："></a>4.3 WebSocket生命周期：</h4><ol><li>打开事件：端点上建立新链接时，该事件是先于其他任何事件发生之前。该事件发生会产生三部分信息。<ol><li>创建WebSocket Session对象：用于表示已经建立好的链接</li><li>配置对象：包含配置端点的信息。</li><li>一组路径参数，用于打开节点握手时，WebSocket端入栈匹配的URI</li></ol></li><li>消息事件：主要是接收WebSocket对话中，另一端发送的消息。链接上的消息将会有三种形式抵达客户端。<ol><li>文本消息 用String处理</li><li>二进制消息 用byteBuffer或者byte[]处理</li><li>pong消息 用Java WebSocket API中的pong.message接口的实例来处理</li></ol></li><li>错误事件：WebSocket链接或者端点发生错误时产生。可以处理入栈消息时发生的各种异常。入栈消息可能产生的三种异常。<ol><li>WebSocket建立链接时发生错误：SessionException类型</li><li>WebSocket试图将入栈消息解码成开发人员使用的对象时 EncodeException类型</li><li>WebSocket端点的其他方法运行时产生的错误，WebSocket实现将记录端点操作过程中产生的任何异常</li></ol></li><li>关闭事件：WebSocket链接端点关闭，做一些清理工作，可以由参与连接的任意一个端点发出。</li></ol><h4 id="4-4-WebSocket如何关闭链接："><a href="#4-4-WebSocket如何关闭链接：" class="headerlink" title="4.4 WebSocket如何关闭链接："></a>4.4 WebSocket如何关闭链接：</h4><p>流程：当服务器被指示关闭WebSocket链接时，服务端会发起一个TCP Close操作， 客户端应该等待服务器的TCP Close</p><ul><li>关闭WebSocket连接，端点需关闭底层TCP连接。</li><li>底层TCP连接，在大多数正常情况下，应该首先被服务器关闭，服务器持有TIME_WAIT状态（因为这会防止它在2个报文最大生存时间（2MLS）内重新打开连接，然而当一个新的带有更高的seq number的SYN时没有对应的服务器影响TIME_WAIT连接被立即重新打开）。</li><li>在异常情况下（例如在一个合理的时间量后没有接收到服务器的TCP Close）,客户端可以发起<code>TCP Close</code>。</li></ul><h3 id="5-基于Netty搭建WebSocket多人聊天室"><a href="#5-基于Netty搭建WebSocket多人聊天室" class="headerlink" title="5. 基于Netty搭建WebSocket多人聊天室"></a>5. 基于Netty搭建WebSocket多人聊天室</h3><ol><li>使用SpringBoot+Netty+WebSocket搭建功能。</li><li>使用Netty提供的HttpServerCodec、HttpObjectAggregator、ChunkedWriteHandler进行编码解码处理。</li><li>环境准备：<code>jdk1.8</code>、<code>Netty4.1.43.Final</code>、<code>spring-boot-starter-web</code></li></ol><blockquote><p>目录结构</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">└── src.main</span><br><span class="line">       ├── java</span><br><span class="line">       │   └── top.chaooo.hellonetty</span><br><span class="line">       │       ├── domain</span><br><span class="line">       │       │    ├── ClientMsgProtocol.java</span><br><span class="line">       │       │    └── ServerMsgProtocol.java</span><br><span class="line">       │       ├── server</span><br><span class="line">       │       │    ├── MyChannelInitializer.java</span><br><span class="line">       │       │    ├── MyServerHandler.java</span><br><span class="line">       │       │    └── NettyServer.java</span><br><span class="line">       │       ├── util</span><br><span class="line">       │       │    ├── ChannelHandler.java</span><br><span class="line">       │       │    └── MsgUtil.java</span><br><span class="line">       │       ├── controller</span><br><span class="line">       │       │    └── NettyController.java    </span><br><span class="line">       │       └── NettyApplication.java</span><br><span class="line">       └── resources</span><br><span class="line">            ├── static(js,img)</span><br><span class="line">            ├── templates</span><br><span class="line">            │    └── index.html</span><br><span class="line">            └── application.yml</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>resources&#x2F;application.yml：基础配置信息，包括了；应用端口、netty服务端端口等</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">netty:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7397</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">HTML5</span></span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p>server&#x2F;MyChannelInitializer.java：websocket处理协议</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyChannelInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel channel)</span> &#123;</span><br><span class="line">        channel.pipeline().addLast(<span class="string">&quot;http-codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">        channel.pipeline().addLast(<span class="string">&quot;aggregator&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65536</span>));</span><br><span class="line">        channel.pipeline().addLast(<span class="string">&quot;http-chunked&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">        <span class="comment">// 在管道中添加我们自己的接收数据实现方法</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server&#x2F;MyServerHandler.java：处理websocket消息信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyServerHandler.class);</span><br><span class="line">    <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动链接服务端的链接后，这个通道就是活跃的了。</span></span><br><span class="line"><span class="comment">     * 也就是客户端与服务端建立了通信通道并且可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) ctx.channel();</span><br><span class="line">        logger.info(<span class="string">&quot;链接报告开始&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;链接报告信息：有一客户端链接到本服务端&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;链接报告IP:&#123;&#125;&quot;</span>, channel.localAddress().getHostString());</span><br><span class="line">        logger.info(<span class="string">&quot;链接报告Port:&#123;&#125;&quot;</span>, channel.localAddress().getPort());</span><br><span class="line">        logger.info(<span class="string">&quot;链接报告完毕&quot;</span>);</span><br><span class="line">        ChannelUtil.channelGroup.add(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端主动断开服务端的链接后，这个通道就是不活跃的。</span></span><br><span class="line"><span class="comment">     * 也就是说客户端与服务端的关闭了通信通道并且不可以传输数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;客户端断开链接&#123;&#125;&quot;</span>, ctx.channel().localAddress().toString());</span><br><span class="line">        ChannelUtil.channelGroup.remove(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//http</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest) &#123;</span><br><span class="line">            <span class="type">FullHttpRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (FullHttpRequest) msg;</span><br><span class="line">            <span class="keyword">if</span> (!httpRequest.decoderResult().isSuccess()) &#123;</span><br><span class="line">                <span class="type">DefaultFullHttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST);</span><br><span class="line">                <span class="comment">// 返回应答给客户端</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.copiedBuffer(httpResponse.status().toString(), CharsetUtil.UTF_8);</span><br><span class="line">                    httpResponse.content().writeBytes(buf);</span><br><span class="line">                    buf.release();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果是非Keep-Alive，关闭连接</span></span><br><span class="line">                <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> ctx.channel().writeAndFlush(httpResponse);</span><br><span class="line">                <span class="keyword">if</span> (httpResponse.status().code() != <span class="number">200</span>) &#123;</span><br><span class="line">                    f.addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">WebSocketServerHandshakerFactory</span> <span class="variable">wsFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocketServerHandshakerFactory</span>(<span class="string">&quot;ws:/&quot;</span> + ctx.channel() + <span class="string">&quot;/websocket&quot;</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">            handshaker = wsFactory.newHandshaker(httpRequest);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == handshaker) &#123;</span><br><span class="line">                WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handshaker.handshake(ctx.channel(), httpRequest);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ws</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame) &#123;</span><br><span class="line">            <span class="type">WebSocketFrame</span> <span class="variable">webSocketFrame</span> <span class="operator">=</span> (WebSocketFrame) msg;</span><br><span class="line">            <span class="comment">//关闭请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> CloseWebSocketFrame) &#123;</span><br><span class="line">                handshaker.close(ctx.channel(), (CloseWebSocketFrame) webSocketFrame.retain());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//ping请求</span></span><br><span class="line">            <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> PingWebSocketFrame) &#123;</span><br><span class="line">                ctx.channel().write(<span class="keyword">new</span> <span class="title class_">PongWebSocketFrame</span>(webSocketFrame.content().retain()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//只支持文本格式，不支持二进制消息</span></span><br><span class="line">            <span class="keyword">if</span> (!(webSocketFrame <span class="keyword">instanceof</span> TextWebSocketFrame)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;仅支持文本格式&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> ((TextWebSocketFrame) webSocketFrame).text();</span><br><span class="line">            System.out.println(<span class="string">&quot;服务端收到：&quot;</span> + request);</span><br><span class="line">            <span class="type">ClientMsgProtocol</span> <span class="variable">clientMsgProtocol</span> <span class="operator">=</span> JSON.parseObject(request, ClientMsgProtocol.class);</span><br><span class="line">            <span class="comment">//1请求个人信息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                ctx.channel().writeAndFlush(MsgUtil.buildMsgOwner(ctx.channel().id().toString()));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//群发消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> == clientMsgProtocol.getType()) &#123;</span><br><span class="line">                <span class="type">TextWebSocketFrame</span> <span class="variable">textWebSocketFrame</span> <span class="operator">=</span> MsgUtil.buildMsgAll(ctx.channel().id().toString(), clientMsgProtocol.getMsgInfo());</span><br><span class="line">                ChannelUtil.channelGroup.writeAndFlush(textWebSocketFrame);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抓住异常，当发生异常的时候，可以做一些相应的处理，比如打印日志、关闭链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">        logger.info(<span class="string">&quot;异常信息：\r\n&quot;</span> + cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>server&#x2F;NettyServer.java：主服务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;nettyServer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NettyServer.class);</span><br><span class="line">    <span class="comment">//配置服务端NIO线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">parentGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">childGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">bing</span><span class="params">(InetSocketAddress address)</span> &#123;</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(parentGroup, childGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)    <span class="comment">//非阻塞模式</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">MyChannelInitializer</span>());</span><br><span class="line">            channelFuture = b.bind(address).syncUninterruptibly();</span><br><span class="line">            channel = channelFuture.channel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != channelFuture &amp;&amp; channelFuture.isSuccess()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;demo-netty server start done&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;demo-netty server start error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channelFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == channel) <span class="keyword">return</span>;</span><br><span class="line">        channel.close();</span><br><span class="line">        parentGroup.shutdownGracefully();</span><br><span class="line">        childGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util&#x2F;MsgUtil.java：消息构建工具类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title function_">buildMsgAll</span><span class="params">(String channelId, String msgInfo)</span> &#123;</span><br><span class="line">        <span class="comment">//模拟头像</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Math.abs(channelId.hashCode()) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerMsgProtocol</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerMsgProtocol</span>();</span><br><span class="line">        msg.setType(<span class="number">2</span>); <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        msg.setUserHeadImg(<span class="string">&quot;head&quot;</span> + i + <span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">        msg.setMsgInfo(msgInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TextWebSocketFrame <span class="title function_">buildMsgOwner</span><span class="params">(String channelId)</span> &#123;</span><br><span class="line">        <span class="type">ServerMsgProtocol</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerMsgProtocol</span>();</span><br><span class="line">        msg.setType(<span class="number">1</span>); <span class="comment">//链接信息;1链接信息、2消息信息</span></span><br><span class="line">        msg.setChannelId(channelId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(JSON.toJSONString(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>util&#x2F;ChannelUtil.java：存储每一个客户端接入进来时的channel对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelUtil</span> &#123;</span><br><span class="line">    <span class="comment">//用于存放用户Channel信息，也可以建立map结构模拟不同的消息群</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span> <span class="variable">channelGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>domain&#x2F;*MsgProtocol.java：省略get&#x2F;set</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerMsgProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;             <span class="comment">//链接信息;1:自发信息、2:群发消息</span></span><br><span class="line">    <span class="keyword">private</span> String channelId;     <span class="comment">//通信管道ID，实际使用中会映射成用户名</span></span><br><span class="line">    <span class="keyword">private</span> String userHeadImg;   <span class="comment">//用户头像[模拟分配]</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo;       <span class="comment">//通信消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientMsgProtocol</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> type;       <span class="comment">//1:请求个人信息，2:发送聊天信息</span></span><br><span class="line">    <span class="keyword">private</span> String msgInfo; <span class="comment">//消息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>controller&#x2F;NettyController.java：路由控制层</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Dear&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>js逻辑：依赖jquery.min.js、jquery.serialize-object.min.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript Document</span></span><br><span class="line"><span class="keyword">var</span> socket;</span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">WebSocket</span>)&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="property">WebSocket</span> = <span class="variable language_">window</span>.<span class="property">MozWebSocket</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">WebSocket</span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;您的浏览器不支持WebSocket协议！推荐使用谷歌浏览器进行测试。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://localhost:7397/websocket&quot;</span>);</span><br><span class="line">    socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(event.<span class="property">data</span>);</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == msg.<span class="property">type</span>)&#123;</span><br><span class="line">            jQuery.<span class="title function_">data</span>(<span class="variable language_">document</span>.<span class="property">body</span>, <span class="string">&#x27;channelId&#x27;</span>, msg.<span class="property">channelId</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接信息;1自发信息、2群发消息</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">2</span> == msg.<span class="property">type</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> channelId =    msg.<span class="property">channelId</span>;</span><br><span class="line">            <span class="comment">//自己</span></span><br><span class="line">            <span class="keyword">if</span>(channelId == jQuery.<span class="title function_">data</span>(<span class="variable language_">document</span>.<span class="property">body</span>, <span class="string">&#x27;channelId&#x27;</span>))&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="variable language_">module</span> = $(<span class="string">&quot;.msgBlockOwnerClone&quot;</span>).<span class="title function_">clone</span>();</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">removeClass</span>(<span class="string">&quot;msgBlockOwnerClone&quot;</span>).<span class="title function_">addClass</span>(<span class="string">&quot;msgBlockOwner&quot;</span>).<span class="title function_">css</span>(&#123;<span class="attr">display</span>: <span class="string">&quot;block&quot;</span>&#125;);</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">find</span>(<span class="string">&quot;.headPoint&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;res/img/&quot;</span>+msg.<span class="property">userHeadImg</span>);</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">find</span>(<span class="string">&quot;.msgBlock_msgInfo .msgPoint&quot;</span>).<span class="title function_">text</span>(msg.<span class="property">msgInfo</span>);</span><br><span class="line">                $(<span class="string">&quot;#msgPoint&quot;</span>).<span class="title function_">before</span>(<span class="variable language_">module</span>);</span><br><span class="line">                util.<span class="title function_">divScroll</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//好友</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="variable language_">module</span> = $(<span class="string">&quot;.msgBlockFriendClone&quot;</span>).<span class="title function_">clone</span>();</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">removeClass</span>(<span class="string">&quot;msgBlockFriendClone&quot;</span>).<span class="title function_">addClass</span>(<span class="string">&quot;msgBlockFriend&quot;</span>).<span class="title function_">css</span>(&#123;<span class="attr">display</span>: <span class="string">&quot;block&quot;</span>&#125;);</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">find</span>(<span class="string">&quot;.headPoint&quot;</span>).<span class="title function_">attr</span>(<span class="string">&quot;src&quot;</span>, <span class="string">&quot;res/img/&quot;</span>+msg.<span class="property">userHeadImg</span>);</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">find</span>(<span class="string">&quot;.msgBlock_channelId&quot;</span>).<span class="title function_">text</span>(<span class="string">&quot;ID：&quot;</span>+msg.<span class="property">channelId</span>);</span><br><span class="line">                <span class="variable language_">module</span>.<span class="title function_">find</span>(<span class="string">&quot;.msgBlock_msgInfo .msgPoint&quot;</span>).<span class="title function_">text</span>(msg.<span class="property">msgInfo</span>);</span><br><span class="line">                $(<span class="string">&quot;#msgPoint&quot;</span>).<span class="title function_">before</span>(<span class="variable language_">module</span>);</span><br><span class="line">                util.<span class="title function_">divScroll</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;打开WebSoket 服务正常，浏览器支持WebSoket!&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">        clientMsgProtocol.<span class="property">type</span> = <span class="number">1</span>;</span><br><span class="line">        clientMsgProtocol.<span class="property">msgInfo</span> = <span class="string">&quot;请求个人信息&quot;</span>;</span><br><span class="line">        socket.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(clientMsgProtocol));</span><br><span class="line">     &#125;;</span><br><span class="line">    socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;WebSocket 关闭&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">13</span> == e.<span class="property">keyCode</span> &amp;&amp; e.<span class="property">ctrlKey</span>)&#123;</span><br><span class="line">            util.<span class="title function_">send</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">util = &#123;</span><br><span class="line">    <span class="attr">send</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">WebSocket</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> clientMsgProtocol = &#123;&#125;;</span><br><span class="line">            clientMsgProtocol.<span class="property">type</span> = <span class="number">2</span>;</span><br><span class="line">            clientMsgProtocol.<span class="property">msgInfo</span> = $(<span class="string">&quot;#sendBox&quot;</span>).<span class="title function_">val</span>();</span><br><span class="line">            socket.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(clientMsgProtocol));</span><br><span class="line">            $(<span class="string">&quot;#sendBox&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&quot;WebSocket 连接没有建立成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">divScroll</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;show&#x27;</span>); </span><br><span class="line">        div.<span class="property">scrollTop</span> = div.<span class="property">scrollHeight</span>; </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>主要Html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">xmlns:sec</span>=<span class="string">&quot;http://www.thymeleaf.org/extras/spring-security&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/jquery.serialize-object.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;chatDiv&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;chat&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:529px; height:667px; background-color:#F5F5F5; float:right;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 begin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:529px; height:450px; float:left;overflow-y:scroll;&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；好友 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgBlockFriendClone&quot;</span> <span class="attr">style</span>=<span class="string">&quot; display:none; margin-left:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:left;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgBlock_userHeadImg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;headPoint&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/img/head5.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;35px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;35px&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius:3px;-moz-border-radius:3px;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgBlock_channelId&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left; width:100px; margin-top:-5px; margin-left:10px; padding-bottom:2px; font-size:10px;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 名称 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgBlock_msgInfo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; &quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:4px; height:20px; background-color:#CC0000; float:left;border-radius:3px;-moz-border-radius:3px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgPoint&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 消息块；自己 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgBlockOwnerClone&quot;</span> <span class="attr">style</span>=<span class="string">&quot; display:none; margin-right:30px; margin-top:15px; width:340px; height:auto; margin-bottom:15px; float:right;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;float:right; width:35px; height:35px;border-radius:3px;-moz-border-radius:3px; background-color:#FFFFFF;&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;headPoint&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/img/head3.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;35px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;35px&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border-radius:3px;-moz-border-radius:3px;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgBlock_msgInfo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:auto;width:280px;float:left;margin-left:12px; margin-top:4px;border-radius:3px;-moz-border-radius:3px; &quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;msgPoint&quot;</span> <span class="attr">style</span>=<span class="string">&quot;float:left;width:260px; padding:7px; background-color:#FFFFFF; border-radius:3px;-moz-border-radius:3px; height:auto; font-size:12px;display:block;word-break: break-all;word-wrap: break-word;&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:4px; height:20px; background-color:#CC0000; float:right;border-radius:3px;-moz-border-radius:3px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;msgPoint&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 会话区域 end --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%; height:2px; float:left; background-color:#CCCCCC;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin:0 auto; width:100%; height:149px; margin-top:5px;  background-color:#FFFFFF; float:left;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;sendBox&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px; border:0; width:499px; height:80px; outline:none; padding:15px;font-family:”微软雅黑”;resize: none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;margin-top:20px; float:right; margin-right:35px; padding:5px; padding-left:15px; padding-right:15px; font-size:12px; background-color:#F5F5F5;border-radius:3px;-moz-border-radius:3px; cursor:pointer;&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;javascript:util.send();&quot;</span>&gt;</span>发送(S)<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动SpringBoot，Netty会随着启动；</li><li>用不同浏览器访问 <code>http://localhost:8080/index</code> 测试多人实时聊天。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并发编程」阻塞队列 与 线程池</title>
      <link href="/2019/10/14/concurrent-blockingqueue-threadpool.html"/>
      <url>/2019/10/14/concurrent-blockingqueue-threadpool.html</url>
      
        <content type="html"><![CDATA[<ul><li>池和队列的关系<ul><li>线程池或者数据库连接池，都有最大限制。如果超出了限制数量，则新进来的申请连接都要放入额外的<strong>队列里</strong>，等到池空出来时，从队列中取出连接放进池里。<span id="more"></span></li></ul></li></ul><h3 id="1-BlockingQueue（阻塞队列）"><a href="#1-BlockingQueue（阻塞队列）" class="headerlink" title="1. BlockingQueue（阻塞队列）"></a>1. BlockingQueue（阻塞队列）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue接口</span><br><span class="line">    |———— BlockingQueue接口</span><br><span class="line">        |———— ArrayBlockingQueue类</span><br><span class="line">        |———— DelayQueue类</span><br><span class="line">        |———— LinkedBlockingQueue类</span><br><span class="line">        |———— PriorityBlockingQueue类</span><br><span class="line">        |———— SynchronousQueue类</span><br></pre></td></tr></table></figure><ul><li><code>BlockingQueue</code>继承了<code>Queue</code>接口，提供了一些阻塞方法，主要作用如下：<ul><li>当线程向队列中插入元素时，如果队列已满，则阻塞线程，直到队列有空闲位置（非满）；</li><li>当线程从队列中取元素（删除队列元素）时，如果队列为空，则阻塞线程，直到队列有元素；</li></ul></li><li><code>BlockingQueue</code>在<code>Queue</code>方法基础上增加了两类和阻塞相关的方法：<code>put(e)</code>、<code>take()</code>；<code>offer(e, time, unit)</code>、<code>poll(time, unit)</code>。</li></ul><table><thead><tr><th>操作类型</th><th>抛出异常</th><th>返回特殊值</th><th>阻塞线程</th><th>超时</th></tr></thead><tbody><tr><td>插入</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>删除</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>读取</td><td>element()</td><td>peek()</td><td>&#x2F;</td><td>&#x2F;</td></tr></tbody></table><ul><li>**<code>put(e)</code><strong>和</strong><code>take()</code>**方法会一直阻塞调用线程，直到线程被中断或队列状态可用；</li><li>**<code>offer(e, time, unit)</code><strong>和</strong><code>poll(time, unit)</code>**方法会限时阻塞调用线程，直到超时或线程被中断或队列状态可用。</li><li>阻塞队列主要用在生产者&#x2F;消费者的场景</li></ul><h4 id="1-1-ArrayBlockingQueue"><a href="#1-1-ArrayBlockingQueue" class="headerlink" title="1.1 ArrayBlockingQueue"></a>1.1 ArrayBlockingQueue</h4><p><code>ArrayBlockingQueue</code>是一个有边界的阻塞队列，它的内部实现是一个数组。</p><ul><li>有边界的意思是它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</li><li><code>ArrayBlockingQueue</code>是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-2-DelayQueue"><a href="#1-2-DelayQueue" class="headerlink" title="1.2 DelayQueue"></a>1.2 DelayQueue</h4><p><code>DelayQueue</code>阻塞的是其内部元素，<code>DelayQueue</code>中的元素必须实现<code>java.util.concurrent.Delayed</code>接口，<code>Delayed</code>接口继承了<code>Comparable</code>接口，这是因为<code>DelayedQueue</code>中的元素需要进行排序，一般情况，我们都是按元素过期时间的优先级进行排序。</p><ul><li><code>DelayQueue</code>应用场景：定时关闭连接、缓存对象，超时处理等</li></ul><h4 id="1-3-LinkedBlockingQueue"><a href="#1-3-LinkedBlockingQueue" class="headerlink" title="1.3 LinkedBlockingQueue"></a>1.3 LinkedBlockingQueue</h4><p><code>LinkedBlockingQueue</code>阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是有边界的，如果不指定，它就是无边界的。</p><ul><li>说是无边界，其实是采用了默认大小为<code>Integer.MAX_VALUE</code>的容量 。它的内部实现是一个链表。</li><li>和<code>ArrayBlockingQueue</code>一样，<code>LinkedBlockingQueue</code> 也是以先进先出的方式存储数据，最新插入的对象是尾部，最新移出的对象是头部。</li></ul><h4 id="1-4-PriorityBlockingQueue"><a href="#1-4-PriorityBlockingQueue" class="headerlink" title="1.4 PriorityBlockingQueue"></a>1.4 PriorityBlockingQueue</h4><p><code>PriorityBlockingQueue</code>是一个没有边界的队列，它的排序规则和<code>java.util.PriorityQueue</code>一样。需要注意，<code>PriorityBlockingQueue</code>中允许插入null对象。</p><ul><li>所有插入<code>PriorityBlockingQueue</code>的对象必须实现<code>java.lang.Comparable</code>接口，队列优先级的排序规则就是按照我们对这个接口的实现来定义的。</li><li>从<code>PriorityBlockingQueue</code>获得一个迭代器<code>Iterator</code>，但这个迭代器并不保证按照优先级顺序进行迭代。</li></ul><h4 id="1-5-SynchronousQueue"><a href="#1-5-SynchronousQueue" class="headerlink" title="1.5 SynchronousQueue"></a>1.5 SynchronousQueue</h4><p><code>SynchronousQueue</code>队列内部仅允许容纳一个元素。</p><ul><li>当一个线程插入一个元素后会被阻塞，除非这个元素被另一个线程消费。</li></ul><h3 id="2-Callable-amp-Future"><a href="#2-Callable-amp-Future" class="headerlink" title="2. Callable &amp; Future"></a>2. Callable &amp; Future</h3><p><code>Callable</code>与<code>Runnable</code>的功能大致相似，<code>Callable</code>功能强大一些，就是被线程执行后，可以返回值，并且能抛出异常。</p><ul><li><code>Runnable</code>接口只有一个<code>run()</code>方法，实现类重写<code>run</code>方法，把一些费时操作写在其中，然后使用某个线程去执行该<code>Runnable</code>实现类即可实现多线程。</li><li><code>Callable</code>是一个泛型接口只有一个<code>call()</code>方法，返回的类型就是创建<code>Callable</code>传进来的V类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Callable</code>一般是和<code>ExecutorService</code>配合来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本</p></blockquote><h4 id="2-1-Future-amp-FutureTask"><a href="#2-1-Future-amp-FutureTask" class="headerlink" title="2.1 Future &amp; FutureTask"></a>2.1 Future &amp; FutureTask</h4><p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的<strong>执行结果</strong>进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，该方法会阻塞直到任务返回结果。</p><ul><li>也就是说<code>Future</code>提供了三种功能：<ol><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ol></li><li>在<code>Future</code>接口中声明了5个方法：**<code>cancel</code><strong>、</strong><code>isCancelled</code><strong>、</strong><code>isDone</code><strong>、</strong><code>get</code>**<ul><li><code>boolean</code> <strong><code>cancel(boolean mayInterruptIfRunning)</code></strong>;&#x2F;&#x2F;用来取消任务，参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务。<ul><li>如果取消已经完成的任务会返回<code>false</code>；如果任务还没有执行会返回<code>true</code>；</li><li>如果任务正在执行，则返回<code>mayInterruptIfRunning</code>设置的值(<code>true/false</code>)；</li></ul></li><li><code>boolean</code> <strong><code>isCancelled()</code></strong>;&#x2F;&#x2F;任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li><code>boolean</code> <strong><code>isDone()</code></strong>;&#x2F;&#x2F;任务是否已经完成，若任务完成，则返回true；</li><li><code>V</code> <strong><code>get()</code></strong>;&#x2F;&#x2F;获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li><code>V</code> <strong><code>get(long timeout, TimeUnit unit)</code></strong>;&#x2F;&#x2F;获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul></li></ul><blockquote><p><code>Future</code>可以得到别的线程任务方法的返回值。<code>Future</code>是一个接口,引用对象指向的实际是<strong>FutureTask</strong>。</p></blockquote><h3 id="3-FutureTask"><a href="#3-FutureTask" class="headerlink" title="3. FutureTask"></a>3. FutureTask</h3><p>**<code>FutureTask</code>**的父类是<code>RunnableFuture</code>，而<code>RunnableFuture</code>继承了<code>Runnbale</code>和<code>Futrue</code>这两个接口</p><ul><li>从<code>FutureTask</code>构造方法可以了解到：<ol><li><code>FutureTask</code>最终都是执行<code>Callable</code>类型的任务。</li><li>如果构造函数参数是<code>Runnable</code>，会被<code>Executors.callable</code>方法转换为<code>Callable</code>类型。</li><li><code>Executors.callable</code>方法直接返回一个<code>RunnableAdapter</code>实例。</li><li><code>RunnableAdapter</code>是<code>FutureTask</code>的一个静态内部类并且实现了<code>Callable</code>，也就是说<code>RunnableAdapter</code>是<code>Callable</code>子类。</li><li><code>RunnableAdapter</code>的<code>call</code>方法实现代码是，执行<code>Runnable</code>的<code>run</code>方法，并返回构造<code>FutureTask</code>传入<code>result</code>参数。</li></ol></li><li><code>FutureTask</code>总结：<ul><li><code>FutureTask</code>实现了两个接口，<code>Runnable</code>和<code>Future</code>，所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值，这个组合的好处：假设有一个很费时逻辑需要计算并且返回这个值，同时这个值不是马上需要，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过<code>Future</code>得到！</li></ul></li></ul><blockquote><p>注意：</p></blockquote><ul><li>通过<code>Executor</code>执行线程任务都是以<code>Callable</code>形式，如果传入<code>Runnable</code>都会转化为<code>Callable</code>。</li><li>通过<code>new Thread(runnable)</code>，只能是<code>Runnable</code>子类形式。</li></ul><h3 id="4-Fork-x2F-Join"><a href="#4-Fork-x2F-Join" class="headerlink" title="4. Fork&#x2F;Join"></a>4. Fork&#x2F;Join</h3><p>从<code>JDK1.7</code>开始，Java提供<code>Fork/Join</code>框架用于并行执行任务，它的思想就是讲一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><ul><li>主要有两步：任务切分 -&gt; 结果合并<ol><li>第一步**<code>分割任务</code>**。首先我们需要有一个 <code>fork</code> 类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。</li><li>第二步执行任务并**<code>合并结果</code><strong>。分割的子任务分别放在</strong>双端队列**里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</li></ol></li><li>工作窃取算法（<code>work-stealing</code>）是指某个线程从其他队列里窃取任务来执行。</li><li><code>Fork/Join</code> 使用两个类来完成以上两个步骤：<ol><li>**<code>ForkJoinTask</code>**：我们要使用 <code>ForkJoin</code> 框架，必须首先创建一个 <code>ForkJoin</code> 任务。它提供在任务中执行 <code>fork()</code> 和 <code>join()</code> 操作的机制，通常情况下我们不需要直接继承 <code>ForkJoinTask</code> 类，而只需要继承它的子类，<code>Fork/Join</code> 框架提供了以下两个子类：<ul><li><code>RecursiveAction</code>：用于没有返回结果的任务。</li><li><code>RecursiveTask</code>：用于有返回结果的任务。</li></ul></li><li>**<code>ForkJoinPool</code>**：<code>ForkJoinTask</code> 需要通过 <code>ForkJoinPool</code> 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</li></ol></li></ul><h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5. 线程池"></a>5. 线程池</h3><p>线程池可以看作是一个资源集，任何池的作用都大同小异，主要是用来减少资源创建、初始化的系统开销。</p><ul><li>一个线程池包括以下四个基本组成部分：<ol><li>线程池管理器（<code>ThreadPool</code>）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li><li>工作线程（<code>PoolWorker</code>）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li><li>任务接口（<code>Task</code>）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li><li>任务队列（<code>taskQueue</code>）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Executor接口</span><br><span class="line">    |———— ExecutorService接口</span><br><span class="line">        |———— AbstractExecutorService抽象类</span><br><span class="line">            |———— ForkJoinPool类</span><br><span class="line">            |———— ThreadPoolExecutor类</span><br><span class="line">        |———— ScheduledExecutorService接口</span><br><span class="line">            |———— ScheduledThreadPoolExecutor类</span><br><span class="line">Executors类</span><br></pre></td></tr></table></figure><h4 id="5-1-通过Executors工厂类中的六个静态方法创建线程池"><a href="#5-1-通过Executors工厂类中的六个静态方法创建线程池" class="headerlink" title="5.1 通过Executors工厂类中的六个静态方法创建线程池"></a>5.1 通过Executors工厂类中的六个静态方法创建线程池</h4><p>六大静态方法创建的<code>ThreadPoolExecutor</code>对象，返回的父接口的引用，即返回的<code>ExecutorService</code>的引用。六大静态方法内部都是直接或间接调用<code>ThreadPoolExecutor</code>类的构造方法创建线程池对象。</p><ol><li><code>newCachedThreadPool(ThreadPoolExecutor)</code>：创建一个可缓存的线程池<ul><li>如果线程池的大小超过了处理任务所需要的线程,那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）,<code>maximumPoolSize</code>最大可以至(<code>Integer.MAX_VALUE</code>),若达到该上限,直接OOM。</li></ul></li><li><code>newFixedThreadPool(ThreadPoolExecutor)</code>：创建固定大小的线程池。<ul><li>每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li></ul></li><li><code>newSingleThreadExecutor(ThreadPoolExecutor)</code>：创建一个单线程的线程池。<ul><li>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务,保证按任务的提交顺序依次执行。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li></ul></li><li><code>newScheduledThreadPool(ScheduledThreadPoolExecutor)</code>：创建一个支持定时及周期性任务执行的线程池。<ul><li>线程数最大至<code>Integer.MAX_ VALUE</code>,存在OOM风险,不回收工作线程.</li></ul></li><li><code>newSingleThreadScheduledExecutor(ScheduledThreadPoolExecutor)</code>：创建一个单线程用于定时以及周期性执行任务的需求。</li><li><code>newWorkStealingPool(ForkJoinPool)</code>：创建一个工作窃取<ul><li>JDK8 引入,创建持有足够线程的线程池支持给定的并行度;并通过使用多个队列减少竞争;</li></ul></li></ol><blockquote><p>Executors返回的线程池对象的弊端：</p><ol><li><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>：<ul><li>允许的<strong>请求队列长度</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>堆积大量的请求</strong>，从而导致OOM。</li></ul></li><li><code>CachedThreadPool</code>：<ul><li>允许的<strong>创建线程数量</strong>为<code>Integer.MAX_VALUE</code>，可能会<strong>创建大量的线程</strong>，从而导致OOM。</li></ul></li></ol></blockquote><h4 id="5-2-通过ThreadPoolExecutor构造方法创建线程池"><a href="#5-2-通过ThreadPoolExecutor构造方法创建线程池" class="headerlink" title="5.2 通过ThreadPoolExecutor构造方法创建线程池"></a>5.2 通过<code>ThreadPoolExecutor</code>构造方法创建线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,   //核心线程数，包括空闲线程</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,//最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, //线程空闲时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,      //时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,//缓存队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,      //线程工厂</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler  //拒绝策略</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ? </span><br><span class="line">        <span class="literal">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-1-corePoolSize-核心线程数量"><a href="#5-2-1-corePoolSize-核心线程数量" class="headerlink" title="5.2.1 corePoolSize(核心线程数量)"></a>5.2.1 corePoolSize(核心线程数量)</h5><ul><li><code>corePoolSize</code>的设置非常关键：<ul><li><code>=0</code>：则任务执行完之后,没有任何请求进入时销毁线程池的线程</li><li><code>&gt;0</code>：即使本地任务执行完毕,核心线程也不会被销毁</li><li>设置过大会浪费资源; 设置过小会导致线程频繁地创建或销毁</li></ul></li><li>若设置了<code>allowCoreThreadTimeOut</code>这个参数,当提交一个任务到线程池时,若<code>线程数量(包括空闲线程)小于corePoolSize</code>,线程池会创建一个新线程放入<code>works(一个HashSet)</code>中执行任务,等到需要执行的任务数大于线程池基本大小时就不再创建,会尝试放入等待队列<code>workQueue</code>；如果调用线程池的<code>prestartAllCoreThreads()</code>,线程池会提前创建并启动所有核心线程</li></ul><h5 id="5-2-2-maximumPoolSize（线程池最大线程数）"><a href="#5-2-2-maximumPoolSize（线程池最大线程数）" class="headerlink" title="5.2.2 maximumPoolSize（线程池最大线程数）"></a>5.2.2 maximumPoolSize（线程池最大线程数）</h5><ul><li><code>maximumPoolSize</code>表示线程池能够容纳同时执行的最大线程数,必须&gt;&#x3D;1.</li><li>若队列满,并且已创建的线程数小于最大线程数,则线程池会再创建新的线程放入<code>works</code>中执行任务,<code>CashedThreadPool</code>的关键,固定线程数的线程池无效</li><li>如果<code>maximumPoolSize = corePoolSize</code>,即是固定大小线程池.</li><li>若使用了无界任务队列,这个参数就没什么效果</li></ul><h5 id="5-2-3-keepAliveTime（线程池中的线程空闲时间）"><a href="#5-2-3-keepAliveTime（线程池中的线程空闲时间）" class="headerlink" title="5.2.3 keepAliveTime（线程池中的线程空闲时间）"></a>5.2.3 keepAliveTime（线程池中的线程空闲时间）</h5><ul><li>线程没有任务执行时最多保持多久时间终止（线程池的工作线程空闲后，保持存活的时间)</li><li>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率</li><li>当空闲时间达到<code>keepAliveTime</code>时,线程会被销毁,直到只剩下<code>corePoolSize</code>个线程;避免浪费内存和句柄资源.</li><li>在默认情况下,当线程池的线程数大于<code>corePoolSize</code>时,<code>keepAliveTime</code>才起作用.</li><li>但是当<code>ThreadPoolExecutor</code>的<code>allowCoreThreadTimeOut=true</code>时,核心线程超时后也会被回收.</li></ul><h5 id="5-2-4-TimeUnit（时间单位）"><a href="#5-2-4-TimeUnit（时间单位）" class="headerlink" title="5.2.4 TimeUnit（时间单位）"></a>5.2.4 TimeUnit（时间单位）</h5><ul><li>keepAliveTime的时间单位通常是<code>TimeUnit.SECONDS</code></li><li>可选的单位：天(<code>DAYS</code>)、小时(<code>HOURS</code>)、分钟(<code>MINUTES</code>)、毫秒(<code>MILLISECONDS</code>)、微秒(<code>MICROSECONDS</code>，千分之一毫秒) 和 纳秒(<code>NANOSECONDS</code>，千分之一微秒)</li></ul><h5 id="5-2-5-workQueue（缓存队列）"><a href="#5-2-5-workQueue（缓存队列）" class="headerlink" title="5.2.5 workQueue（缓存队列）"></a>5.2.5 workQueue（缓存队列）</h5><ul><li>存储待执行任务的阻塞队列，这些任务必须是<code>Runnable</code>的对象（如果是<code>Callable</code>对象，会在<code>submit</code>内部转换为<code>Runnable</code>对象） </li><li>当请求的线程数大于<code>maximumPoolSize</code>时,线程进入<code>BlockingQueue</code>.</li><li>可以选择以下几个阻塞队列:<ul><li><code>LinkedBlockingQueue</code>:一个基于链表结构的阻塞队列,此队列按<code>FIFO</code>排序元素,吞吐量通常要高于<code>ArrayBlockingQueue</code>.静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列</li><li><code>SynchronousQueue</code>:一个不存储元素的阻塞队列.每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常要高于<code>LinkedBlockingQueue</code>,静态工厂方法<code>Executors.newCachedThreadPoo</code>l使用了这个队列</li></ul></li></ul><h5 id="5-2-6-threadFactory-（线程工厂）"><a href="#5-2-6-threadFactory-（线程工厂）" class="headerlink" title="5.2.6 threadFactory （线程工厂）"></a>5.2.6 threadFactory （线程工厂）</h5><ul><li>用于设置创建线程的工厂;</li><li>线程池的命名是通过增加组名前缀来实现的，可以通过线程工厂给每个创建出来的线程设置更有意义的名字</li><li>在虚拟机栈分析时,就可以知道线程任务是由哪个线程工厂产生的.</li></ul><h5 id="5-2-7-RejectedExecutionHandler（拒绝策略）"><a href="#5-2-7-RejectedExecutionHandler（拒绝策略）" class="headerlink" title="5.2.7 RejectedExecutionHandler（拒绝策略）"></a>5.2.7 RejectedExecutionHandler（拒绝策略）</h5><ul><li>当队列和线程池都满,说明线程池饱和,必须采取一种策略处理提交的新任务；策略默认**<code>AbortPolicy</code>**,表无法处理新任务时抛出异常</li><li>当超过参数<code>workQueue</code>的任务缓存区上限的时候,就可以通过该策略处理请求,这是一种简单的限流保护.</li><li>友好的拒绝策略可以是如下三种:<ol><li>保存到数据库进行削峰填谷;在空闲时再提取出来执行</li><li>转向某个提示页面</li><li>打印日志</li></ol></li><li><code>AbortPolicy</code>：丢弃任务，抛出<code>RejectedExecutionException</code></li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务,有反馈机制，使任务提交的速度变慢）。</li><li><code>DiscardOldestPolicy</code>：若没有发生shutdown,尝试丢弃队列里最近的一个任务,并执行当前任务, 丢弃任务缓存队列中最老的任务，并且尝试重新提交新的任务</li><li><code>DiscardPolicy</code>:不处理,丢弃掉, 拒绝执行，不抛异常 </li><li>当然,也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略.如记录日志或持久化存储不能处理的任务</li></ul><h4 id="5-3-自定义一个ThreadPoolExecutor线程池"><a href="#5-3-自定义一个ThreadPoolExecutor线程池" class="headerlink" title="5.3 自定义一个ThreadPoolExecutor线程池"></a>5.3 自定义一个ThreadPoolExecutor线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">5</span>, <span class="comment">//核心线程数</span></span><br><span class="line">    Runtime.getRuntime().availableProcessors() * <span class="number">2</span>,<span class="comment">//最大线程数</span></span><br><span class="line">    <span class="number">60</span>,<span class="comment">//线程空闲时间</span></span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">200</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">            t.setName(<span class="string">&quot;order-thread&quot;</span>);<span class="comment">//设置有意义的线程名字</span></span><br><span class="line">            <span class="keyword">if</span>(t.isDaemon()) &#123;<span class="comment">//若是守护线程将其释放</span></span><br><span class="line">                t.setDaemon(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Thread.NORM_PRIORITY != t.getPriority()) &#123;</span><br><span class="line">                <span class="comment">//恢复线程优先级</span></span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RejectedExecutionHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;拒绝策略:&quot;</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><h4 id="5-3-1-线程池执行流程"><a href="#5-3-1-线程池执行流程" class="headerlink" title="5.3.1 线程池执行流程"></a>5.3.1 线程池执行流程</h4><ul><li>要求 线程池有上限，使用有限队列</li></ul><ol><li>当线程池核心线程数量用完，先扔进队列</li><li>队列也用完后，看最大线程数量</li><li>最大线程数量用完后，走拒绝策略</li><li>拒绝策略可以打印一些日志，做一些补偿</li><li>线程池用完一定要优雅的关闭</li></ol><blockquote><p>线程池要统一管理，不要用Executors工厂类，要用ThreadPoolExecutor自定义线程池</p></blockquote><h4 id="5-3-2-线程池配置-核心线程数量"><a href="#5-3-2-线程池配置-核心线程数量" class="headerlink" title="5.3.2 线程池配置-核心线程数量"></a>5.3.2 线程池配置-核心线程数量</h4><p>线程CPU时间所占比例越高，需要越少线程(CPU密集)。线程等待时间所占比例越高，需要越多线程(IO密集)。</p><ol><li><strong>CPU密集型</strong>：内存运算、不涉及IO操作等<ul><li>设置线程数为：<code>CPU核数+1</code></li></ul></li><li><strong>IO密集型</strong>：数据读取、存取、数据库操作、持久化操作等<ul><li>最佳线程数目：<code>CPU核数/(1-阻塞系数)</code> 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9。</li></ul></li></ol><blockquote><p>java.lang.<code>Runtime.availableProcessors()</code> 方法返回到Java虚拟机的可用的处理器数量(CPU核数)。此值可能会改变在一个特定的虚拟机调用。应用程序可用处理器的数量是敏感的，因此偶尔查询该属性，并适当地调整自己的资源使用情况.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并发编程」AQS框架 与 锁框架（JUC.locks）</title>
      <link href="/2019/10/10/concurrent-aqs-locks.html"/>
      <url>/2019/10/10/concurrent-aqs-locks.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-AQS（队列同步器）"><a href="#1-AQS（队列同步器）" class="headerlink" title="1. AQS（队列同步器）"></a>1. AQS（队列同步器）</h3><p><code>AbstractQueuedSynchronizer</code>：队列同步器，简称<code>AQS</code>。</p><ul><li><code>AQS</code>维护了一个<code>volatile int </code><strong><code>state</code></strong>(代表资源共享变量) 和一个**<code>FIFO</code>线程等待队列**(多线程争用资源被阻塞时会进入此队列)。</li><li><code>AQS</code>定义了两种资源共享方式：<code>Exclusive</code>(独占)，<code>Share</code>(共享)<span id="more"></span></li><li><code>isHeldExclusively</code>方法：该线程是否正在独占资源</li><li><code>tryAcquire</code>&#x2F;<code>tryRelease</code>：独占的方式尝试获取和释放资源</li><li><code>tryAcquireShared</code>&#x2F;<code>tryReleaseShared</code>：共享的方式尝试获取和释放资源</li></ul><p>整个框架的核心就是<strong>如何管理线程阻塞队列</strong>，该队列是严格的<code>FIFO</code>队列，因此不支持线程优先级的同步。</p><ul><li><code>AQS</code>只有一个同步队列，可以有多个条件队列。<ul><li>同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，同步队列选择了**<code>CLH</code>**作为实现的基础。</li><li>条件队列：<code>AQS</code>框架提供了一个<code>ConditionObject</code>类，给维护独占同步的类以及实现<code>Lock</code>接口的类使用。</li></ul></li><li>使用<code>Node</code>实现**<code>FIFO</code>双向队列**，可以用于构建锁 或 其他同步装置的基础框架</li><li>内部有一个int变量表示的**<code>同步状态</code><strong>(同步状态通过</strong><code>getState</code><strong>、</strong><code>setState</code><strong>、</strong><code>compareAndSetState</code>**来维护，同时这三个方法能够保证线程安全)</li><li><code>AQS</code>是个<strong>抽象类</strong>（但没有抽象方法），同步组件一般通过维护<code>AQS</code>的<strong>继承子类来实现</strong>。</li><li><code>AQS</code><strong>既</strong>支持独占地获取同步状态(<strong>排它锁</strong>)，<strong>又</strong>支持共享地获取同步状态(<strong>共享锁</strong>)，从而实现不同类型的组件。</li><li><code>AQS</code>是<strong>基于模板方法</strong>，同步组件需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li></ul><blockquote><p><code>Synchronizer</code>(同步器)：是一个对象，它根据本身的状态调节线程的控制流。常见类型的<code>Synchronizer</code>包括信号量、关卡和闭锁。</p></blockquote><h3 id="2-CountDownLatch（倒计时闭锁）"><a href="#2-CountDownLatch（倒计时闭锁）" class="headerlink" title="2. CountDownLatch（倒计时闭锁）"></a>2. CountDownLatch（倒计时闭锁）</h3><ul><li>闭锁(<code>latch</code>)是一种<code>Synchronizer</code>，它可以延迟线程的进度直到线程达到<strong>终止状态</strong>。</li><li><strong><code>CountDownLatch</code></strong>(倒计时闭锁)是一个灵活的闭锁实现。</li><li><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。</li><li><code>CountDownLatch</code><strong>原理</strong>：是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得<code>减1</code>。当计数器到达<code>0</code>时，表示所有的线程都已完成任务，然后在闭锁上等待的线程就可以恢复执行任务。<ul><li><code>await()</code>，阻塞程序继续执行</li><li><code>countDown()</code>，计数器的值<code>减1</code>，当计数器值减至<code>零</code>时，所有因调用<code>await()</code>方法而处于等待状态的线程就会继续往下执行。</li></ul></li><li>计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用<code>CycliBarrier</code></li></ul><blockquote><p><code>CountDownLatch</code>使用场景：应用初始化</p></blockquote><h3 id="3-Semaphore（信号量）"><a href="#3-Semaphore（信号量）" class="headerlink" title="3. Semaphore（信号量）"></a>3. Semaphore（信号量）</h3><ul><li><strong><code>Semaphore</code></strong>(信号量)：用来<strong>控制同时访问</strong>特定资源的线程<strong>数量</strong>，它通过协调各个线程，以保证合理的使用公共资源。</li><li><code>Semaphore</code><strong>原理</strong>：线程需要通过<code>acquire()</code>方法获取许可，而<code>release()</code>释放许可。如果许可数达到最大活动数，那么调用<code>acquire()</code>之后，便进入等待队列，等待已获得许可的线程释放许可，从而使得多线程能够合理的运行。<ul><li><code>acquire()</code>：获取权限，其底层实现与<code>CountDownLatch.countdown()</code>类似;</li><li><code>release()</code>：释放权限，其底层实现与<code>acquire()</code>是一个互逆的过程。</li></ul></li></ul><blockquote><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。</p></blockquote><h3 id="4-CyclicBarrier（同步屏障）"><a href="#4-CyclicBarrier（同步屏障）" class="headerlink" title="4. CyclicBarrier（同步屏障）"></a>4. CyclicBarrier（同步屏障）</h3><ul><li><strong><code>CyclicBarrier</code></strong>(同步屏障)：可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所有被阻塞的线程才能继续执行。</li><li><code>CyclicBarrier</code>类似于<code>CountDownLatch</code>，它也是通过计数器来实现的。但是相比于<code>CountDownLatch</code>功能更加强大。</li><li><code>CyclicBarrier</code><strong>原理</strong>：当某个线程调用<code>await</code>方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用<code>await</code>进入等待状态的线程被唤醒，继续执行后续操作。因为<code>CycliBarrier</code>在释放等待线程后可以重用，所以称为循环<code>barrier</code>。</li></ul><h4 id="4-1-CountDownLatch-和-CyclicBarrier-对比"><a href="#4-1-CountDownLatch-和-CyclicBarrier-对比" class="headerlink" title="4.1 CountDownLatch 和 CyclicBarrier 对比"></a>4.1 CountDownLatch 和 CyclicBarrier 对比</h4><ol><li><code>CountDownLatch</code>描述的是线程(1个或多个)等待其他线程的关系；<code>CyclicBarrier</code>描述的是多个线程相互等待的关系。</li><li><code>CountDownLatch</code>的计数器只能使用一次。而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置并复用。</li><li><code>CountDownLatch</code>方法比较少，操作比较简单，而<code>CyclicBarrier</code>提供的方法更多，比如：<ul><li><code>getNumberWaiting()</code>：获取阻塞的线程数量。</li><li><code>isBroken()</code>：获取阻塞线程的状态，被中断返回<code>true</code>，否则返回<code>false</code>。</li><li><code>CyclicBarrier</code>的构造方法可以传入<code>barrierAction</code>，指定当所有线程都到达时执行的业务功能；</li></ul></li></ol><blockquote><p><code>CyclicBarrier</code>可以用于多线程计算数据，最后合并计算结果的应用场景</p></blockquote><h3 id="5-JUC-locks-锁框架"><a href="#5-JUC-locks-锁框架" class="headerlink" title="5. JUC.locks 锁框架"></a>5. JUC.locks 锁框架</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks</span><br><span class="line">    |———— Lock接口</span><br><span class="line">        |———— ReentrantLock类</span><br><span class="line">            |———— ReentrantReadWriteLock.ReadLock内部类</span><br><span class="line">            |———— ReentrantReadWriteLock.WriteLock内部类</span><br><span class="line">    |———— Condition接口</span><br><span class="line">    |———— ReadWriteLock接口</span><br><span class="line">        |———— ReentrantReadWriteLock类</span><br><span class="line">    |———— LockSupport类</span><br></pre></td></tr></table></figure><ul><li><strong><code>Lock</code>接口</strong>核心方法：<code>lock()</code>，<code>unlock()</code>，<code>lockInterruptibly()</code>，<code>newCondition()</code>，<code>tryClock()</code><ul><li><code>lock()</code>方法类似于使用<code>synchronized</code>关键字加锁，如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态。</li><li><code>lockInterruptibly()</code>方法顾名思义，就是如果锁不可用，那么当前正在等待的线程是可以被中断的，这比<code>synchronized</code>关键字更加灵活。</li></ul></li><li><strong><code>Condition</code>接口</strong>核心方法：<code>awit()</code>，<code>signal()</code>，<code>signalAll()</code><ul><li>可以看做是Obejct类的wait()、notify()、notifyAll()方法的替代品，与Lock配合使用</li></ul></li><li><strong><code>ReadWriteLock</code>接口</strong>核心方法：<code>readLock()</code>，<code>writeLock()</code><ul><li>获取读锁和写锁，注意除非使用<code>Java8</code>新锁，否则读读不互斥，读写是互斥的</li></ul></li></ul><h3 id="6-ReentrantLock（可重入锁）"><a href="#6-ReentrantLock（可重入锁）" class="headerlink" title="6. ReentrantLock（可重入锁）"></a>6. ReentrantLock（可重入锁）</h3><p><strong><code>ReentrantLock</code>重入锁</strong>使用**<code>AQS</code>同步状态**来保存锁重复持有的次数</p><ul><li>底层代码分析：<ul><li>**<code>state</code>**初始化为0，表示未锁定状态</li><li>A线程<code>lock()</code>时，会调用<code>tryAcquire(</code>)独占该锁并将**<code>state+1</code>**</li><li>此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state=0</code>(即释放锁)为止，其他线程才有机会获取该锁</li><li>当然，锁释放之前，A线程自己是可以重复获取此锁的(<code>state</code>会累加)，这就是可重入的概念</li></ul></li></ul><p><code>synchronized</code>实现的锁的重入依赖于<code>JVM</code>，是一种重量级锁。<br><code>ReentrantLock</code>实现了在内存语义上的<code>synchronized</code>，使用**<code>AQS</code>同步状态**来保存锁重复持有的次数。当锁被一个线程获取时，<code>ReentrantLock</code>也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。</p><ul><li>公平锁和非公平锁<ul><li>公平锁还是非公平锁取决于<code>ReentrantLock</code>的构造方法，<strong>默认</strong>无参为<strong>非公平锁</strong>(<code>NonfairSync</code>)；含参构造方法，入参<code>true</code>为<code>FairSync</code>，入参<code>false</code>为<code>NonfairSync</code>。</li></ul></li><li>非公平锁中，抢到<code>AQS</code>的同步状态的未必是同步队列的首节点，只要线程通过<code>CAS</code>抢到了同步状态或者在<code>acquire</code>中抢到同步状态，就优先占有锁（插队），而相对同步队列这个严格的<code>FIFO</code>队列来说，所以会被认为是非公平锁。</li><li>公平锁的实现直接调用<code>AQS</code>的<code>acquire</code>方法，<code>acquire</code>中调用<code>tryAcquire</code>。和非公平锁相比，这里不会执行一次<code>CAS</code>，接下来在<code>tryAcquire</code>去抢占锁的时候，也会先调用<code>hasQueuedPredecessors</code>看看前面是否有节点已经在等待获取锁了，如果存在则同步队列的前驱节点优先（排队<code>FIFO</code>）。</li></ul><blockquote><p>虽然公平锁看起来在公平性上比非公平锁好，但是公平锁为此付出了大量线程切换的代价，而非公平锁在锁的获取上不能保证公平，就有可能出现锁饥饿，即有的线程多次获取锁而有的线程获取不到锁，没有大量的线程切换保证了非公平锁的吞吐量。</p></blockquote><h3 id="7-读写锁RRW（ReentrantReadWriteLock）"><a href="#7-读写锁RRW（ReentrantReadWriteLock）" class="headerlink" title="7. 读写锁RRW（ReentrantReadWriteLock）"></a>7. 读写锁RRW（ReentrantReadWriteLock）</h3><p><code>ReentrantLock</code>是独占锁，<code>ReentrantReadWriteLock</code>是读写锁。</p><ul><li>独占锁通过<code>state</code>变量的<code>0</code>和<code>1</code>两个状态来控制是否有线程占有锁，共享锁通过<code>state</code>变量<code>0</code>或者<code>非0</code>来控制多个线程访问。</li><li>读写锁定义为：一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。</li><li><code>ReentrantReadWriteLock</code>的特殊之处其实就是用一个<code>int</code>值表示两种不同的状态（<code>低16</code>位表示写锁的重入次数，<code>高16</code>位表示读锁的使用次数），并通过两个内部类同时实现了<code>AQS</code>的两套<code>API</code>，核心部分与共享&#x2F;独占锁并无什么区别。</li></ul><blockquote><p><code>ReentrantReadWriteLock</code>也会发生<strong>写请求饥饿</strong>的情况，因为写请求一样会排队，不管是公平锁还是非公平锁，在有读锁的情况下，都<strong>不能保证写锁</strong>一定能获取到，这样只要读锁一直占用，就会发生写饥饿的情况。<code>JDK8</code>中新增的改进读写锁<code>StampedLock</code>可解决饥饿问题</p></blockquote><h3 id="8-LockSupport工具类"><a href="#8-LockSupport工具类" class="headerlink" title="8. LockSupport工具类"></a>8. LockSupport工具类</h3><p>归根结底，<code>LockSupport</code>调用的<code>Unsafe</code>中的<code>native</code>代码：<code>park()</code>，<code>unpark()</code>；</p><ul><li><code>park</code>函数是将当前<code>Thread</code>阻塞，而<code>unpark</code>函数则是将另一个<code>Thread</code>唤醒。</li><li>与<code>Object</code>类的<code>wait/notify</code>机制相比，<code>park/unpark</code>有两个优点：<ol><li>以<code>thread</code>为操作对象更符合阻塞线程的直观定义；</li><li>操作更精准，可以准确地唤醒某一个线程（<code>Object</code>类的<code>notify</code>随机唤醒一个线程，<code>notifyAll</code>唤醒所有等待的线程），增加了灵活性</li></ol></li></ul><blockquote><p><code>park</code>方法的调用一般要在方法一个循环判断体里面。之所以这样做，是为了防止线程被唤醒后，不进行判断而意外继续向下执行，这其实是一种的多线程设计模式-Guarded Suspension。</p></blockquote><h3 id="9-StampedLock（Java8新型锁）"><a href="#9-StampedLock（Java8新型锁）" class="headerlink" title="9. StampedLock（Java8新型锁）"></a>9. StampedLock（Java8新型锁）</h3><p><code>ReentrantReadWriteLock</code>锁具有读写锁，问题在于<code>ReentrantReadWriteLock</code>使得多个读线程同时持有读锁（只要写锁未被占用），而写锁是独占的 ，很容易造成写锁获取不到资源(写请求饥饿)。</p><ul><li><code>Java8</code>引入了一个新的读写锁叫<code>StampedLock</code>. 不仅这个锁更快，而且它提供强大的乐观锁API。这种乐观策略的锁非常类似于无锁的操作，使得乐观锁完全不会阻塞写线程。</li><li><code>StampedLock</code>的主要特点：<ol><li>所有<strong>获取锁</strong>的方法，都返回一个邮戳（<code>Stamp</code>），<code>Stamp</code>为0表示获取失败，其余都表示成功；</li><li>所有<strong>释放锁</strong>的方法，都需要一个邮戳（<code>Stamp</code>），这个<code>Stamp</code>必须是和成功获取锁时得到的<code>Stamp</code>一致；</li><li><code>StampedLock</code>是<strong>不可重入</strong>的；（如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁）</li><li><code>StampedLock</code>有<strong>三种访问模式</strong>：<ul><li><code>Reading</code>（读模式）：功能和ReentrantReadWriteLock的读锁类似</li><li><code>Writing</code>（写模式）：功能和ReentrantReadWriteLock的写锁类似</li><li><code>Optimistic reading</code>（乐观读模式）：这是一种优化的读模式。</li></ul></li><li><code>StampedLock</code>支持读锁和写锁的相互转换</li><li><code>RRW</code>(ReentrantReadWriteLock)中，当线程获取到写锁后，可以降级为读锁，但是读锁是不能直接升级为写锁的；<code>StampedLock</code>提供了读锁和写锁相互转换的功能，使得该类支持更多的应用场景。</li><li>无论写锁还是读锁，都不支持<code>Conditon</code>等待</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「并发编程」JUC并发容器类</title>
      <link href="/2019/10/06/concurrent-collection.html"/>
      <url>/2019/10/06/concurrent-collection.html</url>
      
        <content type="html"><![CDATA[<p>在<code>java.util.concurrent</code>包中，提供了两种类型的并发集合：一种是阻塞式，另一种是非阻塞式。</p><ul><li>阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程将被阻塞，一直等到该方法可以被成功执行</li><li>非阻塞式集合：当集合已满或为空时，被调用的添加（满）、移除（空）方法就不能立即被执行，调用这个方法的线程不会被阻塞，而是直接则返回null或抛出异常。<span id="more"></span></li></ul><h3 id="1-线程安全相关容器"><a href="#1-线程安全相关容器" class="headerlink" title="1. 线程安全相关容器"></a>1. 线程安全相关容器</h3><h4 id="1-1-线程安全-同步容器："><a href="#1-1-线程安全-同步容器：" class="headerlink" title="1.1 线程安全-同步容器："></a>1.1 线程安全-同步容器：</h4><ol><li><code>ArrayList</code> –&gt; <code>Vector,Stack</code></li><li><code>HashMap</code> –&gt; <code>HashTable</code>(key、value不能为null)</li><li><code>Collections.synchronizedXXX</code>(List&#x2F;Set&#x2F;Map) &#x2F;&#x2F;本质是对相应的容器进行包装，通过在方法中加synchronized同步锁来实现</li></ol><ul><li>同步容器的同步原理就是在方法上用<code>synchronized</code>修饰。<strong>性能开销大</strong>。</li><li>在<strong>单独</strong>使用里面的方法的时候，可以保证线程安全，但是，<strong>复合操作需要额外加锁</strong>来保证线程安全。</li></ul><h4 id="1-2-线程安全-并发容器："><a href="#1-2-线程安全-并发容器：" class="headerlink" title="1.2 线程安全-并发容器："></a>1.2 线程安全-并发容器：</h4><ol><li><code>ArrayList</code> –&gt; **<code>CopyOnWriteArrayList</code><strong>：保证</strong><code>最终一致性</code><strong>，写时复制，适用于</strong><code>读多写少</code>**的并发场景</li><li><code>HashSet</code>、<code>TreeSet</code> –&gt; <code>CopyOnWriteArraySet</code>、<code>ConcurrentSkipListSet</code>：</li><li><code>HashMap</code>、<code>TreeMap</code> –&gt; **<code>ConcurrentHashMap</code>**、<code>ConcurrentSkipListMap</code>：</li></ol><h4 id="1-3-安全共享对象策略"><a href="#1-3-安全共享对象策略" class="headerlink" title="1.3 安全共享对象策略"></a>1.3 安全共享对象策略</h4><ol><li>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有者修改</li><li>共享只读：一个共享只读的对象，在没有额外同步的情况下，可以被多个线程并发访问，但不能修改</li><li>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保证线程安全，其他线程无需额外的同步就可以通过公共接口随意访问它</li><li>被守护对象：被守护对象只能通过获取特定的锁来访问</li></ol><h3 id="2-CopyOnWrite机制"><a href="#2-CopyOnWrite机制" class="headerlink" title="2. CopyOnWrite机制"></a>2. CopyOnWrite机制</h3><p><code>CopyOnWrite</code>（简称COW），是计算机程序设计领域中的一种优化策略，也是一种思想–即<strong>写入时复制思想</strong>。</p><ul><li>在<code>CopyOnWrite</code>中，对容器的修改操作加锁后，通过copy一个新的容器副本来进行修改，修改完毕后将容器替换为新的容器即可。<ul><li>这种方式的好处显而易见：通过copy一个新的容器来进行修改，这样读操作就不需要加锁，可以并发读，因为在读的过程中是采用的旧的容器，即使新容器做了修改对旧容器也没有影响，同时也很好的解决了迭代过程中其他线程修改导致的并发问题。</li></ul></li><li>从JDK1.5开始，<code>java.util.concurrent</code>包中提供了两个<code>CopyOnWrite</code>机制容器，分别为**<code>CopyOnWriteArrayList</code><strong>和</strong><code>CopyOnWriteArraySet</code>**</li><li><code>CopyOnWriteArrayList</code>通过使用**<code>ReentrantLock</code>锁**来实现线程安全：<ul><li>在添加、获取元素时，使用<code>getArray()</code>获取底层数组对象，获取此时集合中的数组对象；使用<code>setArray()</code>设置底层数组，将原有数组对象指针指向新的数组对象—-实以此来实现<code>CopyOnWrite</code>副本概念</li><li><strong>添加元素</strong>: 在添加元素之前进行加锁操作，保证数据的原子性。在添加过程中，进行数组复制，修改操作，再将新生成的数组复制给集合中的<code>array</code>属性。最后，释放锁；<ul><li>由于<code>array</code>属性被<code>volatile</code>修饰，所以当添加完成后，其他线程就可以立刻查看到被修改的内容。</li></ul></li><li><strong>获取元素</strong>：在获取元素时，由于<code>array</code>属性被<code>volatile</code>修饰，所以每当获取线程执行时，都会拿到最新的数据。此外，添加线程在进行添加元素时，会将新的数组赋值给<code>array</code>属性，所以在获取线程中并不会因为元素的添加而导致本线程的执行异常。因为获取线程中的<code>array</code>和被添加后的<code>array</code>指向了不同的内存区域。</li></ul></li></ul><blockquote><p>在执行<code>add()</code>时，为什么还要在加锁的同时又copy了一分新的数组对象?</p><ul><li>因为，在<code>add()</code>时候加了锁，首先不会有多个线程同时进到<code>add</code>中去，这一点保证了数组的安全。当在一个线程执行<code>add</code>时，又进行了数组的复制操作，生成了一个新的数组对象，在<code>add</code>后又将新数组对象的指针指向了旧的数组对象指针，注意此时是指针的替换，原来旧的数组对象还存在。这样就实现了，添加方法无论如何操作数组对象，获取方法在获取到集合后，都不会受到其他线程添加元素的影响。</li></ul></blockquote><ul><li><code>CopyOnWrite</code>机制的优缺点<ul><li>优点: <code>CopyOnWriteArrayList</code>保证了数据在多线程操作时的<strong>最终一致性</strong>。</li><li>缺点: 缺点也同样显著，那就是内存空间的浪费：因为在写操作时，进行数组复制，在内存中产生了两份相同的数组。如果数组对象比较大，那么就会造成频繁的GC操作，进而影响到系统的性能；</li></ul></li></ul><blockquote><p>适用场景：<strong>读多写少</strong>的并发场景</p></blockquote><h3 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3. ConcurrentHashMap"></a>3. ConcurrentHashMap</h3><p><code>ConcurrentHashMap</code>容器相较于CopyOnWrite容器在并发加锁粒度上有了更大一步的优化，它通过修改对<strong>单个hash桶元素加锁</strong>的达到了更细粒度的并发控制。</p><ul><li>在底层数据结构上，<code>ConcurrentHashMap</code>和<code>HashMap</code>都使用了数组+链表+红黑树的方式，只是在HashMap的基础上添加了并发相关的一些控制。</li><li>JDK1.8中<strong>取消</strong>了segment分段锁，而采用<code>CAS和synchronized</code>来保证并发安全。<code>synchronized</code>只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。并且初始化操作大大简化，修改为<code>lazy-load</code>形式。</li></ul><h4 id="3-1-put方法过程"><a href="#3-1-put方法过程" class="headerlink" title="3.1 put方法过程"></a>3.1 put方法过程</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>判断键值是否为<code>null</code>，为null抛出异常</li><li>调用<code>spread()</code>方法计算key的<code>hashCode()</code>获得哈希地址</li><li>判断<code>Node[]</code>数组(<code>table</code>)是否为空，若空则进行初始化操作<ul><li>需要注意的是这里并没有加<code>synchronized</code>，也就是允许多个线程去**<code>尝试</code>**初始化<code>table</code>，但是在初始化函数里面使用了<code>CAS</code>保证只有一个线程去执行初始化过程</li></ul></li><li>使用<code>(容量大小-1 &amp; 哈希地址)</code>计算下标，如果没有碰撞，使用<code>CAS</code>原子性操作放入桶中；插入失败(被别的线程抢先插入了)则进入下次循环。</li><li>如果该下标上的节点(头节点)的哈希地址为<code>-1</code>，代表需要扩容，该线程执行<code>helpTransfer()</code>方法协助扩容。</li><li>如果碰撞了(<code>bucket</code>不为空)且又不需要扩容，则进入到<code>bucket</code>中，且锁住该<code>bucket</code>，其他<code>bucket</code>不影响。</li><li>进入到<code>bucket</code>里面，首先判断这个<code>bucket</code>存储的是红黑树(哈希地址小于0)还是链表。</li><li>如果是链表，则遍历链表，若节点已经存在(<code>key</code>相同)就覆盖旧值，没有找到相同的节点就将新增的节点插入到链表尾部。如果是红黑树，则将节点插入。到这里释放锁。</li><li>判断该<code>bucket</code>上的链表长度是否链表长度超过阀值<code>（TREEIFY_THRESHOLD==8）</code>，大于则调用<code>treeifyBin()</code>方法将链表转成红黑树。</li><li>调用<code>addCount()</code>方法，作用是将<code>ConcurrentHashMap</code>的键值对数量+1，还有另一个作用是检查<code>ConcurrentHashMap</code>是否需要扩容。</li></ol><blockquote><p>总结：</p></blockquote><ul><li>JDK8中的实现也是锁分离的思想，它把锁分的比<code>segment（JDK1.5）</code>更细一些，只要hash不冲突，就不会出现并发获得锁的情况。它首先使用无锁操作<code>CAS</code>插入头结点，如果插入失败，说明已经有别的线程插入头结点了，再次循环进行操作。如果头结点已经存在，则通过<code>synchronized</code>获得头结点锁，进行后续的操作。<strong>性能比segment分段锁又再次提升</strong>。</li></ul><h4 id="3-2-ConcurrentHashMap多线程环境下扩容"><a href="#3-2-ConcurrentHashMap多线程环境下扩容" class="headerlink" title="3.2 ConcurrentHashMap多线程环境下扩容"></a>3.2 ConcurrentHashMap多线程环境下扩容</h4><ul><li><code>transfer()</code>方法为<code>ConcurrentHashMap</code>扩容操作的核心方法。由于<code>ConcurrentHashMap</code>支持<strong>多线程扩容</strong>，而且也<strong>没有进行加锁</strong>，所以实现会变得有点儿复杂。整个扩容操作分为两步：<ul><li>构建一个<code>nextTable</code>，其大小为原来大小的两倍，这个步骤是在单线程环境下完成的</li><li>将原来<code>table</code>里面的内容复制到<code>nextTable</code>中，这个步骤是允许多线程操作的，所以性能得到提升，减少了扩容的时间消耗。</li></ul></li><li>扩容的时机：<ol><li>如果新增节点之后，所在链表的元素个数达到了阈值 8，则会调用treeifyBin方法把链表转换成红黑树，不过在结构转换之前，会对数组长度进行判断：<ul><li>如果数组长度n小于阈值<code>MIN_TREEIFY_CAPACITY</code>，默认是64，则会调用<code>tryPresize</code>方法把数组长度扩大到原来的两倍，并触发<code>transfer</code>方法，重新调整节点的位置。</li></ul></li><li>新增节点之后，会调用<code>addCount</code>方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发<code>transfer</code>方法，重新调整节点的位置。</li></ol></li><li>JDK8的源码里面就引入了一个**<code>ForwardingNode</code>**类，在一个线程发起扩容的时候，就会改变<code>sizeCtl</code>这个值，其含义如下： <ul><li><code>sizeCtl</code> ：默认为0，用来控制<code>table</code>的初始化和扩容操作，具体应用在后续会体现出来。</li><li><code>-1</code> 代表<code>table</code>正在初始化</li><li><code>-N</code> 表示有<code>N-1</code>个线程正在进行扩容操作</li><li>其余情况：  <ol><li>如果<code>table</code>未初始化，表示<code>table</code>需要初始化的大小。  </li><li>如果<code>table</code>初始化完成，表示<code>table</code>的容量，默认是<code>table</code>大小的<code>0.75</code>倍</li></ol></li></ul></li><li>扩容时候会判断<code>sizeCtl</code>的值，如果超过阈值就要扩容，首先根据运算得到需要遍历的次数i，然后利用<code>tabAt</code>方法获得i位置的元素f，初始化一个<code>forwardNode</code>实例<code>fwd</code>，如果<code>f == null</code>，则在<code>table</code>中的i位置放入<code>fwd</code>，否则采用头插法的方式把当前旧<code>table</code>数组的指定任务范围的数据给迁移到新的数组中，然后给旧<code>table</code>原位置赋值<code>fwd</code>。直到遍历过所有的节点以后就完成了复制工作，把<code>table</code>指向<code>nextTable</code>，并更新<code>sizeCtl</code>为新数组大小的<code>0.75</code>倍 ，扩容完成。在此期间如果其他线程的有读写操作都会判断<code>head</code>节点是否为<code>forwardNode</code>节点，如果是就<strong>帮助扩容</strong>。</li><li>在<strong>扩容时读写操作</strong>如何进行<ol><li>对于<code>get</code>读操作，如果当前节点有数据，还没迁移完成，此时不影响读，能够正常进行。如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时<code>get</code>线程会帮助扩容。</li><li>对于<code>put</code>&#x2F;<code>remove</code>写操作，如果当前链表已经迁移完成，那么头节点会被设置成<code>fwd</code>节点，此时写线程会帮助扩容，如果扩容没有完成，当前链表的头节点会被锁住，所以写线程会被阻塞，直到扩容完成。</li></ol></li></ul><blockquote><p>总结: <code>ConcurrentHashMap</code>扩容的原理是新生成原来<code>2倍</code>的数组，然后拷贝旧数组数据到新的数组里面，在多线程情况下，这里面如果注意线程安全问题，在解决安全问题的同时，我们也要关注其效率，这才是并发容器类的最出色的地方。 </p></blockquote><h4 id="3-3-size、mappingCount方法"><a href="#3-3-size、mappingCount方法" class="headerlink" title="3.3 size、mappingCount方法"></a>3.3 size、mappingCount方法</h4><ul><li><code>size</code>和<code>mappingCount</code>方法都是用来统计table的<code>size</code>的</li><li>这两者不同的地方在<code>size</code>返回的是一个<code>int类型</code>，即可以表示<code>size</code>的范围是<code>[-2^31，2^31-1]</code>，超过这个范围就返回int能表示的最大值</li><li><code>mappingCount</code>返回的是一个<code>long类型</code>，即可以表示<code>size</code>的范围是<code>[-2^63，2^63-1]</code>。</li><li>这两个方法都是调用的<code>sumCount()</code>方法实现统计。</li><li><strong>对于<code>size</code>和迭代器是弱一致性</strong><ul><li><code>volatile</code>修饰的数组引用是强可见的，但是其元素却不一定，所以，这导致<code>size</code>的根据<code>sumCount</code>的方法<strong>并不准确</strong>。</li><li>同理<code>Iteritor</code>的迭代器也一样，并不能准确反映最新的实际情况</li></ul></li></ul><h3 id="4-ConcurrentSkipListMap"><a href="#4-ConcurrentSkipListMap" class="headerlink" title="4. ConcurrentSkipListMap"></a>4. ConcurrentSkipListMap</h3><p><code>ConcurrentSkipListMap</code>内部使用<strong>跳表（<code>SkipList</code>）</strong>这种数据结构来实现，他的结构相对红黑树来说非常简单理解，实现起来也相对简单，而且在理论上它的查找、插入、删除时间复杂度都为<code>log(n)</code>。在并发上，<code>ConcurrentSkipListMap</code>采用无锁的**<code>CAS+自旋</code>**来控制。</p><ul><li>跳表简单来说就是一个多层的链表，底层是一个普通的链表，然后逐层减少，通常通过一个简单的算法实现每一层元素是下一层的元素的二分之一，这样当搜索元素时从最顶层开始搜索，可以说是另一种形式的二分查找。</li><li><code>ConcurrentSkipListMap</code>的**<code>put</code>**(插入)：<ul><li>调用<code>doPut()</code>方法，可以分为3大步来理解：</li><li>第一步获取前继节点后通过<code>CAS</code>来插入节点；</li><li>第二步对<code>level</code>层数进行判断，如果大于最大层数，则插入一层；</li><li>第三步插入对应层的数据。整个插入过程全部通过<code>CAS</code>自旋的方式保证并发情况下的数据正确性。</li></ul></li></ul><h3 id="5-volatile-amp-Atmoic-amp-UnSafe"><a href="#5-volatile-amp-Atmoic-amp-UnSafe" class="headerlink" title="5. volatile &amp; Atmoic &amp; UnSafe"></a>5. volatile &amp; Atmoic &amp; UnSafe</h3><ul><li>**<code>volatile</code>**作用：①多线程间的可见性、②阻止指令重排序</li><li>**<code>Atmoic系列类</code>**提供了原子性操作，保障多线程下的安全</li><li>**<code>UnSafe类</code>**的作用：①内存操作、②字段的定位与修改(底层)、③线程挂起与恢复、④<code>CAS</code>操作(乐观锁)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「深入JVM」内存模型JMM 与 锁机制</title>
      <link href="/2019/08/27/jvm-jmm.html"/>
      <url>/2019/08/27/jvm-jmm.html</url>
      
        <content type="html"><![CDATA[<h3 id="Java-内存模型-Java-Memory-Model"><a href="#Java-内存模型-Java-Memory-Model" class="headerlink" title="Java 内存模型(Java Memory Model)"></a>Java 内存模型(Java Memory Model)</h3><p>Java Memory Model(JMM)描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量存储到内存中和从内存中读取变量这样的底层细节(可见性,有序性,原子性)。</p><ul><li>所有的变量都存储在主内存中</li><li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li><li>JMM 规定： + 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。 + 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。<span id="more"></span></li></ul><p><img src="/2019/08/27/jvm-jmm/JMM.png"></p><h3 id="1-JMM-同步八种操作"><a href="#1-JMM-同步八种操作" class="headerlink" title="1. JMM-同步八种操作"></a>1. JMM-同步八种操作</h3><p>JMM 模型下,线程间通信必须要经过主内存。<br>JMM 数据原子操作:<code>lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock</code></p><ol><li><strong>lock</strong>（锁定）：将<strong>主内存</strong>变量加锁，标识为线程独占状态</li><li><strong>read</strong>（读取）：从<strong>主内存</strong>读取数据到工作内存</li><li><strong>load</strong>（载入）：将读取的数据写入<strong>工作内存</strong></li><li><strong>use</strong>（使用）：将<strong>工作内存</strong>数据传递给执行引擎来计算</li><li><strong>assign</strong>（赋值）：将计算好的值赋值给<strong>工作内存</strong>的变量</li><li><strong>store</strong>（存储）：把<strong>工作内存</strong>数据存储到主内存</li><li><strong>write</strong>（写入）：把 store 过来的变量值赋值给<strong>主内存</strong>的变量</li><li><strong>unlock</strong>（解锁）：将<strong>主内存</strong>变量解锁，释放后的变量才可以被其他线程锁定。</li></ol><p>在执行上述八种基本操作时，必须满足如下规则：</p><ol><li>从主复制到工作,必须按顺序执行<code>read-&gt;load</code>操作; 从工作同步到主内存,必须按顺序执行<code>store-&gt;write</code>操作; 但不保证必须是连续执行</li><li>不允许<code>read-&gt;load</code>、<code>store-&gt;write</code>操作之一单独出现</li><li>assign 操作改变数据后必须同步到主内存,不允许把没有发生过 assign 操作的数据同步到主内存</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量</li><li>一个变量在同一时刻只允许一条线程对其进行 lock 操作,lock 和 unlock 必须成对出现</li><li>lock 操作会清空工作内存中此变量的值，执行引擎使用前需要重新执行 load 或 assign 操作初始化变量的值</li><li>不允许去 unlock 一个未被锁定 或 被其他线程锁定的变量</li><li>unlock 之前，必须先同步到主内存中（执行 store 和 write 操作）</li></ol><h3 id="2-JMM-原子性"><a href="#2-JMM-原子性" class="headerlink" title="2. JMM-原子性"></a>2. JMM-原子性</h3><p>和数据库事务中的原子性一样，满足原子性特性的操作是不可中断的，要么全部执行成功要么全部执行失败。<br>Synchronized 能够实现：<strong>原子性</strong>(同步) 和 可见性</p><ul><li>JMM 关于 synchronized 的两条规定：<ol><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ol></li><li>线程执行互斥代码的过程：<ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol></li></ul><h3 id="2-JMM-可见性"><a href="#2-JMM-可见性" class="headerlink" title="2. JMM-可见性"></a>2. JMM-可见性</h3><p>多个线程访问同一个共享变量时，其中一个线程对这个共享变量值的修改，其他线程能够立刻获得修改以后的值。<br>volatile 能够实现<strong>可见性</strong>，但不保证原子性</p><ul><li><p>深入来说：通过加入内存屏障和禁止重排序优化来实现的。</p><ul><li>对 volatile 变量执行写操作时，会在写操作后加入一条 store 屏蔽指令</li><li>对 volatile 变量执行读操作时，会在读操作前加入一条 load 屏蔽指令</li></ul></li><li><p>通俗地讲：volatile 变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</p></li><li><p>线程写 volatile 变量的过程：</p><ol><li>改变线程工作内存中 volatile 变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol></li><li><p>线程读 volatile 变量的过程：</p><ol><li>从主内存中读取 volatile 变量的最新值到线程的工作内存中</li><li>从工作内存中读取 volatile 变量的副本</li></ol></li></ul><h4 id="2-1-happens-before-规则"><a href="#2-1-happens-before-规则" class="headerlink" title="2.1 happens-before 规则"></a>2.1 happens-before 规则</h4><p>在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这 2 个操作之间必须要存在 happens-before 关系。</p><ul><li>定义: 如果一个操作在另一个操作之前发生(happens-before),那么第一个操作的执行结果将对第二个操作可见, 而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在 happens-before 关系，并不意味着一定要按照 happens-before 原则制定的顺序来执行。如果重排序之后的执行结果与按照 happens-before 关系来执行的结果一致，那么这种重排序并不非法。</li></ul><ul><li>happens-before 规则：<ol><li>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！</li><li>锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；论是单线程还是多线程，必须要先释放锁，然后其他线程才能进行 lock 操作</li><li>volatile 变量规则：就是如果一个线程先去写一个 volatile 变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。</li><li>传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C</li><li>线程启动规则：在主线程 A 执行过程中，启动子线程 B，那么线程 A 在启动子线程 B 之前对共享变量的修改结果对线程 B 可见</li><li>线程终止规则：在主线程 A 执行过程中，子线程 B 终止，那么线程 B 在终止之前对共享变量的修改结果在线程 A 中可见。</li><li>线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过 Thread.interrupted()检测到是否发生中断</li><li>对象终结规则：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before 它的 finalize()方法。</li></ol></li></ul><h3 id="3-JMM-有序性"><a href="#3-JMM-有序性" class="headerlink" title="3. JMM-有序性"></a>3. JMM-有序性</h3><p>编译器和处理器为了优化程序性能而对指令序列进行重排序，也就是你编写的代码顺序和最终执行的指令顺序是不一致的，重排序可能会导致多线程程序出现内存可见性问题。</p><ul><li>我们编写的源代码到最终执行的指令，会经过三种重排序:<ul><li>源代码–&gt;<strong>编译器优化重排序</strong>–&gt;<strong>指令级并行重排序</strong>–&gt;<strong>内存系统重排序</strong>–&gt;最终执行的指令</li></ul></li></ul><h4 id="3-1-as-if-serial-语义"><a href="#3-1-as-if-serial-语义" class="headerlink" title="3.1 as-if-serial 语义"></a>3.1 as-if-serial 语义</h4><p>as-if-serial 语义：不管怎么重排序(编译器和处理器为了提高并行度做的优化),(单线程)程序的执行结果不会改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。<br>多线程中程序交错执行时, 重排序可能造成内存可见性问题, 可能会改变程序的执行结果。</p><ul><li><p>有序性规则表现在以下两种场景: 线程内和线程间</p><ol><li>线程内: 指令会按照一种“串行”(as-if-serial)的方式执行，此种方式已经应用于顺序编程语言。</li><li>线程间: 一个线程“观察”到其他线程并发地执行非同步的代码时，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块以及 volatile 字段的操作仍维持相对有序。</li></ol></li><li><p>As-if-serial 只是保障单线程不会出问题，所以有序性保障，可以理解为把 As-if-serial 扩展到多线程，那么在多线程中也不会出现问题</p><ul><li>从底层的角度来看，是借助于处理器提供的相关指令内存屏障来实现的</li><li>对于 Java 语言本身来说，Java 已经帮我们与底层打交道，我们不会直接接触内存屏障指令，java 提供的关键字 synchronized 和 volatile，可以达到这个效果，保障有序性（借助于显式锁 Lock 也是一样的，Lock 逻辑与 synchronized 一致）</li></ul></li></ul><h4 id="3-2-著名的双检锁-double-checked-locking-模式实现单例"><a href="#3-2-著名的双检锁-double-checked-locking-模式实现单例" class="headerlink" title="3.2 著名的双检锁(double-checked locking)模式实现单例"></a>3.2 著名的双检锁(double-checked locking)模式实现单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile保证happens-before规则,重排序被禁止</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例没创建,才进入内部的synchronized代码块</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 判断其他线程是否已经创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == INSTANCE) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不用 volatile 修饰 INSTANCE,可能造成访问的是一个初始化未完成的对象; 使用了 volatile 关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p></blockquote><h3 id="4-锁机制"><a href="#4-锁机制" class="headerlink" title="4. 锁机制"></a>4. 锁机制</h3><ul><li>锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是<strong>锁的升级是单向的</strong>，也就是说只能从低到高升级，不会出现锁的降级）。</li><li>锁的状态是通过对象监视器在<strong>对象头</strong>中的字段来表明的。 四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。 这四种状态都不是 Java 语言中的锁，而是 Jvm 为了提高锁的获取与释放效率而做的优化(<strong>使用 synchronized 时</strong>)。</li></ul><h4 id="4-1-对象头-Mark"><a href="#4-1-对象头-Mark" class="headerlink" title="4.1 对象头 Mark"></a>4.1 对象头 Mark</h4><ul><li>Mark Word,对象头的标记,32 位: 描述对象的 hash,锁信息,垃圾回收标记,分代年龄<ul><li>指向锁记录的指针</li><li>指向 monitor 的指针</li><li>GC 标记</li><li>偏向锁线程 ID</li></ul></li></ul><h4 id="4-2-偏向锁"><a href="#4-2-偏向锁" class="headerlink" title="4.2 偏向锁"></a>4.2 偏向锁</h4><p>Java 偏向锁(Biased Locking)是 Java6 引入的一项多线程优化</p><ul><li>大部分情况锁是没有竞争的,所以可以通过偏向锁来提高性能;</li><li>所谓偏向,就是偏心,即锁会偏向于当前已经占有锁的线程,总是由同一线程多次获得;</li><li>会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID</li><li>只要没有竞争,获得偏向锁的线程,在将来进入同步块,不需要做同步</li><li>当其他线程请求相同的锁时,偏向模式结束</li><li>-XX:+UseBiasedLocking(默认开启)</li><li>在竞争激烈的场合,偏向锁会增加系统负担</li></ul><h4 id="4-3-轻量级锁"><a href="#4-3-轻量级锁" class="headerlink" title="4.3 轻量级锁"></a>4.3 轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><ul><li>普通的锁处理性能不够理想,轻量级锁是一种快速的锁定方法.</li><li>过程: 如果对象没有被锁定:<ol><li>将对象头的 Mark 指针保存到锁对象中</li><li>将对象头设置为指向锁的指针(在线程栈空间中)</li></ol></li><li>如果轻量级锁失败,表示存在竞争,升级为重量级锁(常规锁)</li><li>在没有锁竞争的情况下,减少传统锁使用 OS 互斥量产生的性能损耗</li><li>在竞争激烈的场合,轻量级锁会多做很多额外操作,导致性能下降</li></ul><h4 id="4-4-自旋锁"><a href="#4-4-自旋锁" class="headerlink" title="4.4 自旋锁"></a>4.4 自旋锁</h4><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗 CPU。</p><ul><li>当竞争存在时,如果线程可以很快获得锁,那么可以不在 OS 层挂起线程,让线程做几个空操作(自旋)</li><li>如果同步块很长,自旋失败,会降低系统性能</li><li>如果同步块很短,自旋成功,节省线程挂起切换时间,提升系统性能</li></ul><h4 id="4-5-重量级锁"><a href="#4-5-重量级锁" class="headerlink" title="4.5 重量级锁"></a>4.5 重量级锁</h4><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h4 id="4-6-synchronized-的执行过程："><a href="#4-6-synchronized-的执行过程：" class="headerlink" title="4.6 synchronized 的执行过程："></a>4.6 synchronized 的执行过程：</h4><ol><li>检测 Mark Word 里面是不是当前线程的 ID，如果是，表示当前线程处于偏向锁</li><li>如果不是，则使用 CAS 将当前线程的 ID 替换 Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位 1</li><li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li><li>当前线程使用 CAS 将对象头的 Mark Word 替换为锁记录指针，如果成功，当前线程获得锁</li><li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li><li>如果自旋成功则依然处于轻量级状态。</li><li>如果自旋失败，则升级为重量级锁。</li></ol><blockquote><p>以上几种锁都是 JVM 自己内部实现，当我们执行 synchronized 同步块的时候 jvm 会根据启用的锁和当前线程的争用情况，决定如何执行同步操作；</p></blockquote><h3 id="5-Java-语言层面对锁的优化"><a href="#5-Java-语言层面对锁的优化" class="headerlink" title="5. Java 语言层面对锁的优化"></a>5. Java 语言层面对锁的优化</h3><ol><li><strong>减少锁持有时间</strong><ul><li>不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</li></ul></li><li><strong>减少锁的粒度</strong><ul><li>它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；</li><li>java 中很多数据结构都是采用这种方法提高并发操作的效率：<ul><li>ConcurrentHashMap: 使用 Segment 数组,Segment 继承自 ReenTrantLock，所以每个 Segment 就是个可重入锁，每个 Segment 有一个 HashEntry&lt; K,V &gt;数组用来存放数据，put 操作时，先确定往哪个 Segment 放数据，只需要锁定这个 Segment，执行 put，其它的 Segment 不会被锁定；所以数组中有多少个 Segment 就允许同一时刻多少个线程存放数据，这样增加了并发能力。</li><li>LongAdder:实现思路也类似 ConcurrentHashMap，LongAdder 有一个根据当前并发状况动态改变的 Cell 数组，Cell 对象里面有一个 long 类型的 value 用来存储值;开始没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 cas 来将值累加到成员变量的 base 上，在并发争用的情况下，LongAdder 会初始化 cells 数组，在 Cell 数组中选定一个 Cell 加锁，数组有多少个 cell，就允许同时有多少线程进行修改，最后将数组中每个 Cell 中的 value 相加，在加上 base 的值，就是最终的值；cell 数组还能根据当前线程争用情况进行扩容，初始长度为 2，每次扩容会增长一倍，直到扩容到大于等于 cpu 数量就不再扩容，这也就是为什么 LongAdder 比 cas 和 AtomicInteger 效率要高的原因，后面两者都是 volatile+cas 实现的，他们的竞争维度是 1，LongAdder 的竞争维度为“Cell 个数+1”为什么要+1？因为它还有一个 base，如果竞争不到锁还会尝试将数值加到 base 上；</li></ul></li><li>拆锁的粒度不能无限拆，最多可以将一个锁拆为当前 CPU 数量即可；</li></ul></li><li><strong>锁粗化</strong><ul><li>大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度(如:循环内的操作);</li></ul></li><li><strong>锁分离</strong><ul><li>使用读写锁: ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写；</li><li>读写分离: CopyOnWriteArrayList 、CopyOnWriteArraySet<ul><li>CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器</li><li>CopyOnWrite 并发容器用于读多写少的并发场景，因为，读的时候没有锁，但是对其进行更改的时候是会加锁的，否则会导致多个线程同时复制出多个副本，各自修改各自的；</li></ul></li><li>LinkedBlockingQueue: LinkedBlockingQueue 也体现了这样的思想，在队列头入队，在队列尾出队，入队和出队使用不同的锁，相对于 LinkedBlockingArray 只有一个锁效率要高；</li></ul></li><li><strong>锁消除</strong><ul><li>在即时编译时,如果发现不可能被共享的对象,则可以消除对象的锁操作</li></ul></li><li><strong>无锁</strong>(如 CAS)<ul><li>如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用 CAS 效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用 volatiled+CAS 操作会是非常高效的选择；</li></ul></li><li>消除缓存行的伪共享<ul><li>除了我们在代码中使用的同步锁和 jvm 自己内置的同步锁外，还有一种隐藏的锁就是缓存行，它也被称为性能杀手。在多核 cup 的处理器中，每个 cup 都有自己独占的一级缓存、二级缓存，甚至还有一个共享的三级缓存，为了提高性能，cpu 读写数据是以缓存行为最小单元读写的；32 位的 cpu 缓存行为 32 字节，64 位 cup 的缓存行为 64 字节，这就导致了一些问题。</li></ul></li></ol><h3 id="6-CAS-与原子类"><a href="#6-CAS-与原子类" class="headerlink" title="6. CAS 与原子类"></a>6. CAS 与原子类</h3><p>CAS 即<code>Compare and Swap</code>翻译过来就是比较并替换, 它体现了一种乐观锁的思想 (synchronized 为悲观锁思想);</p><ul><li>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>(非阻塞同步),适用于竞争不激烈,多核 CPU 的场景下(竞争激烈,重试频繁发生会影响效率);</li><li>CAS 算法涉及到三个操作数: 内存值 V, 旧值 A, 新值 B; 当且仅当 V&#x3D;&#x3D;A 时，CAS 用新值 B 来更新 V，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li><li>CAS 底层依赖一个 Unsafe 类来直接调用操作系统底层的 CAS 指令;</li></ul><h4 id="6-1-Unsafe-类"><a href="#6-1-Unsafe-类" class="headerlink" title="6.1 Unsafe 类"></a>6.1 Unsafe 类</h4><p>java 中 CAS 操作依赖于 Unsafe 类，Unsafe 类所有方法都是 native 的，直接调用操作系统底层资源执行相应任务，它可以像 C 一样操作内存指针，是非线程安全的。</p><ul><li>Unsafe 里的 CAS 操作相关实现: compareAndSwapObject,compareAndSwapInt,compareAndSwapLong</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，</span></span><br><span class="line"><span class="comment">//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,Object expected, Object x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">long</span> expected,<span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure><h4 id="6-2-原子操作类"><a href="#6-2-原子操作类" class="headerlink" title="6.2 原子操作类"></a>6.2 原子操作类</h4><p>并发包 JUC(java.util.concurrent)中的原子操作类(Atomic 系列),底层是基于<code>CAS + volatile</code>实现的.</p><ul><li>AtomicBoolean：原子更新布尔类型</li><li>AtomicInteger：原子更新整型</li><li>AtomicLong：原子更新长整型</li></ul><p>下面看 AtomicInteger 类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable&#123;</span><br><span class="line">    <span class="comment">//获取指针类Unsafe</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="comment">//省略...获取内存偏移量等</span></span><br><span class="line">    <span class="comment">//如果当前值为expect，则设置为update(当前值指的是value变量)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前值加1返回旧值，底层CAS操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicInteger 基本是基于 Unsafe 类中 CAS 相关操作实现的，是无锁操作。<br>再看 Unsafe 类中的 getAndAddInt()方法，该方法执行一个 CAS 操作，保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unsafe类中的getAndAddInt方法(JDK8)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出 getAndAddInt 通过一个 while 循环不断的重试更新要设置的值，直到成功为止，调用的是 Unsafe 类中的 compareAndSwapInt 方法，是一个 CAS 操作方法。</p><h4 id="6-3-CAS-操作中可能会带来的-ABA-问题"><a href="#6-3-CAS-操作中可能会带来的-ABA-问题" class="headerlink" title="6.3 CAS 操作中可能会带来的 ABA 问题"></a>6.3 CAS 操作中可能会带来的 ABA 问题</h4><p>ABA 问题是指在 CAS 操作时，其他线程将变量值 A 改为了 B，但是又被改回了 A，等到本线程使用期望值 A 与当前变量进行比较时，发现变量 A 没有变，于是 CAS 就将 A 值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。</p><ul><li><strong>无法正确判断这个变量是否已被修改过</strong>，一般称这种情况为 ABA 问题。</li><li>ABA 问题一般不会有太大影响，产生几率也比较小。但是并不排除极特殊场景下会造成影响，因此需要解决方法：<ul><li>AtomicStampedReference 类</li><li>AtomicMarkableReference 类</li></ul></li><li><strong>AtomicStampedReference 类</strong>: 一个带有时间戳的对象引用，每次修改时，不但会设置新的值，还会记录修改时间。在下一次更新时，不但会对比当前值和期望值，还会对比当前时间和期望值对应的修改时间，只有二者都相同，才会做出更新。解决了反复读写时，无法预知值是否已被修改的窘境。<ul><li>底层实现为：一个键值对 Pair 存储数据和时间戳，并构造 volatile 修饰的私有实例；两者都符合预期才会调用 Unsafe 的 compareAndSwapObject 方法执行数值和时间戳替换。</li></ul></li><li>AtomicMarkableReference 类: 一个 boolean 值的标识，true 和 false 两种切换状态表示是否被修改。不靠谱。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「深入JVM」 类文件结构 与 类加载机制</title>
      <link href="/2019/08/25/jvm-class.html"/>
      <url>/2019/08/25/jvm-class.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1. 类文件结构"></a>1. 类文件结构</h3><p>Class 文件是一组以 <strong>8 位字节</strong>为基础单位的二进制流，各个数据<strong>严格按照顺序紧凑的排列</strong>在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。<br>Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的伪结构体来存储数据，这种伪结构体中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。<span id="more"></span></p><ul><li><strong>无符号数</strong>：属于基本数据类型，以 u1、u2、u4、u8 来代表 1 个字节、2 个字节、4 个字节、8 个字节的无符号数， 无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。</li><li><strong>表</strong>：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以「_info」结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件就是一张表。</li></ul><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                <span class="comment">//Class文件的标志(魔数)</span></span><br><span class="line">    u2             minor_version;        <span class="comment">//Class的小版本号</span></span><br><span class="line">    u2             major_version;        <span class="comment">//Class的大版本号</span></span><br><span class="line">    u2             constant_pool_count;  <span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;         <span class="comment">//Class的访问标记</span></span><br><span class="line">    u2             this_class;           <span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;          <span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;     <span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;          <span class="comment">//Class文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];  <span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;         <span class="comment">//Class文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;      <span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/25/jvm-class/JVM-class.png"></p><h4 id="1-1-魔数-Magic-Number"><a href="#1-1-魔数-Magic-Number" class="headerlink" title="1.1 魔数 (Magic Number)"></a>1.1 魔数 (Magic Number)</h4><ul><li>Class 文件的<strong>0~3 字节</strong>(前四个字节: ca fe ba be)</li><li>作用: 确定这个文件是否为一个能被虚拟机接收的 Class 文件</li></ul><h4 id="1-2-Class-文件版本"><a href="#1-2-Class-文件版本" class="headerlink" title="1.2 Class 文件版本"></a>1.2 Class 文件版本</h4><ul><li><strong>4~7 字节</strong>, 其中 4<del>5 次版本号,6</del>7 主版本号(如 jdk8 主版本号是: 00 34)</li></ul><h4 id="1-3-常量池"><a href="#1-3-常量池" class="headerlink" title="1.3 常量池"></a>1.3 常量池</h4><ul><li><strong>8~9 字节</strong>表示 16 进制常量池数量,其后紧跟具体常量池, 常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）</li><li>常量池主要存放两大常量: <strong>字面量</strong>和<strong>符号引用</strong><ul><li>字面量: Java 语言层面的常量概念(String,final 等)</li><li>符号引用: 编译原理方面的概念(类和接口的全限定名\字段的名称和描述符\方法的名称和描述符)</li></ul></li><li>常量池中每一项常量都是一个表，这<strong>14 种表</strong>有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型</strong></li><li>.class 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)</li></ul><h4 id="1-4-类的访问标志与继承信息"><a href="#1-4-类的访问标志与继承信息" class="headerlink" title="1.4 类的访问标志与继承信息"></a>1.4 类的访问标志与继承信息</h4><ul><li>在常量池结束之后，紧接着的<strong>两个字节</strong>代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等.</li><li>access_flags 中一共有 16 个标志位可以使用，当前只定义了其中的 8 个，没有使用到的标志位要求一律为 0。</li></ul><h4 id="1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces"><a href="#1-5-当前类索引-this-父类索引-super-与接口索引集合-interfaces" class="headerlink" title="1.5 当前类索引(this),父类索引(super)与接口索引集合(interfaces)"></a>1.5 当前类索引(<code>this</code>),父类索引(<code>super</code>)与接口索引集合(<code>interfaces</code>)</h4><ul><li>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</li><li>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 implents(如果这个类本身是接口的话则是 extends) 后的接口顺序从左到右排列在接口索引集合中。</li></ul><h4 id="1-6-成员变量信息-Feild"><a href="#1-6-成员变量信息-Feild" class="headerlink" title="1.6 成员变量信息(Feild)"></a>1.6 成员变量信息(Feild)</h4><ul><li>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</li><li>字段信息包括：字段的作用域（public、private、protected 修饰符）、是实例变量还是类变量（static 修饰符）、可变性（final）、并发可见性（volatile 修饰符，是否强制从主内存读写）、可否被序列化（transient 修饰符）、字段数据类型（基本类型、对象、数组）、字段名称，以上修饰符都是布尔类型。</li><li>方法和字段的描述符作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</li><li>根描述规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，对象类型使用字符 L 加对象的全限定名来表示。<ul><li>B: 基本类型 byte</li><li>C: 基本类型 char</li><li>D: 基本类型 double</li><li>F: 基本类型 float</li><li>I: 基本类型</li><li>J: 基本类型 long</li><li>S: 基本类型 short</li><li>Z: 基本类型 boolean</li><li>V: 特殊类型 void</li><li>L: 对象类型，如 Ljava&#x2F;lang&#x2F;Object</li></ul></li></ul><h4 id="1-7-方法信息-Method"><a href="#1-7-方法信息-Method" class="headerlink" title="1.7 方法信息(Method)"></a>1.7 方法信息(Method)</h4><ul><li><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</li><li>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</li></ul><h4 id="1-8-附加属性信息"><a href="#1-8-附加属性信息" class="headerlink" title="1.8 附加属性信息"></a>1.8 附加属性信息</h4><ul><li><code>attributes_count</code>表示属性表中的属性个数, <code>attribute_info</code> 表示属性表</li><li>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</li></ul><h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2. 字节码指令"></a>2. 字节码指令</h3><p>Java 字节码指令就是 Java 虚拟机能够识别、可执行的指令，可以说是 Jvm 的最小执行单元。javac 命令会将 Java 源文件编译成字节码文件，即.class 文件，其中就包含了大量的字节码指令，javap 命令可以解析字节码(.class 文件)，将字节码内部逻辑以可读的方式呈现出来 (<code>javap -v -p HelloWorld</code>)。</p><ul><li>按指令的功能分为如下几类：<ol><li><strong>存储和加载类指令</strong>：主要包括 load 系列(将一个局部变量加载到操作数栈)、store 系列(将一个数值从操作数栈存储到局部变量表)和 ldc&#x2F;push&#x2F;const 系列(将一个常量加载到操作数栈)，主要用于在<strong>局部变量表</strong>、<strong>操作数栈</strong>和<strong>常量池</strong>三者之间进行<strong>数据调度</strong>；<ul><li>例如: <code>iload_0</code>表示从当前栈帧局部变量表中 0 号位置取 int 类型的数值加载到操作数栈</li></ul></li><li><strong>对象操作指令</strong>（创建与读写访问）：比如我们刚刚的 putfield 和 getfield 就属于读写访问的指令，此外还有 putstatic&#x2F;getstatic，还有 new 系列指令，以及 instanceof 等指令。</li><li><strong>操作数栈管理指令</strong>：如 pop 和 dup，他们只对操作数栈进行操作。</li><li>类型转换指令和运算指令：如 add(加)&#x2F;sub(减)&#x2F;mul(乘)&#x2F;div(除)&#x2F;l2i&#x2F;d2f 等系列指令，实际上这类指令一般也只对操作数栈进行操作。</li><li>控制跳转指令：这类里包含常用的 if 系列指令以及 goto 类指令。</li><li><strong>方法调用和返回指令</strong>：主要包括 invoke 系列指令和 return 系列指令。这类指令也意味这一个方法空间的开辟和结束，即 invoke 会唤醒一个新的 java 方法小宇宙（新的栈和局部变量表），而 return 则意味着这个宇宙的结束回收。</li></ol></li><li>从指令操作的数据类型来讲：指令开头或尾部的一些字母，就往往表明了它所能操作的数据类型：<ul><li>a 对应对象，表示指令操作对象性数据，比如 aload 和 astore、areturn 等等。</li><li>i 对应整形。也就有 iload，istore 等 i 系列指令。</li><li>f 对应浮点型，l 对应 long，b 对应 byte，d 对应 double，c 对应 char。</li><li>ia 对应 int array，aa 对应 object array，da 对应 double array。</li></ul></li></ul><h3 id="3-编译期处理-语法糖"><a href="#3-编译期处理-语法糖" class="headerlink" title="3. 编译期处理(语法糖)"></a>3. 编译期处理(语法糖)</h3><p><strong>语法糖</strong>: 指 Java 编译器把.java 源码编译为.class 字节码过程中,自动生成和转换的一些代码. 如:默认构造器,自动拆装箱等.</p><ol><li><strong>默认构造器</strong>: <code>public class Candy&#123;&#125;</code> 编译后为: <code>public class Candy&#123;public Candy()&#123;super();&#125;&#125;</code></li><li><strong>自动拆装箱</strong>: <code>Integer x=1;int y=x;</code> 编译后为: <code>Integer x=Integer.valueOf(1);int y=x.intValue();</code></li><li><strong>泛型擦除</strong>: 擦除的是字节码上的泛型信息.</li><li><strong>泛型反射</strong>: 通过反射获得泛型信息</li><li><strong>可变参数</strong>: <code>String... args</code> 可以是一个<code>String[] args</code></li><li><strong>foreach</strong>: 集合相当于获取迭代器 Iterator</li><li><strong>switch</strong>: Jdk7 开始可以配合 String 和枚举<ul><li>switch-String: 执行了两遍 switch,第一遍根据字符串的 hashCode 和 equals 将字符串转换为相应的 byte 类型,第二遍利用 byte 执行比较.</li><li>switch-枚举: 会为当前类生成一个静态内部类(合成类,仅 JVM 使用,对我们不可见),用来映射枚举类的枚举编号(从 0 开始)与数组元素的关系,数组大小即为枚举元素的个数,里面存储 case 用来对比的数字,根据这个数字执行 switch</li></ul></li><li><strong>枚举类</strong>: 继承 Enum 并且用 final 修饰类,构造方法私有,枚举量被编译成本类的 final 类变量,定义私有静态枚举量数组$VALUES,静态方法 values()用来返回定义的枚举量数组的 clone(),静态方法 valueOf()调用父类 valueOf(本类.class,名称)根据类型和名称得到相应实例</li><li><strong>try-with-resources</strong>: 无论 try 块的异常还是关闭资源时的异常都不会丢。可以在 try-with-resources 语句中同时处理多个资源。<ul><li>在 Java 7&#x2F;8 ，try-with-resources 语句中必须声明要关闭的资源。通过这种方式声明的资源属于隐式 final。</li><li>Java 9 中甚至能使用预先创建的资源，只要所引用的资源声明为 final 或者是 effective final。</li><li>在幕后施展魔法的是 AutoCloseable 或者 Closeable 接口，它们与 try-with-resources 语句协同工作。</li></ul></li><li><strong>重写桥接</strong>: 子类重写方法返回值可以是父类返回值的子类,JVM 内部使用了桥接方法(synthetic bridge 修饰)重写父类方法并返回子类重写的同名方法,并且没有命名冲突,仅对 jvm 可见.</li><li><strong>匿名内部类</strong>: 内部创建了 final 修饰的实现类, 匿名内部类引用局部变量时,局部变量必须是 final 的:因为内部创建实现类时,将值赋给其对象的 valx 属性,valx 属性没有机会再跟着一起变化.</li></ol><h3 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4. 类加载阶段"></a>4. 类加载阶段</h3><ol><li>隐式加载：new</li><li>显式加载：loadClass、forName 等(需要调用 Class 的 newInstance 方法获取实例)</li><li>类的装载阶段：**<code>加载 --&gt; 链接 --&gt; 初始化</code>**<ul><li>加载：通过 Classloader 加载 class 文件字节码，生成 class 对象</li><li>链接：校验–&gt;准备–&gt;解析<ul><li>校验：检查加载的 Class 的正确性和安全性</li><li>准备：为变量分配存储空间并设置类变量初始值</li><li>解析：JVM 将常量池内的符号引用转换为直接引用</li></ul></li><li>初始化：执行类变量赋值和静态代码块</li></ul></li></ol><h4 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h4><ul><li>将类的字节码载入方法区中,内部采用 C++的 instanceKlass 描述 java 类, 它的重要 field 有:<ul><li><code>_java_mirror</code>:Java 类的镜像, <code>_super</code>:父类, <code>_field</code>:成员变量, <code>_methods</code>:方法, <code>_constants</code>:常量池, <code>_class_loader</code>:类加载器, <code>_vtable</code>:虚方法表, <code>_itable</code>:接口方法表</li></ul></li><li>如果这个类还有父类没加载,先加载父类</li><li><strong>加载和链接可能是交替运行的</strong></li></ul><blockquote><p><code>instanceKlass</code>这样的元数据是存储在方法区(元空间),但<code>_java_mirror</code>存储在堆中; 可通过 HSDB 工具查看.</p></blockquote><h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><ol><li>验证: 验证类是否符合 JVM 规范,安全性检查</li><li>准备: 为 static 变量分配空间,设置默认值<ul><li>jdk7 开始, static 变量存储于<code>_java_mirror</code>末尾, jdk7 之前是 instanceKlass 末尾.</li><li>static 变量分配空间和赋值是两个步骤, 分配空间在准备阶段完成,赋值在初始化阶段完成</li><li>如果 static 变量是 final 的<strong>基本类型或字符串常量</strong>,那么编译阶段值就确定了,赋值在准备阶段完成</li><li>如果 static 变量是 final 的<strong>引用类型</strong>,那么赋值还是会在初始化阶段完成</li></ul></li><li>解析: 将常量池中的符号引用解析为直接引用(确切知道类,方法,属性在内存中的位置)</li></ol><h4 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h4><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code>方法,虚拟机会<strong>保证</strong>这个类的[<strong>构造方法</strong>]<strong>线程安全</strong></li><li><strong>发生的时机</strong>: 概括的说,类初始化是[<strong>懒惰的</strong>]<ul><li>main 方法所在的类的,总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化, 如果父类没有初始化,会引发</li><li>子类访问父类静态变量, 只会触发父类的初始化</li><li>Class.forName 和 new 操作 导致初始化</li></ul></li><li><strong>不会</strong>导致类初始化的情况<ul><li>访问类的 static final 静态常量(基本类型和字符串常量)<strong>不会</strong>触发初始化</li><li>类对象.class 不会</li><li>创建该类的数组 不会</li><li>类加载器的 loadClass 方法 不会</li><li>Class.forName 的第二个参数为 false 时 不会</li></ul></li></ul><h4 id="4-4-应用实例-懒惰初始化单例模式-线程安全"><a href="#4-4-应用实例-懒惰初始化单例模式-线程安全" class="headerlink" title="4.4 应用实例-懒惰初始化单例模式(线程安全)"></a>4.4 应用实例-懒惰初始化单例模式(线程安全)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 内部类中保存单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一次调用getInstance,才会导致内部类加载和初始化其静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5. 类加载器"></a>5. 类加载器</h3><p>以 JDK8 为例:</p><table><thead><tr><th>名称</th><th>加载哪的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>启动类加载器, 最顶层, 打印显示为 null</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>扩展类加载器, 第二级, 打印显示为$ExtClassLoader</td></tr><tr><td>Application ClassLoader</td><td>classpath</td><td>应用程序类加载器, 第三级, 打印显示为$AppClassLoader</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为 Application</td></tr></tbody></table><h4 id="5-1-类加载器-双亲委派机制"><a href="#5-1-类加载器-双亲委派机制" class="headerlink" title="5.1 类加载器-双亲委派机制"></a>5.1 类加载器-双亲委派机制</h4><ul><li>类加载器在接到加载类的请求时，首先将加载任务<strong>委托给上级加载器</strong>，依次递归，如果上级加载器可以完成类加载任务，就成功返回；只有上级加载器无法完成此加载任务时，才自己去加载。</li><li>这种双亲委派模式的好处，一个可以避免类的重复加载，另外也避免了 java 的核心 API 被篡改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * loadClass方法的实现方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//「1」 检查该类是否已经加载</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//「2」 有上级的话,委派上级 loadClass</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//「3」 如果没有上级了(ExtClassLoader),则委派BootstrapClassLoader</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//「4」 每一级都找不到,调用findClass(每个类加载器自己扩展)来加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-线程上下文类加载器"><a href="#5-2-线程上下文类加载器" class="headerlink" title="5.2 线程上下文类加载器"></a>5.2 线程上下文类加载器</h4><ul><li>Java 提供了很多服务提供者接口(Service Provider Interface，SPI),允许第三方为这些接口提供实现(常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等)。</li><li>SPI 接口中的代码经常需要加载具体的实现类; SPI 的接口由 Java 核心库来提供，实现类可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到。</li><li>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；引导类加载器是无法找到 SPI 的实现类的,这时候需要抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。</li><li>类 java.lang.Thread 中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。</li><li>Java 默认的 线程上下文类加载器 是 应用程序类加载器(AppClassLoader)。</li></ul><h4 id="5-3-何时使用-Thread-getContextClassLoader"><a href="#5-3-何时使用-Thread-getContextClassLoader" class="headerlink" title="5.3 何时使用 Thread.getContextClassLoader()?"></a>5.3 何时使用 Thread.getContextClassLoader()?</h4><ul><li>总的说来动态加载资源时，一般只有两种选择，当前类加载器和线程上下文类加载器。当前类加载器是指当前方法所在类的加载器。这个类加载器是运行时类解析使用的加载器，Class.forName(String)和 Class.getResource(String)也使用该类加载器。代码中 X.class 的写法使用的类加载器也是这个类加载器。</li><li>该如何选择类加载器？<ul><li>如若代码是限于某些特定框架，这些框架有着特定加载规则，则不要做任何改动，让框架开发者来保证其工作（比如应用服务器提供商，尽管他们并不能总是做对）。如在 Web 应用和 EJB 中，要使用 Class.gerResource 来加载资源。</li><li>在其他情况下，我们可以自己来选择最合适的类加载器。可以使用策略模式来设计选择机制。其思想是将“总是使用上下文类加载器”或者“总是使用当前类加载器”的决策同具体实现逻辑分离开。往往设计之初是很难预测何种类加载策略是合适的，该设计能够让你可以后来修改类加载策略。</li><li>一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程。</li></ul></li></ul><h4 id="5-4-类加载器与-Web-容器"><a href="#5-4-类加载器与-Web-容器" class="headerlink" title="5.4 类加载器与 Web 容器"></a>5.4 类加载器与 Web 容器</h4><p>以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。<strong>该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类</strong>。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。</p><ul><li>绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则：<ol><li>每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF&#x2F;classes 和 WEB-INF&#x2F;lib 目录下面。</li><li>多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。</li><li>当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。</li></ol></li></ul><h4 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h4><ol><li>什么时候需要自定义类加载器<ul><li>加载非 classpath 路径的任意路径类文件</li><li>都是通过接口来使用实现,希望解耦时,常用于框架设计</li><li>这些类希望予以隔离,不同应用的同名类都可以加载,不冲突,常见于 tomcat 容器</li></ul></li><li>如何自定义类加载器<ol><li>继承 ClassLoader 类</li><li>重写 findClass(String className)方法</li><li>读取(加载)类文件的字节码。</li><li>调用 ClassLoader 超类的 defineClass 方法，向虚拟机提供字节码。</li><li>使用者调用该自定义类加载器的 loadClass 方法</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 类名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">cname</span> <span class="operator">=</span> <span class="string">&quot;E:\\myclasspath\\&quot;</span> + name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="type">byte</span>[] classBytes = Files.readAllBytes(Paths.get(cname));</span><br><span class="line">            Class&lt;?&gt; cl = defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">            <span class="keyword">if</span> (cl == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.print(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-运行期-JVM-自动优化"><a href="#6-运行期-JVM-自动优化" class="headerlink" title="6. 运行期 JVM 自动优化"></a>6. 运行期 JVM 自动优化</h3><p>Java 程序最初是通过解释器进行解释执行的，当程序需要迅速启动和执行时，解释器可以首先发挥作用，省去编译时间，立即执行；当程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。<strong>解释执行节约内存，编译执行提升效率</strong>。 同时，解释器可以作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，则通过逆优化退回到解释状态继续执行。<br>HotSpot 虚拟机中内置了两个即时编译器，分别称为**Client Compiler(C1 编译器)<strong>和</strong>Server Compiler(C2 编译器)**，默认采用 Interpreter(解释器)与其中一个编译器直接配合的方式工作，使用哪个编译器取决于虚拟机运行的模式，也可以自己去指定。</p><ul><li><p>分层编译策略, JVM 将执行状态分成了 5 个层次: 1. 0 层, 解释执行 2. 1 层, 使用 C1 即时编译器编译执行(不带 profiling) 3. 2 层, 使用 C1 即时编译器编译执行(带基本的 profiling) 4. 3 层, 使用 C1 即时编译器编译执行(带完全的 profiling) 5. 4 层, 使用 C2 即时编译器编译执行</p><blockquote><p>profiling 是指在运行过程中收集一些程序执行状态的数据,例如[方法的调用次数],[循环的回边次数]等</p></blockquote></li><li><p>即时编译器(JIT)与解释器的区别</p><ul><li>解释器是将字节码解释为机器码,下次即便遇到相同的字节码,仍会执行重复的解释</li><li>JIT 是将一些字节码编译为机器码并存入 CodeCache,下次遇到相同的代码,直接执行,无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT 会根据平台类型,生成平台特定的机器码</li></ul></li><li><p>对于占据大部分的不常用的代码,我们无需耗费时间将其编译成机器码,而是采用解释执行的方式运行;另一方面,对于占据小部分的热点代码,我们则可以将其编译成机器码,以达到理想的运行速度;</p></li><li><p>执行效率: <code>Interpreter &lt; C1 &lt; C2</code>, 总的目标是发现热点代码(hotpot 名称的由来)优化之.</p></li></ul><h4 id="6-1-公共子表达式消除"><a href="#6-1-公共子表达式消除" class="headerlink" title="6.1 公共子表达式消除"></a>6.1 公共子表达式消除</h4><p>如果一个表达式 E 已经计算过了，并且先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共表达式，可以直接用之前的结果替换。<br>例：int d &#x3D; (c _ b) _ 12 + a + (a + b _ c) &#x3D;&gt; int d &#x3D; E _ 12 + a + (a + E)</p><h4 id="6-2-数组边界检查消除"><a href="#6-2-数组边界检查消除" class="headerlink" title="6.2 数组边界检查消除"></a>6.2 数组边界检查消除</h4><p>Java 语言中访问数组元素都要进行上下界的范围检查，每次读写都有一次条件判定操作，这无疑是一种负担。编译器只要通过数据流分析就可以判定循环变量的取值范围永远在数组长度以内，那么整个循环中就可以把上下界检查消除，这样可以省很多次的条件判断操作。</p><h4 id="6-3-方法内联"><a href="#6-3-方法内联" class="headerlink" title="6.3 方法内联"></a>6.3 方法内联</h4><p>方法内联能去除方法调用的成本，同时也为其他优化建立了良好的基础，因此各种编译器一般会把内联优化放在优化序列的最靠前位置，然而由于 Java 对象的方法默认都是虚方法，在编译期无法确定方法版本，就无法内联。</p><ul><li>因此方法调用都需要在运行时进行多态选择，为了解决虚方法的内联问题，Java 虚拟机团队引入了“类型继承关系分析(CHA)”的技术。<ol><li>在内联时，若是非虚方法，则可以直接内联</li><li>遇到虚方法，首先根据 CHA 判断此方法是否有多个目标版本，若只有一个，可以直接内联，但是需要预留一个“逃生门”，称为守护内联，若在程序的后续执行过程中，加载了导致继承关系发生变化的新类，就需要抛弃已经编译的代码，退回到解释状态执行，或者重新编译。</li><li>若 CHA 判断此方法有多个目标版本，则编译器会使用“内联缓存”，第一次调用缓存记录下方法接收者的版本信息，并且每次调用都比较版本，若一致则可以一直使用，若不一致则取消内联，查找虚方法表进行方法分派。</li></ol></li></ul><h4 id="6-4-逃逸分析"><a href="#6-4-逃逸分析" class="headerlink" title="6.4 逃逸分析"></a>6.4 逃逸分析</h4><p>分析对象动态作用域，当一个方法被定以后，它可能被外部方法所引用，称为方法逃逸，甚至还有可能被外部线程访问到，称为线程逃逸。</p><ul><li>若能证明一个对象不会逃逸到方法或线程之外，这可以通过栈上分配、同步消除、标量替换来进行优化。<ol><li>栈上分配：如果确定一个对象不会逃逸，则可以让它分配在栈上，对象所占用的内存空间就可以随栈帧出栈而销毁。这样可以减小垃圾收集系统的压力。</li><li>同步消除：线程同步相对耗时，如果确定一个变量不会逃逸出线程，那这个变量的读写不会有竞争，则对这个变量实施的同步措施也就可以消除掉。</li><li>标量替换：如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那么程序真正执行的时候可以不创建这个对象，改为直接创建它的成员变量，这样就可以在栈上分配。</li></ol></li></ul><h3 id="7-反射机制"><a href="#7-反射机制" class="headerlink" title="7. 反射机制"></a>7. 反射机制</h3><p>简单说，反射机制是程序在运行时能够获取自身的信息。在 java 中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。<br>Class 反射对象描述的是类的语义结构，通过 class 对象，可以获取构造器，成员变量，方法等类元素的反射对象，并且可以用编程的方法通过这些反射对象对目标对象进行操作。<br>这些反射类在 java.lang.reflect 包中定义，下面是最主要的三个类：</p><ol><li>Constructor：类的构造函数反射类：<ul><li>通过 Class#getConstructors()方法可以获得类的所有构造函数的反射对象数组。</li><li>其中最主要的方法是 newInstance(Object[] args),通过该方法可以创建一个对象类的实例，功能和 new 一样。在 jdk5.0 之后，提供了 newInstance(Object…args)更为灵活。</li></ul></li><li>Method：类方法的反射类。<ul><li>通过 Class#getDeclaredMethods()方法可以获取所有方法的反射类对象数组 Method[].其中最主要的方法是:</li><li>invoke(String name,class parameterTypes),和 invoke(Object obj,Object…args)。同时也还有很多其他方法</li><li>Class getReturnType（）：获取方法的返回值类型</li><li>Class[] getParameterTypes（）：获取方法的参数数组</li></ul></li><li>Field：类成员变量的反射类，<ul><li>通过 Class#getDeclareFields（）可以获取类成员变量反射的数组。</li><li>Class#getDeclareField（String  name）获取某特定名称的反射对象。</li><li>最主要的方法是：set(Object obj,Object value),为目标对象的成员变量赋值。如果是基础类型还可以这样赋值 setInt(),setString()…</li></ul></li></ol><ul><li>java 还提供了包的反射类和注解的反射类。</li><li>总结:java 反射体系保证了通过程序化的方式访问目标对象的所有元素，对于 private 和 protected 成员变量或者方法，也是可以访问的。</li></ul><h4 id="7-1-反射中，Class-forName-和-classloader-的区别"><a href="#7-1-反射中，Class-forName-和-classloader-的区别" class="headerlink" title="7.1 反射中，Class.forName 和 classloader 的区别"></a>7.1 反射中，Class.forName 和 classloader 的区别</h4><ul><li>Class.forName()得到的 Class 是完成初始化的</li><li>而 ClassLoader.loadClass()得到的 Class 是还没有链接的。</li><li>Spring IoC 为了加快初始化速度，因此大量使用了延时加载技术。而使用 classloader 不需要执行类中的初始化代码，可以加快加载速度，把类的初始化工作留到实际使用到这个类的时候。</li></ul><h4 id="7-2-哪里用到反射机制？"><a href="#7-2-哪里用到反射机制？" class="headerlink" title="7.2 哪里用到反射机制？"></a>7.2 哪里用到反射机制？</h4><ul><li>JDBC 中，利用反射动态加载了数据库驱动程序。</li><li>Web 服务器中利用反射调用了 Sevlet 的服务方法。</li><li>Eclispe 等开发工具利用反射动态刨析对象的类型与结构，动态提示对象的属性和方法。</li><li>很多框架都用到反射机制，注入属性，调用方法，如 Spring。</li></ul><h4 id="7-3-反射机制的优缺点？"><a href="#7-3-反射机制的优缺点？" class="headerlink" title="7.3 反射机制的优缺点？"></a>7.3 反射机制的优缺点？</h4><p>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了 java 的灵活性。<br>缺点：对性能有影响，这类操作总是慢于直接执行 java 代码。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「深入JVM」 运行时数据区 与 垃圾回收机制</title>
      <link href="/2019/08/23/jvm-stack.html"/>
      <url>/2019/08/23/jvm-stack.html</url>
      
        <content type="html"><![CDATA[<h3 id="Java-虚拟机运行时数据区"><a href="#Java-虚拟机运行时数据区" class="headerlink" title="Java 虚拟机运行时数据区"></a>Java 虚拟机运行时数据区</h3><ol><li>程序计数器（Program Counter Register）</li><li>本地方法栈（Native Method Stack）</li><li>Java 虚拟机栈（VM Stack）</li><li>Java 堆（Heap）（线程共享）</li><li>方法区（Method Area）（线程共享）<span id="more"></span></li></ol><p><img src="/2019/08/23/jvm-stack/JVM.png"></p><h4 id="Java-运行过程"><a href="#Java-运行过程" class="headerlink" title="Java 运行过程"></a>Java 运行过程</h4><ol><li><code>Java源代码</code> 经过<strong>Javac</strong>编译成 字节码（bytecode)<code>.class文件</code>;</li><li>在运行时，通过 <strong>虚拟机(JVM)内嵌的解释器</strong> 将<code>字节码</code>转换成为最终的<code>机器码</code>。</li></ol><blockquote><p>常见的 JVM，都提供了 JIT(Just-In-Time)编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，所以准确的说 Java 代码会<code>解释执行或编译执行</code>。</p></blockquote><h3 id="1-程序计数器（Program-Counter-Register）"><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.程序计数器（Program Counter Register）"></a>1.程序计数器（Program Counter Register）</h3><ul><li>线程私有</li><li>不会内存溢出</li><li>作用：记住下一条 JVM 指令的执行地址。</li></ul><h3 id="2-Java-虚拟机栈（VM-Stack）"><a href="#2-Java-虚拟机栈（VM-Stack）" class="headerlink" title="2.Java 虚拟机栈（VM Stack）"></a>2.Java 虚拟机栈（VM Stack）</h3><ul><li>线程私有</li><li>LIFO（后进先出）</li><li>存储栈帧，支撑 Java 方法的调用、执行和退出</li><li>可能出现 OutOfMemoryError 异常（如果被设计成动态扩展，而扩展又未申请到足够的内存抛出）和 StackOverflowError 异常（如线程请求的栈深度大于最大深度抛出）</li></ul><p><img src="/2019/08/23/jvm-stack/JVM-stack.png"></p><h4 id="2-1-栈帧（Frame）"><a href="#2-1-栈帧（Frame）" class="headerlink" title="2.1 栈帧（Frame）"></a>2.1 栈帧（Frame）</h4><ul><li>Java 虚拟机栈中存储的内容，它被用于存储数据和部分过程结构的数据结构，同时也被用来处理动态链接、方法返回值 和 异常分派</li><li>一个完整的栈帧包含：<strong>局部变量表</strong>、<strong>操作数栈</strong>、动态连接信息、方法正常完成和异常完成的信息</li><li>每个栈由多个栈帧组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="2-2-局部变量表"><a href="#2-2-局部变量表" class="headerlink" title="2.2 局部变量表"></a>2.2 局部变量表</h4><ul><li>由若干个 Slot 组成，长度由编译期决定</li><li>单个 Slot 可以储存一个类型为 boolean、byte、char、short、float、reference、returnAddress 的数据，两个 Slot 可以存储一个类型为 long 或 double 的数据</li><li>局部变量表用于方法间参数的传递，以及方法执行过程中存储基础数据类型的值和对象的引用</li></ul><h4 id="2-3-操作数栈"><a href="#2-3-操作数栈" class="headerlink" title="2.3 操作数栈"></a>2.3 操作数栈</h4><ul><li>一个后进先出栈，由若干个 Entry 组成，长度由编译期决定</li><li>单个 Entry 即可以存储一个 Java 虚拟机中定义的任意数据类型的值，包括 long 和 double 类型，但是存储 long 和 double 类型的 Entry 深度为 2，其他类型深度为 1</li><li>在方法执行过程中，栈帧用于存储计算参数和计算结果；在方法调用时，操作数栈也用来准备调用方法的参数以及接收方法返回结果</li></ul><h4 id="2-4-栈的内存溢出（StackOverflowError）"><a href="#2-4-栈的内存溢出（StackOverflowError）" class="headerlink" title="2.4 栈的内存溢出（StackOverflowError）"></a>2.4 栈的内存溢出（StackOverflowError）</h4><ol><li>栈帧过多导致内存溢出（方法的递归调用）</li><li>栈帧过大导致内存溢出</li><li>JSON 数据转换可能导致内存溢出（可用@JsonIgnore 忽略不能转换的属性）</li></ol><h4 id="2-5-线程诊断"><a href="#2-5-线程诊断" class="headerlink" title="2.5 线程诊断"></a>2.5 线程诊断</h4><ol><li>案例 1：cpu 占用过高<ul><li>Linux 下，<code>top</code>打印所有进程，筛选 cpu 占用高的进程号，如：32655</li><li>用<code>ps H -eo pid,tid,%cpu | grep 32655</code>打印 32655 的所有线程，定位到具体 cpu 占用过高的线程</li><li><code>jstack 进程id</code>打印该线程的所有线程详情</li><li>将线程 id 换算成 16 进制，对比打印出的线程详情，定位到具体线程，进一步定位到源代码具体代码行号。</li></ul></li><li>案例 2：程序运行很长时间没有结果<ul><li>前面步骤同上，<code>jstack 进程id</code>打印该线程的所有线程详情</li><li>在最后一段找到了 Found one Java-level <strong>deadlock</strong>，定位死锁的具体行号。</li></ul></li></ol><h3 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.本地方法栈（Native Method Stack）"></a>3.本地方法栈（Native Method Stack）</h3><ul><li>线程私有</li><li>LIFO（后进先出）</li><li>支撑 Native 方法的调用、执行和退出</li><li>可能出现 OutOfMemoryError 异常 和 StackOverflowError 异常</li><li>有一些虚拟机（如 HotSpot）将 Java 虚拟机栈和本地方法栈合并实现</li></ul><h4 id="3-1-Java-虚拟机栈和本地方法栈可能发生的异常情况："><a href="#3-1-Java-虚拟机栈和本地方法栈可能发生的异常情况：" class="headerlink" title="3.1 Java 虚拟机栈和本地方法栈可能发生的异常情况："></a>3.1 Java 虚拟机栈和本地方法栈可能发生的异常情况：</h4><ul><li>如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量时，Java 虚拟机将会抛出一个 StackOverflowError 异常</li><li>如果 Java 虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><h3 id="4-Java-堆（Heap）"><a href="#4-Java-堆（Heap）" class="headerlink" title="4.Java 堆（Heap）"></a>4.Java 堆（Heap）</h3><ul><li>全局共享</li><li>通常是 Java 虚拟机中最大的一块内存区域</li><li>作用是作为 Java 对象的主要存储区域（通过 new 创建的对象都会使用堆内存）</li><li>有垃圾回收机制</li></ul><p><img src="/2019/08/23/jvm-stack/JVM-heap.png"></p><h4 id="4-1-Java-堆可能发生的异常"><a href="#4-1-Java-堆可能发生的异常" class="headerlink" title="4.1 Java 堆可能发生的异常"></a>4.1 Java 堆可能发生的异常</h4><ul><li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><h4 id="4-2-堆内存诊断"><a href="#4-2-堆内存诊断" class="headerlink" title="4.2 堆内存诊断"></a>4.2 堆内存诊断</h4><ol><li><strong>jps 工具</strong>：查看当前系统中有哪些 Java 进程</li><li><strong>jmap 工具</strong>：查看堆内存占用情况<code>jmap -head 进程id</code></li><li><strong>jconsole 工具</strong>：图形界面，多功能的监测工具，可以连续监测</li></ol><ul><li>案例：垃圾回收后，内存占用仍然很高<ul><li>jps 工具定位进程，<code>jmap -head 进程id</code>查看堆使用情况，</li><li>可以用 jconsole 工具手动执行 GC</li><li>用 jvirsualvm 抓取堆 dump(快照，抓取堆里面有哪些类型的对象及个数等信息)</li></ul></li></ul><h4 id="4-3-字符串常量池-StringTable"><a href="#4-3-字符串常量池-StringTable" class="headerlink" title="4.3 字符串常量池 (StringTable)"></a>4.3 字符串常量池 (StringTable)</h4><ul><li>在 JDK6.0 及之前版本，字符串常量池是放在 Perm Gen 区(也就是方法区)中；</li><li>在 JDK7.0 版本，字符串常量池被移到了堆中</li><li>字符串手动入池: 调用<code>String.intern()</code></li></ul><h3 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5.方法区（Method Area）"></a>5.方法区（Method Area）</h3><ul><li>全局共享</li><li>作用是存储 Java 类的结构信息</li><li>JVMS 不要求该区域实现自动内存管理，但是商用 Java 虚拟机都能够自动管理该区域内存</li><li>在 JDK1.8 后，方法区由元空间实现</li></ul><blockquote><p>方法区内存溢出场景：spring、mabatis 等动态加载类的场景使用不当会导致方法区内存溢出</p></blockquote><h4 id="5-1-运行时常量池"><a href="#5-1-运行时常量池" class="headerlink" title="5.1 运行时常量池"></a>5.1 运行时常量池</h4><ul><li>全局共享</li><li>是方法区的一部分</li><li>作用是存储 Java 类文件常量池中的符号信息</li><li>可能出现 OutOfMemoryError 异常</li></ul><h4 id="5-2-永久代与方法区"><a href="#5-2-永久代与方法区" class="headerlink" title="5.2 永久代与方法区"></a>5.2 永久代与方法区</h4><ul><li>在 JDK1.2~6，HotSpot 使用永久代实现方法区</li><li>在 JDK1.7，开始移除（符号表被到 Native Heap，字符串常量和类的静态引用被移到 Java Head 中）</li><li>在 JDK1.8，永久代被元空间（Metaspace）所替代</li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h3><ul><li>全局共享</li><li>并非 JVMS 定义的标准 Java 运行时内存区域, 属于操作系统内存</li><li>JDK1.4 引入 NIO，目的是避免 Java 堆 和 Native 堆 中来回 复制数据 带来的性能损耗。</li><li>能被自动管理，但是在检测手段上可能会由一些简陋</li><li>可能出现 OutOfMemoryError 异常</li><li>常用于 NIO 操作时，用于数据缓冲区</li><li>分配回收成本高，但读写性能高，不受 JVM 内存回收管理</li></ul><h3 id="7-可回收对象的判定"><a href="#7-可回收对象的判定" class="headerlink" title="7.可回收对象的判定"></a>7.可回收对象的判定</h3><ol><li>引用计数法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器就+1，当引用失效就-1，任何时候计数器为 0 时就是可回收对象。</li><li>可达性分析：通过一系列名为 GC Roots 的对象作为起始点，从这些根节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则称该对象是不可达的。</li></ol><blockquote><p>目前主流 Java 虚拟机中<strong>并没有</strong>选用引用计数法，其中最重要的原因是它很难解决<strong>循环引用问题</strong></p></blockquote><h4 id="7-1-Java-语言中的-GC-Roots"><a href="#7-1-Java-语言中的-GC-Roots" class="headerlink" title="7.1 Java 语言中的 GC Roots"></a>7.1 Java 语言中的 GC Roots</h4><ul><li>在虚拟机栈（栈帧中的本地变量表）中的引用的对象。</li><li>在方法区中的类静态属性引用的对象。</li><li>在方法区中的常量引用的对象。</li><li>在本地方法栈中 JNI（即一般说的 Native 方法）的引用对象。</li></ul><h4 id="7-2-Java-引用类型"><a href="#7-2-Java-引用类型" class="headerlink" title="7.2 Java 引用类型"></a>7.2 Java 引用类型</h4><ol><li>强引用：Java 中默认声明的就是强引用<ul><li>垃圾回收器将永远<strong>不会</strong>回收被「强引用」对象，哪怕内存不足时，JVM 也会直接抛出 OutOfMemoryError，不会去回收。可以赋值为 null 中断强引用。</li></ul></li><li>软引用（SoftReference）：用来描述一些非必需但仍有用的对象，用 java.lang.ref.SoftReference 类来表示软引用<ul><li>垃圾回收后，在内存<strong>不足时会</strong>再次触发垃圾回收，回收「软引用」对象，仍不足，才会抛出内存溢出异常。可以配合引用队列来释放软引用自身。</li></ul></li><li>弱引用（WeakReference）：用 java.lang.ref.WeakReference 来表示弱引用<ul><li>垃圾回收器将永远<strong>都会</strong>回收被「弱引用」对象，无论内存是否足够。可以配合引用队列来释放弱引用自身。</li></ul></li><li>虚引用（PhantomReference）：最弱的一种引用关系，用 PhantomReference 类来表示<ul><li><strong>必须配合引用队列</strong>使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存。</li></ul></li></ol><h3 id="8-垃圾回收算法"><a href="#8-垃圾回收算法" class="headerlink" title="8.垃圾回收算法"></a>8.垃圾回收算法</h3><ol><li>标记清除算法（Mark-Sweep）</li><li>标记整理算法(Mark-Compact)</li><li>复制算法（copying）</li></ol><h4 id="8-1-分代垃圾回收（Java-堆分为新生代和老年代）"><a href="#8-1-分代垃圾回收（Java-堆分为新生代和老年代）" class="headerlink" title="8.1 分代垃圾回收（Java 堆分为新生代和老年代）"></a>8.1 分代垃圾回收（Java 堆分为新生代和老年代）</h4><ol><li>对象首先分配在新生代的<code>Eden区</code></li><li>新生代空间不足时，触发 <code>Minor GC</code>，Eden 区和 From 幸存区(Survivor)存活的对象使用 coping 复制到 To 幸存区中，存活的年龄+1 并且交换 From 和 To。</li><li>Minor GC 会引发 <code>STW(Stop the world)</code>，暂停其他用户的线程，等垃圾回收结束后，用户线程才恢复运行</li><li>当对象<code>寿命超过阈值</code>时，会晋升至老年代，最大寿命 15(4bit)</li><li>当老年代空间不足，会先尝试触发 Minor GC，如果之后空间仍不足，那么触发 <code>Full GC</code>，STW 的时间更长</li></ol><h4 id="8-2-相关-JVM-参数"><a href="#8-2-相关-JVM-参数" class="headerlink" title="8.2 相关 JVM 参数"></a>8.2 相关 JVM 参数</h4><ol><li>堆初始大小： <code>-Xms</code></li><li>堆最大大小： <code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></li><li>新生代大小： <code>-Xmn</code> 或 <code>(-XX:NewSize=size + -XX:MaxNewSize=size)</code></li><li>幸存区比例（动态）： <code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></li><li>幸存区比例： <code>-XX:SurvivorRatio=ratio</code></li><li>晋升阈值： <code>-XX:MaxTenuringThreshold=threshold</code></li><li>晋升详情： <code>-XX:+PrintTenuringDistribution</code></li><li>GC 详情： <code>-XX:+PrintGCDetils -verbose:gc</code></li><li>FullGC 前 MinorGC： <code>-XX:+ScavengeBeforeFullGC</code></li></ol><h3 id="9-垃圾回收器"><a href="#9-垃圾回收器" class="headerlink" title="9.垃圾回收器"></a>9.垃圾回收器</h3><ol><li>串行（开启：<code>-XX:+UseSerialGC=Serial + SerialOld</code>）<ul><li>单线程</li><li>适合堆内存较小，适合个人电脑</li></ul></li><li>吞吐量优先<ul><li>多线程</li><li>堆内存较大，多核 CPU</li><li>让单位时间内，总 STW 的时间最短</li></ul></li><li>响应时间优先<ul><li>多线程</li><li>堆内存较大，多核 CPU</li><li>尽量让单次 STW 的时间最短</li></ul></li></ol><h4 id="9-1-吞吐量优先（并行）回收器"><a href="#9-1-吞吐量优先（并行）回收器" class="headerlink" title="9.1 吞吐量优先（并行）回收器"></a>9.1 吞吐量优先（并行）回收器</h4><ol><li>开启(默认开启)： <code>-XX:+UseParallelGC</code> ~ <code>-XX:+UseParallelOldGC</code></li><li>动态调整堆大小：<code>-XX:+UseAdaptiveSizePolicy</code></li><li>目标吞吐量：<code>-XX:GCTimeRatio=ratio</code></li><li>最大暂停时间的目标值：<code>-XX:MaxGCPauseMillis=ms</code></li><li>线程数：<code>-XX:ParallelGCThreads=n</code></li></ol><h4 id="9-2-响应时间优先（并发）回收器"><a href="#9-2-响应时间优先（并发）回收器" class="headerlink" title="9.2 响应时间优先（并发）回收器"></a>9.2 响应时间优先（并发）回收器</h4><p>可以和用户线程<strong>并发</strong>执行，工作在老年代</p><ol><li>开启：<code>-XX:+UseConcMarkSweepGC</code> 配合 <code>-XX:UseParNewGC</code> ~ <code>SerialOld</code></li><li>并行和并发线程数：<code>-XX:ParallelGCThreads=n</code> ~ <code>-XX:ConsGCThreads=threads</code></li><li>回收时机（内存占比）:<code>-XX:CMSInitiatingOccupancyFraction=percent</code></li><li>重新标记前对新生代先做垃圾回收：<code>-XX:+CMSScavengeBeforeRemark</code></li></ol><h4 id="9-3-G1（Garbage-First）（并发）"><a href="#9-3-G1（Garbage-First）（并发）" class="headerlink" title="9.3 G1（Garbage First）（并发）"></a>9.3 G1（Garbage First）（并发）</h4><ol><li>G1 回收器 适用场景<ul><li>同时注重 吞吐量(Throughput)和低延迟(Low latency)，默认暂停目标是 200ms</li><li>超大堆内存，会将堆划分为多个大小相等的区域(Region)</li><li>整体上是标记+整理算法，两个区域之间是复制算法</li></ul></li><li>相关 JVM 参数<ul><li>开启（JDK9 默认）：<code>-XX:+UseG1GC</code></li><li>区域大小：<code>-XX:G1HeapRegionSize=size</code></li><li>最大暂停时间：<code>-XX:MaxGCPauseMillis=time</code></li></ul></li><li>G1 垃圾回收阶段（三个阶段循环）<ol><li>**<code>Young Collection</code>**：新生代 GC（会 STW）</li><li>**<code>Young Collection + Concurrent Mark</code>**：<ul><li>在 YoungGC 时会进行<code>GC Root</code>的初始标记</li><li>老年代占用堆空间比例达到阈值值，进行并发标记(不会 STW)，由下面的 JVM 参数决定</li><li><code>-XX:InitiatingHeadOccupancyPercent=percent</code>(默认 45%)</li></ul></li><li>**<code>Mixed Collection</code>**：会对 Eden、Survivor、Old 进行全面垃圾回收<ul><li>最终标记(Remark)会 STW</li><li>拷贝存活(Evacuation)会 STW</li><li>为达到最大暂停时间短的目标，Old 区是优先回收垃圾最多的区域</li></ul></li></ol></li></ol><h4 id="9-4-Minor-GC-和-Full-GC"><a href="#9-4-Minor-GC-和-Full-GC" class="headerlink" title="9.4 Minor GC 和 Full GC"></a>9.4 Minor GC 和 Full GC</h4><ol><li>SerialGC<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：Full GC</li></ul></li><li>ParallelGC<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：Full GC</li></ul></li><li>CMS<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：分两种情况（回收速度高于内存产生速度不会触发 Full GC）</li></ul></li><li>G1<ul><li>新生代内存不足：Minor GC</li><li>老年代内存不足：分两种情况（回收速度高于内存产生速度不会触发 Full GC）</li></ul></li></ol><blockquote><ul><li><code>Minor GC</code>：当 Eden 区满时，触发 Minor GC</li><li><code>Full GC</code>：<ul><li>System.gc()方法的调用</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、From 幸存区 向 To 幸存区 复制时，对象大小大于 To 区可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul></blockquote><h3 id="10-垃圾回收调优"><a href="#10-垃圾回收调优" class="headerlink" title="10.垃圾回收调优"></a>10.垃圾回收调优</h3><ol><li>调优领域：内存、锁竞争、CPU 占用、IO</li><li>调优目标：「低延迟」还是「高吞吐量」（高吞吐量:ParallelGC，低延迟:CMS,G1,ZGC）</li><li>最快的 GC 是不发生 GC：查看 Full GC 前后的内存占用（内存数据太多？数据表示太臃肿？内存泄漏？）</li><li>新生代调优：new 操作内存分配廉价、死亡对象回收代价是零、大部分对象用过即死、MinorGC 时间远低于 FullGC</li></ol><h4 id="10-1-新生代调优"><a href="#10-1-新生代调优" class="headerlink" title="10.1 新生代调优"></a>10.1 新生代调优</h4><ol><li>理想情况：新生代能容纳所有「并发量*(请求-响应)」的数据</li><li>幸存区大到能够保留「当前活跃对象+需要晋升对象」</li><li>「晋升阈值配置」得当，让长时间存活的对象尽快晋升<ul><li>调整最大晋升阈值：<code>-XX:MaxTenuringThreshold=threshold</code></li><li>打印晋升详情：<code>-XX:+PrintTenuringDistribution</code></li></ul></li></ol><h4 id="10-2-老年代调优"><a href="#10-2-老年代调优" class="headerlink" title="10.2 老年代调优"></a>10.2 老年代调优</h4><p>以 CMS 为例：</p><ol><li>CMS 的老年代内存越大越好（避免浮动垃圾引起的并发失败）</li><li>先尝试不做调优，如果没有 FullGC 那么已经 OK，否则先尝试调优新生代</li><li>观察发生 Full GC 时老年代内存占用，将老年代内存预设调大 1&#x2F;4~1&#x2F;3<ul><li><code>-XX:CMSInitiatingOccupancyPercent=percent</code></li></ul></li></ol><h4 id="10-3-调优案例"><a href="#10-3-调优案例" class="headerlink" title="10.3 调优案例"></a>10.3 调优案例</h4><ol><li>案例 1：FullGC 和 MinorGC 频繁<ul><li>可能原因：空间紧张，若业务高峰期时，新生代空间紧张，幸存区的晋升阈值会降低，大量本来生存短对象晋升老年区，进一步触发老年代 FullGC 的频繁发生</li><li>解决方法：经过分析，观察堆空间大小，先试着增大新生代内存，同时增大幸存区的空间以及晋升阈值。</li></ul></li><li>案例 2：请求高峰期发生了 FullGC，单次暂停时间特别长（CMS）<ul><li>查看日志，看 CMS 哪个阶段暂停时间长（重新标记阶段），解决：打开开关参数 CMSScavengeBeforeRemark</li><li>重新标记前对新生代先做垃圾回收：<code>-XX:+CMSScavengeBeforeRemark</code></li></ul></li></ol><h4 id="10-4-G1-调优最佳实践"><a href="#10-4-G1-调优最佳实践" class="headerlink" title="10.4 G1 调优最佳实践"></a>10.4 G1 调优最佳实践</h4><ol><li>不要设置新生代和老年代的大小<ul><li>G1 收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间目标。设置了新生代大小相当于放弃了 G1 为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小。</li></ul></li><li>不断调优暂停时间指标<ul><li>通过 XX:MaxGCPauseMillis&#x3D;x 可以设置启动应用程序暂停的时间，G1 在运行的时候会根据这个参数选择 CSet 来满足响应时间的设置。一般情况下这个值设置到 100ms 或者 200ms 都是可以的(不同情况下会不一样)，但如果设置成 50ms 就不太合理。暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度。最终退化成 Full GC。所以对这个参数的调优是一个持续的过程，逐步调整到最佳状态。</li></ul></li><li>关注 Evacuation Failure<ul><li>Evacuation Failure 类似于 CMS 里面的晋升失败，堆空间的垃圾太多导致无法完成 Region 之间的拷贝，于是不得不退化成 Full GC 来做一次全局范围内的垃圾收集。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据结构」常见JAVA集合类的数据结构分析</title>
      <link href="/2019/07/28/data-structure-java.html"/>
      <url>/2019/07/28/data-structure-java.html</url>
      
        <content type="html"><![CDATA[<h3 id="集合-Collection-x2F-Map"><a href="#集合-Collection-x2F-Map" class="headerlink" title="集合(Collection&#x2F;Map)"></a>集合(Collection&#x2F;Map)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Collection接口</span><br><span class="line">    |———— List接口</span><br><span class="line">        |———— ArrayList类</span><br><span class="line">        |———— Vector类</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">        |———— Stack类</span><br><span class="line">    |———— Set接口</span><br><span class="line">        |———— HashSet类</span><br><span class="line">        |———— TreeSet类</span><br><span class="line">        |———— LinkedHashSet类</span><br><span class="line">    |———— Queue接口</span><br><span class="line">        |———— LinkedList类</span><br><span class="line">Map接口</span><br><span class="line">    |———— HashMap类</span><br><span class="line">    |———— TreeMap类</span><br><span class="line">    |———— LinkedHashMap类</span><br><span class="line">    |———— Hashtable类</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="0-1-List"><a href="#0-1-List" class="headerlink" title="0.1 List"></a>0.1 List</h4><ul><li><strong>Arraylist</strong>： 动态数组</li><li>Vector： 动态数组(线程安全)</li><li><strong>LinkedList</strong>： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环)</li></ul><h4 id="0-2-Set"><a href="#0-2-Set" class="headerlink" title="0.2 Set"></a>0.2 Set</h4><ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li>TreeSet（有序，唯一）：红黑树(自平衡的排序二叉树)</li></ul><h4 id="0-3-Map"><a href="#0-3-Map" class="headerlink" title="0.3 Map"></a>0.3 Map</h4><ul><li><strong>HashMap</strong>： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间</li><li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，<strong>增加了一条双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>Hashtable： 数组+链表(线程安全)，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul><h4 id="0-4-如何选用集合"><a href="#0-4-如何选用集合" class="headerlink" title="0.4 如何选用集合"></a>0.4 如何选用集合</h4><p>主要根据集合的特点来选用：</p><ul><li>键值对就选用Map接口下的集合，需要排序时选择TreeMap，不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.</li><li>只需要存放元素值时，就选用Collection接口下的集合，需要保证元素唯一时选择实现Set接口的集合（TreeSet或HashSet），不需要就选择实现List接口的ArrayList或LinkedList</li></ul><h4 id="0-5-对数公式log-与-时空复杂度"><a href="#0-5-对数公式log-与-时空复杂度" class="headerlink" title="0.5 对数公式log 与 时空复杂度"></a>0.5 对数公式log 与 时空复杂度</h4><ul><li>若<code>a^n = b</code> (a&gt;0,a≠1) 则 <code>n = log(a)b</code> , 如<code>log(2)8 = 3</code>; Java数据结构中log默认以2为底(个人理解,有待考证)</li><li>常用O(1), O(n), O(logn)表示对应算法的时间复杂度, 也用于表示空间复杂度。<ul><li><strong><code>O(1)</code></strong>: 最低的时空复杂度, 无论数据规模多大，都可以在一次计算后找到目标</li><li><strong><code>O(n)</code></strong>: 数据量增大n倍时，耗时增大n倍; 比如常见的遍历算法</li><li><strong><code>O(n^2)</code></strong>: 数据量增大n倍时，耗时增大n的平方倍; 比如冒泡排序，对n个数排序，需要扫描n×n次</li><li><strong><code>o(logn)</code></strong>: 当数据增大n倍时，耗时增大logn倍; 二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标(2^8&#x3D;256)</li><li><strong><code>O(nlogn)</code></strong>: 同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8&#x3D;2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度</li></ul></li></ul><h4 id="0-6-移位运算符"><a href="#0-6-移位运算符" class="headerlink" title="0.6  移位运算符"></a>0.6  移位运算符</h4><p>按照平移的方向和填充数字的规则分为三种:&lt;&lt;(左移)、&gt;&gt;(带符号右移) 和 &gt;&gt;&gt;(无符号右移)</p><ul><li><code>左移 &lt;&lt;</code> : 丢弃最高位,0补最低位；左移n位就相当于乘以2的n次方</li><li><code>右移 &gt;&gt;</code> : 符号位不变,高位补上符号位(正数0, 负数1)；右移n位相当于除以2的n次方</li><li><code>无符号右移 &gt;&gt;&gt;</code> : 忽略符号位，0补最高位(补码移位所得)</li></ul><blockquote><ul><li>正数的左移与右移，负数的无符号右移，就是相应的补码移位所得，在高位补0即可。</li><li>负数的右移，就是补码高位补1,然后按位取反加1即可。</li></ul></blockquote><ul><li>运算规则：<ul><li>左移：高位移出(舍弃)，低位的空位补零；int类型时，每移动1位它的第31位就要被移出并且丢弃；long类型时，每移动1位它的第63位就要被移出并且丢弃；byte和short类型时，将自动把这些类型扩大为int型。</li><li>右移：低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1；当右移的运算数是byte 和short类型时，将自动把这些类型扩大为 int 型。</li><li>无符号右移：补码移位，高位补0；正数和右移表现一致，负数变成了很大的正数；</li></ul></li></ul><h3 id="1-Arraylist"><a href="#1-Arraylist" class="headerlink" title="1. Arraylist"></a>1. Arraylist</h3><p>ArrayList的底层是数组队列，相当于<strong>动态数组</strong>。与数组相比，它的容量能动态增长。在添加大量元素前，应用程序使用ensureCapacity操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br>它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。</p><ul><li><strong>数组</strong>时间复杂度: <strong>插入&#x2F;删除:O(n)<strong>，</strong>增加(末尾)&#x2F;随机访问: O(1)</strong></li><li>ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的<strong>添加、删除、修改、遍历</strong>等功能</li><li>ArrayList 实现了RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是<strong>快速随机访问</strong></li><li>ArrayList 实现了Cloneable 接口，即覆盖了函数 clone()，<strong>能被克隆</strong>。</li><li>ArrayList 实现java.io.Serializable 接口，这意味着ArrayList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>和 Vector 不同，ArrayList 中的操作<strong>不是线程安全的</strong>！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li></ul><h4 id="1-1-ArrayList扩容机制-（重点）"><a href="#1-1-ArrayList扩容机制-（重点）" class="headerlink" title="1.1 ArrayList扩容机制*（重点）"></a>1.1 ArrayList扩容机制*（重点）</h4><ul><li>以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组；当add第一个元素时，才真正分配容量(<strong>默认10</strong>)</li><li>ArrayList在每次增加元素(1个或一组)时，都要调用<code>ensureCapacityInternal()</code>方法来确保足够的容量</li><li>当容量不足以容纳当前的元素个数时，进入<code>grow()</code>方法进行扩容，首先设置新的容量为旧容量的<strong>1.5倍</strong></li><li>若设置后的新容量还不够，则设置新容量为<code>minCapacity</code>(所需最小容量)</li><li>比较新容量是否大于<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)，若大于，再比较<code>minCapacity</code>是否大于<code>MAX_ARRAY_SIZE</code>，若大于，设置新的容量为<code>Integer.MAX_VALUE</code>(Integer最大值)，否则设置新的容量为<code>MAX_ARRAY_SIZE</code>(Integer最大值减8)</li><li>最后用<code>Arrays.copyof()</code>方法将元素拷贝到新的数组</li><li>(第<code>Integer.MAX_VALUE+1</code>次添加元素时，抛出<code>OutOfMemoryError</code>异常)</li></ul><blockquote><p><strong>System.arraycopy()和Arrays.copyOf()方法</strong><br>通过源码发现这两个实现数组复制的方法被广泛使用, 比如插入操作add(int index, E element)方法就很巧妙的用到了 System.arraycopy()方法让数组自己复制自己实现让index开始之后的所有成员后移一个位置</p><ul><li>Arrays.copyOf()内部也是调用了System.arraycopy()方法 </li><li>Arrays.copyOf()是系统自动在内部新建一个数组，并返回该数组</li><li>System.arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</li></ul></blockquote><h4 id="1-2-ensureCapacity"><a href="#1-2-ensureCapacity" class="headerlink" title="1.2 ensureCapacity"></a>1.2 ensureCapacity</h4><p>ArrayList对外提供了一个<code>ensureCapacity(int n)</code>方法</p><ul><li>最好在<code>add</code>大量元素之前用ensureCapacity方法，以<strong>减少增量重新分配的次数</strong></li><li>ensureCapacity一次性扩容到位，否则在添加大量元素的过程中，一点一点的进行扩容</li></ul><h4 id="1-3-内部类"><a href="#1-3-内部类" class="headerlink" title="1.3 内部类"></a>1.3 内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt;&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ListItr</span> <span class="keyword">extends</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt;&#123;...&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SubList</span> <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ArrayListSpliterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;E&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure><p>ArrayList有四个内部类</p><ul><li>Itr 实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；</li><li>ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法</li><li>Iterator和ListIterator的区别: <ul><li>ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。</li></ul></li></ul><h3 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2. LinkedList"></a>2. LinkedList</h3><p>LinkedList是基于<strong>双向链表</strong>实现的, 可以在任何位置进行高效地插入和移除操作的有序序列。</p><ul><li>复杂度: <strong>增加(末尾)&#x2F;删除:O(1)<strong>，</strong>插入&#x2F;获取: O(n)</strong></li><li>LinkedList 继承AbstractSequentialList的<strong>双向链表</strong>。它也可以被当作堆栈、队列或双端队列进行操作。</li><li>LinkedList 实现 List 接口，能对它进行<strong>队列操作</strong>。</li><li>LinkedList 实现 Deque 接口，即能将LinkedList当作<strong>双端队列</strong>使用。</li><li>LinkedList 实现了Cloneable接口，即覆盖了函数clone()，<strong>能克隆</strong>。</li><li>LinkedList 实现java.io.Serializable接口，这意味着LinkedList<strong>支持序列化</strong>，能通过序列化去传输。</li><li>LinkedList <strong>不是线程安全的</strong>，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法</li></ul><h4 id="2-1-LinkedList底层分析"><a href="#2-1-LinkedList底层分析" class="headerlink" title="2.1 LinkedList底层分析:"></a>2.1 LinkedList底层分析:</h4><p>LinkedList的底层是一个双向链表，链表中挂载着一个个的Node元素；可以从LinkedList的Node内部类看出奥秘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//头指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//尾指针</span></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item; <span class="comment">// 数据域（当前节点的值）</span></span><br><span class="line">    Node&lt;E&gt; next; <span class="comment">// 后继（指向当前一个节点的后一个节点）</span></span><br><span class="line">    Node&lt;E&gt; prev; <span class="comment">// 前驱（指向当前节点的前一个节点）</span></span><br><span class="line">    <span class="comment">// 构造函数，赋值前驱后继</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LinkedList 是基于链表结构实现，所以在类中包含了 first 和 last 两个指针(Node)。</li><li>Node 中包含了上一个节点和下一个节点的引用，这样就构成了双向的链表。</li></ul><h4 id="2-2-LinkedList增删改查"><a href="#2-2-LinkedList增删改查" class="headerlink" title="2.2 LinkedList增删改查"></a>2.2 LinkedList增删改查</h4><ul><li>链表批量增加，是靠for循环遍历原数组，依次执行插入节点操作。增加一定会修改modCount。</li><li>通过下标获取某个node的时候(add select)，会根据index处于前半段还是后半段<strong>进行一个折半</strong>，以提升查询效率</li><li>删也一定会修改modCount。 <ul><li>按下标删，也是先根据index找到Node，然后去链表上unlink掉这个Node。 </li><li>按元素删，会先去遍历链表寻找是否有该Node，如果有，去链表上unlink掉这个Node。</li></ul></li><li>改也是先根据index找到Node，然后替换值。不修改modCount。</li><li>CRUD操作里，都涉及到根据index去找到Node的操作。</li></ul><h4 id="2-2-unlink原理"><a href="#2-2-unlink原理" class="headerlink" title="2.2 unlink原理"></a>2.2 unlink原理</h4><ul><li>先判断该节点是否存在上一个节点，即是否有前驱节点。<ul><li>无前驱节点则说明要删除的节点为链表的第一节点，那么只需要把该节点的下一个节点设置为链表的第一个节点。</li><li>有前驱节点则需要把前驱节点的尾部引用指向该节点的下一个节点。</li></ul></li><li>再判断该节点是否存在下一个节点，即是否有后继节点。<ul><li>无后继节点则说明该节点是链表的最后一个节点，那么只需要把该节点前驱节点设置成链表的最后一个节点即可。</li><li>有后继节点则需要把后继节点的头部引用指向该节点的上一个节点。</li></ul></li><li>核心就是在于将要删除的节点的前驱节点尾部指向该节点的后继节点，将要删除的节点的后继节点的头部指向该节点的前驱节点。这样便完成了链表的删除操作。</li></ul><blockquote><p>删除和新增方法的实现基本是对该节点的上一个节点和下一个节点的引用设置，不需要操作其他节点，效率相对较高</p></blockquote><h4 id="2-3-offer与add的区别"><a href="#2-3-offer与add的区别" class="headerlink" title="2.3 offer与add的区别"></a>2.3 offer与add的区别</h4><ul><li>offer属于 offer in interface <strong>Deque</strong>。</li><li>add 属于 add in interface <strong>Collection</strong>。</li><li>当队列为空时候，使用add方法会报错，而offer方法会返回false。</li><li>作为List使用时,一般采用add &#x2F; get方法来 压入&#x2F;获取对象。</li><li>作为Queue使用时,才会采用 offer&#x2F;poll&#x2F;take等方法作为链表对象时,offer等方法相对来说没有什么意义这些方法是用于支持队列应用的。</li></ul><h4 id="2-2-对比Vector、ArrayList、LinkedList有何区别"><a href="#2-2-对比Vector、ArrayList、LinkedList有何区别" class="headerlink" title="2.2 对比Vector、ArrayList、LinkedList有何区别"></a>2.2 对比Vector、ArrayList、LinkedList有何区别</h4><p>这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p><ul><li>Vector 是 Java 早期提供的<strong>线程安全</strong>的动态数组，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据扩容为旧容量的<strong>2倍</strong>。</li><li>ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。ArrayList 也是可以根据需要调整容量，在扩容为旧容量的<strong>1.5倍</strong>。</li><li>LinkedList 顾名思义是 Java 提供的双向链表，<strong>不需要扩容</strong>，它也不是线程安全的。LinkedList不支持高效的随机元素访问。</li></ul><h3 id="3-HashMap"><a href="#3-HashMap" class="headerlink" title="3. HashMap"></a>3. HashMap</h3><p>HashMap是<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的, 用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。</p><ul><li>HashMap继承了AbstractMap类，实现了Map，Cloneable，Serializable接口</li><li>继承 abstractMap，也就是用来减轻实现Map接口的编写负担。</li><li>实现 Cloneable：能够使用Clone()方法，在HashMap中，实现的是<strong>浅层次拷贝</strong>，即对拷贝对象的改变会影响被拷贝的对象。</li><li>实现 Serializable：能够使之<strong>序列化</strong>，即可以将HashMap对象保存至本地，之后可以恢复状态。</li></ul><blockquote><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，<strong>当链表长度大于阈值（默认为 8）时，将链表转化为红黑树</strong>，以实现O(logn)时间复杂读查找。</p></blockquote><p>HashMap类中有一个非常重要的字段，就是 Node[] table，即<strong>哈希桶数组</strong>，明显它是一个Node的数组。</p><ul><li>HashMap的实例有两个参数影响其性能:<ul><li>初始容量(默认16)：哈希表中桶的数量</li><li>加载因子(默认0.75)：哈希表在其容量自动增加之前可以达到多满的一种尺度</li></ul></li><li>当哈希表中条目数超出了当前容量*加载因子(其实就是HashMap的实际容量)时，则对该哈希表进行rehash操作，将哈希表扩充至两倍的桶数。</li></ul><h4 id="3-1-HashMap的-put-方法过程-（重点）"><a href="#3-1-HashMap的-put-方法过程-（重点）" class="headerlink" title="3.1 HashMap的 put 方法过程*（重点）"></a>3.1 HashMap的 put 方法过程*（重点）</h4><p>put方法内部是一个 <code>putVal</code> 的调用：</p><ol><li>对 Key 求 Hash 值，然后再计算下标。</li><li>如果没有碰撞，直接放入桶中，</li><li>如果碰撞了，若是树节点，就<code>putTreeVal</code>添加元素，若不是就遍历链表插入。</li><li>如果链表长度超过阀值（TREEIFY_THRESHOLD&#x3D;&#x3D;8），就把链表转成红黑树。</li><li>如果节点已经存在就替换旧值，若未找到则继续</li><li>如果桶满了（容量 * 加载因子），就需要 resize(扩容为原来2倍并重新散列,元素的下标要么不变，要么变为「原下标+原容量」)。</li></ol><h4 id="3-2-HashMap-桶下标计算"><a href="#3-2-HashMap-桶下标计算" class="headerlink" title="3.2 HashMap 桶下标计算"></a>3.2 HashMap 桶下标计算</h4><ul><li><strong>下标</strong>：<code>hash(key) &amp; (table.length - 1)</code></li><li>扰动函数**hash(key)**：(key&#x3D;&#x3D;null) ? 0 : <code>(key.hashCode()^(key.hashCode() &gt;&gt;&gt; 16))</code></li><li>低16位 和 高 16位 做了一个<strong>异或</strong>得到 hash值 与 (容器长度-1)进行**取模(%)**运算,得到下标。<ul><li>利用位运算代替取模运算，提高程序的计算效率：（当 b&#x3D;2^n 时，a%b &#x3D; a &amp; (b-1) ），也是因此，HashMap 才将初始长度设置为 16，且扩容只能是以 2 的倍数（2^n）扩容。</li></ul></li><li>有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以尽可能有效的避免哈希碰撞。</li></ul><blockquote><p>HashMap 的性能表现非常依赖于哈希码的有效性: equals相等，hashCode一定要相等。重写了 hashCode 也要重写 equals。hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</p></blockquote><h4 id="3-3-HashMap-容量、负载因子和树化"><a href="#3-3-HashMap-容量、负载因子和树化" class="headerlink" title="3.3 HashMap 容量、负载因子和树化"></a>3.3 HashMap 容量、负载因子和树化</h4><ul><li>容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。</li><li>如果能够知道 HashMap 要存取的键值对数量，可以考虑预先设置合适的容量大小。</li><li>计算条件：<strong>负载因子 * 容量 &gt; 元素数量</strong>；所以，预先设置的容量需要满足，大于“预估元素数量&#x2F;负载因子”，同时它是<strong>2的幂数</strong></li><li>容量理论最大极限由 MAXIMUM_CAPACITY 指定，数值为 <strong>1&lt;&lt;30</strong>，也就是2的30次方</li></ul><h5 id="3-3-1-HashMap-负载因子loadFactor"><a href="#3-3-1-HashMap-负载因子loadFactor" class="headerlink" title="3.3.1 HashMap 负载因子loadFactor"></a>3.3.1 HashMap 负载因子loadFactor</h5><ul><li>loadFactor加载因子是控制数组存放数据的疏密程度，越大越密，越小越稀疏。</li><li>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的<strong>默认值为0.75f</strong>是官方给出的一个比较好的临界值。</li><li>给定的默认容量为16，负载因子为0.75。当数量达到了 16*0.75 &#x3D; 12 就需要将当前16的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</li><li>而对于负载因子，建议：<ul><li>如果没有特别需求，不要轻易进行更改，因为 JDK 自身的默认负载因子是非常符合通用场景的需求的。</li><li>如果确实需要调整，建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li><li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li></ul></li></ul><h5 id="3-3-2-HashMap-门限值threshold"><a href="#3-3-2-HashMap-门限值threshold" class="headerlink" title="3.3.2 HashMap 门限值threshold"></a>3.3.2 HashMap 门限值threshold</h5><p><code>threshold = capacity * loadFactor</code>，当<code>Size&gt;=threshold</code>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。</p><ul><li>门限值等于(负载因子 x 容量)，如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li><li>门限通常是以倍数进行调整 （newThr &#x3D; oldThr &lt;&lt; 1），根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li><li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li></ul><h5 id="3-3-2-HashMap-树化改造"><a href="#3-3-2-HashMap-树化改造" class="headerlink" title="3.3.2 HashMap 树化改造"></a>3.3.2 HashMap 树化改造</h5><p>树化改造逻辑主要在 putVal 和 <code>treeifyBin</code> 中。</p><ul><li>链表结构（这里叫 bin）的数量大于 <code>TREEIFY_THRESHOLD</code>(默认为8) 时：<ul><li>如果容量小于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64) ，只会进行简单的扩容。</li><li>如果容量大于 <code>MIN_TREEIFY_CAPACITY</code>(默认为64)，则会进行树化改造。</li></ul></li></ul><h4 id="3-4-HashMap-扩容resize"><a href="#3-4-HashMap-扩容resize" class="headerlink" title="3.4 HashMap 扩容resize"></a>3.4 HashMap 扩容resize</h4><ul><li>HashMap扩容条件：<ul><li>元素个数超出了加载因子与当前容量的乘积，并且发生了Hash碰撞</li></ul></li><li>HashMap扩容步骤：<ol><li>创建一个新的Entry空数组，长度是原来的2倍。</li><li>遍历原Entry数组，把所有的Entry重新Hash到新数组里。</li><li>重新散列的元素下标要么「不变」，要么变为「原下标+原容量」，取决于位运算((n - 1) &amp; hash)</li></ol></li></ul><blockquote><p>经过一次扩容处理后，元素会更加均匀的分布在各个桶中，会提升访问效率。<br>但会遍历所有的元素，时间复杂度很高；遍历元素所带来的坏处大于元素在桶中均匀分布所带来的好处。<br>尽量避免进行扩容处理。</p></blockquote><h4 id="3-5-常见的hash算法及冲突的解决"><a href="#3-5-常见的hash算法及冲突的解决" class="headerlink" title="3.5 常见的hash算法及冲突的解决"></a>3.5 常见的hash算法及冲突的解决</h4><p>hash函数，即散列函数。它可以将不定长的输入，通过散列算法转换成一个定长的输出，这个输出就是散列值(不保证唯一)。</p><ul><li>常见Hash算法：<ol><li>直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址（H(k)&#x3D;ak+b）。</li><li>数字分析法：提取关键字中取值比较均匀的数字作为哈希地址（如一组出生日期，相较于年-月，月-日的差别要大得多，可以降低冲突概率）</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。</li><li>伪随机数法：选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址（H(k)&#x3D;k%p, p&lt;&#x3D;m; p一般取m或素数）。</li></ol></li><li>常见解决hash冲突的方法<ol><li>链地址法：将哈希表的每个单元作为链表的头结点，所有哈希地址为 i 的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li><li>开放定址法：即发生冲突时，去寻找下一个空的哈希地址。只要哈希表足够大，总能找到空的哈希地址。</li><li>再哈希法：即发生冲突时，由其他的函数再计算一次哈希值。</li><li>建立公共溢出区：将哈希表分为基本表和溢出表，发生冲突时，将冲突的元素放入溢出表。</li></ol></li></ul><blockquote><p>HashMap就是使用链地址法来解决冲突的（JDK1.8增加了红黑树）</p></blockquote><h4 id="3-6-对比Hashtable、HashMap、TreeMap有什么不同"><a href="#3-6-对比Hashtable、HashMap、TreeMap有什么不同" class="headerlink" title="3.6 对比Hashtable、HashMap、TreeMap有什么不同"></a>3.6 对比Hashtable、HashMap、TreeMap有什么不同</h4><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以键值对的形式存储和操作数据的容器类型。</p><ul><li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li><li>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</li><li>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O(log(n))的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「网络协议」网络协议基础</title>
      <link href="/2019/07/15/network-protocol.html"/>
      <url>/2019/07/15/network-protocol.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-分层网络协议"><a href="#1-分层网络协议" class="headerlink" title="1. 分层网络协议"></a>1. 分层网络协议</h3><ol><li>OSI七层网络协议：物理层，数据链路层，网络层，传输层(TCP&#x2F;UDP)，会话层，表示层，应用层</li><li>TCP&#x2F;IP协议分层(可以理解为OSI的一种实现)：网络接口层，网络层，传输层(TCP&#x2F;UDP)，应用层<span id="more"></span></li></ol><h3 id="2-TCP通信协议简介："><a href="#2-TCP通信协议简介：" class="headerlink" title="2. TCP通信协议简介："></a>2. TCP通信协议简介：</h3><ul><li>面向连接的、可靠的、基于字节流的 传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和来校验数据在传输过程中是否有误</li><li>报文头中的ACK(确认序号标志)，SYN(同步序号，用于建立连接过程)</li></ul><h3 id="3-TCP建立连接的三次握手"><a href="#3-TCP建立连接的三次握手" class="headerlink" title="3. TCP建立连接的三次握手"></a>3. TCP建立连接的三次握手</h3><ol><li>第一次：建立连接时，客户端发送<code>SYN包(syn=j)</code>到服务器，并进入<code>SYS_SEND</code>状态，等待服务器确认；</li><li>第二次：服务器收到<code>SYN包</code>，必须确认客户的<code>SYN(ack=j+1)</code>，同时自己也发送一个<code>SYN包(syn=k)</code>，即 <code>SYN+ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态；</li><li>第三次：客户端收到<code>SYN+ACK包</code>，向服务器发送确认包<code>ACK(ack=k+1)</code>，此包发送完毕，客户端和服务端进入<code>ESTABLISHED</code>状态，完成三次握手。</li></ol><h3 id="4-为什么需要三次握手"><a href="#4-为什么需要三次握手" class="headerlink" title="4. 为什么需要三次握手"></a>4. 为什么需要三次握手</h3><ul><li>为了初始化Sequence Number的初始值（通信双方要互相通知对方自己的Sequence Number，要作为以后数据通信的序号，以保证接收到的数据不会因为网络传输问题而乱序，TCP会用这个序号拼接数据）</li></ul><h3 id="5-首次握手的隐患—SYN超时"><a href="#5-首次握手的隐患—SYN超时" class="headerlink" title="5. 首次握手的隐患—SYN超时"></a>5. 首次握手的隐患—SYN超时</h3><ul><li>服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认</li><li>服务端不断尝试(重发SYN-ACK)直至超时，Linux默认等待63秒才断开连接(默认重试5次，重试间隔1s开始，每次翻倍，即1+2+4+8+16+32&#x3D;63)</li><li>可能遭受SYN Flood的风险(syn攻击，又称为ddos攻击)</li></ul><h3 id="6-什么是SYN-Flood攻击"><a href="#6-什么是SYN-Flood攻击" class="headerlink" title="6. 什么是SYN Flood攻击"></a>6. 什么是SYN Flood攻击</h3><ul><li>客户端恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。而攻击发起方的资源消耗相比较可忽略不计。</li><li>SYN Flood是当前最流行的DoS（拒绝服务攻击）与DDoS（分布式拒绝服务攻击）的方式之一。</li></ul><h3 id="7-Linux针对SYN-Flood的防护措施"><a href="#7-Linux针对SYN-Flood的防护措施" class="headerlink" title="7. Linux针对SYN Flood的防护措施"></a>7. Linux针对SYN Flood的防护措施</h3><ul><li>SYN队列满后，通过tcp_syncookies参数回发SYN Cookies</li><li>若为正常连接则客户端会回发SYN Cookies，直接建立连接</li></ul><h3 id="8-建立连接后，客户端出现故障怎么办（保活机制）"><a href="#8-建立连接后，客户端出现故障怎么办（保活机制）" class="headerlink" title="8. 建立连接后，客户端出现故障怎么办（保活机制）"></a>8. 建立连接后，客户端出现故障怎么办（保活机制）</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测树仍未收到响应则中断连接</li></ul><h3 id="9-TCP终止连接的四次挥手（以客户端主动为例）"><a href="#9-TCP终止连接的四次挥手（以客户端主动为例）" class="headerlink" title="9. TCP终止连接的四次挥手（以客户端主动为例）"></a>9. TCP终止连接的四次挥手（以客户端主动为例）</h3><ol><li>第一次：客户端发送一个<code>FIN(seq=u)</code>，用来关闭客户端到服务器的数据传送，客户端进入<code>FIN_WAIT_1</code>状态；</li><li>第二次：服务器收到<code>FIN</code>，发回一个<code>ACK(ack=u+1)</code>，确认序号为收到的序号+1(和SYN一样，一个FIN将占用一个序号)，服务端进入<code>CLOSE_WAIT</code>状态；</li><li>第三次：服务端发送一个<code>FIN(seq=w)</code>，用来关闭服务端到客户端的数据传送，服务端进入<code>LAST_ACK</code>状态；</li><li>第四次：客户端收到<code>FIN</code>，发回一个<code>ACK(ack=w+1)</code>，将确认序号设置为收到序号+1，客户端进入<code>TIME_WAIT</code>状态，服务端进入<code>CLOSED</code>状态，完成四次挥手。</li></ol><h3 id="10-存在TIME-WAIT状态的原因"><a href="#10-存在TIME-WAIT状态的原因" class="headerlink" title="10. 存在TIME_WAIT状态的原因"></a>10. 存在TIME_WAIT状态的原因</h3><ul><li>保证TCP全双工连接的可靠释放，确保有足够时间让对方收到ACK包</li><li>避免新旧来凝结混淆，使旧数据包在网络中因过期而失效</li></ul><h3 id="11-为什么需要四次挥手"><a href="#11-为什么需要四次挥手" class="headerlink" title="11. 为什么需要四次挥手"></a>11. 为什么需要四次挥手</h3><ul><li>因为全双工，发送方和接收方都需要FIN报文和ACK报文</li></ul><h3 id="12-服务器出现大量CLOSE-WAIT状态的原因"><a href="#12-服务器出现大量CLOSE-WAIT状态的原因" class="headerlink" title="12. 服务器出现大量CLOSE_WAIT状态的原因"></a>12. 服务器出现大量CLOSE_WAIT状态的原因</h3><ul><li>对方关闭socket连接，我方忙于读或写，没有及时关闭连接<ul><li>检查代码，特别是释放资源的代码</li><li>检查配置，特别是处理请求的线程配置</li></ul></li></ul><h3 id="13-UDP简介"><a href="#13-UDP简介" class="headerlink" title="13. UDP简介"></a>13. UDP简介</h3><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同消息</li><li>数据包报头只有8个字节，额外开销小</li><li>吞吐量只受限于数据生成速率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠性，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或者合并</li></ul><h3 id="14-TCP和UDP的区别"><a href="#14-TCP和UDP的区别" class="headerlink" title="14. TCP和UDP的区别"></a>14. TCP和UDP的区别</h3><ul><li>面向连接 vs 无连接</li><li>可靠性和有序性 vs 不保证</li><li>全双工的字节流 vs 全双工的数据报</li><li>效率低 vs 速度快</li><li>重量级 vs 轻量级</li></ul><h3 id="15-Http协议简介"><a href="#15-Http协议简介" class="headerlink" title="15. Http协议简介"></a>15. Http协议简介</h3><ul><li>基于TCP&#x2F;IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等），Hyper Text Transfer Protocol（超文本传输协议）的缩写。</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法(GET、HEAD、POST等)和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li><strong>无连接</strong>：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</li><li><strong>支持B&#x2F;S及C&#x2F;S模式</strong>。</li></ul><h3 id="16-HTTP-请求-x2F-响应的步骤"><a href="#16-HTTP-请求-x2F-响应的步骤" class="headerlink" title="16. HTTP 请求&#x2F;响应的步骤"></a>16. HTTP 请求&#x2F;响应的步骤</h3><ol><li>客户端连接到Web服务器<ul><li>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="https://chaooo.github.io/">https://chaooo.github.io</a>。</li></ul></li><li>发送HTTP请求<ul><li>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li></ul></li><li>服务器接受请求并返回HTTP响应<ul><li>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li></ul></li><li>释放连接TCP连接<ul><li>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li></ul></li><li>客户端浏览器解析HTML内容<ul><li>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li></ul></li></ol><h3 id="17-在浏览器地址栏键入URL，按下回车之后会经历以下流程："><a href="#17-在浏览器地址栏键入URL，按下回车之后会经历以下流程：" class="headerlink" title="17. 在浏览器地址栏键入URL，按下回车之后会经历以下流程："></a>17. 在浏览器地址栏键入URL，按下回车之后会经历以下流程：</h3><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>释放 TCP连接;</li><li>浏览器将该 html 文本并显示内容;</li></ol><p> 　</p><h3 id="18-HTTP之状态码"><a href="#18-HTTP之状态码" class="headerlink" title="18. HTTP之状态码"></a>18. HTTP之状态码</h3><ol><li>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:<ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul></li><li>常见状态码：<ul><li>200 OK                    &#x2F;&#x2F;客户端请求成功</li><li>400 Bad Request           &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解</li><li>401 Unauthorized          &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </li><li>403 Forbidden             &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务</li><li>404 Not Found             &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL</li><li>500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误</li><li>503 Server Unavailable    &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul></li></ol><h3 id="19-HTTPS和HTTP的区别："><a href="#19-HTTPS和HTTP的区别：" class="headerlink" title="19. HTTPS和HTTP的区别："></a>19. HTTPS和HTTP的区别：</h3><ol><li>https协议需要到CA申请证书(收费)，http不需要。</li><li>https密文传输，http明文传输。</li><li>http使用80端口，https默认使用443端口。</li><li>https &#x3D; http + 加密 + 认证 + 完整性保护</li></ol><h3 id="20-Socket简介"><a href="#20-Socket简介" class="headerlink" title="20. Socket简介"></a>20. Socket简介</h3><ul><li><p>Socket是对TCP&#x2F;IP协议的抽象，是操作系统对外开发的接口</p></li><li><p>基于tcp协议的编程模型</p><ul><li>服务器：<ol><li>创建ServerSocket类型的对象并提供端口号；</li><li>等待客户端的连接请求，调用accept方法；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li><li>客户端：<ol><li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li></ul></li><li><p>基于udp协议的编程模型</p><ul><li>主机A(接收方):<ol><li>创建DatagramSocket类型的对象，并提供端口号；</li><li>创建DatagramPacket类型的对象，用于接收发来的数据；</li><li>从Socket中接收数据，调用**receive()**方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li><li>主机B(发送方)<ol><li>创建DatagramSocket类型的对象；</li><li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li><li>通过Socket发送数据，调用**send()**方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> java </tag>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Redis」基于Redis的分布式锁实现</title>
      <link href="/2019/04/08/redis-lock.html"/>
      <url>/2019/04/08/redis-lock.html</url>
      
        <content type="html"><![CDATA[<h3 id="SETNX命令简介"><a href="#SETNX命令简介" class="headerlink" title="SETNX命令简介"></a>SETNX命令简介</h3><ul><li><code>SETNX key value</code>返回(<code>1:key</code>的值被设置，<code>0:key</code>的值没被设置)，将<code>key</code>的值设为<code>value</code>，并且仅当<code>key</code>不存在。</li><li>锁的<code>key</code>为目标数据的唯一键，<code>value</code>为锁的期望超时时间点；</li><li>基于<code>Redis</code>实现的分布式锁，主要基于<code>redis</code>的<code>setnx（set if not exist）</code>命令；<span id="more"></span></li></ul><h3 id="1-jedis实现分布式锁"><a href="#1-jedis实现分布式锁" class="headerlink" title="1. jedis实现分布式锁"></a>1. jedis实现分布式锁</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-1-实现示例"><a href="#1-1-实现示例" class="headerlink" title="1.1 实现示例:"></a>1.1 实现示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">correctGetLock</span><span class="params">(String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jedis.set(String key, String value, String nxxx, String expx, int time)</code><br>    - **<code>key</code>**：保证唯一，用来当锁（<code>redis</code>记录的<code>key</code>）<br>    - **<code>value</code>**：<code>redis</code>记录的<code>value</code>，目的是为了标志锁的所有者（竞争锁的客户端），保证解锁时只能解自己加的锁。<code>requestId</code>可以使用<code>UUID.randomUUID().toString()</code>方法生成<br>    - **<code>nxxx</code>**：<code>&quot;NX&quot;</code>意思是<code>SET IF NOT EXIST</code>，即当<code>key</code>不存在时，我们进行<code>set</code>操作，若<code>key</code>已经存在，则不做任何操作<br>    - **<code>expx</code>**：<code>&quot;PX&quot;</code>意思是要给这个<code>key</code>加一个过期的设置（单位毫秒），过期时间由第五个参数决定<br>    - **<code>time</code>**：<code>expx</code>设置为<code>&quot;PX&quot;</code>时，<code>redis key</code>的过期时间</p><h4 id="1-2-解锁示例"><a href="#1-2-解锁示例" class="headerlink" title="1.2 解锁示例:"></a>1.2 解锁示例:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">correctReleaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>eval</code>命令执行<code>Lua</code>代码的时候，<code>Lua</code>代码将被当成一个命令去执行，并且直到<code>eval</code>命令执行完成，<code>Redis</code>才会执行其他命令，所以保证了检查和删除操作都是原子的。</p><h4 id="1-3-这类琐最大的缺点"><a href="#1-3-这类琐最大的缺点" class="headerlink" title="1.3 这类琐最大的缺点"></a>1.3 这类琐最大的缺点</h4><p>加锁时只作用在一个<code>Redis</code>节点上，即使<code>Redis</code>通过<code>sentinel</code>保证高可用，如果这个<code>master</code>节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p><ol><li>在<code>Redis</code>的<code>master</code>节点上拿到了锁；</li><li>但是这个加锁的<code>key</code>还没有同步到<code>slave</code>节点；</li><li><code>master</code>故障，发生故障转移，<code>slave</code>节点升级为<code>master</code>节点；</li><li>导致锁丢失。</li></ol><blockquote><p>因此，<code>Redis</code>作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：<code>Redlock</code>。基于<code>Redis</code>的<code>Redisson</code>实现了<code>Redlock</code>。</p></blockquote><h3 id="2-Redisson实现普通分布式锁"><a href="#2-Redisson实现普通分布式锁" class="headerlink" title="2. Redisson实现普通分布式锁"></a>2. Redisson实现普通分布式锁</h3><p>普通分布式实现非常简单，无论是那种架构，向<code>Redis</code>通过<code>EVAL</code>命令执行<code>LUA脚本</code>即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>单机模式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造redisson实现分布式锁必要的Config</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSingleServer().setAddress(<span class="string">&quot;redis://172.29.1.180:5379&quot;</span>)</span><br><span class="line">                        .setPassword(<span class="string">&quot;a123456&quot;</span>).setDatabase(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 构造RedissonClient</span></span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"><span class="comment">// 设置锁定资源名称, 还可以getFairLock(), getReadWriteLock()</span></span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;DISLOCK&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> isLock;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取分布式锁</span></span><br><span class="line">    <span class="comment">// 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span><br><span class="line">    isLock = lock.tryLock(<span class="number">500</span>, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哨兵模式:</strong><br>即<code>Sentinel</code>模式，实现代码和单机模式几乎一样，唯一的不同就是<code>Config</code>的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useSentinelServers().addSentinelAddress(</span><br><span class="line">        <span class="string">&quot;redis://172.29.3.245:26378&quot;</span>,<span class="string">&quot;redis://172.29.3.245:26379&quot;</span>, <span class="string">&quot;redis://172.29.3.245:26380&quot;</span>)</span><br><span class="line">      .setMasterName(<span class="string">&quot;mymaster&quot;</span>).setPassword(<span class="string">&quot;a123456&quot;</span>).setDatabase(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>集群模式:</strong><br>即<code>Cluster</code>模式，集群模式构造<code>Config</code>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useClusterServers().addNodeAddress(</span><br><span class="line">        <span class="string">&quot;redis://172.29.3.245:6375&quot;</span>,<span class="string">&quot;redis://172.29.3.245:6376&quot;</span>, <span class="string">&quot;redis://172.29.3.245:6377&quot;</span>,</span><br><span class="line">        <span class="string">&quot;redis://172.29.3.245:6378&quot;</span>,<span class="string">&quot;redis://172.29.3.245:6379&quot;</span>, <span class="string">&quot;redis://172.29.3.245:6380&quot;</span>)</span><br><span class="line">      .setPassword(<span class="string">&quot;a123456&quot;</span>).setScanInterval(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure><h3 id="3-Redisson实现Redlock分布式锁"><a href="#3-Redisson实现Redlock分布式锁" class="headerlink" title="3. Redisson实现Redlock分布式锁"></a>3. Redisson实现Redlock分布式锁</h3><h4 id="3-1-Redlock算法大概原理："><a href="#3-1-Redlock算法大概原理：" class="headerlink" title="3.1 Redlock算法大概原理："></a>3.1 Redlock算法大概原理：</h4><ul><li>在<code>Redis</code>的分布式环境中，我们假设有<code>N</code>个<code>Redis master</code>。这些节点<strong>完全互相独立，不存在主从复制或者其他集群协调机制</strong>。我们确保将在<code>N</code>个实例上使用与在<code>Redis</code>单实例下相同方法获取和释放锁。</li><li>为了取到锁，客户端应该执行以下操作:<ul><li>获取当前<code>Unix</code>时间，以毫秒为单位。</li><li>依次尝试从<code>N</code>个实例，使用相同的<code>key</code>和具有唯一性的<code>value</code>（例如UUID）获取锁。</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。</li><li><strong>当且仅当(N&#x2F;2+1)的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</strong>，例如3个节点至少需要<code>3/2+1=2</code>2个。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li><li>若获取锁失败，客户端应该在<strong>所有的Redis实例上进行解锁</strong>（即便某些Redis实例根本就没有加锁成功）。</li></ul></li></ul><h4 id="3-2-使用Redlock"><a href="#3-2-使用Redlock" class="headerlink" title="3.2 使用Redlock"></a>3.2 使用<code>Redlock</code></h4><p>单机模式<code>Redis</code>为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config.useClusterServers().addNodeAddress(</span><br><span class="line">        <span class="string">&quot;redis://127.0.0.1:6379&quot;</span>,<span class="string">&quot;redis://127.0.0.1:6369&quot;</span>, <span class="string">&quot;redis://127.0.0.1:6359&quot;</span>,</span><br><span class="line">        <span class="string">&quot;redis://127.0.0.1:6349&quot;</span>,<span class="string">&quot;redis://127.0.0.1:6339&quot;</span>)</span><br><span class="line">        .setPassword(<span class="string">&quot;******&quot;</span>);</span><br><span class="line"><span class="comment">// 节点1</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config1.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient1</span> <span class="operator">=</span> Redisson.create(config1);</span><br><span class="line"><span class="comment">// 节点2</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config2.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6378&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient2</span> <span class="operator">=</span> Redisson.create(config2);</span><br><span class="line"><span class="comment">// 节点3</span></span><br><span class="line"><span class="type">Config</span> <span class="variable">config3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">config3.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6377&quot;</span>);</span><br><span class="line"><span class="type">RedissonClient</span> <span class="variable">redissonClient3</span> <span class="operator">=</span> Redisson.create(config3);</span><br><span class="line"><span class="comment">// 设置锁定资源名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">resourceName</span> <span class="operator">=</span> <span class="string">&quot;REDLOCK&quot;</span>;</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient1.getLock(resourceName);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(resourceName);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(resourceName);</span><br><span class="line"><span class="comment">// 实例化RedissonRedLock</span></span><br><span class="line"><span class="type">RedissonRedLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redLock.tryLock(<span class="number">500</span>, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">//TODO if get lock success, do something;</span></span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    redLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的变化就是 <code>RedissonRedLock redLock</code>&#x3D;**<code>new RedissonRedLock(lock1,lock2,lock3)</code>;**，因为我这里是以三个节点为例。</p><ul><li>如果是主从<code>Redis</code>架构、哨兵<code>Redis</code>架构、集群<code>Redis</code>架构实现<code>Redlock</code>，只需要改变上述<code>config1</code>、<code>config2</code>、<code>config3</code>为主从模式、哨兵模式、集群模式配置即可，但相应需要<code>3</code>个独立的<code>Redis</code>主从集群、<code>3</code>个<code>Redis</code>独立的哨兵集群、<code>3</code>个独立的<code>Cluster</code>集群。</li><li>以<code>sentinel</code>模式架构为例，<code>3</code>个<code>sentinel</code>模式集群，如果要获取分布式锁，那么需要向这<code>3</code>个<code>sentinel</code>集群通过<code>EVAL</code>命令执行<code>LUA</code>脚本，需要<code>3/2+1=2</code>，即至少2个<code>sentinel</code>集群响应成功，才算成功的以<code>Redlock</code>算法获取到分布式锁。</li></ul><h3 id="4-Redlock问题合集"><a href="#4-Redlock问题合集" class="headerlink" title="4. Redlock问题合集"></a>4. Redlock问题合集</h3><h4 id="4-1-N个节点的理解"><a href="#4-1-N个节点的理解" class="headerlink" title="4.1 N个节点的理解"></a>4.1 N个节点的理解</h4><p>假设我们用<code>N(&gt;=3)</code>个节点实现<code>Redlock</code>算法的分布式锁。<strong>不是</strong>一个有<code>N</code>个主节点的cluster集群；而是<strong>要么是<code>N</code>个redis单实例，要么是<code>N</code>个sentinel集群，要么是<code>N</code>个cluster集群</strong>。</p><h4 id="4-2-失效时间如何设置"><a href="#4-2-失效时间如何设置" class="headerlink" title="4.2 失效时间如何设置"></a>4.2 失效时间如何设置</h4><p>这个问题的场景是，假设设置失效时间10秒，如果由于某些原因导致10秒还没执行完任务，这时候锁自动失效，导致其他线程也会拿到分布式锁。<br>这确实是Redis分布式最大的问题，不管是普通分布式锁，还是Redlock算法分布式锁，都没有解决这个问题。也有一些文章提出了对失效时间续租，即延长失效时间，很明显这又提升了分布式锁的复杂度（没有现成的框架有实现）。</p><h4 id="4-3-redis分布式锁的高可用"><a href="#4-3-redis分布式锁的高可用" class="headerlink" title="4.3 redis分布式锁的高可用"></a>4.3 redis分布式锁的高可用</h4><p>关于Redis分布式锁的安全性问题，在分布式系统专家Martin Kleppmann和Redis的作者Antirez之间已经发生过一场争论。有兴趣的同学，搜索”基于Redis的分布式锁到底安全吗”就能得到你想要的答案，需要注意的是，有上下两篇（这应该就是传说中的神仙打架吧）。</p><h4 id="4-4-使用Zookeeper还是Redis实现分布式锁"><a href="#4-4-使用Zookeeper还是Redis实现分布式锁" class="headerlink" title="4.4 使用Zookeeper还是Redis实现分布式锁"></a>4.4 使用Zookeeper还是Redis实现分布式锁</h4><p>没有绝对的好坏，只有更适合自己的业务。<br>就<strong>性能</strong>而言，<code>Redis</code>很明显优于<code>Zookeeper</code>；就分布式锁实现的健壮性(<strong>高可用</strong>)而言，<code>Zookeeper</code>很明显优于<code>Redis</code>。至于如何选择，还要看具体业务场景。</p><blockquote><p>参考：<a href="https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ">https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Redis」Redis穿透、击穿、雪崩和数据一致性</title>
      <link href="/2019/03/27/redis-consistency.html"/>
      <url>/2019/03/27/redis-consistency.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h3><p>访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。</p><ul><li>解决方案：<ol><li>采用布隆过滤器（bloomfilter就类似于一个hash set），使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；</li><li>访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。</li><li>接口限流与熔断、降级</li><li>使用互斥锁排队（分布式环境中要使用分布式锁，单机的话用普通的锁（synchronized、Lock））</li></ol></li></ul><span id="more"></span><h3 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h3><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p><ul><li>解决方案<ol><li>可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。</li><li>建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</li><li>加锁排队，实现同上;</li></ol></li></ul><h3 id="3-缓存击穿"><a href="#3-缓存击穿" class="headerlink" title="3. 缓存击穿"></a>3. 缓存击穿</h3><p>一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。</p><ul><li>解决方案<ul><li>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。</li></ul></li></ul><h3 id="4-缓存并发竞争"><a href="#4-缓存并发竞争" class="headerlink" title="4. 缓存并发竞争"></a>4. 缓存并发竞争</h3><p>多个redis的client同时set key引起的并发问题（例如：多客户端同时并发写一个key，一个key的值是1，本来按顺序修改为2,3,4，最后是4，但是顺序变成了4,3,2，最后变成了2）</p><ul><li>解决方案<ol><li>如果对这个key操作，不要求顺序：准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可。</li><li>如果对这个key操作，要求顺序：<ol><li>分布式锁+时间戳（假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00&lt;7:05），那就不做set操作了）</li><li>利用消息队列（把Redis.set操作放在队列中使其串行化,必须的一个一个执行）</li></ol></li></ol></li></ul><h3 id="5-缓存和数据库一致性解决方案"><a href="#5-缓存和数据库一致性解决方案" class="headerlink" title="5. 缓存和数据库一致性解决方案"></a>5. 缓存和数据库一致性解决方案</h3><h4 id="5-1-并发量、一致性要求都不是很高的场景"><a href="#5-1-并发量、一致性要求都不是很高的场景" class="headerlink" title="5.1 并发量、一致性要求都不是很高的场景"></a>5.1 并发量、一致性要求都不是很高的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，之后再<strong>异步将数据刷回缓存</strong></li><li>读流程：先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：实现起来简单，异步刷新，补缺补漏</li><li>缺点：容灾不足，并发问题，一个比较大的缺陷在于刷新缓存有可能会失败，而失败之后缓存中数据就一直会处于错误状态，所以它并不能保证数据的最终一致性</li></ol><h4 id="5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）"><a href="#5-2-业务简单，读写QPS比较低的场景（QPS每秒查询率-Query-Per-Second-）" class="headerlink" title="5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）"></a>5.2 业务简单，读写QPS比较低的场景（QPS每秒查询率(Query Per Second)）</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库</strong>，监听从库binlog，通过<strong>解析binlog来刷新缓存</strong></li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据刷回缓存</li></ul><ol><li>优点：容灾</li><li>缺点：只适合简单业务，复杂业务容易发生并发问题（例如：读&#x2F;写的时候，缓存中的数据已失效，此时又发生了更新）</li></ol><h4 id="5-3-业务只需要达到“最终一致性”要求的场景"><a href="#5-3-业务只需要达到“最终一致性”要求的场景" class="headerlink" title="5.3 业务只需要达到“最终一致性”要求的场景"></a>5.3 业务只需要达到“最终一致性”要求的场景</h4><ul><li>写流程：<strong>先淘汰缓存，再写数据库，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的<strong>数据标识</strong>，然后将<strong>数据标识写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li><li>读流程：第一步先读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：只能达到”最终一致性”</li></ol><h4 id="5-4-强一致性的场景"><a href="#5-4-强一致性的场景" class="headerlink" title="5.4 强一致性的场景"></a>5.4 强一致性的场景</h4><ul><li>写流程：我们把<strong>修改的数据通过Cache_0标记</strong>“正在被修改”，如果<strong>标记成功，写数据库，删除缓存，监听从库binlog</strong>，通过分析binlog我们解析出需要需要刷新的数据标识，然后将数据标识<strong>写入MQ</strong>，接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存； 那如果标记失败，则要放弃这次修改。</li><li>读流程：先读Cache_0，看看要读的数据是否被标记，如果被标记，则直接读主库；如果没有被标记，读缓存，如果缓存没读到，则去读DB，之后再异步将数据标识写入MQ（这里MQ与写流程的MQ是同一个），接下来就消费MQ，解析MQ消息来读库获取相应的数据刷新缓存。</li></ul><ol><li>优点：容灾完善，无并发问题</li><li>缺点：增加Cache_0强依赖，复杂度是比较高的（涉及到Databus、MQ、定时任务等等组件）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Redis」深入学习Redis及集群</title>
      <link href="/2019/03/20/redis-cluster.html"/>
      <url>/2019/03/20/redis-cluster.html</url>
      
        <content type="html"><![CDATA[<p>Redis本质上是一个Key-Value类型的<strong>内存数据库</strong>，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过10万次读写操作，是已知性能最快的Key-Value DB。</p><span id="more"></span><p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB。另外Redis也可以对存入的Key-Value设置expire时间。 Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p><h3 id="1-Redis数据结构及命令操作"><a href="#1-Redis数据结构及命令操作" class="headerlink" title="1. Redis数据结构及命令操作"></a>1. Redis数据结构及命令操作</h3><h4 id="1-1-基本概念及操作"><a href="#1-1-基本概念及操作" class="headerlink" title="1.1 基本概念及操作"></a>1.1 基本概念及操作</h4><ul><li>默认16个数据库，类似数组下表从零开始，初始默认使用零号库；</li><li>统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上，redis默认端口是6379；</li><li>select命令切换数据库：select 0-15；</li><li>dbsize：查看当前数据库的key的数量；</li><li>flushdb：清空当前库；</li><li>flushall；通杀全部库；</li></ul><h4 id="1-2-Redis数据结构"><a href="#1-2-Redis数据结构" class="headerlink" title="1.2 Redis数据结构"></a>1.2 Redis数据结构</h4><p>redis存储的是：key-value格式的数据，其中key都是字符串，value有5种不同的数据结构:String、Hash、List、Set、Zset(Sorted Set)</p><ol><li>String：set, get, del, append, strlen</li><li>Hash：hset, hget, hdel, hmset(批量设值), hmget, hgetall</li><li>List：lpush, rpush, lrange, lpop(删除), rpop, lindex</li><li>Set：sadd, smembers, srem(根据可以移除member), sismember(判断是否为key的成员)</li><li>ZSet：zadd, zrange, zrem</li></ol><h4 id="1-3-Redis键-key-–常用命令介绍"><a href="#1-3-Redis键-key-–常用命令介绍" class="headerlink" title="1.3 Redis键(key)–常用命令介绍"></a>1.3 Redis键(key)–常用命令介绍</h4><ul><li>keys *：查看所有 key ；</li><li>exists key的名字：判断某个 key 是否存在；</li><li>move key dbID（0-15）： 当前库就没有了，被移除了；</li><li>expire key 秒钟： 为给定的 key 设置过期时间；</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期；</li><li>type key： 查看你的 key 是什么类型；</li></ul><h3 id="2-Redis持久化"><a href="#2-Redis持久化" class="headerlink" title="2. Redis持久化"></a>2. Redis持久化</h3><p>Redis作为一个键值对内存数据库(NoSQL)，数据都存储在内存当中，在处理客户端请求时，所有操作都在内存当中进行，为了避免内存中数据丢失，Redis提供了RDB和AOF两种不同的数据持久化方式。</p><h4 id="2-1-RDB（Redis-DataBase）"><a href="#2-1-RDB（Redis-DataBase）" class="headerlink" title="2.1 RDB（Redis DataBase）"></a>2.1 RDB（Redis DataBase）</h4><p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p><ul><li>开启RDB持久化方式一：save命令，或bgsave(异步)</li><li>开启方式二：在Redis配置文件redis.conf配置，配置完后启动时加载：<code>redis-server redis.conf</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save <span class="number">900</span> <span class="number">1</span>     # <span class="number">900</span>s内至少达到一条写命令</span><br><span class="line">save <span class="number">300</span> <span class="number">10</span>    # <span class="number">300</span>s内至少达至<span class="number">10</span>条写命令</span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span>  # <span class="number">60</span>s内至少达到<span class="number">10000</span>条写命令</span><br></pre></td></tr></table></figure><ul><li><p>RDB的几个优点</p><ul><li>与AOF方式相比，通过rdb文件恢复数据比较快。</li><li>rdb文件非常紧凑，适合于数据备份。</li><li>通过RDB进行数据备，由于使用子进程生成，所以对Redis服务器性能影响较小。</li></ul></li><li><p>RDB的几个缺点</p><ul><li>如果服务器宕机的话，采用RDB的方式会造成某个时段内数据的丢失，比如我们设置10分钟同步一次或5分钟达到1000次写入就同步一次，那么如果还没达到触发条件服务器就死机了，那么这个时间段的数据会丢失。</li><li>使用save命令会造成服务器阻塞，直接数据同步完成才能接收后续请求。</li><li>使用bgsave命令在forks子进程时，如果数据量太大，forks的过程也会发生阻塞，另外，forks子进程会耗费内存。</li></ul></li></ul><h4 id="2-2-AOF-Append-only-file"><a href="#2-2-AOF-Append-only-file" class="headerlink" title="2.2 AOF(Append-only file)"></a>2.2 AOF(Append-only file)</h4><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令（以日志的形式），并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><ul><li>开启方式：在Redis配置文件redis.conf配置</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes                  # 开启aof机制</span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> # aof文件名</span><br><span class="line"># 写入策略<span class="punctuation">,</span>always表示每个写操作都保存到aof文件中<span class="punctuation">,</span>也可以是everysec(每秒写入一次)或no(操作系统处理)</span><br><span class="line">appendfsync always</span><br><span class="line">no-appendfsync-on-rewrite no    # 默认不重写aof文件</span><br><span class="line">dir ~/redis/                    # 保存目录</span><br></pre></td></tr></table></figure><ul><li>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决，Redis通过重写aof，可以生成一个恢复当前数据的最少命令集，两种方式：配置no-appendfsync-on-rewrite(默认no)，或者客户端向服务器发送bgrewriteaof命令</li></ul><ul><li>AOF的优点：AOF只是追加日志文件，因此对服务器性能影响较小，速度比RDB要快，消耗的内存较少。</li><li>AOF的缺点：AOF方式生成的日志文件太大，即使通过AFO重写，文件体积仍然很大。恢复数据的速度比RDB慢。</li><li>当RDB与AOF两种方式都开启时，Redis会优先使用AOF日志来恢复数据，因为AOF保存的文件比RDB文件更完整。</li></ul><h5 id="2-2-1-AOF文件修复"><a href="#2-2-1-AOF文件修复" class="headerlink" title="2.2.1 AOF文件修复"></a>2.2.1 AOF文件修复</h5><ol><li>备份被写坏的AOF文件</li><li>运行redis-check-aof –fix进行修复</li><li>用diff -u来看下两个文件的差异，确认问题点</li><li>重启redis，加载修复后的AOF文件</li></ol><h3 id="3-Redis的高并发和快速原因"><a href="#3-Redis的高并发和快速原因" class="headerlink" title="3. Redis的高并发和快速原因"></a>3. Redis的高并发和快速原因</h3><ol><li>redis是基于内存的，内存的读写速度非常快；</li><li>redis是单线程的，省去了很多上下文切换线程的时间；</li><li>redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。</li><li>另外，数据结构也帮了不少忙，Redis全程使用hash结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</li><li>还有一点，Redis采用自己实现的事件分离器，效率比较高，内部采用非阻塞的执行方式，吞吐能力比较大。</li></ol><h3 id="4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用"><a href="#4-Redis利用哨兵-Sentinel-，复制-Replication-这两个功能来保证高可用" class="headerlink" title="4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用"></a>4. Redis利用哨兵(Sentinel)，复制(Replication)这两个功能来保证高可用</h3><ol><li>哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。<ol><li>集群监控：负责监控Redis master和slave进程是否正常工作</li><li>消息通知：如果某个Redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员</li><li>故障转移：如果master node挂掉了，会自动转移到slave node上</li><li>配置中心：如果故障转移发生了，通知client客户端新的master地址</li></ol></li><li>复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。<ol><li>从数据库向主数据库发送sync(数据同步)命令。</li><li>主数据库接收同步命令后，会保存快照，创建一个RDB文件。</li><li>当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。</li><li>主数据库将缓冲区的所有写命令发给从服务器执行。</li><li>以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。</li></ol></li></ol><h3 id="5-Redis-主从复制、哨兵和集群这三个有什么区别"><a href="#5-Redis-主从复制、哨兵和集群这三个有什么区别" class="headerlink" title="5. Redis 主从复制、哨兵和集群这三个有什么区别"></a>5. Redis 主从复制、哨兵和集群这三个有什么区别</h3><p>主从复制是为了数据备份，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是因为单实例能力有限，搞多个分散压力。</p><ol><li>主从模式：读写分离，备份，一个Master可以有多个Slaves。</li><li>哨兵entinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。</li><li>集群Cluster：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存&#x2F;QPS不受限于单机，可受益于分布式集群高扩展性。</li></ol><h3 id="6-Redis-Cluster集群"><a href="#6-Redis-Cluster集群" class="headerlink" title="6. Redis Cluster集群"></a>6. Redis Cluster集群</h3><p>Redis Cluster，是Redis 3.0开始引入的分布式存储方案。<br>集群由多个节点(Node)组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</p><ul><li>集群的作用：<ol><li>数据分区：数据分区(或称数据分片)是集群最核心的功能。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务。</li></ol></li></ul><h4 id="6-1-Redis-Cluster集群的搭建可以分为四步："><a href="#6-1-Redis-Cluster集群的搭建可以分为四步：" class="headerlink" title="6.1 Redis Cluster集群的搭建可以分为四步："></a>6.1 Redis Cluster集群的搭建可以分为四步：</h4><ol><li><strong>启动节点</strong>：将节点以集群模式启动，此时节点是独立的，并没有建立联系；</li><li><strong>节点握手</strong>：让独立的节点连成一个网络；</li><li><strong>分配槽</strong>：将16384个槽分配给主节点；</li><li><strong>指定主从关系</strong>：为从节点指定主节点。</li></ol><h4 id="6-2-Redis-Cluster工作原理"><a href="#6-2-Redis-Cluster工作原理" class="headerlink" title="6.2 Redis Cluster工作原理"></a>6.2 Redis Cluster工作原理</h4><ul><li>客户端与Redis节点直连,不需要中间Proxy层，直接连接任意一个Master节点</li><li>根据公式<code>HASH_SLOT=CRC16(key) mod 16384</code>，计算出映射到哪个分片上，然后Redis会去相应的节点进行操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         CRC16(key)    |  0~5460   | &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">         mode 16384    |</span><br><span class="line">Client --------------&gt; | 5461~10922| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line">                       |</span><br><span class="line">                       |10923~10383| &lt;--Slot--|Redis(M)|&lt;---|Redis(S可多个从)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-3-Redis-Cluster优点"><a href="#6-3-Redis-Cluster优点" class="headerlink" title="6.3 Redis Cluster优点:"></a>6.3 Redis Cluster优点:</h4><ol><li>无需Sentinel哨兵监控，如果Master挂了，Redis Cluster内部自动将Slave切换Master</li><li>可以进行水平扩容</li><li>支持自动化迁移，当出现某个Slave宕机了，那么就只有Master了，这时候的高可用性就无法很好的保证了，万一master也宕机了，咋办呢？ 针对这种情况，如果说其他Master有多余的Slave ，集群自动把多余的Slave迁移到没有Slave的Master 中。</li></ol><h4 id="6-4-Redis-Cluster缺点"><a href="#6-4-Redis-Cluster缺点" class="headerlink" title="6.4 Redis Cluster缺点:"></a>6.4 Redis Cluster缺点:</h4><ol><li>批量操作是个坑（不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通）</li><li>资源隔离性较差，容易出现相互影响的情况。</li></ol><h4 id="6-5-Redis-Cluster总结："><a href="#6-5-Redis-Cluster总结：" class="headerlink" title="6.5 Redis Cluster总结："></a>6.5 Redis Cluster总结：</h4><ol><li>Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效。</li><li>单机下的redis可以支持16个数据库（db0 ~ db15），在Redis Cluster集群架构下只有一个数据库空间，即db0。</li><li>不同的key会划分到不同的slot中，因此直接使用mset或者mget等操作是行不通。</li><li>如果Hash对象非常大，是不支持映射到不同节点的！只能映射到集群中的一个节点上。</li><li>Redis集群模式下进行批量操作：如果执行的key数量比较少，就用串行get操作； 如果需要执行的key很多，就使用Hashtag保证这些key映射到同一台redis节点上。</li><li>Redis Cluster的架构，是属于分片集群的架构，不做读写分离，因为redis本身在内存上操作，不会涉及IO吞吐，即使读写分离也不会提升太多性能，Redis在生产上的主要问题是考虑容量，单机最多10-20G，key太多降低redis性能.因此采用分片集群结构，已经能保证了我们的性能。其次，用上了读写分离后，还要考虑主从一致性，主从延迟等问题，徒增业务复杂度。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「MySQL」MySQL慢日志查询分析</title>
      <link href="/2019/02/15/mysql-slow-log.html"/>
      <url>/2019/02/15/mysql-slow-log.html</url>
      
        <content type="html"><![CDATA[<p>同大多数关系型数据库一样，日志文件是MySQL数据库的重要组成部分。MySQL有几种不同的日志文件，通常包括错误日志文件，二进制日志，通用日志，慢查询日志，等等。这些日志可以帮助我们定位mysqld内部发生的事件，数据库性能故障，记录数据的变更历史，用户恢复数据库等等。<span id="more"></span></p><ul><li>错误日志：记录启动、运行或停止mysqld时出现的问题。</li><li>通用日志：记录建立的客户端连接和执行的语句。</li><li>更新日志：记录更改数据的语句。该日志在MySQL 5.1中已不再使用。</li><li>二进制日志：记录所有更改数据的语句。还用于复制。</li><li>慢查询日志：记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询</li><li>Innodb日志：InnoDB redo log(记录了事务的行为，可以很好的通过其对页进行“重做”操作)</li></ul><h3 id="1-开启慢查询日志"><a href="#1-开启慢查询日志" class="headerlink" title="1. 开启慢查询日志"></a>1. 开启慢查询日志</h3><p>开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。<br>通过<code>show variables like &#39;slow_query%&#39;;</code>查询是否开了慢查询(默认禁用OFF)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name       <span class="operator">|</span> <span class="keyword">Value</span>                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> slow_query_log      <span class="operator">|</span> OFF                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> slow_query_log_file <span class="operator">|</span> D:\mysql<span class="number">-5.7</span><span class="number">.27</span><span class="operator">-</span>winx64\data\DESKTOP<span class="operator">-</span>E9F062A<span class="operator">-</span>slow.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><blockquote><p><code>slow_query_log</code> 慢查询开启状态  OFF 未开启 ON 为开启<br><code>slow_query_log_file</code> 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</p></blockquote><p>开启慢查询，需要设置<code>slow_query_log</code>参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>设置开启或者关闭，<span class="number">0</span>为关闭，<span class="number">1</span>为开启</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">3</span>;  <span class="operator">/</span><span class="operator">/</span>设置慢的阙值时间，默认<span class="number">10</span>秒</span><br></pre></td></tr></table></figure><blockquote><p>如果通过终端命令设定的话，需要重新连接或新开一个会话才能看到修改值</p></blockquote><p>使用set global slow_query_log 命令开启慢查询日志，只对当前数据库生效，如果Mysql重启后则会失效。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log <span class="operator">=</span> <span class="number">1</span> #开启</span><br><span class="line">slow_query_log_file <span class="operator">=</span> <span class="operator">/</span>mysql<span class="number">-5.7</span><span class="number">.27</span><span class="operator">-</span>winx64<span class="operator">/</span>data<span class="operator">/</span>mysql<span class="operator">-</span>slow.log #默认host_name_show.log</span><br><span class="line">long_query_time <span class="operator">=</span> <span class="number">3</span> #默认<span class="number">10</span>秒（查询超过多少秒才记录）</span><br><span class="line">log<span class="operator">-</span>queries<span class="operator">-</span><span class="keyword">not</span><span class="operator">-</span><span class="keyword">using</span><span class="operator">-</span>indexes <span class="operator">=</span> <span class="keyword">on</span> #如果值设置为<span class="keyword">ON</span>，则会记录所有没有利用索引的查询，一般在性能调优的时候会暂时开启。</span><br><span class="line">log_output <span class="operator">=</span> <span class="string">&#x27;FILE,TABLE&#x27;</span> #输出的格式(FILE:文本, <span class="keyword">TABLE</span>:表中, FILE,<span class="keyword">TABLE</span>:同时输出到文本和表中)</span><br></pre></td></tr></table></figure><p>插入一条测试慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> sleep(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>通过MySQL命令查看有多少慢查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;%Slow_queries%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Slow_queries  <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br></pre></td></tr></table></figure><h3 id="2-慢查询日志分析工具"><a href="#2-慢查询日志分析工具" class="headerlink" title="2. 慢查询日志分析工具"></a>2. 慢查询日志分析工具</h3><table><thead><tr><th>工具</th><th>一般统计</th><th>高级统计</th><th>语言</th><th>优势</th><th>针对log</th></tr></thead><tbody><tr><td>mysqldumpslow</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>mysql官方自带</td><td>slow</td></tr><tr><td>myprofi</td><td><code>√</code></td><td><code>×</code></td><td>php</td><td>简单</td><td>slow</td></tr><tr><td>mysql-log-filter</td><td><code>√</code></td><td>部分<code>√</code></td><td>python</td><td>简单</td><td>slow</td></tr><tr><td>mysql-explain-slow-log</td><td><code>√</code></td><td><code>×</code></td><td>perl</td><td>无</td><td>slow</td></tr><tr><td>mysqlbinlog</td><td><code>√</code></td><td><code>×</code></td><td>二进制</td><td>mysql官方自带</td><td>binary log</td></tr><tr><td>mysqlsla</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr><tr><td>pt-query-digest</td><td><code>√</code></td><td><code>√</code></td><td>perl</td><td>总能强大，使用简单，自定义能力强</td><td>所有日志，包括自定义日志</td></tr></tbody></table><h4 id="2-1-mysqldumpslow"><a href="#2-1-mysqldumpslow" class="headerlink" title="2.1 mysqldumpslow"></a>2.1 mysqldumpslow</h4><ul><li>MySQL自带的慢查询日志分析工具mysqldumpslow主要功能是, 统计不同慢sql的:<ul><li>出现次数(Count),</li><li>执行最长时间(Time), </li><li>累计总耗费时间(Time),</li><li>等待锁的时间(Lock), </li><li>发送给客户端的行总数(Rows),</li><li>扫描的行总数(Rows), </li><li>用户以及sql语句本身(抽象了一下格式, 比如 limit 1, 20 用 limit N,N 表示).<br>安装后基本使用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>data<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log  <span class="operator">/</span><span class="operator">/</span>得到返回记录集最多的<span class="number">10</span>个<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s c <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>data<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log <span class="operator">/</span><span class="operator">/</span>得到访问次数最多的<span class="number">10</span>个<span class="keyword">SQL</span> </span><br><span class="line">mysqldumpslow <span class="operator">-</span>s t <span class="operator">-</span>t <span class="number">10</span> <span class="operator">-</span>g &quot;left join&quot; <span class="operator">/</span>data<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log  <span class="operator">/</span><span class="operator">/</span>得到按照时间排序的前<span class="number">10</span>条里面含有做了连接的查询<span class="keyword">SQL</span></span><br><span class="line">mysqldumpslow <span class="operator">-</span>s r <span class="operator">-</span>t <span class="number">10</span> <span class="operator">/</span>data<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slow.log <span class="operator">|</span> more  <span class="operator">/</span><span class="operator">/</span>另外建议在使用这些命令时结合<span class="operator">|</span>和more使用，否则有可能出现爆屏情况</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-2-mysqlsla"><a href="#2-2-mysqlsla" class="headerlink" title="2.2 mysqlsla"></a>2.2 mysqlsla</h4><p>hackmysql.com推出的一款日志分析工具(该网站还维护了 mysqlreport, mysqlidxchk 等比较实用的mysql工具)</p><ul><li>整体来说, 功能非常强大. 数据报表,非常有利于分析慢查询的原因, 包括执行频率, 数据量, 查询消耗等.</li></ul><p>安装后基本使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlsla <span class="operator">-</span>lt slow <span class="operator">-</span>sort t_sum <span class="operator">-</span>top <span class="number">1000</span>  <span class="operator">/</span>tmp<span class="operator">/</span>slow_query.log</span><br></pre></td></tr></table></figure><ul><li>结果选项说明：<ul><li>总查询次数 (queries total),</li><li>去重后的sql数量 (unique),</li><li>输出报表的内容排序(sorted by),</li><li>最重大的慢sql统计信息(包括 平均执行时间, 等待锁时间, 结果行的总数, 扫描的行总数)</li><li>Count, sql的执行次数及占总的slow log数量的百分比.</li><li>Time, 执行时间, 包括总时间, 平均时间, 最小, 最大时间, 时间占到总慢sql时间的百分比.</li><li>95% of Time, 去除最快和最慢的sql, 覆盖率占95%的sql的执行时间.</li><li>Lock Time, 等待锁的时间.</li><li>95% of Lock , 95%的慢sql等待锁时间.</li><li>Rows sent, 结果行统计数量, 包括平均, 最小, 最大数量.</li><li>Rows examined, 扫描的行数量.</li><li>Database, 属于哪个数据库</li><li>Users, 哪个用户,IP, 占到所有用户执行的sql百分比</li><li>Query abstract, 抽象后的sql语句</li><li>Query sample, sql语句</li></ul></li><li>mysqlsla常用参数说明：<ol><li><code>-log-type (-lt) type logs</code>:通过这个参数来制定log的类型，主要有slow, general, binary, msl, udl,分析slow log时通过制定为slow</li><li><code>-sort</code>:t_sum:按总时间排序(默认)，c_sum:按总次数排序c_sum_p: sql语句执行次数占总执行次数的百分比。</li><li><code>-top</code>:显示sql的数量，默认是10,表示按规则取排序的前多少条</li><li><code>–statement-filter (-sf) [+-][TYPE]</code>:过滤sql语句的类型，比如select、update、drop，[TYPE] 有SELECT, CREATE, DROP, UPDATE, INSERT，例如”+SELECT,INSERT”，不出现的默认是-，即不包括。</li><li><code>-db</code>：要处理哪个库的日志：</li></ol></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 举个例子，只取funsion数据库的<span class="keyword">select</span>语句，并按照总时间排序，取前<span class="number">1000</span>条数据</span><br><span class="line"># 保存到当前目录下的 slow_query.pretty.log文件中</span><br><span class="line">mysqlsla <span class="operator">-</span>lt slow  <span class="operator">-</span>sort t_sum  <span class="operator">-</span>sf &quot;+select&quot;  <span class="operator">-</span>db funsion  <span class="operator">-</span>top <span class="number">1000</span>  <span class="operator">/</span>tmp<span class="operator">/</span>slow_query.log <span class="operator">&gt;</span> .<span class="operator">/</span>slow_query.pretty.log</span><br></pre></td></tr></table></figure><blockquote><p>深度使用可参考： <a href="https://yq.aliyun.com/articles/59260">MySQL日志分析神器之mysqlsla</a></p></blockquote><h4 id="2-3-pt-query-digest"><a href="#2-3-pt-query-digest" class="headerlink" title="2.3 pt-query-digest"></a>2.3 pt-query-digest</h4><p>pt-query-digest是用于分析mysql慢查询的一个工具，它可以分析binlog、General log、slowlog，也可以通过SHOWPROCESSLIST或者通过tcpdump抓取的MySQL协议数据来进行分析。可以把分析结果输出到文件中，分析过程是先对查询语句的条件进行参数化，然后对参数化以后的查询进行分组统计，统计出各查询的执行时间、次数、占比等，可以借助分析结果找出问题进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 分析最近<span class="number">12</span>小时内的查询：</span><br><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest  <span class="comment">--since=12h  slow.log &gt; slow_report2.log</span></span><br></pre></td></tr></table></figure><ol><li>pt-query-digest语法及重要选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pt<span class="operator">-</span>query<span class="operator">-</span>digest [OPTIONS] [FILES] [DSN]</span><br><span class="line">    <span class="comment">--create-review-table  当使用--review参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--create-history-table  当使用--history参数把分析结果输出到表中时，如果没有表就自动创建。</span></span><br><span class="line">    <span class="comment">--filter  对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</span></span><br><span class="line">    <span class="comment">--limit    限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</span></span><br><span class="line">    <span class="comment">--host  mysql服务器地址</span></span><br><span class="line">    <span class="comment">--user  mysql用户名</span></span><br><span class="line">    <span class="comment">--password  mysql用户密码</span></span><br><span class="line">    <span class="comment">--history 将分析结果保存到表中，分析结果比较详细，下次再使用--history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</span></span><br><span class="line">    <span class="comment">--review 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用--review时，如果存在相同的语句分析，就不会记录到数据表中。</span></span><br><span class="line">    <span class="comment">--output 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</span></span><br><span class="line">    <span class="comment">--since 从什么时间开始分析，值为字符串，可以是指定的某个”yyyy-mm-dd [hh:mm:ss]”格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。</span></span><br><span class="line">    <span class="comment">--until 截止时间，配合—since可以分析一段时间内的慢查询。</span></span><br></pre></td></tr></table></figure></li></ol><p>分析pt-query-digest输出结果</p><ol><li>总体统计结果<ul><li>Overall：总共有多少条查询</li><li>Time range：查询执行的时间范围</li><li>unique：唯一查询数量，即对查询条件进行参数化以后，总共有多少个不同的查询</li><li>total：总计   min：最小   max：最大  avg：平均</li><li>95%：把所有值从小到大排列，位置位于95%的那个数，这个数一般最具有参考价值</li><li>median：中位数，把所有值从小到大排列，位置位于中间那个数</li></ul></li><li>查询分组统计结果<ul><li>Rank：所有语句的排名，默认按查询时间降序排列，通过–order-by指定</li><li>Query ID：语句的ID，（去掉多余空格和文本字符，计算hash值）</li><li>Response：总的响应时间</li><li>time：该查询在本次分析中总的时间占比</li><li>calls：执行次数，即本次分析总共有多少条这种类型的查询语句</li><li>R&#x2F;Call：平均每次执行的响应时间</li><li>V&#x2F;M：响应时间Variance-to-mean的比率</li><li>Item：查询对象</li></ul></li><li>每一种查询的详细统计结果<ul><li>由下面查询的详细统计结果，最上面的表格列出了执行次数、最大、最小、平均、95%等各项目的统计。</li><li>ID：查询的ID号，和上图的Query ID对应</li><li>Databases：数据库名</li><li>Users：各个用户执行的次数（占比）</li><li>Query_time distribution ：查询时间分布, 长短体现区间占比，本例中1s-10s之间查询数量是10s以上的两倍。</li><li>Tables：查询中涉及到的表</li><li>Explain：SQL语句</li></ul></li></ol><h3 id="3-explain查看执行计划"><a href="#3-explain查看执行计划" class="headerlink" title="3. explain查看执行计划"></a>3. explain查看执行计划</h3><p>在上面的慢查询中，我们已经将查询时间超过阀值的sql语句过滤了出来，<code>explain+查询语句</code>具体分析是哪里出了问题。<br>MySQL 提供了一个 <code>Explain</code> 命令, 它可以对 select 语句进行分析, 并输出 select 执行的详细信息, 以供开发人员针对性优化.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_info <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">           id: <span class="number">1</span></span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        <span class="keyword">table</span>: user_info</span><br><span class="line">   partitions: <span class="keyword">NULL</span></span><br><span class="line">         type: const</span><br><span class="line">possible_keys: <span class="keyword">PRIMARY</span></span><br><span class="line">          key: <span class="keyword">PRIMARY</span></span><br><span class="line">      key_len: <span class="number">8</span></span><br><span class="line">          <span class="keyword">ref</span>: const</span><br><span class="line">         <span class="keyword">rows</span>: <span class="number">1</span></span><br><span class="line">     filtered: <span class="number">100.00</span></span><br><span class="line">        Extra: <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.06</span> sec)</span><br></pre></td></tr></table></figure><ol><li><p>各列的含义如下:</p><ul><li><code>id</code>: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li><li><code>select_type</code>: SELECT 查询的类型.<ul><li>SIMPLE, 表示此查询不包含 UNION 查询或子查询</li><li>PRIMARY, 表示此查询是最外层的查询</li><li>UNION, 表示此查询是 UNION 的第二或随后的查询</li><li>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</li><li>UNION RESULT, UNION 的结果</li><li>SUBQUERY, 子查询中的第一个 SELECT</li><li>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</li></ul></li><li><code>table</code>: 查询的是哪个表</li><li><code>partitions</code>: 匹配的分区</li><li><code>type</code>: join 类型<ul><li>type字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过<code>type</code>字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</li><li>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</li><li>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.</li><li>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 &#x3D;, 查询效率较高. </li><li>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.</li><li>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, IN() 操作中.</li><li>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</li><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难.</li></ul></li><li><code>possible_keys</code>: 此次查询中可能选用的索引<ul><li>表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</li></ul></li><li><code>key</code>: 此字段是 MySQL 在当前查询时所真正使用到的索引.</li><li><code>key_len</code>: 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</li><li><code>ref</code>: 哪个字段或常数与 key 一起被使用</li><li><code>rows</code>: 显示此查询一共扫描了多少行. 这个是一个估计值.<ul><li>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数, 这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</li></ul></li><li><code>filtered</code>: 表示此查询条件所过滤的数据的百分比</li><li><code>extra</code>: EXplain 中的很多额外的信息会在 Extra 字段显示<ul><li>Using filesort: 当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li><li>Using index: “覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li><li>Using temporary: 查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul></li></ul></li><li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:</p></li></ol><ul><li><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><ul><li>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</li><li>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li><li>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</li></ul></li></ul><h3 id="4-MySQL性能分析语句show-profile"><a href="#4-MySQL性能分析语句show-profile" class="headerlink" title="4. MySQL性能分析语句show profile"></a>4. MySQL性能分析语句show profile</h3><p>Query Profile是MySQL自带的一种Query诊断分析工具，可以完整的显示一条sql执行的各方面的详细信息，默认关闭;</p><ol><li><p>看看当前的MySQL版本是否支持: <code>show variables like &#39;profiling&#39;;</code>或<code>show variables like &#39;profiling%&#39;;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name          <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> profiling              <span class="operator">|</span> OFF   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> profiling_history_size <span class="operator">|</span> <span class="number">15</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p>使用前需要开启: <code>set profiling = 1; (1:开 / 0:关)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行sql后</strong>，查询结果<code>show profiles;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> PROFILES\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Query_ID: <span class="number">1</span></span><br><span class="line">Duration: <span class="number">0.02949950</span></span><br><span class="line">   Query: explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Query_ID: <span class="number">2</span></span><br><span class="line">Duration: <span class="number">0.03405350</span></span><br><span class="line">   Query: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> housedemo</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Query_ID: <span class="number">3</span></span><br><span class="line">Duration: <span class="number">0.07813800</span></span><br><span class="line">   Query: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> house</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">4.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">Query_ID: <span class="number">4</span></span><br><span class="line">Duration: <span class="number">0.00018150</span></span><br><span class="line">   Query: <span class="keyword">show</span> prifiles</span><br></pre></td></tr></table></figure></li><li><p>诊断SQL, show profile <code>Type</code> io for query <code>Query_ID</code></p><ul><li>LIMIT部分的用法与SELECT中LIMIT子句一致，不赘述。</li><li>Type是可选的，取值范围可以如下：<ul><li><code>ALL</code> 显示所有性能信息</li><li><code>BLOCK IO</code> 显示块IO操作的次数</li><li><code>CONTEXT SWITCHES</code> 显示上下文切换次数，不管是主动还是被动</li><li><code>CPU</code> 显示用户CPU时间、系统CPU时间</li><li><code>IPC</code> 显示发送和接收的消息数量</li><li><code>MEMORY</code> [暂未实现]</li><li><code>PAGE FAULTS</code> 显示页错误数量</li><li><code>SOURCE</code> 显示源码中的函数名称与位置</li><li><code>SWAPS</code> 显示SWAP的次数</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile cpu,block io <span class="keyword">for</span> query <span class="number">3</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span> CPU_user <span class="operator">|</span> CPU_system <span class="operator">|</span> Block_ops_in <span class="operator">|</span> Block_ops_out <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br><span class="line"><span class="operator">|</span> starting             <span class="operator">|</span> <span class="number">0.000077</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions <span class="operator">|</span> <span class="number">0.000013</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables       <span class="operator">|</span> <span class="number">0.031992</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                 <span class="operator">|</span> <span class="number">0.000059</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock          <span class="operator">|</span> <span class="number">0.000016</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing           <span class="operator">|</span> <span class="number">0.000007</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics           <span class="operator">|</span> <span class="number">0.000017</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing            <span class="operator">|</span> <span class="number">0.008535</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span> <span class="number">0.000016</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">0.037234</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                  <span class="operator">|</span> <span class="number">0.000011</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>            <span class="operator">|</span> <span class="number">0.000012</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000014</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items        <span class="operator">|</span> <span class="number">0.000108</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up          <span class="operator">|</span> <span class="number">0.000030</span> <span class="operator">|</span> <span class="number">0.000000</span> <span class="operator">|</span>   <span class="number">0.000000</span> <span class="operator">|</span>         <span class="keyword">NULL</span> <span class="operator">|</span>          <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+----------+------------+--------------+---------------+</span></span><br></pre></td></tr></table></figure><p>从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理的你工作，在这完全可以看到一条SQL的完整生命周期。</p><ol start="5"><li>日常开发需要注意<ul><li>如果show profile … for query id；出现了如下四个，则必须优化这条sql。<ol><li><code>converting HEAP to MyISAM</code> 查询结果太大， 内存都不够用了网磁盘上搬了</li><li><code>Creating tmp table</code> 创建临时表</li><li>拷贝数据到临时表：假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这个时候就是导致SQL变慢的罪魁祸首</li><li>用完再删除</li><li><code>Copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li><li><code>locked</code></li></ol></li></ul></li></ol><h3 id="5-全局查询日志"><a href="#5-全局查询日志" class="headerlink" title="5. 全局查询日志"></a>5. 全局查询日志</h3><p>切记：<strong>永远不要再生产环境开启这个功能</strong>。<br>全局查询日志有时也能帮助我们来调SQL。但是，切记，这家伙只能在测试环境使用，绝不可以在生产环境使用。</p><ol><li><p>命令启用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span><span class="number">1</span>; #开启后会把所有的<span class="keyword">SQL</span>偷偷的记录</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> log_output<span class="operator">=</span><span class="string">&#x27;TABLE&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>配置启用,  在MySQL的my.cnf中，设置如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#开启</span><br><span class="line">general_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line">#记录日志文件的路径</span><br><span class="line">general_log_file<span class="operator">=</span><span class="operator">/</span>path<span class="operator">/</span>logfile</span><br><span class="line">#输出格式</span><br><span class="line">log_output<span class="operator">=</span>file</span><br></pre></td></tr></table></figure></li><li><p>此后，你所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.general_log;</span><br></pre></td></tr></table></figure><blockquote><p>场景：如果需要做系统的定案分析(今天下午2点-3点出的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。那么用general_log这个表来收集什么时间段发生了什么样的SQL，帮助我们定位收集。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「MySQL」MySQL事务处理与并发控制</title>
      <link href="/2019/02/09/mysql-transaction.html"/>
      <url>/2019/02/09/mysql-transaction.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-MySQL事务"><a href="#1-MySQL事务" class="headerlink" title="1. MySQL事务"></a>1. MySQL事务</h3><ol><li>事务: 数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；事务是一组不可再分割的操作集合(工作逻辑单元)；<span id="more"></span></li><li>事务的特性(ACID)：<ul><li><strong>原子性</strong>（Atomicity，或称不可分割性）：最小的工作单元，整个工作单元要么一起提交成功，要么全部失败回滚</li><li><strong>一致性</strong>（Consistency）：事务中操作的数据及状态改变是一致的，即写入资料的结果必须完全符合预设的规则， 不会因为出现系统意外等原因导致状态的不一致</li><li><strong>隔离性</strong>（Isolation，又称独立性）：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般设定为不可见）</li><li><strong>持久性</strong>（Durability）：事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li></ul></li><li>事务的开启与提交模式<ul><li>若参数autocommit&#x3D;0，自动开启<strong>手动提交</strong></li><li>若参数autocommit&#x3D;1（系统默认值），又分为两种状态：<ul><li><strong>自动开启自动提交</strong>：用户的每一个操作都是一个完整的事务周期。</li><li><strong>手动开启手动提交</strong>：从用户执行<code>start transaction</code>命令到用户执行<code>commit</code>命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。<ul><li><code>begin</code> 或者 <code>start transaction</code>   – 开启事务</li><li><code>commit</code> 或者 <code>rollback</code>           – 事务提交或回滚</li></ul></li></ul></li></ul></li></ol><h4 id="1-1-事务的隔离级别"><a href="#1-1-事务的隔离级别" class="headerlink" title="1.1 事务的隔离级别"></a>1.1 事务的隔离级别</h4><ul><li>查看&#x2F;设置隔离级别<ul><li>查看：<code>SELECT @@tx_isolation</code></li><li>设置：<code>set tx_isolation=&#39;xxx&#39;</code></li></ul></li></ul><ol><li><strong>读未提交</strong>（Read Uncommitted）<ul><li>事务未提交对其他事务也是可见的，脏读（dirty read）</li></ul></li><li><strong>读提交</strong>（Read Committed）–解决脏读问题 <ul><li>一个事务开始之后，只能看到自己提交的事务所做的修改，不可重复读（nonrepeatable read）</li></ul></li><li><strong>可重复读</strong>（Repeatable Read）–解决不可重复读问题<ul><li>在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未定义解决幻读的问题</li></ul></li><li><strong>串行化</strong>（Serializable）–解决所有问题<ul><li>最高的隔离级别，通过强制事务的串行执行，但是会导致大量超时以及锁争用问题</li></ul></li></ol><blockquote><p>Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别。<br>事务的隔离级别的实现：锁、MVCC（多版本并发控制 Multiversion Currency Control）。</p></blockquote><h4 id="1-2-事务的七大传播行为"><a href="#1-2-事务的七大传播行为" class="headerlink" title="1.2 事务的七大传播行为"></a>1.2 事务的七大传播行为</h4><p>Spring在TransactionDefinition接口中规定了<strong>7种</strong>类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。</p><ul><li>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时<strong>事务如何传播</strong>。<ul><li><code>@Transactional(propagation = Propagation.REQUIRED)</code></li></ul></li></ul><ol><li>第一类：运行在同一个事务<ul><li>**<code>REQUIRED</code>**（required）：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>（supports）：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>（mandatory）：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li>**<code>REQUIRES_NEW</code>**（requires new）：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>(not supported)：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>（never）：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li>**<code>NESTED</code>**（nested）：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><h3 id="2-锁"><a href="#2-锁" class="headerlink" title="2. 锁"></a>2. 锁</h3><p>锁是用于管理不同事务对共享资源的并发访问，InnoDB存储引擎支持行锁和表锁（InnoDB表锁是另类的行锁）</p><ul><li>InnoDB行锁<ul><li>共享锁（读锁）：Shared Locks</li><li>排它锁（写锁）：Exclusive Locks</li></ul></li><li>InnoDB表锁<ul><li>意向锁共享锁（IS）：Intention Shared Locks</li><li>意向锁排它锁（IX）：Intention Exclusive Locks</li><li>自增锁：AUTO-INC Locks</li></ul></li><li>行锁的算法<ul><li>记录锁 Record Locks</li><li>间隙锁 Gap Locks</li><li>临键锁 Next-key Locks</li></ul></li></ul><h4 id="2-1-共享锁-Shared-amp-排他锁-Exclusive"><a href="#2-1-共享锁-Shared-amp-排他锁-Exclusive" class="headerlink" title="2.1 共享锁(Shared) &amp; 排他锁(Exclusive)"></a>2.1 共享锁(Shared) &amp; 排他锁(Exclusive)</h4><p>它们都是标准的<strong>行级锁</strong>。</p><ul><li>共享锁（S锁）：读锁，读锁允许多个连接可以同一时刻<strong>并发的读</strong>取同一资源,互不干扰，但是只能读不能修改;<ul><li>加锁： <code>select * from users WHERE id=1 </code><strong><code>LOCK IN SHARE MODE</code></strong>; </li><li>解锁：**<code>commit</code><strong>或</strong><code>rollback</code>**</li></ul></li><li>排他锁（X锁）：写锁，一个写锁会<strong>阻塞</strong>其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。<ul><li>加锁： <code>select * from users WHERE id=1 </code><strong><code>FOR UPDATE</code></strong>; </li><li><strong><code>delete/update/insert 默认上 X 锁</code></strong></li><li>解锁：**<code>commit</code><strong>或</strong><code>rollback</code>**</li></ul></li></ul><blockquote><p>注意：所谓共享锁、排他锁其实均是<strong>锁机制本身的策略</strong>，通过这两种策略对锁做了区分。</p></blockquote><ul><li>InnoDB的行锁是通过<strong>给索引上的索引项加锁</strong>来实现的。</li><li>只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）</li></ul><h4 id="2-2-意向锁-Intention-amp-自增锁-AUTO-INC"><a href="#2-2-意向锁-Intention-amp-自增锁-AUTO-INC" class="headerlink" title="2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)"></a>2.2 意向锁(Intention) &amp; 自增锁(AUTO-INC)</h4><p>它们都是标准的<strong>表级锁</strong>。</p><ul><li><strong>意向锁</strong>（Intention Locks）：表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，才被允许对该表加行锁(S或X)。(即一个数据行加锁前必须先取得该表的意向锁)<ul><li>意向锁(IS、IX)是InnoDB数据操作之前<strong>自动加的</strong>，不需要用户干预 </li><li>意义：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li></ul></li><li><strong>自增锁</strong>（AUTO-INC Locks）：针对自增列自增长的一个特殊的表级别锁<ul><li><code>show variables like &#39;innodb_autoinc_lock_mode&#39;</code>;</li><li>默认取值1，代表连续，事务未提交ID永久丢失</li></ul></li></ul><h4 id="2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key"><a href="#2-3-记录锁-Record-amp-间隙锁-Gap-amp-临键锁-Next-key" class="headerlink" title="2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)"></a>2.3 记录锁(Record) &amp; 间隙锁(Gap) &amp; 临键锁(Next-key)</h4><ul><li><strong>临键锁 Next-key locks</strong>： <ul><li><strong>锁住记录+区间（左开右闭）</strong></li><li>Innodb<strong>默认</strong>行锁算法</li><li>当sql执行按照索引进行数据的检索时,查询条件为范围查找（between and、&lt;、&gt;等）并有数 据命中则此时SQL语句加上的锁为Next-key locks，<strong>锁住索引的记录+区间（左开右闭）</strong></li></ul></li><li><strong>间隙锁 Gap locks</strong>：<ul><li><strong>锁住数据不存在的区间（左开右开）</strong></li><li>当记录不存在，临键锁<strong>退化</strong>为Gap锁</li><li>当sql执行按照索引进行数据的检索时，查询条件的数据不存在，这时SQL语句加上的锁即为 Gap locks，Gap只在RR事务隔离级别存在，<strong>锁住索引不存在的区间（左开右开</strong>）</li></ul></li><li><strong>记录锁 Record locks</strong>： <ul><li><strong>锁住具体的索引项</strong></li><li>唯一性(主键&#x2F;唯一)索引，条件为<strong>精准匹配，退化</strong>成Record锁</li><li>当sql执行按照唯一性（Primary key、Unique key）索引进行数据的检索时，查询条件等值匹 配且查询的数据是存在，这时SQL语句加上的锁即为记录锁Record locks，<strong>锁住具体的索引项</strong></li></ul></li></ul><h4 id="2-4-死锁的产生与避免"><a href="#2-4-死锁的产生与避免" class="headerlink" title="2.4 死锁的产生与避免"></a>2.4 死锁的产生与避免</h4><ul><li>死锁<ul><li>在InnoDB中，锁是逐步获得的，就造成了死锁的可能（2个或以上并发事务）</li><li>每个事务都持有锁（或者是已经在等待锁）; </li><li>每个事务都需要再继续持有锁；<strong>事务之间产生加锁的循环等待</strong>，形成死锁。</li></ul></li><li>死锁的产生与避免<ol><li>类似的业务逻辑以固定的<strong>顺序访问</strong>表和行。</li><li>大事务拆小。大事务更倾向于死锁，如果业务允许，将<strong>大事务拆小</strong>。</li><li>在同<strong>一个事务</strong>中，尽可能做到<strong>一次锁定</strong>所需要的所有资源，减少死锁概 率。</li><li>降低隔离级别，如果业务允许，将隔离级别调低也是较好的选择</li><li>为表添加<strong>合理的索引</strong>。可以看到如果不走索引将会为表的每一行记录添 加上锁（或者说是表锁）</li></ol></li></ul><h3 id="3-MVCC-多版本并发控制"><a href="#3-MVCC-多版本并发控制" class="headerlink" title="3. MVCC(多版本并发控制)"></a>3. MVCC(多版本并发控制)</h3><p>Multiversion concurrency control (多版本并发控制)：</p><ul><li><strong>MVCC</strong> 就是 <strong>同一份数据临时保留多版本的一种方式，进而实现并发控制</strong></li><li>是行级锁的变种，它在普通读情况下<strong>避免了加锁操作</strong>，因此<strong>开销更低</strong>。</li><li>MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用<strong>时间戳或者事务ID</strong>去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。<strong>读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据</strong>。</li></ul><h4 id="3-1-MVCC逻辑流程"><a href="#3-1-MVCC逻辑流程" class="headerlink" title="3.1 MVCC逻辑流程"></a>3.1 MVCC逻辑流程</h4><ul><li>在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列<ul><li><code>DB_TRX_ID</code>：数据行的版本号</li><li><code>DB_ROLL_PT</code>：删除版本号</li></ul></li></ul><ol><li>MVCC逻辑流程-插入<ul><li>在插入数据的时候，会把全局事务ID记录到列<code>DB_TRX_ID</code>中去</li></ul></li><li>MVCC逻辑流程-删除<ul><li>执行完删除SQL之后数据并没有被真正删除，而是对删除版本号(<code>DB_ROLL_PT</code>)做改变</li></ul></li><li>MVCC逻辑流程-修改<ul><li>修改数据的时候 会先复制一条当前记录行数据，同时标记这条数据的数据行版本号为当前事务ID，最后把旧数据的删除版本号标记为新数据行版本号的值(即当前事务ID)。</li></ul></li><li>MVCC逻辑流程-查询<ul><li>查找数据行版本号早于当前事务ID的数据行记录</li><li>也就是说，数据行的版本号要小于或等于 当前事务ID，这样也就确保了读取到的数据是当前事务开始前已经存在的数据，或者是自身事务改变过的数据</li><li>查找删除版本号要么为NULL，要么大于当前事务版本号的记录</li><li>这样确保查询出来的数据行记录在事务开启之前没有被删除</li></ul></li></ol><blockquote><p>MySQL解决不可重复读和脏读并不是单纯利用 MVCC 机制来实现的。</p></blockquote><h3 id="4-MySQL事务日志-Undo-Log和Redo-Log"><a href="#4-MySQL事务日志-Undo-Log和Redo-Log" class="headerlink" title="4. MySQL事务日志(Undo Log和Redo Log)"></a>4. MySQL事务日志(Undo Log和Redo Log)</h3><p>innodb事务日志包括redo log和undo log。redo log是重做日志，提供前滚操作，undo log是回滚日志，提供回滚操作。<br>undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：</p><ol><li>redo log通常是<strong>物理日志</strong>，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置)。</li><li>undo用来回滚行记录到某个版本。undo log一般是<strong>逻辑日志</strong>，根据每行记录进行记录。</li></ol><p>s</p><h4 id="4-1-Undo-Log"><a href="#4-1-Undo-Log" class="headerlink" title="4.1 Undo Log"></a>4.1 Undo Log</h4><ul><li>Undo Log定义：<ul><li>undo意为取消，以撤销操作为目的，返回指定某个状态的操作</li><li>undo log指事务开始之前，在操作任何数据之前,首先将需操作的数据备份到一个地方 (Undo Log)</li></ul></li><li><strong>UndoLog是为了实现事务的原子性而出现的产物</strong></li><li>Undo Log实现事务原子性：<ul><li>事务处理过程中如果出现了错误或者用户执行了 ROLLBACK语句,Mysql可以利用Undo Log中的备份 将数据恢复到事务开始之前的状态</li></ul></li><li><strong>UndoLog在Mysql innodb存储引擎中用来实现多版本并发控制</strong></li><li>Undo log实现多版本并发控制：<ul><li>事务未提交之前，Undo保存了未提交之前的版本数据，Undo中的数据可作为数据旧版本快照供 其他并发事务进行快照读</li></ul></li></ul><h4 id="4-2-当前读-amp-快照读"><a href="#4-2-当前读-amp-快照读" class="headerlink" title="4.2 当前读 &amp; 快照读"></a>4.2 当前读 &amp; 快照读</h4><ul><li>快照读：<ul><li>SQL读取的数据是快照版本，也就是历史版本，普通的SELECT就是快照读 innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改过的数据) 两部分组成</li></ul></li><li>当前读：<ul><li>SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改 UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE都是当前读</li></ul></li></ul><h4 id="4-3-Redo-Log"><a href="#4-3-Redo-Log" class="headerlink" title="4.3 Redo Log"></a>4.3 Redo Log</h4><ul><li>Undo Log定义： <ul><li>Redo，顾名思义就是重做。以恢复操作为目的，重现操作；</li><li>Redo log指事务中操作的任何数据,将最新的数据备份到一个地方 (Redo Log)</li></ul></li><li>Redo log的持久： <ul><li>不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo 中。具体 的落盘策略可以进行配置</li></ul></li><li><strong>RedoLog是为了实现事务的持久性而出现的产物</strong></li><li>Redo Log实现事务持久性： <ul><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。</li></ul></li><li>一旦事务成功提交且数据持久化落盘之后，此时Redo log中的对应事务数据记录就失去了意义，所 以Redo log的写入是日志文件循环写入的</li></ul><h3 id="附-58同城数据库设计30条军规"><a href="#附-58同城数据库设计30条军规" class="headerlink" title="附: 58同城数据库设计30条军规"></a>附: 58同城数据库设计30条军规</h3><ul><li>军规适用场景：并发量大、数据量大的互联网业务 </li><li>解读：讲解原因，<strong>解读比军规更重要</strong></li></ul><h4 id="一、基础规范"><a href="#一、基础规范" class="headerlink" title="一、基础规范"></a>一、基础规范</h4><ol><li>必须使用InnoDB存储引擎<ul><li>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</li></ul></li><li>必须使用UTF8字符集 UTF-8MB4<ul><li>解读：万国码，无需转码，无乱码风险，节省空间</li></ul></li><li>数据表、数据字段必须加入中文注释<ul><li>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</li></ul></li><li>禁止使用存储过程、视图、触发器、Event<ul><li>解读：<strong>高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务 层”</strong>，并发量大的情况下，这些功能很可能将数据库拖死，<strong>业务逻辑放到服务层具备更好的 扩展性，能够轻易实现“增机器就加性能”</strong>。数据库擅长存储与索引，CPU计算还是上移吧</li></ul></li><li>禁止存储大文件或者大照片<ul><li>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI 多好</li></ul></li></ol><h4 id="二、命名规范"><a href="#二、命名规范" class="headerlink" title="二、命名规范"></a>二、命名规范</h4><ol start="6"><li>只允许<strong>使用内网域名，而不是ip连接数据库</strong></li><li>线上环境、开发环境、测试环境数据库内网域名遵循命名规范<ul><li>业务名称：xxx，线上环境：xxx.db，开发环境：xxx.rdb，测试环境：xxx.tdb </li><li>从库在名称后加-s标识，备库在名称后加-ss标识 线上从库：xxx-s.db 线上备库：xxx-sss.db</li></ul></li><li>库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止 拼音英文混用</li><li>表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</li></ol><h4 id="三、表设计规范"><a href="#三、表设计规范" class="headerlink" title="三、表设计规范"></a>三、表设计规范</h4><ol start="10"><li>单实例表数目必须小于500</li><li>单表列数目必须小于30</li><li>表必须有主键，例如自增主键<ul><li>解读：<ol><li>主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和 内存的使用</li><li>主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类 型可以有效的减少索引的磁盘空间，提高索引的缓存效率</li><li>无主键的表删除，在row模式的主从架构，会导致备库夯住</li></ol></li></ul></li><li>禁止使用外键，如果有外键完整性约束，需要应用程序控制<ul><li>解读：<strong>外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响 sql 的性能</strong>，甚至会造成死锁。高并发情况下容易造成数据库性能，<strong>大数据高并发业务场景 数据库使用以性能优先</strong></li></ul></li></ol><h4 id="四、字段设计规范"><a href="#四、字段设计规范" class="headerlink" title="四、字段设计规范"></a>四、字段设计规范</h4><ol start="14"><li>必须把字段定义为NOT NULL并且提供默认值<ul><li>解读： <ol><li>null的列使索引&#x2F;索引统计&#x2F;值比较都更加复杂，对MySQL来说更难优化</li><li>null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条 件下，表中有较多空字段的时候，数据库的处理性能会降低很多</li><li>null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标 识</li><li>对null 的处理时候，只能采用is null或is not null，而不能采用&#x3D;、in、&lt;、&lt;&gt;、!&#x3D;、 not in这些操作符号。如：where name!&#x3D;’shenjian’，如果存在name为null值的记 录，查询结果就不会包含name为null值的记录</li></ol></li></ul></li><li>禁止使用TEXT、BLOB类型<ul><li>解读：会浪费更多的磁盘和内存空间，<strong>非必要的大量的大字段查询会淘汰掉热数据，导致内 存命中率急剧降低，影响数据库性能</strong></li></ul></li><li>禁止使用小数存储货币<ul><li>解读：使用整数吧，小数容易导致钱对不上</li></ul></li><li>必须使用varchar(20)存储手机号<ul><li>解读：<ol><li>涉及到区号或者国家代号，可能出现+-()</li><li>手机号会去做数学运算么？</li><li>varchar可以支持模糊查询，例如：like“138%”</li></ol></li></ul></li><li>禁止使用ENUM，可使用TINYINT代替<ul><li>解读：<ol><li>增加新的ENUM值要做DDL操作</li><li>ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</li></ol></li></ul></li></ol><h4 id="五、索引设计规范"><a href="#五、索引设计规范" class="headerlink" title="五、索引设计规范"></a>五、索引设计规范</h4><ol start="19"><li>单表索引建议控制在5个以内</li><li>单索引字段数不允许超过5个<ul><li>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</li></ul></li><li>禁止在更新十分频繁、区分度不高的属性上建立索引<ul><li>解读：<ol><li>更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能</li><li>“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性 能与全表扫描类似</li></ol></li></ul></li><li>建立组合索引，必须把区分度高的字段放在前面<ul><li>解读：能够更加有效的过滤数据</li></ul></li></ol><h4 id="六、SQL使用规范"><a href="#六、SQL使用规范" class="headerlink" title="六、SQL使用规范"></a>六、SQL使用规范</h4><ol start="23"><li>禁止使用SELECT *，只获取必要的字段，需要显示说明列属性<ul><li>解读：<ol><li>读取不需要的列会增加CPU、IO、NET消耗</li><li>不能有效的利用覆盖索引</li></ol></li></ul></li><li>禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性<ul><li>解读：容易在增加或者删除字段后出现程序BUG</li></ul></li><li>禁止使用属性隐式转换<ul><li>解读：SELECT uid FROM t_user WHERE phone&#x3D;13812345678 <strong>会导致全表扫描</strong>，而不 能命中phone索引</li></ul></li><li>禁止在WHERE条件的属性上使用函数或者表达式<ul><li>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;&#x3D;’2017-02-15’ 会导致全 表扫描 正确的写法是：SELECT uid FROM t_user WHERE day&gt;&#x3D; unix_timestamp(‘2017-02-15 00:00:00’)</li></ul></li><li>禁止负向查询，以及%开头的模糊查询<ul><li>解读：<ol><li>负向查询条件：NOT、!&#x3D;、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描</li><li>%开头的模糊查询，会导致全表扫描</li></ol></li></ul></li><li>禁止大表使用JOIN查询，禁止大表使用子查询<ul><li>解读：<strong>会产生临时表</strong>，消耗较多内存与CPU，极大影响数据库性能</li></ul></li><li>禁止使用OR条件，必须改为IN查询<ul><li>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费 更多的CPU帮助实施查询优化呢？</li></ul></li><li>应用程序必须捕获SQL异常，并有相应处理</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「MySQL」MySQL索引的使用及优化</title>
      <link href="/2019/02/05/mysql-index.html"/>
      <url>/2019/02/05/mysql-index.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-索引的基本概念"><a href="#1-索引的基本概念" class="headerlink" title="1. 索引的基本概念"></a>1. 索引的基本概念</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引意义：<ol><li>索引能极大的减少存储引擎需要扫描的数据量</li><li>索引可以把随机IO变成顺序IO</li><li>索引可以帮助我们在进行分组、排序等操作时，避免使用临时表<span id="more"></span></li></ol></li><li>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引。</li></ul><h3 id="2-索引的适用场景"><a href="#2-索引的适用场景" class="headerlink" title="2. 索引的适用场景"></a>2. 索引的适用场景</h3><h4 id="2-1-适合建索引的场景"><a href="#2-1-适合建索引的场景" class="headerlink" title="2.1 适合建索引的场景"></a>2.1 适合建索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="2-2-不适合建索引的场景"><a href="#2-2-不适合建索引的场景" class="headerlink" title="2.2 不适合建索引的场景"></a>2.2 不适合建索引的场景</h4><ol><li>表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）</li><li>经常增删改的表（why：提高了查询速度，同事却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存下索引文件）。</li><li>数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为他建立索引就没有太大的实际效果了。（加入一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980&#x2F;2000&#x3D;0.99。一个索引的选择性越接近于1，这个索引的效率就越高。）</li></ol><h3 id="3-MySQl中索引的结构（B-树）"><a href="#3-MySQl中索引的结构（B-树）" class="headerlink" title="3. MySQl中索引的结构（B+树）"></a>3. MySQl中索引的结构（B+树）</h3><h4 id="3-1-基本概念："><a href="#3-1-基本概念：" class="headerlink" title="3.1 基本概念："></a>3.1 基本概念：</h4><ol><li>二叉树：一个节点最多两个子节点，一个节点只存储一个关键字，等于则命中，小于走左节点，大于走右节点；</li><li>B树：多路搜索树，每个节点存储M&#x2F;2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li><li>B+树：在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li><li>B*树：在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1&#x2F;2提高到2&#x2F;3；</li></ol><h4 id="3-2-B-树的特性："><a href="#3-2-B-树的特性：" class="headerlink" title="3.2 B+树的特性："></a>3.2 B+树的特性：</h4><ol><li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li><li>更适合文件索引系统；</li></ol><h4 id="3-3-B-树的三个特点："><a href="#3-3-B-树的三个特点：" class="headerlink" title="3.3 B+树的三个特点："></a>3.3 B+树的三个特点：</h4><ol><li>关键字数和子树相同<ul><li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li></ul></li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul><li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li><li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li></ul></li><li>叶子节点用指针连在一起<ul><li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li></ul></li></ol><blockquote><p>由于 B+ 树的中间节点不含有实际数据，只有子树的最大数据和子树指针，因此磁盘页中可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。<br>B+ 树的查找必会查到叶子节点，更加稳定。<br>有时候需要查询某个范围内的数据，由于 B+ 树的叶子节点是一个有序链表，只需在叶子节点上遍历即可，不用像 B 树那样挨个中序遍历比较大小。</p></blockquote><h4 id="3-4-B-树的三个优点："><a href="#3-4-B-树的三个优点：" class="headerlink" title="3.4 B+ 树的三个优点："></a>3.4 B+ 树的三个优点：</h4><ul><li>层级更低，IO 次数更少</li><li>每次都需要查询到叶子节点，查询性能稳定</li><li>叶子节点形成有序链表，范围查询方便</li></ul><h3 id="4-索引的优化"><a href="#4-索引的优化" class="headerlink" title="4. 索引的优化"></a>4. 索引的优化</h3><h4 id="4-1-优化法则（口诀）："><a href="#4-1-优化法则（口诀）：" class="headerlink" title="4.1 优化法则（口诀）："></a>4.1 优化法则（口诀）：</h4><ul><li>全值匹配我最爱，最左前缀要遵守</li><li>带头大哥不能死，中间兄弟不能断</li><li>索引列上无计算，范围之后全失效</li><li>like百分写最右，覆盖索引不写星</li><li>不等控制还有or，索引失效要少用</li><li>var引号不能丢，SQL优化也不难</li></ul><h4 id="4-2-具体描述"><a href="#4-2-具体描述" class="headerlink" title="4.2 具体描述"></a>4.2 具体描述</h4><ol><li>全值匹配<ul><li>怎么建索引就怎么用索引，where后面的条件越来越多精度越来越高，精度越来越高带来的就是长度和花费的代价也就越来越多</li></ul></li><li>最佳左前缀法则<ul><li>指的是查询从索引的最左前列开始并且不跳过索引中的列。</li><li>例如：复合索引<code>A-&gt;B-&gt;C</code>，如果把开头A去掉的话，B，C也就都失效了（带头大哥不能死）；如果把中间B去掉的话，则只会走索引A，而C就失效了（中间兄弟不能断）。</li></ul></li><li>不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右面的列<ul><li>例如：<code>select t from test where A=1 and B&gt;2 and C=3</code>，那么B&gt;2后的查询条件失效。</li></ul></li><li>尽量使用覆盖索引————只访问索引的查询（索引列和查询列一致），减少 <code>SELECT *</code>。</li><li>MySQL在使用不等于(<code>!=</code> 或<code>&lt;&gt;</code>)的时候无法使用索引会导致全表扫描</li><li><code>is null</code>，<code>is not null</code> 也无法使用索引</li><li>like以通配符开头<code>(&#39;%abc...&#39;)</code>mysql索引失效回变成全表扫描的操作（使用覆盖索引可解决），只有通配符在右面<code>(&#39;abc...%&#39;)</code>的才能避免索引失效。</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li></ol><h3 id="5-in-和-exists区别及应用场景"><a href="#5-in-和-exists区别及应用场景" class="headerlink" title="5. in 和 exists区别及应用场景"></a>5. in 和 exists区别及应用场景</h3><h4 id="5-1-in-和-exists的区别"><a href="#5-1-in-和-exists的区别" class="headerlink" title="5.1 in 和 exists的区别:"></a>5.1 in 和 exists的区别:</h4><ul><li>如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。</li><li>其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外IN时不对NULL进行处理。</li><li>in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。</li></ul><h4 id="5-2-not-in-和not-exists"><a href="#5-2-not-in-和not-exists" class="headerlink" title="5.2 not in 和not exists"></a>5.2 not in 和not exists</h4><ul><li>如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；</li><li>而not extsts 的子查询依然能用到表上的索引。</li><li>所以无论那个表大，用not exists都比not in要快</li></ul><h3 id="6-order-by-和-group-by-优化"><a href="#6-order-by-和-group-by-优化" class="headerlink" title="6. order by 和 group by 优化"></a>6. order by 和 group by 优化</h3><p>索引的主要作用就是查找和排序，ORDER BY 子句尽量使用Index方式排序，能避免使用FileSort方式排序，尽可能在索引列上外城排序操作，遵照索引键的最佳左前缀。</p><h4 id="6-1-提高ORDER-BY速度的技巧"><a href="#6-1-提高ORDER-BY速度的技巧" class="headerlink" title="6.1 提高ORDER BY速度的技巧"></a>6.1 提高ORDER BY速度的技巧</h4><ol><li>ORDER BY时不要使用SELECT *，只查需要的字段。</li><li>增大<code>sort_buffer_size</code>参数大小（根据系统能力去提高，因为这个参数是针对每个进程的）</li><li>增大<code>max_length_for_sort_data</code>参数大小</li></ol><h4 id="6-2-GROUP-BY的优化"><a href="#6-2-GROUP-BY的优化" class="headerlink" title="6.2 GROUP BY的优化"></a>6.2 GROUP BY的优化</h4><ol><li>GROUP BY实质上是先排序后进行分组，遵照索引的最佳左前缀。</li><li>当无法使用索引列，考虑增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>的参数设置。</li><li>WHERE 高于 HAVING，能写在WHERE解决的条件就不要去HAVING限定了。</li></ol><blockquote><p>注意：group by 表面上叫分组，但是分组之前比排序。所以说group by和order by两者排序的法则和索引优化的原则几乎是一致的。当然也有不一样的地方，group by 还有having的存在。如果group by错乱，会导致临时表的产生。(就是说group by的顺序不对，建好的索引我用不上，我内部使用了内排序产生了filesort，为了把这些数据挪出来内部建了一张临时表来进行分组)</p></blockquote><p>一般性建议：</p><ul><li>对于单值索引，尽量选择针对query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段的顺序中，位置越靠左越好。</li><li>在选择组合索引的时候，尽量选择可能包含当前query中的where子句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的。</li></ul><blockquote><p>参考链接：<a href="https://www.zhihu.com/people/hen-six-49/activities">https://www.zhihu.com/people/hen-six-49/activities</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「MySQL」MySQL性能优化基础</title>
      <link href="/2019/02/01/mysql-base.html"/>
      <url>/2019/02/01/mysql-base.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-MySQL基础操作"><a href="#1-MySQL基础操作" class="headerlink" title="1. MySQL基础操作"></a>1. MySQL基础操作</h3><h4 id="1-1-MySQL备份与恢复"><a href="#1-1-MySQL备份与恢复" class="headerlink" title="1.1 MySQL备份与恢复"></a>1.1 MySQL备份与恢复</h4><ol><li>备份：在mysql的安装目录的bin目录下有<strong>mysqldump命令</strong>，可以完成对数据库的备份。 <ul><li>语法：<code>mysqldump -u 用户名 -p 数据库名&gt; 磁盘SQL文件路径</code> <span id="more"></span></li><li>由于mysqldump命令不是sql命令，需要在<strong>dos窗口下使用</strong>。</li><li>仅仅只会备份数据库中的表和数据，恢复时需要先手动创建数据库。</li></ul></li><li>恢复：先手动创建数据库：<code>create database 数据库名</code><ul><li>然后dos窗口：<code>mysql -u 用户名-p 导入库名&lt; 磁盘SQL文件绝对路径</code></li></ul></li></ol><h4 id="1-2-MySQL事务基础"><a href="#1-2-MySQL事务基础" class="headerlink" title="1.2 MySQL事务基础"></a>1.2 MySQL事务基础</h4><ol><li>特性(ACID)：<strong>原子性</strong>（Atomicity，或称不可分割性）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation，又称独立性）、<strong>持久性</strong>（Durability）。</li><li>事务隔离级别：<strong>读未提交</strong>（Read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（Serializable）。</li><li>MYSQL事务处理主要有两种方法： <ol><li>用 BEGIN, ROLLBACK, COMMIT来实现:<ul><li>BEGIN 开始一个事务</li><li>COMMIT 事务确认 </li><li>ROLLBACK 事务回滚</li></ul></li><li>直接用 SET 来改变 MySQL 的自动提交模式: <ul><li>SET AUTOCOMMIT&#x3D;0 禁止自动提交</li><li>SET AUTOCOMMIT&#x3D;1 开启自动提交</li></ul></li></ol></li><li>事务并发操作出现几种问题: 丢失修改数据、读“脏”数据、数据不一致</li></ol><h4 id="1-3-查看设置MySQL编码"><a href="#1-3-查看设置MySQL编码" class="headerlink" title="1.3 查看设置MySQL编码"></a>1.3 查看设置MySQL编码</h4><ol><li>查看：<code>mysql&gt; show variables like &#39;character%&#39;</code></li><li>设置: # <code>vi /etc/my.cnf</code>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">character‐set‐server=utf8</span><br><span class="line">collation‐server=utf8_general_ci</span><br><span class="line">sql_mode=<span class="string">&#x27;NO_ENGINE_SUBSTITUTION&#x27;</span></span><br><span class="line">[mysql] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[mysql.server] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[mysqld_safe] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8 </span><br><span class="line">[client] </span><br><span class="line"><span class="keyword">default</span>‐character‐set = utf8</span><br></pre></td></tr></table></figure></li><li>mysql的主配置文件: <code>/etc/my.cnf</code></li><li>数据库文件存放位置: <code>/var/lib/mysql</code></li><li>数据库的日志输出存放位置: <code>/var/log/mysql</code></li><li>端口: <code>Netstat –nltp</code> 看是否能找到3306的端口</li></ol><h4 id="1-4-范式"><a href="#1-4-范式" class="headerlink" title="1.4 范式"></a>1.4 范式</h4><p>概念：范式就是符合某一规范级别的关系模式的集合。共有7种范式：<code>1NF⊃2NF⊃3NF⊃BCNF⊃4NF⊃5NF⊃6NF</code></p><ol><li>第一范式(1NF, First Normal Form)：字段值具有<strong>原子性</strong>,不能再分(所有关系型数据库系统都满足第一范式);<ul><li>例如：姓名字段,其中姓和名是一个整体,如果区分姓和名那么必须设立两个独立字段;</li></ul></li><li>第二范式(2NF, Second Normal Form)：一个表<strong>必须有主键</strong>,即每行数据都能被唯一的区分(2NF必须先满足第一范式);</li><li>第三范式(3NF, Third Normal Form)：一个表中不能包涵其他相关表中非关键字段的信息,即数据表<strong>不能有冗余字段</strong>(3NF必须先满足第二范式);<ul><li>备注：往往我们在设计表中不能遵守第三范式,因为合理的沉余字段将会给我们减少join的查询;</li><li>例如：相册表中会添加图片的点击数字段,在相册图片表中也会添加图片的点击数字段;</li></ul></li></ol><h3 id="2-SQL语句优化"><a href="#2-SQL语句优化" class="headerlink" title="2. SQL语句优化"></a>2. SQL语句优化</h3><h4 id="2-1-通过慢查日志发现有问题的SQL"><a href="#2-1-通过慢查日志发现有问题的SQL" class="headerlink" title="2.1 通过慢查日志发现有问题的SQL"></a>2.1 通过慢查日志发现有问题的SQL</h4><ol><li>查询次数多且每次查询占用时间长的sql<ul><li>通常为<strong>pt-query-digest</strong>分析的前几个查询；该工具可以很清楚的看出每个SQL执行的次数及百分比等信息，执行的次数多，占比比较大的SQL</li></ul></li><li>IO大的sql<ul><li>注意pt-query-digest分析中的Rows examine项。扫描的行数越多，IO越大。</li></ul></li><li>未命中的索引的SQL<ul><li>注意pt-query-digest分析中的Rows examine 和Rows Send的对比。说明该SQL的索引命中率不高，对于这种SQL，我们要重点进行关注。</li></ul></li><li>通过explain查询分析SQL的执行计划, SQL的执行计划侧面反映出了SQL的执行效率，</li></ol><h4 id="2-2-常见SQL优化手段"><a href="#2-2-常见SQL优化手段" class="headerlink" title="2.2 常见SQL优化手段"></a>2.2 常见SQL优化手段</h4><ol><li>函数Max()的优化<ul><li>在求max的字段<strong>建索引</strong></li></ul></li><li>函数Count()的优化：<ul><li>Count(*):是包含null值；Count(id)：不包含null值</li></ul></li><li>子查询的优化<ul><li>子查询是我们在开发过程中经常使用的一种方式，在通常情况下，需要把<strong>子查询优化为join查询</strong>但在优化是需要注意关联键是否有一对多的关系，要注意重复数据(distinct去重)。</li><li>在用Join进行多表联合查询时，我们通常使用On来建立两个表的关系。其实还有一个更方便的关键字，那就是Using（如果两个表的关联字段名是一样）。</li></ul></li><li>group by的优化: <ul><li>最好使用同一表中的列，在子查询中分组</li></ul></li><li>Limit查询的优化：Limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts这样会造成大量的IO问题。<ul><li>优化步骤1：使用有索引的列或主键进行order by操作，因为大家知道，innodb是按照主键的逻辑顺序进行排序的。可以避免很多的IO操作。</li><li>优化步骤2：记录上次返回的主键， 在下次查询时使用主键过滤。（说明：避免了数据量大时扫描过多的记录）</li><li>注意事项：主键要顺序排序并连续的，如果主键中间空缺了某一列，或者某几列，会出现列出数据不足一页的数据；如果不连续的情况，建立一个附加的列index_id列，保证这一列数据要自增的，并添加索引即可。</li></ul></li></ol><h3 id="3-索引的优化"><a href="#3-索引的优化" class="headerlink" title="3. 索引的优化"></a>3. 索引的优化</h3><h4 id="3-1-索引基础概念"><a href="#3-1-索引基础概念" class="headerlink" title="3.1 索引基础概念"></a>3.1 索引基础概念</h4><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><ul><li>索引的建立是表中<strong>比较有指向性的字段</strong>，相当于目录，比如说行政区域代码，同一个地域的行政区域代码都是相同的，那么给这一列加上索引，避免让它重复扫描，从而达到优化的目的！</li><li>创建索引：在执行create table语句时可以创建索引，也可以单独用create index或alter index来为表增加索引。<strong>不能用create index语句创建primary key索引</strong>。</li><li>在创建索引时，可以规定索引能否包含重复值。如果不包含，则索引应该创建为primary key或unique索引。对于单列惟一性索引，这保证单列不包含重复的值。对于<strong>多列惟一性索引，保证多个值的组合不重复</strong>。</li><li>primary key索引和unique索引非常类似。事实上，<strong>primary key索引仅是一个具有名称PRIMARY的unique索引</strong>。</li><li>查看索引：<code>show index from tblname;</code>或<code>show keys from tblname;</code></li></ul><h4 id="3-2-索引的创建与删除"><a href="#3-2-索引的创建与删除" class="headerlink" title="3.2 索引的创建与删除"></a>3.2 索引的创建与删除</h4><ol><li>创建<strong>普通索引</strong>：<ul><li>方式1：<code>create index 索引名 on 表名(列名)</code></li><li>方式2：<code>alter table 表名 add index 索引名(列名)</code></li><li>方式3：创建表的时候直接指定: <code>,index [索引名] (列名)</code></li></ul></li><li>删除索引： <code>drop index [索引名] on 表名</code></li><li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li><li>创建<strong>唯一索引</strong>：<ul><li>方式1：<code>create unique index 索引名 on 表名(列名)</code></li><li>方式2：<code>alter table 表名 add unique 索引名(列名)</code></li><li>方式3：创建表的时候直接指定: <code>,unique [索引名] (列名)</code></li></ul></li></ol><h4 id="3-3-使用索引的场景"><a href="#3-3-使用索引的场景" class="headerlink" title="3.3 使用索引的场景"></a>3.3 使用索引的场景</h4><ol><li>表的主键自动建立唯一索引</li><li>表的字段唯一约束</li><li>直接条件查询的字段（在SQL中用于条件约束的字段）</li><li>查询中与其它表关联的字段</li><li>查询中排序的字段（排序的字段如果通过索引去访问那将大大提高排序速度）</li><li>查询中统计或分组统计的字段</li><li>表记录太少（如果一个表只有5条记录，采用索引去访问记录的话，那首先需访问索引表，再通过索引表访问数据表，一般索引表与数据表不在同一个数据块）</li><li>经常插入、删除、修改的表（对一些经常处理的业务表应在查询允许的情况下尽量减少索引）</li><li>数据重复且分布平均的表字段（假如一个表有10万行记录，有一个字段A只有T和F两种值，且每个值的分布概率大约为50%，那么对这种表A字段建索引一般不会提高数据库的查询速度。）</li><li>经常和主字段一块查询但主字段索引值比较多的表字段</li><li>对千万级MySQL数据库建立索引的事项及提高性能的手段</li></ol><h4 id="3-4-索引的维护及优化（重复及冗余索引）"><a href="#3-4-索引的维护及优化（重复及冗余索引）" class="headerlink" title="3.4 索引的维护及优化（重复及冗余索引）"></a>3.4 索引的维护及优化（重复及冗余索引）</h4><p>增加索引会有利于查询效率，但会降低insert，update，delete的效率，但实际上往往不是这样的，<strong>过多的索引会不但会影响使用效率，同时会影响查询效率</strong>，这是由于数据库进行查询分析时，首先要选择使用哪一个索引进行查询，如果索引过多，分析过程就会越慢，这样同样的减少查询的效率，因此我们要知道如何增加，有时候要知道维护和删除不需要的索引</p><ul><li>重复索引：重复索引是指相同的列以相同的顺序建立的同类型的索引，如在primary key再建立唯一索引就是重复索引</li><li>冗余索引：冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，如对于innodb来说，每一个索引后面，实际上都会包含主键，这时候我们建立的联合索引，又人为的把主键包含进去，那么这个时候就是一个冗余索引。</li><li>工具：使用**<code>pt-duplicate-key-checker</code>工具检查重复及冗余索引**: <code>pt-duplicate-key-checker -uroot -padmin -h 127.0.0.1</code></li><li>索引维护的方法: 由于业务变更，某些索引是后续不需要使用的，就要进行<strong>删除</strong>。</li><li>在mysql中，目前只能通过慢查询日志配合pt-index-usage工具来进行索引使用情况的分析；<code>pt-index-usage -uroot -padmin /var/lib/mysql/mysql-host-slow.log</code></li></ul><h4 id="3-5-设计MySql索引的注意事项"><a href="#3-5-设计MySql索引的注意事项" class="headerlink" title="3.5 设计MySql索引的注意事项"></a>3.5 设计MySql索引的注意事项</h4><p>设计好MySql的索引可以让你的数据库飞起来，大大的提高数据库效率。设计MySql索引的时候有一下几点注意：</p><ol><li><strong>创建索引</strong><ul><li>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。</li><li>但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。</li></ul></li><li><strong>复合索引</strong><ul><li>比如有一条语句是这样的：select * from users where area&#x3D;’beijing’ and age&#x3D;22;</li><li>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age,salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为<strong>最佳左前缀特性</strong>。</li><li>因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。</li></ul></li><li>索引不会包含有NULL值的列<ul><li>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有<strong>NULL值</strong>，那么这一列对于此复合索引就是<strong>无效</strong>的。所以我们在数据库设计时不要让字段的默认值为NULL。</li></ul></li><li>使用短索引<ul><li>对字符串列进行索引，如果可能应该<strong>指定一个前缀长度</strong>。</li><li>例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I&#x2F;O操作。</li></ul></li><li>排序的索引问题<ul><li>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列<strong>创建复合索引</strong>。</li></ul></li><li>like语句操作<ul><li>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” <strong>不会使用索引</strong>，而like “aaa%”可以使用索引。</li></ul></li><li>不要在列上进行运算<ul><li>select * from users where YEAR(adddate)</li></ul></li><li>不使用NOT IN操作<ul><li>NOT IN操作都不会使用索引将进行全表扫描。NOT IN可以<strong>NOT EXISTS代替</strong></li></ul></li></ol><h3 id="4-MYSQL数据库设计规范与原则"><a href="#4-MYSQL数据库设计规范与原则" class="headerlink" title="4. MYSQL数据库设计规范与原则"></a>4. MYSQL数据库设计规范与原则</h3><h4 id="4-1-设计规范"><a href="#4-1-设计规范" class="headerlink" title="4.1 设计规范"></a>4.1 设计规范</h4><ol><li>命名规范<ul><li>采用26个英文字母(区分大小写)和0-9的自然数(经常不需要)加上下划线’_’组成</li><li>命名简洁明确,多个单词用下划线’_’分隔,长度不超过30个字符</li><li>除非是备份数据库可以加0-9的自然数,如：<code>&#39;user_db_20191210&#39;</code></li><li>表前缀可以有效的把相同关系的表显示在一起,如：<code>&#39;user_&#39;</code></li><li>每个表中必须有自增主键</li><li>表与表之间的相关联字段名称要求尽可能的相同</li></ul></li><li>字段类型规范<ul><li>用尽量少的存储空间来存数一个字段的数据, 例如：能使用int就不要使用varchar、char,能用varchar(16)就不要使用varchar(256);</li><li>IP地址最好使用int类型;</li><li>固定长度的类型最好使用char,例如：邮编;</li><li>能使用tinyint就不要使用smallint,int;</li><li>最好给每个字段一个默认值, 最好不能为null;</li></ul></li><li>索引规范<ul><li>命名简洁明确,例如：<code>user_login</code>表<code>user_name</code>字段的索引应为<code>user_name_index</code>唯一索引;</li><li>为每个表创建一个主键索引;</li><li>为每个表创建合理的索引;</li><li>建立复合索引请<strong>慎重</strong>;</li></ul></li></ol><h4 id="4-2-设计原则"><a href="#4-2-设计原则" class="headerlink" title="4.2 设计原则"></a>4.2 设计原则</h4><ol><li>核心原则<ul><li>不在数据库做运算;</li><li>cpu计算务必移至业务层;</li><li>控制列数量(字段少而精,字段数建议在20以内);</li><li>平衡范式与冗余(效率优先；往往牺牲范式)</li><li>拒绝3B(拒绝大sql语句：big sql、拒绝大事务：big transaction、拒绝大批量：big batch);</li></ul></li><li>字段类原则<ul><li>用好数值类型(用合适的字段类型节约空间);</li><li>字符转化为数字(能转化的最好转化,同样节约空间、提高查询性能);</li><li>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效);</li><li>少用text类型(尽量使用varchar代替text字段);</li></ul></li><li>索引类原则<ul><li>合理使用索引(改善查询,减慢更新,索引一定不是越多越好);</li><li>字符字段必须建前缀索引;</li><li>不在索引做列运算;</li><li>innodb主键推荐使用自增列(主键建立聚簇索引,主键不应该被修改,字符串不应该做主键)(理解Innodb的索引保存结构就知道了);</li><li>不用外键(由程序保证约束);</li></ul></li><li>sql类原则<ul><li>sql语句尽可能简单(一条sql只能在一个cpu运算,大语句拆小语句,减少锁时间,一条大sql可以堵死整个库);</li><li>简单的事务;</li><li>避免使用trig&#x2F;func(触发器、函数不用客户端程序取而代之);</li><li>不用select *(消耗cpu,io,内存,带宽,这种程序不具有扩展性);</li><li>OR改写为IN(or的效率是n级别);</li><li>OR改写为UNION(mysql的索引合并很弱智);</li><li>避免负向%;</li><li>慎用count(*);</li><li>limit高效分页(limit越大，效率越低);</li><li>使用union all替代union(union有去重开销);</li><li>少用连接join;</li><li>使用group by;</li><li>请使用同类型比较;</li><li>打散批量更新;</li></ul></li></ol><h3 id="5-数据库结构的优化"><a href="#5-数据库结构的优化" class="headerlink" title="5. 数据库结构的优化"></a>5. 数据库结构的优化</h3><h4 id="5-1-选择合适的数据类型"><a href="#5-1-选择合适的数据类型" class="headerlink" title="5.1 选择合适的数据类型"></a>5.1 选择合适的数据类型</h4><p>数据类型的选择，重点在于“合适”二字</p><ol><li>使用可以存下你的数据的最小的数据类型。（时间类型数据：可以使用varchar类型，可以使用int类型，也可以使用时间戳类型）</li><li>使用简单的数据类型，int要比varchar类型在mysql处理上简单。（int类型存储时间是最好的选择）</li><li>尽可能的使用not null定义字段。（innodb的特性所决定，非not null的值，需要额外的在字段存储，同时也会增加IO和存储的开销）</li><li>尽量少用text类型，非用不可时最好考虑分表。</li></ol><h4 id="5-2-数据库表的范式化优化"><a href="#5-2-数据库表的范式化优化" class="headerlink" title="5.2 数据库表的范式化优化"></a>5.2 数据库表的范式化优化</h4><ol><li>表范式化<ul><li>范式化是指数据库设计的规范，目前说道范式化一般是指第三设计范式。也就是要求数据表中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式。</li></ul></li><li>反范式化<ul><li>反范式化是指为了查询效率的考虑把原本符合<strong>第三范式</strong>的表“适当”的<strong>增加冗余</strong>，以达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</li></ul></li></ol><h4 id="5-3-数据库表的垂直拆分"><a href="#5-3-数据库表的垂直拆分" class="headerlink" title="5.3 数据库表的垂直拆分"></a>5.3 数据库表的垂直拆分</h4><p>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。</p><ul><li>垂直拆分原则<ol><li>把不常用的字段表单独存放到一个表中。</li><li>把大字段独立存放到一个表中。</li><li>把经常一起使用的字段放到一起。</li></ol></li></ul><h4 id="5-4-数据库表的水平拆分"><a href="#5-4-数据库表的水平拆分" class="headerlink" title="5.4 数据库表的水平拆分"></a>5.4 数据库表的水平拆分</h4><p>表的水平拆分是为了解决单表数据量过大的问题，水平拆分的表每一个表的结构都是完全一致的</p><ol><li>水平拆分原因<ul><li>如果单表的数据量达到上亿条，那么这时候我们尽管加了完美的索引，查询效率低，写入的效率也相应的降低。</li></ul></li><li>如何将数据平均分为N份<ol><li>对customer_id进行hash运算，如果要拆分为5个表则使用mod（customer_id，5）取出0-4个值。</li><li>针对不动的hashid把数据存储到不同的表中。</li></ol></li><li>水平拆分面临的挑战<ol><li>夸分区表进行数据查询<ul><li>前端业务统计：业务上给不同的用户返回不同的业务信息，对分区表没有大的挑战。</li></ul></li><li>统计及后台报表操作<ul><li>但是对后台进行报表统计时，数据量比较大，后台统计时效性比较低，后台就用汇总表，将前后台的表拆分开。</li></ul></li></ol></li></ol><h3 id="6-数据库系统配置优化"><a href="#6-数据库系统配置优化" class="headerlink" title="6. 数据库系统配置优化"></a>6. 数据库系统配置优化</h3><p>数据库是基于操作系统的，目前大多数MySQL都是安装在<strong>linux系统</strong>之上，所以对于操作系统的一些参数配置也会影响到MySQL的性能</p><h4 id="6-1-操作系统的优化"><a href="#6-1-操作系统的优化" class="headerlink" title="6.1 操作系统的优化"></a>6.1 操作系统的优化</h4><p>网络方面的配置，要修改<code>/etc/sysctl.conf</code></p><ol><li>增加tcp支持的队列数<ul><li><code>net.ipv4.tcp_max_syn_backlog = 65535</code></li></ul></li><li>减少断开连接时，资源回收(tcp有连接状态)<ul><li><code>net.ipv4.tcp_max_tw_buckets = 8000</code></li><li><code>net.ipv4.tcp_tw_reuse = 1</code></li><li><code>net.ipv4.tcp_tw_recycle = 1</code></li><li><code>net.ipv4.tcp_fin_timeout = 10</code></li><li>说明： TCP是有连接状态，通过netstat查看连接状态，经常会看到timeout状态或者timewait状态连接，为了加快timewait状态的连接回收，就需要调整上面的四个参数，保持TCP连接数在一个适当的状态。</li></ul></li></ol><h4 id="6-2-打开文件数的限制"><a href="#6-2-打开文件数的限制" class="headerlink" title="6.2 打开文件数的限制"></a>6.2 打开文件数的限制</h4><p>打开文件数的限制，可以使用ulimit –a查看目录的各个限制，可以修改<code>/etc/security/limits.conf</code>文件</p><ul><li>limits.conf中增加以下内容以修改打开文件数量的限制（永久生效）<ul><li><code>*Soft nofile 65535</code></li><li><code>*Hard nofile 65535</code></li></ul></li><li>如果一次有效，就要使用<code>ulimit –n 65535</code>即可。（默认情况是1024）</li><li>除此之外最好在MySQL服务器上关闭iptables，selinux等防火墙软件</li></ul><h4 id="6-3-MySQL配置文件优化"><a href="#6-3-MySQL配置文件优化" class="headerlink" title="6.3 MySQL配置文件优化"></a>6.3 MySQL配置文件优化</h4><p>Mysql可以通过启动时指定参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于<code>/etc/my.cnf</code>或<code>/etc/mysql/my.cnf</code></p><ul><li>MySQL<strong>查找配置文件的顺序</strong>可以通过以下命令获得：<ul><li><code>/usr/sbin/mysqld --verbose --help | grep -A 1 &#39;default options&#39;</code></li><li>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的。</li></ul></li></ul><h5 id="6-3-1-my-cnf常用-连接请求-参数"><a href="#6-3-1-my-cnf常用-连接请求-参数" class="headerlink" title="6.3.1 my.cnf常用 连接请求 参数"></a>6.3.1 <code>my.cnf</code>常用 连接请求 参数</h5><ol><li><code>max_connections</code>：最大连接数<ul><li>如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，MySQL会为每个连接提供连接缓冲区，连接数越多就会开销越多的内存，所以要<strong>适当调整该值</strong>，不能盲目提高设值。</li><li>数值过小会经常出现ERROR 1040: Too many connections错误，可以过’conn%’通配符查看当前状态的连接数量，以定夺该值的大小。</li><li><code>max_used_connections / max_connections * 100% </code>（**理想值≈ 85%**）: 响应的连接数&#x2F;最大连接数</li></ul></li><li><code>back_log</code>：能暂存的连接数量<ul><li>如果MySQL的连接数据达到<code>max_connections</code>时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即<code>back_log</code>，如果等待连接的数量超过<code>back_log</code>，将不被授予连接资源。</li><li><strong>默认数值是50，可调优为128</strong>，对于Linux系统设置范围为小于512的整数。</li></ul></li><li><code>interactive_timeout</code>：服务器关闭<strong>交互式连接</strong>前等待活动的秒数<ul><li>默认数值是28800，可调优为7200。</li></ul></li><li><code>wait_timeout</code>：服务器关闭<strong>非交互连接</strong>之前等待活动的秒数<ul><li>指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</li></ul></li></ol><h5 id="6-3-1-my-cnf常用-缓冲区-参数"><a href="#6-3-1-my-cnf常用-缓冲区-参数" class="headerlink" title="6.3.1 my.cnf常用 缓冲区 参数"></a>6.3.1 <code>my.cnf</code>常用 缓冲区 参数</h5><ol><li><code>key_buffer_size</code>: 指定索引缓冲区的大小<ul><li>它决定索引处理的速度，尤其是索引读的速度。</li><li>它只对<strong>MyISAM表起作用</strong>。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值</li></ul></li><li><code>query_cache_size</code> ：查询缓存的内存<ul><li>使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。</li><li>通过检查状态值Qcache_*，可以知道<code>query_cache_size</code>设置是否合理（上述状态值可以使用<code>SHOW STATUS LIKE ‘Qcache%’</code>获得）。如果<code>Qcache_lowmem_prunes</code>的值非常大，则表明经常出现缓冲不够的情况，如果<code>Qcache_hits</code>的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果<code>Qcache_hits</code>的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入<code>SQL_NO_CACHE</code>可以明确表示不使用查询缓冲。</li><li>与查询缓冲有关的参数还有<code>query_cache_type</code>、<code>query_cache_limit</code>、<code>query_cache_min_res_unit</code>。<ul><li><code>query_cache_type</code>指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。</li><li><code>query_cache_limit</code>指定单个查询能够使用的缓冲区大小，缺省为1M。</li><li><code>query_cache_min_res_unit</code>指定分配缓冲区空间的最小单位，缺省为4K。检查状态值<code>Qcache_free_blocks</code>，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小<code>query_cache_min_res_unit</code>。</li></ul></li></ul></li><li><code>record_buffer_size</code>：顺序扫描缓冲区大小<ul><li>每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</li><li>默认数值是131072(128K)，可改为16773120 (16M)</li></ul></li><li><code>read_rnd_buffer_size</code>：随机读缓冲区大小<ul><li>当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。一般可设置为16M</li></ul></li><li><code>sort_buffer_size</code>：排序扫描缓冲区大小<ul><li>每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY或GROUP BY操作。</li><li>默认数值是2097144(2M)，可改为16777208 (16M)。</li></ul></li><li><code>join_buffer_size</code>：联合查询缓冲区大小<ul><li>联合查询操作所能使用的缓冲区大小。</li><li><code>record_buffer_size</code>，<code>read_rnd_buffer_size</code>，<code>sort_buffer_size</code>，<code>join_buffer_size</code>为每个线程独占，也就是说，如果有100个线程连接，则占用为16M*100</li></ul></li><li><code>table_cache</code>：表高速缓存的大小<ul><li>表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值<code>Open_tables</code>和<code>Opened_tables</code>，可以决定是否需要增加<code>table_cache</code>的值。如果你发现open_tables等于<code>table_cache</code>，并且opened_tables在不断增长，那么你就需要增加<code>table_cache</code>的值了（上述状态值可以使用<code>SHOW STATUS LIKE ‘Open%tables’</code>获得）。注意，不能盲目地把<code>table_cache</code>设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。</li><li>1G内存机器，推荐值是128－256。内存在4GB左右的服务器该参数可设置为256M或384M。</li></ul></li><li><code>max_heap_table_size</code>：用户可以创建的内存表(memory table)的大小<ul><li>这个值用来计算内存表的最大行数值。这个变量支持动态改变，即set @max_heap_table_size&#x3D;#</li><li>这个变量和tmp_table_size一起限制了内部内存表的大小。如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。</li></ul></li><li><code>tmp_table_size</code>：临时表的大小<ul><li>通过设置<code>tmp_table_size</code>选项来增加一张临时表的大小，例如做高级GROUP BY操作生成的临时表。如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果，建议尽量优化查询，要确保查询过程中生成的临时表在内存中，避免临时表过大导致生成基于硬盘的MyISAM表。</li><li>每次创建临时表，<code>Created_tmp_tables</code>增加，如果临时表大小超过<code>tmp_table_size</code>，则是在磁盘上创建临时表，<code>Created_tmp_disk_tables</code>也增加,<code>Created_tmp_files</code>表示MySQL服务创建的临时文件文件数</li><li>比较理想的配置是：<code>Created_tmp_disk_tables / Created_tmp_tables * 100% &lt;= 25%</code>比如上面的服务器<code>Created_tmp_disk_tables / Created_tmp_tables * 100% ＝1.20%</code>，应该相当好了</li><li>默认为16M，可调到64-256最佳，线程独占，太大可能内存不够I&#x2F;O堵塞</li></ul></li><li><code>thread_cache_size</code>：可以复用的保存在中的线程的数量<ul><li>可以复用的保存在中的线程的数量。如果有，新的线程从缓存中取得，当断开连接的时候如果有空间，客户的线置在缓存中。如果有很多新的线程，为了提高性能可以这个变量值。</li><li>通过比较 Connections和<code>Threads_created</code>状态的变量，可以看到这个变量的作用。默认值为110，可调优为80。</li></ul></li><li><code>thread_concurrency</code>：同一时间运行的线程系统提示所需数量的线程<ul><li>推荐设置为服务器 CPU核数的2倍，</li><li>例如双核的CPU, 那么<code>thread_concurrency</code>的应该为4；2个双核的cpu, <code>thread_concurrency</code>的值应为8。默认为8</li><li>这个参数<strong>已经在5.7.2版本的MySQL中被移除</strong></li></ul></li></ol><h5 id="6-3-1-my-cnf常用-配置InnoDB的-参数"><a href="#6-3-1-my-cnf常用-配置InnoDB的-参数" class="headerlink" title="6.3.1 my.cnf常用 配置InnoDB的 参数"></a>6.3.1 <code>my.cnf</code>常用 配置InnoDB的 参数</h5><ol><li><code>innodb_buffer_pool_size</code>：缓冲池大小<ul><li>对于InnoDB表来说，<code>innodb_buffer_pool_size</code>的作用就相当于<code>key_buffer_size</code>对于MyISAM表的作用一样。</li><li>InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。</li><li>根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。</li></ul></li><li><code>innodb_flush_log_at_trx_commit</code>：主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个<ul><li>设置为0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；</li><li>设置为1，则在每秒钟或是每次事物的提交都会引起日志文件写入、flush磁盘的操作，确保了事务的ACID；</li><li>设置为2，每次事务提交引起写入日志文件的动作，但每秒钟完成一次flush磁盘操作。</li><li>实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</li><li>根据MySQL手册，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</li></ul></li><li><code>innodb_log_buffer_size</code>：log缓存大小<ul><li>一般为1-8M，默认为1M，对于较大的事务，可以增大缓存大小。可设置为4M或8M。</li></ul></li><li><code>innodb_additional_mem_pool_size</code>：内存池大小<ul><li>该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。</li><li>根据MySQL手册，对于2G内存的机器，推荐值是20M，可适当增加。</li><li><code>innodb_thread_concurrency=8</code>，推荐设置为 2*(NumCPUs+NumDisks)，默认一般为8</li></ul></li><li><code>skip-name-resolve</code>：禁止域名解析<ul><li>禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。</li><li>但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</li></ul></li></ol><h3 id="7-MySQL的执行顺序"><a href="#7-MySQL的执行顺序" class="headerlink" title="7. MySQL的执行顺序"></a>7. MySQL的执行顺序</h3><p>MySQL的语句一共分为<strong>11步</strong>，最<strong>先</strong>执行的总是<strong>FROM</strong>操作，最<strong>后</strong>执行的是<strong>LIMIT</strong>操作。</p><ul><li>其中<strong>每一个操作都会产生一张虚拟的表</strong>，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明的，但是只有<strong>最后一个虚拟的表才会被作为结果返回</strong>。</li><li>如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。<ul><li>⑧<code>select</code></li><li>⑨<code>distinct &lt;字段名&gt;</code></li><li>①<code>from &lt;表名&gt;</code></li><li>③<code>&lt;连接类型&gt;join &lt;表名&gt;</code></li><li>②<code>on&lt;连接条件&gt;</code></li><li>④<code>where&lt;查询条件&gt;</code></li><li>④<code>group by&lt;分组字段&gt;</code></li><li>⑥<code>with&#123;cube|rollup&#125;</code></li><li>⑦<code>having&lt;查询条件&gt;</code></li><li>⑩<code>order by&lt;排序字段&gt;</code></li><li>⑪<code>limit&lt;分页数量&gt;</code></li></ul></li></ul><p>查询处理的每一个阶段分析：</p><ol><li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算<strong>笛卡尔积</strong>。产生虚表VT1</li><li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<code>&lt;连接条件&gt;</code>的行才会被记录在虚表VT2中。</li><li><strong>JOIN</strong>：如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。</li><li><strong>WHERE</strong>：对虚拟表VT3进行WHERE条件过滤。只有符合<code>&lt;where查询条件&gt;</code>的记录才会被插入到虚拟表VT4中。</li><li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li><li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li><li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<code>&lt;having查询条件&gt;</code>的记录才会被 插入到虚拟表VT7中。</li></ol><h3 id="8-MySQL执行引擎"><a href="#8-MySQL执行引擎" class="headerlink" title="8. MySQL执行引擎"></a>8. MySQL执行引擎</h3><h4 id="8-1-MyISAM存储引擎"><a href="#8-1-MyISAM存储引擎" class="headerlink" title="8.1 MyISAM存储引擎"></a>8.1 MyISAM存储引擎</h4><ul><li><strong>不支持事务、也不支持外键</strong>，优势是<strong>访问速度快</strong>，对事务完整性没有 要求或者以select，insert为主的应用基本上可以用这个引擎来创建表</li><li>支持3种不同的存储格式，分别是：静态表；动态表；压缩表</li><li>静态表：<ul><li>表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。</li></ul></li><li>动态表：<ul><li>记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能</li></ul></li><li>压缩表：<ul><li>因为每个记录是被单独压缩的，所以只有非常小的访问开支</li></ul></li></ul><h4 id="8-2-InnoDB存储引擎"><a href="#8-2-InnoDB存储引擎" class="headerlink" title="8.2 InnoDB存储引擎"></a>8.2 InnoDB存储引擎</h4><ul><li>提供了具有提交、回滚和崩溃恢复能力的<strong>事务安全</strong>。但是对比MyISAM引擎，<strong>写的处理效率会差一些</strong>，并且会占用更多的磁盘空间以保留数据和索引。 </li><li>InnoDB存储引擎的特点：<strong>支持自动增长列，支持外键约束</strong></li></ul><h4 id="8-3-MEMORY存储引擎"><a href="#8-3-MEMORY存储引擎" class="headerlink" title="8.3 MEMORY存储引擎"></a>8.3 MEMORY存储引擎</h4><ul><li>Memory存储引擎使用存在于内存中的内容来创建表。每个memory表只实际对应一个磁盘文件，格式是.frm。memory类型的表访问非常的快，因为它的数据是放在内存中的，并且<strong>默认使用HASH索引</strong>，但是<strong>一旦服务关闭，表中的数据就会丢失掉</strong>。 </li><li>MEMORY存储引擎的表可以选择使用<strong>BTREE索引</strong>或者<strong>HASH索引</strong>，两种不同类型的索引有其不同的使用范围</li><li>Hash索引优点： <ul><li>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引。</li></ul><p> </p></li><li>Hash索引缺点： <ul><li>那么不精确查找呢，也很明显，因为hash算法是基于等值计算的，所以对于“like”等范围查找hash索引无效，不支持；</li></ul></li><li>Memory类型的存储引擎主要用于哪些内容变化不频繁的代码表，或者作为统计操作的中间结果表，便于高效地对中间结果进行分析并得到最终的统计结果，。对存储引擎为memory的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以一定要对下次重新启动服务后如何获得这些修改后的数据有所考虑。</li></ul><h4 id="8-4-MERGE存储引擎"><a href="#8-4-MERGE存储引擎" class="headerlink" title="8.4 MERGE存储引擎"></a>8.4 MERGE存储引擎</h4><ul><li>Merge存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，merge表本身并没有数据，对merge类型的表可以进行查询，更新，删除操作，这些操作实际上是对内部的MyISAM表进行的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ElasticStack」Beats+Logstash+Elasticsearch+Kibana基础整合</title>
      <link href="/2018/11/28/elastic-stack.html"/>
      <url>/2018/11/28/elastic-stack.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-ElasticStack-的组成"><a href="#1-ElasticStack-的组成" class="headerlink" title="1. ElasticStack 的组成"></a>1. ElasticStack 的组成</h3><ol><li>**<code>Beats</code>**：数据采集</li><li><strong><code>LogStash</code></strong>: 数据处理</li><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<span id="more"></span></li></ol><p><img src="/2018/11/28/elastic-stack/elastic-stream.jpg"></p><h3 id="2-Filebeat"><a href="#2-Filebeat" class="headerlink" title="2. Filebeat"></a>2. Filebeat</h3><p><code>Filebeat</code>是本地文件的轻量型日志数据采集器。<br><code>Beats</code>可以直接（或者通过<code>Logstash</code>）将数据发送到<code>Elasticsearch</code>，在那里你可以进一步处理和增强数据，然后在<code>Kibana</code>中将其可视化。</p><h4 id="2-1-Filebeat-工作原理"><a href="#2-1-Filebeat-工作原理" class="headerlink" title="2.1 Filebeat 工作原理"></a>2.1 Filebeat 工作原理</h4><p>Filebeat 由两个主要组件组成：<code>prospector</code>和<code>harvester</code>。这些组件一起工作来读取文件（tail file）并将事件数据发送到您指定的输出</p><ul><li>**<code>Harvester</code>**：<ul><li>负责<strong>读取单个文件</strong>的内容</li><li>如果文件在读取时被删除或重命名，<code>Filebeat</code>将继续读取文件</li></ul></li><li>**<code>prospector</code>**：<ul><li><code>prospector</code>负责**管理<code>harvester</code>**并找到所有要读取的文件来源</li><li>如果输入类型为日志，则查找器将查找路径匹配的所有文件，并为每个文件启动一个<code>harvester</code></li><li><code>Filebeat</code>目前支持两种<code>prospector</code>类型：<code>log</code>和<code>stdin</code></li></ul></li></ul><p><img src="/2018/11/28/elastic-stack/filebeat.jpg"></p><blockquote><ul><li><code>Filebeat</code>如何<strong>保持文件的状态</strong><ul><li><code>Filebeat</code> 保存每个文件的状态并经常将状态刷新到磁盘上的注册文件中</li><li>该状态用于记住<code>harvester</code>正在读取的最后偏移量，并确保发送所有日志行</li><li>如果输出（例如<code>Elasticsearch</code>或<code>Logstash</code>）无法访问，<code>Filebeat</code>会跟踪最后发送的行，并在输出再次可用时继续读取文件。</li><li>在<code>Filebeat</code>运行时，每个<code>prospector</code>内存中也会保存的文件状态信息，当重新启动<code>Filebeat</code>时，将使用注册文件的数据来重建文件状态，<code>Filebeat</code>将每个<code>harvester</code>在从保存的最后偏移量继续读取</li><li><code>Filebeat</code>存储唯一标识符以检测文件是否先前已采集过</li></ul></li></ul></blockquote><blockquote><ul><li><code>Filebeat</code>如何<strong>确保至少一次交付</strong><ul><li><code>Filebeat</code>保证事件至少会被传送到配置的输出一次，并且不会丢失数据。 <code>Filebeat</code>能够实现此行为，因为它将每个事件的传递状态存储在注册文件中。</li><li>在输出阻塞或未确认所有事件的情况下，<code>Filebeat</code>将继续尝试发送事件，直到接收端确认已收到。</li><li>如果<code>Filebeat</code>在发送事件的过程中关闭，它不会等待输出确认所有收到事件。</li><li>发送到输出但在<code>Filebeat</code>关闭前未确认的任何事件在重新启动<code>Filebeat</code>时会再次发送。</li><li>这可以确保每个事件至少发送一次，但最终会将重复事件发送到输出。</li><li>也可以通过设置<code>shutdown_timeout</code>选项来配置<code>Filebeat</code>以在关闭之前等待特定时间</li></ul></li></ul></blockquote><h4 id="2-2-Filebeat-安装与配置"><a href="#2-2-Filebeat-安装与配置" class="headerlink" title="2.2 Filebeat 安装与配置"></a>2.2 Filebeat 安装与配置</h4><p>安装<code>Filebeat</code>，创建配置文件<code>itcast.yml</code>，控制台运行测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建如下配置文件 itcast.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: stdin  <span class="comment"># 标准输入</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">output.console: <span class="comment"># 输出到控制台</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动filebeat</span></span><br><span class="line">./filebeat -e -c itcast.yml</span><br></pre></td></tr></table></figure><p>输入 hello 运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@timestamp&quot;</span>: <span class="string">&quot;2019-11-23T09:21:19.213Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;@metadata&quot;</span>: &#123; <span class="comment">#元数据信息</span></span><br><span class="line">    <span class="string">&quot;beat&quot;</span>: <span class="string">&quot;filebeat&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;7.4.2&quot;</span> <span class="comment"># beat版本</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;chaooo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;agent&quot;</span>: &#123; &#125;,</span><br><span class="line">  <span class="string">&quot;log&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello&quot;</span>, <span class="comment"># 输入的内容</span></span><br><span class="line">  <span class="string">&quot;input&quot;</span>: &#123; <span class="comment"># 控制台标准输入</span></span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;stdin&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;ecs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-读取文件"><a href="#2-3-读取文件" class="headerlink" title="2.3 读取文件"></a>2.3 读取文件</h4><p>创建配置文件<code>itcast-log.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /test/*.<span class="built_in">log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line">output.console: <span class="comment"># 输出到控制台</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"><span class="comment">#启动filebeat</span></span><br><span class="line">./filebeat -e -c itcast-log.yml</span><br></pre></td></tr></table></figure><p>在<code>/test/</code>下创建<code>a.log</code>文件，并输入如下内容<code>hello world</code>,观察<code>filebeat</code>输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@timestamp&quot;</span>: <span class="string">&quot;2019-11-23T09:45:56.379Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;@metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;beat&quot;</span>: <span class="string">&quot;filebeat&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;7.4.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;log&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: 0,</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/test/a.log&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="string">&quot;input&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;log&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;ecs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;chaooo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;agent&quot;</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@timestamp&quot;</span>: <span class="string">&quot;2019-11-23T09:45:56.379Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;@metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;beat&quot;</span>: <span class="string">&quot;filebeat&quot;</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;7.4.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;host&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;chaooo&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;agent&quot;</span>: &#123; &#125;,</span><br><span class="line">  <span class="string">&quot;log&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;file&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/test/a.log&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;offset&quot;</span>: 7</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line">  <span class="string">&quot;input&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;log&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;ecs&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.1.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-自定义字段"><a href="#2-4-自定义字段" class="headerlink" title="2.4 自定义字段"></a>2.4 自定义字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /test/*.<span class="built_in">log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line">  tags: [<span class="string">&quot;web&quot;</span>] <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line">  fields: <span class="comment">#添加自定义字段</span></span><br><span class="line">    from: itcast-im</span><br><span class="line">  fields_under_root: <span class="literal">true</span> <span class="comment">#true为添加到根节点，false为添加到子节点中</span></span><br><span class="line">output.console: <span class="comment"># 输出到控制台</span></span><br><span class="line">  pretty: <span class="literal">true</span></span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2-5-输出到-Elasticsearch"><a href="#2-5-输出到-Elasticsearch" class="headerlink" title="2.5 输出到 Elasticsearch"></a>2.5 输出到 Elasticsearch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /test/*.<span class="built_in">log</span>   <span class="comment"># 可以使用单个路径</span></span><br><span class="line">  tags: [<span class="string">&quot;web&quot;</span>] <span class="comment">#添加自定义tag，便于后续的处理</span></span><br><span class="line">  fields: <span class="comment">#添加自定义字段</span></span><br><span class="line">    from: itcast-im</span><br><span class="line">  fields_under_root: <span class="literal">false</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3 <span class="comment">#指定索引的分区数</span></span><br><span class="line">output.elasticsearch: <span class="comment">#指定ES的配置</span></span><br><span class="line">  hosts: [<span class="string">&quot;192.168.1.7:9200&quot;</span>,<span class="string">&quot;192.168.1.7:9201&quot;</span>,<span class="string">&quot;192.168.1.7:9202&quot;</span>]</span><br></pre></td></tr></table></figure><h4 id="2-6-读取-Nginx-日志文件"><a href="#2-6-读取-Nginx-日志文件" class="headerlink" title="2.6 读取 Nginx 日志文件"></a>2.6 读取 Nginx 日志文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /usr/local/nginx/logs/*.<span class="built_in">log</span></span><br><span class="line">  tags: [<span class="string">&quot;nginx&quot;</span>]</span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3 <span class="comment">#指定索引的分区数</span></span><br><span class="line">output.elasticsearch: <span class="comment">#指定ES的配置</span></span><br><span class="line">  hosts: [<span class="string">&quot;192.168.1.7:9200&quot;</span>,<span class="string">&quot;192.168.1.7:9201&quot;</span>,<span class="string">&quot;192.168.1.7:9202&quot;</span>]</span><br></pre></td></tr></table></figure><h4 id="2-7-Filebeat-的-Module"><a href="#2-7-Filebeat-的-Module" class="headerlink" title="2.7 Filebeat 的 Module"></a>2.7 Filebeat 的 Module</h4><p>日志数据的读取与处理可以不用手动配置的，在<code>Filebeat</code>中，有大量的<code>Module</code>，可以直接使用简化配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">./filebeat modules list</span><br><span class="line">Enabled:</span><br><span class="line"></span><br><span class="line">Disabled:</span><br><span class="line">apache</span><br><span class="line">auditd</span><br><span class="line">aws</span><br><span class="line">cef</span><br><span class="line">cisco</span><br><span class="line">coredns</span><br><span class="line">elasticsearch</span><br><span class="line">envoyproxy</span><br><span class="line">googlecloud</span><br><span class="line">haproxy</span><br><span class="line">ibmmq</span><br><span class="line">icinga</span><br><span class="line">iis</span><br><span class="line">iptables</span><br><span class="line">kafka</span><br><span class="line">kibana</span><br><span class="line">logstash</span><br><span class="line">mongodb</span><br><span class="line">mssql</span><br><span class="line">mysql</span><br><span class="line">nats</span><br><span class="line">netflow</span><br><span class="line">nginx</span><br><span class="line">osquery</span><br><span class="line">panw</span><br><span class="line">postgresql</span><br><span class="line">rabbitmq</span><br><span class="line">redis</span><br><span class="line">santa</span><br><span class="line">suricata</span><br><span class="line">system</span><br><span class="line">traefik</span><br><span class="line">zeek</span><br></pre></td></tr></table></figure><p>可以看到，内置了很多的<code>module</code>，但都没有启用，如果需要启用需要进行<code>enable</code>操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/filebeat modules <span class="built_in">enable</span> nginx <span class="comment">#启动</span></span><br><span class="line">./filebeat modules <span class="built_in">disable</span> nginx <span class="comment">#禁用</span></span><br></pre></td></tr></table></figure><h4 id="2-8-nginx-module-与-filebeat-配置"><a href="#2-8-nginx-module-与-filebeat-配置" class="headerlink" title="2.8 nginx module 与 filebeat 配置"></a>2.8 nginx module 与 filebeat 配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- module: nginx</span><br><span class="line">  access:      <span class="comment"># Access logs</span></span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    var.paths: [<span class="string">&quot;/usr/local/nginx/logs/access.log*&quot;</span>]</span><br><span class="line">  error:       <span class="comment"># Error logs</span></span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line">    var.paths: [<span class="string">&quot;/usr/local/nginx/logs/error.log*&quot;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-nginx.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line"><span class="comment">#- type: log</span></span><br><span class="line"><span class="comment"># enabled: true</span></span><br><span class="line"><span class="comment"># paths:</span></span><br><span class="line"><span class="comment"># - /usr/local/nginx/logs/*.log</span></span><br><span class="line"><span class="comment"># tags: [&quot;nginx&quot;]</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.40.133:9200&quot;</span>,<span class="string">&quot;192.168.40.134:9200&quot;</span>,<span class="string">&quot;192.168.40.135:9200&quot;</span>]</span><br><span class="line">filebeat.config.modules:</span><br><span class="line">  path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br><span class="line">  reload.enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>若启动报错，需要在<code>Elasticsearch</code>中安装<code>ingest-user-agent、ingest-geoip</code>插件</p><h3 id="3-Metricbeat"><a href="#3-Metricbeat" class="headerlink" title="3. Metricbeat"></a>3. Metricbeat</h3><p>用于从系统和服务<strong>收集指标</strong>。<code>Metricbeat</code>和<code>Filebeat</code>一样，是一个<strong>轻量级的采集器</strong>，<code>Metricbeat</code>由模块(<code>Module</code>)和度量集(<code>Metricset</code>)组成。<code>Metricbeat</code>模块定义了从特定服务（如 Redis，MySQL 等）收集数据的基本逻辑。该模块指定有关服务的详细信息，包括如何连接，收集指标的频率以及要收集的指标。</p><ul><li><code>Metricbeat</code>有 2 部分组成，一部分是<code>Module</code>，另一部分为<code>Metricset</code>。</li><li><code>Module</code><ul><li>收集的对象，如：<code>mysql、redis、nginx、操作系统</code>等；</li></ul></li><li><code>Metricset</code><ul><li>收集指标的集合，如：<code>cpu、memory、network</code>等；</li></ul></li><li>以<code>Redis Module</code>为例：<br><img src="/2018/11/28/elastic-stack/metricbeat.jpg"></li></ul><h4 id="3-1-安装配置"><a href="#3-1-安装配置" class="headerlink" title="3.1 安装配置"></a>3.1 安装配置</h4><p>安装 Metricbeat，根据实际情况配置文件<code>metricbeat.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">metricbeat.config.modules:</span><br><span class="line">  path: <span class="variable">$&#123;path.config&#125;</span>/modules.d/*.yml</span><br><span class="line">  reload.enabled: <span class="literal">false</span></span><br><span class="line">setup.kibana:</span><br><span class="line">  host: <span class="string">&quot;192.168.56.13:5601&quot;</span></span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.56.13:9200&quot;</span>]</span><br><span class="line">  username: <span class="string">&quot;elastic&quot;</span></span><br><span class="line">  password: <span class="string">&quot;qiuyuetao&quot;</span></span><br></pre></td></tr></table></figure><p>启动：<code>./metricbeat -e</code><br>查看<code>module</code>列表：<code>./metricbeat modules list</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Enabled:</span><br><span class="line">system <span class="comment">#默认启用</span></span><br><span class="line"></span><br><span class="line">Disabled:</span><br><span class="line">apache</span><br><span class="line">elasticsearch</span><br><span class="line">nginx</span><br><span class="line">mysql</span><br><span class="line">redis</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>system module</code>默认启用的，其配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> system.yml</span><br><span class="line"><span class="comment"># Module: system</span></span><br><span class="line"><span class="comment"># Docs: https://www.elastic.co/guide/en/beats/metricbeat/6.5/metricbeat-modulesystem.html</span></span><br><span class="line">- module: system</span><br><span class="line">  period: 10s</span><br><span class="line">  metricsets:</span><br><span class="line">    - cpu</span><br><span class="line">    - load</span><br><span class="line">    - memory</span><br><span class="line">    - network</span><br><span class="line">    - process</span><br><span class="line">    - process_summary</span><br><span class="line">    <span class="comment">#- core</span></span><br><span class="line">    <span class="comment">#- diskio</span></span><br><span class="line">    <span class="comment">#- socket</span></span><br><span class="line">  process.include_top_n:</span><br><span class="line">    by_cpu: 5 <span class="comment"># include top 5 processes by CPU</span></span><br><span class="line">    by_memory: 5 <span class="comment"># include top 5 processes by memory</span></span><br><span class="line">- module: system</span><br><span class="line">  period: 1m</span><br><span class="line">  metricsets:</span><br><span class="line">    - filesystem</span><br><span class="line">    - fsstat</span><br><span class="line">  processors:</span><br><span class="line">  - drop_event.when.regexp:</span><br><span class="line">    system.filesystem.mount_point: <span class="string">&#x27;^/(sys|cgroup|proc|dev|etc|host|lib)($|/)&#x27;</span></span><br><span class="line">- module: system</span><br><span class="line">  period: 15m</span><br><span class="line">  metricsets:</span><br><span class="line">    - <span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><h4 id="3-2-Nginx-Module"><a href="#3-2-Nginx-Module" class="headerlink" title="3.2 Nginx Module"></a>3.2 Nginx Module</h4><p>在 nginx 中，需要开启状态查询，才能查询到指标数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置nginx</span></span><br><span class="line">location /nginx-status &#123;</span><br><span class="line">    stub_status on;</span><br><span class="line">    access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>192.168.56.13/nginx-status</code>查看<code>nginx-status</code><ul><li><code>Active connections</code>：正在处理的活动连接数</li><li><code>server accepts handled requests</code>（连接数，握手数，处理请求总数）</li><li><code>Reading: 0 Writing: 1 Waiting: 1</code>（ 读取到客户端的 Header 信息数，返回给客户端 Header 信息数，已经处理完正在等候下一次请求指令的驻留链接）</li></ul></li></ul><p>配置<code>Nginx Module（metricbeat/modules.d/nginx.yml）</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- module: nginx</span><br><span class="line">  metricsets: [<span class="string">&quot;stubstatus&quot;</span>]</span><br><span class="line">  period: 10s</span><br><span class="line">  <span class="comment"># Nginx hosts</span></span><br><span class="line">  hosts: [<span class="string">&quot;http://192.168.56.11&quot;</span>]</span><br><span class="line">  <span class="comment"># Path to server status. Default server-status</span></span><br><span class="line"> server_status_path: <span class="string">&quot;nginx_status&quot;</span></span><br></pre></td></tr></table></figure><p>启动：<code>./metricbeat -e</code></p><h3 id="4-Logstash"><a href="#4-Logstash" class="headerlink" title="4. Logstash"></a>4. Logstash</h3><p><code>Logstash</code>是<code>ElasticStack</code>中的实时数据采集引擎，可以采集来自不同数据源的数据，并对数据进行处理后输出到多种输出源，是<code>Elastic Stack</code>的重要组成部分。<br><img src="/2018/11/28/elastic-stack/elastic-logstash.jpg"></p><h4 id="4-1-Logstash-的数据处理过程"><a href="#4-1-Logstash-的数据处理过程" class="headerlink" title="4.1 Logstash 的数据处理过程"></a>4.1 Logstash 的数据处理过程</h4><ul><li><code>Inputs(Codecs)--&gt;Filters--&gt;Outputs(Codecs)</code><ul><li>用户通过定义<code>pipeline</code>配置文件，设置需要使用的<code>input</code>，<code>filter</code>，<code>output</code>, <code>codec</code>插件，以实现特定的数据采集，数据处理，数据输出等功能</li></ul></li></ul><ol><li><code>Inputs</code>：用于从数据源获取数据，常见的插件如<code>file, syslog, redis, beats</code>等</li><li><code>Filters</code>：用于处理数据如格式转换，数据派生等，常见的插件如<code>grok, mutate, drop, clone, geoip</code>等</li><li><code>Outputs</code>：用于数据输出，常见的插件如<code>elastcisearch，file, graphite, statsd</code>等</li><li><code>Codecs</code>：<code>Codecs</code>不是一个单独的流程，而是在输入和输出等插件中用于数据转换的模块，用于对数据进行编码处理，常见的插件如<code>json，multiline</code></li></ol><h4 id="4-2-执行模型"><a href="#4-2-执行模型" class="headerlink" title="4.2 执行模型"></a>4.2 执行模型</h4><ol><li>每个<code>Input</code>启动一个线程，从对应数据源获取数据</li><li><code>Input</code>会将数据写入一个队列：默认为内存中的有界队列（意外停止会导致数据丢失）。为了防止数丢失<code>Logstash</code>提供了两个特性：<ul><li><code>Persistent Queues</code>：通过磁盘上的<code>queue</code>来防止数据丢失</li><li><code>Dead Letter Queues</code>：保存无法处理的<code>event</code>（仅支持<code>Elasticsearch</code>作为输出源）</li></ul></li><li><code>Logstash</code>会有多个<code>pipeline worker</code>, 每一个<code>pipeline worker</code>会从队列中取一批数据，然后执行<code>filter</code>和<code>output</code>（<code>worker</code>数目及每次处理的数据量均由配置确定）</li></ol><h4 id="4-3-安装配置"><a href="#4-3-安装配置" class="headerlink" title="4.3 安装配置"></a>4.3 安装配置</h4><p>下载<code>Logstash</code>并解压，配置有三部分，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123; <span class="comment">#输入</span></span><br><span class="line">stdin &#123; ... &#125; <span class="comment">#标准输入</span></span><br><span class="line">&#125;</span><br><span class="line">filter &#123; <span class="comment">#过滤，对数据进行分割、截取等处理</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">output &#123; <span class="comment">#输出</span></span><br><span class="line">stdout &#123; ... &#125; <span class="comment">#标准输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-读取自定义日志"><a href="#4-4-读取自定义日志" class="headerlink" title="4.4 读取自定义日志"></a>4.4 读取自定义日志</h4><ol><li>日志结构：<code>2019-11-23 21:21:21|ERROR|读取数据出错|参数：id=1002</code>，日志中的内容是使用<code>“|”</code>进行分割的，使用，我们在处理的时候，也需要对数据做分割处理。</li><li>编写配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-pipeline.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; <span class="string">&quot;/itcast/logstash/logs/app.log&quot;</span></span><br><span class="line">    start_position =&gt; <span class="string">&quot;beginning&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    <span class="built_in">split</span> =&gt; &#123;<span class="string">&quot;message&quot;</span>=&gt;<span class="string">&quot;|&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>启动测试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">./bin/logstash -f ./itcast-pipeline.conf</span><br><span class="line"><span class="comment">#写日志到文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;2019-11-23 21:21:21|ERROR|读取数据出错|参数：id=1002&quot;</span> &gt;&gt; app.log</span><br><span class="line"><span class="comment">#输出的结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;@timestamp&quot;</span> =&gt; 2019-03-15T08:44:04.749Z,</span><br><span class="line">        <span class="string">&quot;path&quot;</span> =&gt; <span class="string">&quot;/itcast/logstash/logs/app.log&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@version&quot;</span> =&gt; <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;host&quot;</span> =&gt; <span class="string">&quot;node01&quot;</span>,</span><br><span class="line">     <span class="string">&quot;message&quot;</span> =&gt; [</span><br><span class="line">        [0] <span class="string">&quot;2019-11-23 21:21:21&quot;</span>,</span><br><span class="line">        [1] <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">        [2] <span class="string">&quot;读取数据出错&quot;</span>,</span><br><span class="line">        [3] <span class="string">&quot;参数：id=1002&quot;</span></span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>输出到<code>Elasticsearch</code>配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ <span class="string">&quot;192.168.40.133:9200&quot;</span>,<span class="string">&quot;192.168.40.134:9200&quot;</span>,<span class="string">&quot;192.168.40.135:9200&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Elasticsearch-Logstash-Beats-Kibana-基础整合"><a href="#5-Elasticsearch-Logstash-Beats-Kibana-基础整合" class="headerlink" title="5. Elasticsearch + Logstash + Beats + Kibana 基础整合"></a>5. Elasticsearch + Logstash + Beats + Kibana 基础整合</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">           (读取)          (发送)           (写入)                (读取)</span><br><span class="line">「日志文件」&lt;----「FileBeat」----&gt;「Logstash」----&gt;「Elasticsearch」&lt;----「Kibana」</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><code>Filebeat</code>配置与启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-dashboard.yml</span></span><br><span class="line">filebeat.inputs:</span><br><span class="line">- <span class="built_in">type</span>: <span class="built_in">log</span></span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /itcast/logs/*.<span class="built_in">log</span></span><br><span class="line">setup.template.settings:</span><br><span class="line">  index.number_of_shards: 3</span><br><span class="line">output.logstash:</span><br><span class="line">  hosts: [<span class="string">&quot;192.168.40.133:5044&quot;</span>] <span class="comment">#Logstash端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">./filebeat -e -c itcast-dashboard.yml</span><br></pre></td></tr></table></figure><ol start="2"><li><code>Logstash</code>配置与启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vim itcast-dashboard.conf</span></span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; <span class="string">&quot;5044&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    <span class="built_in">split</span> =&gt; &#123;<span class="string">&quot;message&quot;</span>=&gt;<span class="string">&quot;|&quot;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  mutate &#123;</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      <span class="string">&quot;userId&quot;</span> =&gt; <span class="string">&quot;%&#123;message[1]&#125;&quot;</span></span><br><span class="line">      <span class="string">&quot;visit&quot;</span> =&gt; <span class="string">&quot;%&#123;message[2]&#125;&quot;</span></span><br><span class="line">      <span class="string">&quot;date&quot;</span> =&gt; <span class="string">&quot;%&#123;message[3]&#125;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutate &#123;</span><br><span class="line">      convert =&gt; &#123;</span><br><span class="line">        <span class="string">&quot;userId&quot;</span> =&gt; <span class="string">&quot;integer&quot;</span></span><br><span class="line">        <span class="string">&quot;visit&quot;</span> =&gt; <span class="string">&quot;string&quot;</span></span><br><span class="line">        <span class="string">&quot;date&quot;</span> =&gt; <span class="string">&quot;string&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts =&gt; [ <span class="string">&quot;192.168.40.133:9200&quot;</span>,<span class="string">&quot;192.168.40.134:9200&quot;</span>,<span class="string">&quot;192.168.40.135:9200&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">./bin/logstash -f itcast-dashboard.conf</span><br></pre></td></tr></table></figure><ol start="3"><li><code>ElasticSearch</code>启动与<code>Kibana</code>启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ElasticSearch默认端口:9200</span></span><br><span class="line">bin/elasticsearch</span><br><span class="line"><span class="comment"># kibana默认端口:5601</span></span><br><span class="line">bin/kibana</span><br><span class="line"><span class="comment">#通过浏览器进行访问,添加Logstash索引到Kibana中</span></span><br><span class="line">http://192.168.40.133:5601</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ElasticStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Kibana </tag>
            
            <tag> ElasticStack </tag>
            
            <tag> LogStash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ElasticStack」ElasticSearch聚合分析与数据建模</title>
      <link href="/2018/11/21/elastic-aggregation.html"/>
      <url>/2018/11/21/elastic-aggregation.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-ElasticSearch-中的聚合分析"><a href="#1-ElasticSearch-中的聚合分析" class="headerlink" title="1. ElasticSearch 中的聚合分析"></a>1. ElasticSearch 中的聚合分析</h3><p>聚合分析，英文<code>Aggregation</code>，是 ES 除了搜索功能之外提供的针对 ES 数据进行统计分析的功能。</p><ul><li>特点：<ul><li>① 功能丰富，可满足大部分分析需求；</li><li>② 实时性高，所有计算结果实时返回。</li></ul></li><li>基于分析规则的不同，ES 将聚合分析主要划分为以下 4 种：<ol><li><strong><code>Metric</code></strong>: 指标分析类型，如：计算最值，平均值等；</li><li><strong><code>Bucket</code></strong>: 分桶类型，类似于<code>group by</code>语法，根据一定规则划分为若干个桶分类；</li><li><strong><code>Pipeline</code></strong>: 管道分析类型，基于上一级的聚合分析结果进行再分析；</li><li><code>Matrix</code>: 矩阵分析类型。<span id="more"></span></li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 聚合分析格式：</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123; <span class="comment"># 关键词</span></span><br><span class="line">  <span class="string">&quot;&lt;aggregation_name&gt;&quot;</span>:&#123; <span class="comment"># 自定义聚合分析名称，一般起的有意义</span></span><br><span class="line">   <span class="string">&quot;&lt;aggregation_type&gt;&quot;</span>:&#123; <span class="comment"># 聚合分析类型</span></span><br><span class="line">    <span class="string">&quot;&lt;aggregation_body&gt;&quot;</span> <span class="comment"># 聚合分析主体</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [,<span class="string">&quot;aggs&quot;</span>:&#123;[&lt;svb_aggregation&gt;]+&#125;] <span class="comment"># 可包含多个子聚合分析</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-Metric-聚合分析"><a href="#1-1-Metric-聚合分析" class="headerlink" title="1.1 Metric 聚合分析"></a>1.1 Metric 聚合分析</h4><p>主要分为两类：单值分析（输出单个结果）和多值分析（输出多个结果）。</p><h5 id="1-1-1-单值分析"><a href="#1-1-1-单值分析" class="headerlink" title="1.1.1 单值分析"></a>1.1.1 单值分析</h5><ol><li><code>min</code>：返回数值类型字段的最小值</li><li><code>max</code>：返回数值类型字段的最大值</li><li><code>avg</code>：返回数值类型字段的平均值</li><li><code>sum</code>：返回数值类型字段值的总和</li><li><code>cardinality</code>：返回字段的基数</li><li>使用多个单值分析关键词，返回多个结果</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;min_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;min&quot;</span>:&#123; <span class="comment"># 关键字min/max/avg/sum/cardinality</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用多个单值分析关键词，返回多个分析结果</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;min_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;min&quot;</span>:&#123;  <span class="comment"># 求最小年龄</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;max_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;max&quot;</span>:&#123;  <span class="comment"># 求最大年龄</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;avg_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;avg&quot;</span>:&#123;  <span class="comment"># 求平均年龄</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;sum_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;sum&quot;</span>:&#123;  <span class="comment"># 求年龄总和</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-2-多值分析"><a href="#1-1-2-多值分析" class="headerlink" title="1.1.2 多值分析"></a>1.1.2 多值分析</h5><ol><li><code>stats</code>：返回所有单值结果</li><li><code>extended_stats</code>：对<code>stats</code>进行扩展，包含更多，如：方差，标准差，标准差范围等</li><li><code>Percentile</code>：百分位数统计</li><li><code>Top hits</code>：一般用于分桶之后获取该桶内最匹配的定不稳当列表，即详情数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;stats_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;stats&quot;</span>:&#123; <span class="comment"># 关键字stats/extended_stats/percentiles</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用percentiles关键词进行百分位数预测。</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;per_age&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;percentiles&quot;</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span>,</span><br><span class="line">    <span class="string">&quot;values&quot;</span>:[20, 25] <span class="comment"># 判断20和25分别在之前的年轻区间的什么位置，以百分数显示</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用top_hits关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>, <span class="comment"># 按job.keyword进行分桶聚合</span></span><br><span class="line">     <span class="string">&quot;size&quot;</span>:10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;top_employee&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;top_hits&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;size&quot;</span>:10,    <span class="comment"># 返回文档数量</span></span><br><span class="line">       <span class="string">&quot;sort&quot;</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">         <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;order&quot;</span>:<span class="string">&quot;desc&quot;</span>  <span class="comment"># 按年龄倒叙排列</span></span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       ]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Bucket-聚合分析"><a href="#1-2-Bucket-聚合分析" class="headerlink" title="1.2 Bucket 聚合分析"></a>1.2 Bucket 聚合分析</h4><p><code>Bucket</code>，意为桶。即：按照一定规则，将文档分配到不同的桶中，达分类的目的。常见的有以下五类：</p><ol><li><code>Terms</code>: 直接按<code>term</code>进行分桶，如果是<code>text</code>类型，按分词后的结果分桶</li><li><code>Range</code>: 按指定数值范围进行分桶</li><li><code>Date Range</code>: 按指定日期范围进行分桶</li><li><code>Histogram</code>: 直方图，按固定数值间隔策略进行数据分割</li><li><code>Date Histogram</code>: 日期直方图，按固定时间间隔进行数据分割</li></ol><h5 id="1-2-1-Terms"><a href="#1-2-1-Terms" class="headerlink" title="1.2.1 Terms"></a>1.2.1 Terms</h5><p><code>Terms</code>: 直接按<code>term</code>进行分桶，如果是<code>text</code>类型，按分词后的结果分桶</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用terms关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;terms_job&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>, <span class="comment"># 按job.keyword进行分桶</span></span><br><span class="line">    <span class="string">&quot;size&quot;</span>:5               <span class="comment"># 返回五个文档</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-2-Range"><a href="#1-2-2-Range" class="headerlink" title="1.2.2 Range"></a>1.2.2 Range</h5><p><code>Range</code>: 按指定数值范围进行分桶：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用range关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;number_ranges&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;range&quot;</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span>,    <span class="comment"># 按age进行分桶</span></span><br><span class="line">    <span class="string">&quot;ranges&quot;</span>:[</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>:<span class="string">&quot;&gt;=19 &amp;&amp; &lt; 25&quot;</span>,  <span class="comment"># 第一个桶：  19&lt;=年龄&lt;25</span></span><br><span class="line">      <span class="string">&quot;from&quot;</span>:19,</span><br><span class="line">      <span class="string">&quot;to&quot;</span>:25</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>:<span class="string">&quot;&lt; 19&quot;</span>,    <span class="comment"># 第二个桶：  年龄&lt;19</span></span><br><span class="line">      <span class="string">&quot;to&quot;</span>:19</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>:<span class="string">&quot;&gt;= 25&quot;</span>,    <span class="comment"># 第三个桶：  年龄&gt;=25</span></span><br><span class="line">      <span class="string">&quot;from&quot;</span>:25</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-3-Date-Range"><a href="#1-2-3-Date-Range" class="headerlink" title="1.2.3 Date Range"></a>1.2.3 Date Range</h5><p><code>Date Range</code>: 按指定日期范围进行分桶</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用date_range关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;date_ranges&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;date_range&quot;</span>:&#123;    <span class="comment"># 关键字</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;birth&quot;</span>,    <span class="comment"># 按age进行分桶</span></span><br><span class="line">    <span class="string">&quot;format&quot;</span>:<span class="string">&quot;yyyy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ranges&quot;</span>:[</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>:<span class="string">&quot;&gt;=1980 &amp;&amp; &lt; 1990&quot;</span>,  <span class="comment"># 第一个桶：  1980&lt;=出生日期&lt;1990</span></span><br><span class="line">      <span class="string">&quot;from&quot;</span>:<span class="string">&quot;1980&quot;</span>,</span><br><span class="line">      <span class="string">&quot;to&quot;</span>:<span class="string">&quot;1990&quot;</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>:<span class="string">&quot;&lt; 1980&quot;</span>,    <span class="comment"># 第二个桶：  出生日期&lt;1980</span></span><br><span class="line">      <span class="string">&quot;to&quot;</span>:1980</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>:<span class="string">&quot;&gt;= 1990&quot;</span>,    <span class="comment"># 第三个桶：  出生日期&gt;=1990</span></span><br><span class="line">      <span class="string">&quot;from&quot;</span>:1990</span><br><span class="line">     &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-4-Histogram"><a href="#1-2-4-Histogram" class="headerlink" title="1.2.4 Histogram"></a>1.2.4 Histogram</h5><p><code>Histogram</code>: 直方图，按固定数值间隔策略进行数据分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用histogram关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;age_hist&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;histogram&quot;</span>:&#123;     <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval&quot;</span>:3,    <span class="comment"># 设定间隔大小为2</span></span><br><span class="line">    <span class="string">&quot;extended_bounds&quot;</span>:&#123;    <span class="comment"># 设定数据范围</span></span><br><span class="line">     <span class="string">&quot;min&quot;</span>:0,</span><br><span class="line">     <span class="string">&quot;max&quot;</span>:30</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-5-Date-Histogram"><a href="#1-2-5-Date-Histogram" class="headerlink" title="1.2.5 Date Histogram"></a>1.2.5 Date Histogram</h5><p><code>Date Histogram</code>: 日期直方图，按固定时间间隔进行数据分割</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用date_histogram关键词</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;birth_hist&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;date_histogram&quot;</span>:&#123;     <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;birth&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval&quot;</span>:<span class="string">&quot;year&quot;</span>,    <span class="comment"># 设定间隔大小为年year</span></span><br><span class="line">    <span class="string">&quot;format&quot;</span>:<span class="string">&quot;yyyy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;extended_bounds&quot;</span>:&#123;    <span class="comment"># 设定数据范围</span></span><br><span class="line">     <span class="string">&quot;min&quot;</span>:<span class="string">&quot;1980&quot;</span>,</span><br><span class="line">     <span class="string">&quot;max&quot;</span>:<span class="string">&quot;1990&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Bucket-Metric-聚合分析"><a href="#1-3-Bucket-Metric-聚合分析" class="headerlink" title="1.3 Bucket+Metric 聚合分析"></a>1.3 Bucket+Metric 聚合分析</h4><p>Bucket 聚合分析允许通过添加子分析来进一步进行分析，该子分析可以是 Bucket，也可以是 Metric。</p><ol><li>分桶之后再分桶（Bucket+Bucket），在数据可视化中一般使用千层饼图进行显示。</li><li>分桶之后再数据分析（Bucket+Metric）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分桶之后再分桶——Bucket+Bucket</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;             <span class="comment"># 第一层Bucket</span></span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>,</span><br><span class="line">     <span class="string">&quot;size&quot;</span>:10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;age_range&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;range&quot;</span>:&#123;             <span class="comment"># 第二层Bucket</span></span><br><span class="line">       <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span>,</span><br><span class="line">       <span class="string">&quot;ranges&quot;</span>:[</span><br><span class="line">        &#123;<span class="string">&quot;to&quot;</span>:20&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;from&quot;</span>:20,<span class="string">&quot;to&quot;</span>:30&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;from&quot;</span>:30&#125;</span><br><span class="line">       ]</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分桶之后再数据分析——Bucket+Metric</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;             <span class="comment"># 第一层Bucket</span></span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>,</span><br><span class="line">     <span class="string">&quot;size&quot;</span>:10</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;stats_age&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;stats&quot;</span>:&#123;            <span class="comment"># 第二层Metric</span></span><br><span class="line">       <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-Pipeline-聚合分析"><a href="#1-4-Pipeline-聚合分析" class="headerlink" title="1.4 Pipeline 聚合分析"></a>1.4 Pipeline 聚合分析</h4><p>针对聚合分析的结果进行再分析，且支持链式调用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用pipeline聚合分析,计算订单月平均销售额。</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;sales_per_month&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;date_histogram&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;date&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval&quot;</span>:<span class="string">&quot;month&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;sales&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;sum&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;field&quot;</span>:<span class="string">&quot;price&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;avg_monthly_sales&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;avg_bucket&quot;</span>:&#123;    <span class="comment"># bucket类型</span></span><br><span class="line">    <span class="string">&quot;buckets_path&quot;</span>:<span class="string">&quot;sales_per_month&gt;sales&quot;</span>    <span class="comment"># 使用buckets_path参数，表明是pipeline</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pipeline</code>的分析结果会输出到原结果中，由输出位置不同，分为两类：<code>Parent</code>和<code>Sibling</code>。</p><ol><li><code>Sibling</code>。结果与现有聚合分析结果同级，如：Max&#x2F;Min&#x2F;Sum&#x2F;Avg Bucket、Stats&#x2F;Extended Stats Bucket、Percentiles Bucket</li><li><code>Parent</code>。结果内嵌到现有聚合分析结果中，如：Derivate、Moving Average、Cumulative Sum</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sibling聚合分析(min_bucket)</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>: 0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;    <span class="comment"># 根据job.keyword进行分桶</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>:10</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;avg_salary&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;avg&quot;</span>:&#123;    <span class="comment"># 之后Metric中求工资的平均数</span></span><br><span class="line">      <span class="string">&quot;field&quot;</span>:<span class="string">&quot;salary&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;min_salary_by_job&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;min_bucket&quot;</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">&quot;buckets_path&quot;</span>:<span class="string">&quot;jobs&gt;avg_salary&quot;</span>    <span class="comment"># 按工资平均数，排列每个桶中的job</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Parent聚合分析(Derivate)</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bitrh&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;date_histogram&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;birth&quot;</span>,</span><br><span class="line">    <span class="string">&quot;interval&quot;</span>:<span class="string">&quot;year&quot;</span>,</span><br><span class="line">    <span class="string">&quot;min_doc_count&quot;</span>:0</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;avg_salary&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;avg&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;field&quot;</span>:<span class="string">&quot;salary&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;derivative_avg_salary&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;derivative&quot;</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">      <span class="string">&quot;buckets_path&quot;</span>:<span class="string">&quot;avg_salary&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-5-聚合分析的作用范围"><a href="#1-5-聚合分析的作用范围" class="headerlink" title="1.5 聚合分析的作用范围"></a>1.5 聚合分析的作用范围</h4><p>ES 聚合分析默认作用范围是<code>query的结果集</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES中聚合分析的默认作用范围是query的结果集</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;    <span class="comment"># 此时，只在username字段中包含alfred的文档中进行分桶</span></span><br><span class="line">     <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>,</span><br><span class="line">     <span class="string">&quot;size&quot;</span>:10</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过以下方式修改：<code>filter</code>、<code>post_filter</code>、<code>global</code></p><ol><li>filter: 为某个结合分析设定过滤条件，从而在不改变整体 query 语句的情况下修改范围</li><li>post_filter，作用于文档过滤，但在聚合分析之后才生效</li><li>global，无视 query 条件，基于所有文档进行分析</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用filter进行过滤</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs_salary_small&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;filter&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;salary&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;to&quot;</span>:10000</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;terms&quot;</span>:&#123;    <span class="comment"># 在salary小于10000的文档中对工作进行分桶</span></span><br><span class="line">      <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用post_filter进行过滤</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;    <span class="comment"># 在salary小于10000的文档中对工作进行分桶</span></span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">&quot;post_filter&quot;</span>:&#123;    <span class="comment"># 在集合分析之后才生效</span></span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;job.keyword&quot;</span>:<span class="string">&quot;java engineer&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用global进行过滤</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;job.keyword&quot;</span>:<span class="string">&quot;java engineer&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;java_avg_salary&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;avg&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;salary&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;all&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;global&quot;</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;avg_salary&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;avg&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;field&quot;</span>:<span class="string">&quot;salary&quot;</span>    <span class="comment"># 依然是对所有的文档进行查询，而不会去管query</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-6-聚合分析中的排序"><a href="#1-6-聚合分析中的排序" class="headerlink" title="1.6 聚合分析中的排序"></a>1.6 聚合分析中的排序</h4><ol><li>可使用自带的关键数据排序，如：<code>_count</code>文档数、<code>_key</code>按 key 值</li><li>也可使用聚合结果进行排序</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用自带的数据进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;jobs&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;field&quot;</span>:<span class="string">&quot;job.keyword&quot;</span>,</span><br><span class="line">    <span class="string">&quot;size&quot;</span>:10,</span><br><span class="line">    <span class="string">&quot;order&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;_count&quot;</span>:<span class="string">&quot;asc&quot;</span>    <span class="comment"># 默认按_count倒叙排列</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;_key&quot;</span>:<span class="string">&quot;desc&quot;</span>    使用多个排序值，从上往下的顺序进行排列</span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用聚合结果进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:0,</span><br><span class="line"> <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;salary_hist&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;histogram&quot;</span>:&#123;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;filter&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;gte&quot;</span>:10</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">&quot;aggs&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;avg_age&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;field&quot;</span>:<span class="string">&quot;age&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-计算精准度问题"><a href="#1-7-计算精准度问题" class="headerlink" title="1.7 计算精准度问题"></a>1.7 计算精准度问题</h4><p>ES 聚合的执行流程：每个<code>Shard</code>上分别计算，由<code>coordinating Node</code>做聚合。</p><ul><li><code>Terms</code>计算不准确原因：数据分散在多个<code>Shard</code>上，<code>coordinating Node</code>无法得悉数据全貌，那么在取数据的时候，造成精准度不准确。</li><li>如下图：正确结果应该为<code>a,b,c</code>,而返回的是 a,b,d</li></ul><p><img src="/2018/11/21/elastic-aggregation/elastic-hits.jpg"></p><ul><li><p>解决办法有两种：</p><ol><li>直接设置<code>shard</code>数量为 1；消除数据分散问题，但无法承载大数据量。</li><li>设置<code>shard_size</code>大小，即每次从<code>shard</code>上额外多获取数据，从而提升精准度</li></ol></li><li><p>terms 聚合返回结果中有两个统计值：</p><ol><li><code>doc_count_error_upper_bound</code>：被遗漏的 term 可能的最大值；</li><li><code>sum_other_doc_count</code>：返回结果 bucket 的 term 外其他 term 的文档总数。</li></ol></li><li><p>设定<code>show_term_doc_count_error</code>可以查看每个 bucket 误算的最大值(<code>doc_count_error_upper_bound</code>,为<code>0</code>表示计算准确)</p></li><li><p>Shard_Size 默认大小：<code>(size*1.5)+10</code></p><ul><li>通过调整 Shard_Size 的大小降低<code>doc_count_error_upper_bound</code>来提升准确度</li><li>增大了整体的计算量，从而降低了响应时间</li></ul></li><li><p>权衡 <strong><code>海量数据</code>、<code>精准度</code>、<code>实时性</code></strong> 三者只能取其二。</p></li><li><p>Elasticsearch 目前支持两种近似算法：cardinality(度量) 和 percentiles(百分位数度量)</p><ul><li>结果近似准确，但不一定精准</li><li>可通过参数的调整使其结果精准，但同时消耗更多时间和性能</li></ul></li></ul><h3 id="2-ElasticSearch-的数据建模"><a href="#2-ElasticSearch-的数据建模" class="headerlink" title="2. ElasticSearch 的数据建模"></a>2. ElasticSearch 的数据建模</h3><p>数据建模(Data Modeling)大致分为三个阶段：概念建模、逻辑建模、物理建模</p><ol><li>概念模型：时间占比<code>10%</code><ul><li>基础。确定系统的核心需求和范围边界，实际实体与实体之间的关系。</li></ul></li><li>逻辑模型：时间占比<code>60-70%</code><ul><li>核心。确定系统的核心需求和范围边界，实际实体与实体之间的关系。</li></ul></li><li>物理模型：时间占比<code>20-30%</code><ul><li>落地实现。结合具体的数据库产品，在满足业务读写性能等需求的前提下确定最终的定义。</li></ul></li></ol><h4 id="2-1-ES-中的数据建模"><a href="#2-1-ES-中的数据建模" class="headerlink" title="2.1 ES 中的数据建模"></a>2.1 ES 中的数据建模</h4><p>ES 是基于 Luence 以倒排索引为基础实现的存储体系，不遵循关系型数据库中的范式约定。<br><img src="/2018/11/21/elastic-aggregation/elastic-md.jpg"></p><h4 id="2-2-Mapping-字段相关设置"><a href="#2-2-Mapping-字段相关设置" class="headerlink" title="2.2 Mapping 字段相关设置"></a>2.2 Mapping 字段相关设置</h4><ol><li><strong><code>enabled</code></strong>:<code>true/false</code>。<code>false</code>表示 仅存储，不做搜索或聚合分析。</li><li>**<code>index</code>:<code>true/false</code>。是否构建倒排索引。不需进行字段的检索的时候设为 false。</li><li><strong><code>index_options</code></strong>:<code>docs/freqs/positions/offsets</code>。确定存储倒排索引的哪些信息。</li><li><strong><code>norms</code></strong>:<code>true/false</code>。是否存储归一化相关系数，若字段仅用于过滤和聚合分析，则可关闭。</li><li><strong><code>doc_values</code></strong>:<code>true/false</code>。是否启用 doc_values，用于排序和聚类分析。默认开启。</li><li><strong><code>field_data</code></strong>:<code>true/false</code>。是否设 text 类型为 fielddata，实现排序和聚合分析。默认关闭。</li><li><strong><code>store</code></strong>:<code>true/false</code>。是否存储该字段。</li><li><strong><code>coerce</code></strong>:<code>true/false</code>。  是否开启数值类型转换功能，如：字符串转数字等。</li><li><strong><code>multifields</code></strong>:<code>多字段</code>。灵活使用多字段特性来解决多样业务需求。</li><li><strong><code>dynamic</code></strong>:<code>true/false/strict</code>。控制 mapping 自动更新。</li><li><strong><code>date_detection</code></strong>:<code>true/false</code>。是否启用自定识别日期类型，一般设为 false，避免不必要的识别字符串中的日期。</li></ol><h4 id="2-3-Mapping-字段属性设定流程"><a href="#2-3-Mapping-字段属性设定流程" class="headerlink" title="2.3 Mapping 字段属性设定流程"></a>2.3 Mapping 字段属性设定流程</h4><p><code>判断类型</code>—&gt;<code>是否需要检索</code>—&gt;<code>是否需要排序和聚合分析</code>—&gt;<code>是否需要另行存储</code></p><ol><li>判断类型<ul><li>字符串类型：需要分词，则设为 text，否则设为 keyword。</li><li>枚举类型：基于性能考虑，设为 keyword，即便该数据为整型。</li><li>数值类型：尽量选择贴近的类型，如 byte 即可表示所有数值时，即用 byte，而不是所有都用 long。</li><li>其他类型：布尔型，日期类型，地理位置类型等。</li></ul></li><li>是否需要检索<ul><li>完全不需要检索、排序、聚合分析的字段<code>enabled设为false</code>。</li><li>不需检索的字段<code>index设为false</code>。</li><li>需检索的字段，可通过如下配置设定需要的存储粒度:<ul><li><code>index_options</code> 结合需要设定。</li><li><code>norms</code> 不需归一化数据时可关闭。</li></ul></li></ul></li><li>是否需要排序和聚合分析<ul><li>当不需要排序和聚合分析功能时：<ul><li><code>doc_values设为false</code>。</li><li><code>field_data设为false</code>。</li></ul></li></ul></li><li>是否需要另行存储<ul><li><code>store设为true</code>即可存储该字段的原始内容(且与<code>_source</code>无关)，一般结合<code>_source</code>的<code>enabled设为false</code>时使用。</li></ul></li></ol><h4 id="2-4-ES-建模实例"><a href="#2-4-ES-建模实例" class="headerlink" title="2.4 ES 建模实例"></a>2.4 ES 建模实例</h4><ul><li>针对博客文章设定索引 blog_index，包含字段：<ul><li>标题：title</li><li>发布日期：publish_data</li><li>作者：author</li><li>摘要：abstract</li><li>网址：url</li></ul></li><li><strong>简易的数据模型</strong>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简易模型blog_index</span></span><br><span class="line">PUT blog_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;title&quot;</span>:&#123;</span><br><span class="line">          <span class="comment">#title设为text，包含自字段keyword。支持检索、排序、聚合分析</span></span><br><span class="line">          <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">          <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;keyword&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,<span class="comment">#publish_data设为date，支持检索、排序、聚合分析</span></span><br><span class="line">      <span class="string">&quot;publish_data&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;date&quot;</span>&#125;,</span><br><span class="line">      <span class="comment"># author设为keyword，支持检索、排序、聚合分析</span></span><br><span class="line">      <span class="string">&quot;author&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>&#125;,</span><br><span class="line">      <span class="comment"># abstract设为text，支持检索、排序、聚合分析</span></span><br><span class="line">      <span class="string">&quot;abstract&quot;</span>:&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">      <span class="comment"># url设为date，不需进行检索</span></span><br><span class="line">      <span class="string">&quot;url&quot;</span>:&#123;<span class="string">&quot;enabled&quot;</span>:<span class="literal">false</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>如果在<code>blog_index</code>中加入一个内容字段<code>content</code></strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为blog_index增加content字段</span></span><br><span class="line">PUT blog_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">     <span class="comment">#关闭，不存原始内容到_source</span></span><br><span class="line">     <span class="string">&quot;_source&quot;</span>:&#123;<span class="string">&quot;enabled&quot;</span>:<span class="literal">false</span>&#125;,</span><br><span class="line">     <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">        <span class="comment">#title设为text，包含自字段keyword。支持检索、排序、聚合分析</span></span><br><span class="line">        <span class="string">&quot;title&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">              <span class="string">&quot;keyword&quot;</span>:&#123;</span><br><span class="line">               <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:<span class="literal">true</span> <span class="comment">#对数据进行存储</span></span><br><span class="line">        &#125;,<span class="comment">#publish_data设为date，支持检索、排序、聚合分析</span></span><br><span class="line">        <span class="string">&quot;publish_data&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;date&quot;</span>,</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:<span class="literal">true</span> <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;author&quot;</span>:&#123;<span class="comment"># author设为keyword，支持检索、排序、聚合分析</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:<span class="literal">true</span>    <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;abstract&quot;</span>:&#123;<span class="comment"># abstract设为text，支持检索、排序、聚合分析</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:<span class="literal">true</span>    <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;content&quot;</span>:&#123;<span class="comment"># content设为text，支持检索、排序、聚合分析</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">            <span class="string">&quot;store&quot;</span>:<span class="literal">true</span>    <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;url&quot;</span>:&#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>,   <span class="comment"># url设为keyword</span></span><br><span class="line">            <span class="string">&quot;doc_values&quot;</span>:<span class="literal">false</span>, <span class="comment"># url不支持排序和聚合分析</span></span><br><span class="line">            <span class="string">&quot;norms&quot;</span>:<span class="literal">false</span>,      <span class="comment"># url也不需要归一化数据</span></span><br><span class="line">            <span class="string">&quot;ignore_above&quot;</span>:100, <span class="comment"># 预设内容长度为100</span></span><br><span class="line">            <span class="string">&quot;store&quot;</span>:<span class="literal">true</span>        <span class="comment"># 对数据进行存储</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>在搜索时增加高亮</strong>: 在此时，<code>content</code>里面的数据会存储大量的内容数据，数据量可能达到上千、上万，甚至几十万。那么在搜索的时候，根据<code>search</code>机制，如果还是像之前一样进行<code>_search</code>搜索，并只显示其他字段的话，其实依然还是每次获取了<code>content</code>字段的内容，影响性能，所以，使用<code>stored_fields</code>参数，控制返回的字段。节省了大量资源：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用stored_fields返回指定的存储后的字段</span></span><br><span class="line">GET blog_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;stored_fields&quot;</span>:[<span class="string">&quot;title&quot;</span>,<span class="string">&quot;publish_data&quot;</span>,<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Abstract&quot;</span>,<span class="string">&quot;url&quot;</span>],</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;content&quot;</span>:<span class="string">&quot;world&quot;</span><span class="comment">#依然进行content搜索，但是不返回所有的content字段</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">&quot;highlight&quot;</span>:&#123; <span class="comment">#针对content字段进行高亮显示</span></span><br><span class="line">  <span class="string">&quot;fields&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;content&quot;</span>:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>GET blog_index/_search?_source=title</code> 虽然只显示了<code>title</code>，但是<code>search</code>机制决定了，会把所有<code>_source</code>内容获取到，但只是显示<code>title</code>。</p></blockquote><h4 id="2-5-ES-中关联关系处理"><a href="#2-5-ES-中关联关系处理" class="headerlink" title="2.5 ES 中关联关系处理"></a>2.5 ES 中关联关系处理</h4><p><code>ES</code>不擅长处理关系型数据库中的关联关系，因为底层使用的倒排索引，如：文章表<code>blog</code>和评论表<code>comment</code>之间通过<code>blog_id</code>关联。<br>目前 ES 主要有以下 4 种常用的方法来处理关联关系：</p><ol><li><strong><code>Nested Object</code></strong>:嵌套文档</li><li><strong><code>Parent/Child</code></strong>:父子文档</li><li><code>Data denormalization</code>:数据的非规范化</li><li><code>Application-side joins</code>:服务端 Join 或客户端 Join</li></ol><h5 id="2-5-1-Application-side-joins（服务端-Join-或客户端-Join）"><a href="#2-5-1-Application-side-joins（服务端-Join-或客户端-Join）" class="headerlink" title="2.5.1 Application-side joins（服务端 Join 或客户端 Join）"></a>2.5.1 Application-side joins（服务端 Join 或客户端 Join）</h5><p>索引之间完全独立（利于对数据进行标准化处理，如便于上述两种增量同步的实现），由应用端的多次查询来实现近似关联关系查询。</p><ul><li>适用于第一个实体只有少量的文档记录的情况（使用<code>ES</code>的<code>terms</code>查询具有上限，默认<code>1024</code>，具体可在<code>elasticsearch.yml</code>中修改），并且最好它们很少改变。这将允许应用程序对结果进行缓存，并避免经常运行第一次查询。</li></ul><h5 id="2-5-2-Data-denormalization（数据的非规范化）"><a href="#2-5-2-Data-denormalization（数据的非规范化）" class="headerlink" title="2.5.2 Data denormalization（数据的非规范化）"></a>2.5.2 Data denormalization（数据的非规范化）</h5><p>通俗点就是通过字段冗余，以一张大宽表来实现粗粒度的<code>index</code>，这样可以充分发挥扁平化的优势。但是这是以牺牲索引性能及灵活度为代价的。</p><ul><li>使用的前提：冗余的字段应该是很少改变的；比较适合与一对少量关系的处理。当业务数据库并非采用非规范化设计时，这时要将数据同步到作为二级索引库的 ES 中，就很难使用上述增量同步方案，必须进行定制化开发，基于特定业务进行应用开发来处理<code>join</code>关联和实体拼接。<blockquote><p>宽表处理在处理一对多、多对多关系时，会有字段冗余问题，适合“一对少量”且这个“一”更新不频繁的应用场景。</p></blockquote></li></ul><h5 id="2-5-3-Nested-objects（嵌套文档）"><a href="#2-5-3-Nested-objects（嵌套文档）" class="headerlink" title="2.5.3 Nested objects（嵌套文档）"></a>2.5.3 Nested objects（嵌套文档）</h5><p>索引性能和查询性能二者不可兼得，必须进行取舍。<br>嵌套文档将实体关系嵌套组合在单文档内部（类似与 json 的一对多层级结构），这种方式牺牲索引性能（文档内任一属性变化都需要重新索引该文档）来换取查询性能，可以同时返回关系实体，比较适合于一对少量的关系处理。</p><ul><li>当使用嵌套文档时，使用通用的查询方式是无法访问到的，必须使用合适的查询方式（nested query、nested filter、nested facet 等），很多场景下，使用嵌套文档的复杂度在于索引阶段对关联关系的组织拼装。</li></ul><h5 id="2-5-4-Parent-x2F-Child（父子文档）"><a href="#2-5-4-Parent-x2F-Child（父子文档）" class="headerlink" title="2.5.4 Parent&#x2F;Child（父子文档）"></a>2.5.4 Parent&#x2F;Child（父子文档）</h5><p>父子文档牺牲了一定的查询性能来换取索引性能，适用于一对多的关系处理。其通过两种 type 的文档来表示父子实体，父子文档的索引是独立的。父-子文档 ID 映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力。</p><ul><li><p>在查询 parent-child 替代方案时，发现了一种 filter-terms 的语法，要求某一字段里有关联实体的 ID 列表。基本的原理是在 terms 的时候，对于多项取值，如果在另外的 index 或者 type 里已知主键 id 的情况下，某一字段有这些值，可以直接嵌套查询。具体可参考官方文档的示例：通过用户里的粉丝关系，微博和用户的关系，来查询某个用户的粉丝发表的微博列表。</p><blockquote><p>父子文档相比嵌套文档较灵活，但只适用于“一对大量”且这个“一”不是海量的应用场景，该方式比较耗内存和 CPU，这种方式查询比嵌套方式慢 5~10 倍，且需要使用特定的 has_parent 和 has_child 过滤器查询语法，查询结果不能同时返回父子文档（一次 join 查询只能返回一种类型的文档）。</p></blockquote></li><li><p>而受限于父子文档必须在同一分片上，ES 父子文档在滚动索引、多索引场景下对父子关系存储和联合查询支持得不好，而且子文档 type 删除比较麻烦（子文档删除必须提供父文档 ID）。</p></li><li><p>如果业务端对查询性能要求很高的话，还是建议使用宽表化处理的方式，这样也可以比较好地应对聚合的需求。在索引阶段需要做 join 处理，查询阶段可能需要做去重处理，分页方式可能也得权衡考虑下。</p></li></ul><h4 id="2-6-ES-中的-reindex"><a href="#2-6-ES-中的-reindex" class="headerlink" title="2.6 ES 中的 reindex"></a>2.6 ES 中的 reindex</h4><p><code>reindex</code>：指重建所有数据的过程，一般发生在一下情况：</p><ol><li><code>mapping</code>设置变更，如：字段类型变化，分词器字典更新等；</li><li><code>index</code>设置变更，如：分片数变化；</li><li>迁移数据。</li></ol><ul><li>ES 提供了线程的 api 用于完成数据重建：<ul><li><code>_update_by_query</code>：在现有索引上重建；</li><li><code>_reindex</code>：在其他索引上重建。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将blog_index中所有文档重建一遍：</span></span><br><span class="line"><span class="comment"># 如果遇到版本冲突，依然执行。</span></span><br><span class="line">POST blog_index/_update_by_query?conflicts=proceed</span><br><span class="line"><span class="comment"># 此时如果blog_index中没有store的数据，则会报错</span></span><br></pre></td></tr></table></figure><h5 id="2-6-1-使用-update-by-query，更新文档的字段值和部分文档："><a href="#2-6-1-使用-update-by-query，更新文档的字段值和部分文档：" class="headerlink" title="2.6.1 使用_update_by_query，更新文档的字段值和部分文档："></a>2.6.1 使用<code>_update_by_query</code>，更新文档的字段值和部分文档：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新文档的字段值及部分文档</span></span><br><span class="line">POST blog_index/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;script&quot;</span>:&#123;    <span class="comment"># 更新文档的字段值</span></span><br><span class="line">  <span class="string">&quot;source&quot;</span>:<span class="string">&quot;ctx._source.likes++&quot;</span>,    <span class="comment"># 代码</span></span><br><span class="line">  <span class="string">&quot;lang&quot;</span>:<span class="string">&quot;painless&quot;</span>    <span class="comment"># ES自带script语法</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;    <span class="comment"># 更新部分文档</span></span><br><span class="line">  <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;user&quot;</span>:<span class="string">&quot;tom&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 reindex 发起后进入的文档，不会参与重建，类似于快照的机制。因此：一般在文档不再发生变更时，进行文档的 reindex。</p><h5 id="2-6-2-使用-reindex，重建数据："><a href="#2-6-2-使用-reindex，重建数据：" class="headerlink" title="2.6.2 使用_reindex，重建数据："></a>2.6.2 使用<code>_reindex</code>，重建数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用_reindex：</span></span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;source&quot;</span>:&#123;    <span class="comment"># 被重建索引</span></span><br><span class="line">  <span class="string">&quot;index&quot;</span>:<span class="string">&quot;blog_index&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="string">&quot;dest&quot;</span>:&#123;    <span class="comment"># 目标索引</span></span><br><span class="line">  <span class="string">&quot;index&quot;</span>:<span class="string">&quot;blog_new_index&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>数据重建时间，受到索引文档规模的影响，此时设定<code>url</code>参数<code>wait_for_completion</code>为<code>false</code>，来异步执行。</li><li><code>ES</code>通过<code>task</code>来描述此类执行任务，并提供了<code>task api</code>来查看任务的执行进度和相关数据：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用task api</span></span><br><span class="line">POST blog_index/_update_by_query?comflicts=proceed&amp;wait_for_completion=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 使用返回的taskid，查看任务的执行进度和相关数据</span></span><br><span class="line">GET _tasks/&lt;返回的task <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="2-7-其他建议："><a href="#2-7-其他建议：" class="headerlink" title="2.7 其他建议："></a>2.7 其他建议：</h4><ol><li>对 mapping 进行版本管理：<ul><li>要么写文件&#x2F;注释，加入到<code>Git</code>仓库，一眼可见；</li><li>要么增加<code>metadata</code>字段，维护版本，并在每次更新<code>mapping</code>设置的时候加<code>1</code>。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;metadata&quot;</span>:&#123;</span><br><span class="line"> <span class="string">&quot;version&quot;</span>:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>防止字段过多：<ul><li><code>index.mapping.total_fields_limit</code>，默认<code>1000</code>个。一般是因为没有高质量的数据建模导致，如：<code>dynamic</code>设为<code>true</code>。此时考虑查分多个索引来解决问题。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ElasticStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Kibana </tag>
            
            <tag> ElasticStack </tag>
            
            <tag> LogStash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ElasticStack」ElasticSearch分布式特性 与 Search机制</title>
      <link href="/2018/11/17/elastic-search.html"/>
      <url>/2018/11/17/elastic-search.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-ElasticSearch-的分布式特性"><a href="#1-ElasticSearch-的分布式特性" class="headerlink" title="1. ElasticSearch 的分布式特性"></a>1. ElasticSearch 的分布式特性</h3><h4 id="1-1-分布式介绍"><a href="#1-1-分布式介绍" class="headerlink" title="1.1 分布式介绍"></a>1.1 分布式介绍</h4><ol><li><code>ES</code>支持<strong>集群模式</strong>，即一个分布式系统。其好处主要有以下 2 个:<ol><li><strong>可增大系统容量</strong>。比如：内存、磁盘的增加使得<code>ES</code>能够支持<code>PB</code>级别的数据；</li><li><strong>提高了系统可用性</strong>。即使一部分节点停止服务，集群依然可以正常对外服务。</li></ol></li><li><code>ES</code>集群由多个<code>ES实例</code>构成。 + 不同集群通过<strong>集群名字</strong>来区分，通过配置文件<code>elasticsearch.yml</code>中的<code>cluster.name</code>可以修改，默认为<code>elasticsearch</code> + 每个<code>ES实例</code>的本质，其实是一个<code>JVM进程</code>，且有自己的名字，通过配置文件中的<code>node.name</code>可以修改。<span id="more"></span></li></ol><h4 id="1-2-构建-ES-集群"><a href="#1-2-构建-ES-集群" class="headerlink" title="1.2 构建 ES 集群"></a>1.2 构建 ES 集群</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个本地化集群my_cluster</span></span><br><span class="line">bin/elasticsearch -Epath.data=node1 -Ecluster.name=my_cluster -Enode.name=node1 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -Ecluster.name=my_cluster -Enode.name=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -Ecluster.name=my_cluster -Enode.name=node3 -d</span><br></pre></td></tr></table></figure><blockquote><p>可以通过 cerebro 插件可以看到，集群<code>my_cluster</code>中存在三个节点，分别为：<code>node1</code>、<code>node2</code>、<code>node3</code></p></blockquote><ol><li>**<code>Cluster State</code>**：ES 集群相关的数据，主要记录如下信息：<ul><li>节点信息：如节点名称、连接地址等</li><li>索引信息：如索引名称、配置等</li></ul></li><li><strong><code>Master Node</code><strong>：</strong>主节点</strong>，可修改<code>cluster state</code>的节点。一个集群<strong>只能有一个</strong>。<ul><li><code>cluster state</code>存储于每个节点上，<code>master</code>维护最新版本并向其他从节点同步。</li><li>master 节点是通过集群中所有节点<strong>选举</strong>产生的，可被选举的节点称为**<code>master-eligible节点</code>**</li><li>通过配置<code>node.master:true</code>设置节点为可被选举节点(默认为 true)</li></ul></li><li>**<code>Cordinating Node</code>**：处理请求的节点。是所有节点的默认角色，且不能取消。<ul><li>路由请求到正确的节点处理，如：创建索引的请求到 master 节点。</li></ul></li><li>**<code>Data Node</code>**：存储数据的节点，默认节点都是<code>data</code>类型。配置<code>node.data:true</code>。</li></ol><h4 id="1-3-副本与分片"><a href="#1-3-副本与分片" class="headerlink" title="1.3 副本与分片"></a>1.3 副本与分片</h4><ul><li><p>提高系统可用性：</p><ol><li>服务可用性：集群</li><li>数据可用性：<strong>副本</strong>(Replication)</li></ol></li><li><p>增大系统容量：<strong>分片</strong>(Shard)</p></li><li><p><strong>分片</strong>是<code>ES</code>能支持<code>PB级别数</code>据的基石：可在创建索引时指定</p><ol><li>分片存储部分数据，可以分布于任意节点；</li><li>分片数在索引创建时指定，且后续不能更改，默认为 5 个；</li><li>有主分片和副本分片之分，以实现数据的高可用；</li><li>副本分片由主分片同步数据，可以有多个，从而提高数据吞吐量。</li></ol></li><li><p><strong>分片数的设定</strong>很重要，需要提前规划好</p><ul><li><strong>过小</strong>会导致后续无法通过增加节点实现水平扩容</li><li><strong>过大</strong>会导致一个节点分片过多，造成资源浪费，同时会影响查询性能</li></ul></li><li><p>例如：在 3 个节点的集群中配置索引指定 3 个分片和 1 个副本（<code>index.number_of_shards:3</code>,<br><code>index.number_of_replicas:1</code>），分布如下：<br><img src="/2018/11/17/elastic-search/es_shard.jpg"></p></li><li><p>怎样增加节点或副本提高索引的吞吐量</p><ul><li><strong>同时</strong>增加新的节点<strong>和</strong>加新的副本，这样把新的副本放在新的节点上，进行索引数据读取的时候，并且读取，就会提升索引数据读取的吞吐量。</li></ul></li></ul><h4 id="1-4-ES-集群状态-与-故障转移"><a href="#1-4-ES-集群状态-与-故障转移" class="headerlink" title="1.4 ES 集群状态 与 故障转移"></a>1.4 ES 集群状态 与 故障转移</h4><ul><li>ES 的**健康状态(<code>Cluster Health</code>)**分为三种：<ol><li><code>Greed</code>，绿色。表示所有主分片和副本分片都正常分配；</li><li><code>Yellow</code>，黄色。表示所有主分片都正常分配，但有副本分片未分配；</li><li><code>Red</code>，红色。表示有主分片未分配。</li></ol></li><li>可通过<code>GET _cluster/health</code>查看集群状态<ul><li>返回<strong>集群名称</strong>，<strong>集群状态</strong>，<strong>节点数</strong>，<strong>活跃分片数</strong>等信息。</li><li>如果此时磁盘空间不够，name 在创建新的索引的时候，主副分片都不会再分配，此时的集群状态会直接飙红，但此时依然可以访问集群和索引，也可以正常进行搜索。</li><li>所以：<strong>ES 的集群状态为红色，不一定就不能正常服务</strong>。</li></ul></li></ul><ul><li><strong>故障转移 <code>Failover</code></strong><ol><li>当其余节点发现定时 ping 主节点 master 无响应的时候，集群状态转为 Red。此时会发起 master 选举。</li><li>新 master 节点发现若有主分片未分配，会将副本分片提升为主分片，此时集群状态转为 Yellow。</li><li>新 master 节点会将提升后的主分片生成新的副本，此时集群状态转为 Green。整个故障转移过程结束。</li></ol></li></ul><h4 id="1-5-文档分布式存储"><a href="#1-5-文档分布式存储" class="headerlink" title="1.5 文档分布式存储"></a>1.5 文档分布式存储</h4><p>通过文档到分片的<strong>映射算法</strong>，使文档<strong>均匀分布</strong>到所有分片上，以充分利用资源。</p><ul><li><p>文档对应分片计算公式：<code>shard = hash(routing)%number_of_primary_shards</code></p><ul><li><code>hash</code>保证数据均匀分布在分片中</li><li><code>routing</code>作为关键参数，默认为文档 ID，也可自行指定</li><li><code>number_of_primary_shards</code>为主分片数</li></ul></li><li><p><strong>主分片数一旦设定，不能更改</strong>：<code>为了保证文档对应的分片不会发生改变</code>。</p></li><li><p>文档<strong>创建</strong>流程:<br><img src="/2018/11/17/elastic-search/elastic1.jpg"></p></li><li><p>文档<strong>读取</strong>流程<br><img src="/2018/11/17/elastic-search/elastic2.jpg"></p></li><li><p>文档<strong>批量创建</strong>流程<br><img src="/2018/11/17/elastic-search/elastic3.jpg"></p></li><li><p>文档<strong>批量读取</strong>流程<br><img src="/2018/11/17/elastic-search/elastic4.jpg"></p></li></ul><h4 id="1-6-脑裂问题"><a href="#1-6-脑裂问题" class="headerlink" title="1.6 脑裂问题"></a>1.6 脑裂问题</h4><ul><li>在分布式系统中一个经典的网络问题<ul><li>当一个集群在运行时，作为<code>master</code>节点的<code>node1</code>的网络突然出现问题，无法和其他节点通信，出现网络隔离情况。那么<code>node1</code>自己会组成一个单节点集群，并更新<code>cluster state</code>；同时作为<code>data</code>节点的<code>node2</code>和<code>node3</code>因为无法和<code>node1</code>通信，则通过选举产生了一个新的<code>master</code>节点<code>node2</code>，也更新了<code>cluster state</code>。那么当<code>node1</code>的网络通信恢复之后，集群无法选择正确的<code>master</code>。</li></ul></li><li>解决方案也很简单：<ul><li>仅在可选举的<code>master-eligible</code>节点数<code>&gt;=quorum</code>的时候才进行<code>master</code>选举。</li><li><code>quorum(至少为2)=master-eligible数量/2 + 1</code>。</li><li>通过<code>discovery.zen.minimum_master_nodes</code>为<code>quorum</code>即可避免脑裂。</li></ul></li></ul><h4 id="1-7-Shards-分片详解"><a href="#1-7-Shards-分片详解" class="headerlink" title="1.7 Shards 分片详解"></a>1.7 Shards 分片详解</h4><ol><li>倒排索引一旦生成，不能更改。<ul><li>优点：<ol><li>不用考虑并发写文件的问题，杜绝了锁机制带来的性能问题</li><li>文件不在更改，则可以利用文件系统缓存，只需载入一次，只要内存足够，直接从内存中读取该文件，性能高；</li><li>利于生成缓存数据(且不需更改)；</li><li>利于对文件进行压缩存储，节省磁盘和内存存储空间。</li></ol></li><li>缺点：在写入新的文档时，必须重构倒排索引文件，然后替换掉老倒排索引文件后，新文档才能被检索到，导致实时性差。</li></ul></li><li>解决文档搜索的实时性问题的方案：<ul><li>新文档直接生成新待排索引文件，查询时同时查询所有倒排索引文件，然后做结果的汇总即可，从而提升了实时性。</li></ul></li><li><code>Segment</code><ul><li><code>Lucene</code>就采用了上述方案，构建的单个倒排索引称为<code>Segment</code>，多个<code>Segment</code>合在一起称为<code>Index</code>(<code>Lucene</code>中的<code>Index</code>)。在<code>ES</code>中的一个<code>shard</code>分片，对应一个<code>Lucene</code>中的<code>Index</code>。且<code>Lucene</code>有一个专门记录所有<code>Segment</code>信息的文件叫做<code>Commit Point</code>。</li><li><code>Segment</code>写入磁盘的过程依然很耗时，可以借助文件系统缓存的特性。「先将<code>Segment</code>在内存中创建并开放查询，来进一步提升实时性」，这个过程在<code>ES</code>中被称为：<code>refresh</code>。</li><li>在<code>refresh</code>之前，文档会先存储到一个缓冲队列<code>buffer</code>中，<code>refresh</code>发生时，将<code>buffer</code>中的所有文档清空，并生成<code>Segment</code>。</li><li><code>ES</code>默认每<code>1s</code>执行一次<code>refresh</code>操作，因此实时性提升到了<code>1s</code>。这也是<code>ES</code>被称为近实时的原因（<code>Near Real Time</code>）。</li></ul></li><li><code>translog</code>文件<ul><li><code>translog</code>机制：当文档写入<code>buffer</code>时，同时会将该操作写入到<code>translog</code>中，这个文件会即时将数据写入磁盘，在 6.0 版本之后默认每个要求都必须落盘，这个操作叫做<code>fsync</code>操作。这个时间也是可以通过配置：<code>index.translog.*</code>进行修改的。比如每五秒进行一次<code>fdync</code>操作，那么风险就是丢失这<code>5s</code>内的数据。</li></ul></li><li>文档搜索实时性——<code>flush</code>(十分重要)<ul><li><code>flush</code>的功能，就是：将内存中的<code>Segment</code>写入磁盘，主要做如下工作：<ol><li>将<code>translog</code>写入磁盘；</li><li>将<code>index bufffer</code>清空，其中的文档生成一个新的<code>Segment</code>，相当于触发一次<code>refresh</code>；</li><li>更新<code>Commit Point</code>文件并写入磁盘；</li><li>执行<code>fsync</code>落盘操作，将内存中的<code>Segment</code>写入磁盘；</li><li>删除旧的<code>translog</code>文件。</li></ol></li></ul></li><li><code>refresh</code>与<code>flush</code>的发生时机<ul><li><code>refresh</code>：发生时机主要有以下几种情况：<ol><li>间隔时间达到。<ul><li>通过<code>index.settings.refresh_interval</code>设置，默认为<code>1s</code>。</li></ul></li><li><code>index.buffer</code>占满时。<ul><li>通过<code>indices.memory.index_buffer_size</code>设置，默认<code>JVM heap</code>的<code>10%</code>，且所有<code>shard</code>共享。</li></ul></li><li><code>flush</code>发生时。会触发一次<code>refresh</code>。</li></ol></li><li><code>flush</code>：发生时机主要有以下几种情况：<ol><li>间隔时间达到。<ul><li>5.x 版本之前，通过<code>index.translog.flush_threshold_period</code>设置，默认 30min。</li><li>5.x 版本之后，<strong>ES 强制每 30min 执行一次 flush，不能再进行更改</strong>。</li></ul></li><li><code>translog</code>占满时。<ul><li>通过<code>index.translog.flush_threshold_size</code>设置，默认<code>512m</code>。且每个<code>Index</code>有自己的<code>translog</code>。</li></ul></li></ol></li></ul></li><li>删除和更新文档：<ul><li>删除：<ul><li><code>Segment</code>一旦生成，就不能更改，删除的时候，<code>Lucene</code>专门维护一个<code>.del</code>文件，记录所有已删除的文档。</li><li><code>.del</code>文件上记录的是文档在<code>Lucene</code>中的<code>ID</code>，在查询结果返回之前，会过滤掉<code>.del</code>文件中的所有文档。</li></ul></li><li>更新：<ul><li>先删除老文档，再创建新文档，两个文档的<code>ID</code>在<code>Lucene</code>中的<code>ID</code>不同，但是在<code>ElasticSearch</code>中<code>ID</code>相同。</li></ul></li></ul></li><li><code>Segment Merging</code>(合并)<ol><li>随着<code>Segment</code>的增多，由于每次查询的<code>Segment</code>数量也增多，导致查询速度变慢；</li><li><code>ES</code>会定时在后台进行<code>Segment merge</code>的操作，减少<code>Segment</code>数量；</li><li>通过<code>force_merge api</code>可以手动强制做<code>Segment</code>的合并操作。</li></ol></li></ol><h3 id="2-ElasticSearch-的集群优化"><a href="#2-ElasticSearch-的集群优化" class="headerlink" title="2. ElasticSearch 的集群优化"></a>2. ElasticSearch 的集群优化</h3><h4 id="2-1-生产环境部署"><a href="#2-1-生产环境部署" class="headerlink" title="2.1 生产环境部署"></a>2.1 生产环境部署</h4><ol><li>遵照官方建议设置所有系统参数。<ul><li>在 ES 的配置文件中 elasticsearch.yml 中，尽量只写必备的参数，其他可通过 api 进行动态设置，随着 ES 版本的不断升级，很多网上流传的参数，现在已经不再适用，所以不要胡乱复制。</li><li>建议设置的基本参数有：<ol><li><code>cluster.name</code></li><li><code>node.name</code></li><li><code>node.master/node.data/node.ingest</code></li><li><code>network.host</code>: 建议显示指定为服务器的内网<code>ip</code>，切勿直接指定<code>0.0.0.0</code>，很容易直接从外部被修改<code>ES</code>数据。</li><li><code>discovery.zen.ping.unicast.hosts</code>: 设置集群其他节点地址，一般设置选举节点即可</li><li><code>discovery.zen.minimum_master_nodes</code>: 一般设置为<code>2</code>，有<code>3</code>个即可。</li><li><code>path.data/path.log</code></li><li>除上述参数外，再根据需要增加其他的静态配置参数，如：<code>refresh</code>优化参数，<code>indices.memory.index_buffer_size</code>。</li></ol></li><li>动态设定的参数有 transient(短暂的)和 persistent(持续的)两种，前者在集群重启后会丢失，后者在集群重启后依然# 生效。二者都覆盖了 yml 中的配置，举例：</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用transient和persistent动态设置ES集群参数</span></span><br><span class="line">PUT /_cluster/Settings</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;persistent&quot;</span>:&#123;    <span class="comment"># 永久</span></span><br><span class="line">  <span class="string">&quot;discovery.zen.minimum_master_nodes:2</span></span><br><span class="line"><span class="string"> &#125;,</span></span><br><span class="line"><span class="string"> &quot;</span>transient<span class="string">&quot;:&#123;   # 临时</span></span><br><span class="line"><span class="string">  &quot;</span>indices.store.throttle.max_bytes_per_sec<span class="string">&quot;:&quot;</span>50mb<span class="string">&quot;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>关于 JVM 内存设定<ul><li>每个节点尽量不要超多<code>31GB</code>。</li><li>预留一半内存给操作系统，用来做文件缓存。ES 的具体内存大小根据 node 要存储的数据量来估算，为了保证性能<ul><li>搜索类项目中：内存：数据量   &#x3D;&#x3D;&#x3D;&gt;   1：16；</li><li>日志类项目中：内存：数据量   &#x3D;&#x3D;&#x3D;&gt;   1：48&#x2F;96。</li></ul></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">假设现有数据1TB，3个node，1个副本，那么：</span><br><span class="line">每个node存储(1+1)*1024 / 3 = 666GB,即700GB左右，做20%预留空间，每个node约存850GB数据。</span><br><span class="line">此时：</span><br><span class="line">如果是搜索类项目，每个node内存约为850/16=53GB，已经超过31GB最大限制；</span><br><span class="line">而：31*16 = 496，意味着每个node最大只能存496GB的数据，则：2024/496=4.08...即至少需要5个节点。</span><br><span class="line">如果是日志类项目，每个node最大能存:31*48=1488GB,则：2024/1488=1.36...，则三个节点已经够了。</span><br></pre></td></tr></table></figure><h4 id="2-2-写性能优化"><a href="#2-2-写性能优化" class="headerlink" title="2.2 写性能优化"></a>2.2 写性能优化</h4><p>在写上面的优化，主要是增大写的吞吐量——<code>EPS(Event Per Second)</code></p><ul><li>优化方案：<ol><li><code>Client</code>：多线程写，批量写<code>bulk</code>；</li><li><code>ES</code>：在高质量数据建模的前提下，主要在<code>refresh</code>、<code>translig</code>和<code>flush</code>之间做文章。</li></ol></li></ul><ol><li>降低<code>refresh</code>写入内存的频率：<ol><li>增大<code>refresh_interval</code>，降低实时性，增大每次<code>refresh</code>处理的文件数，默认 1s。可以设为-1s，禁止自动<code>refresh</code>。</li><li>增大<code>index</code> <code>buffer</code>大小，参数为：<code>indices.memory.index_buffer_size</code>。此为静态参数，需设定在<code>elasticsea.yml</code>中，默认<code>10%</code></li></ol></li><li>降低 translog 写入磁盘频率，同时会降低容灾能力：<ol><li><code>index.translog.durability</code>：设为<code>async</code>；</li><li><code>index.translog.sync_interval</code>。设置需要的大小如：120s  &#x3D;&gt;   每 120s 才写一次磁盘。</li><li><code>index.translog.flush_threshold_size</code>。默认 512m。即当<code>translog</code>大小超过此值，会触发一次<code>flush</code>，可以调大避免<code>flush</code>过早触发。</li></ol></li><li>在<code>flush</code>方面，从 6.x 开始，ES 固定每 30min 执行一次，所以优化点不多，一般都是 ES 自动完成。</li><li>其他：<ol><li>将副本数设置为 0，在文档全部写完之后再加副本；</li><li>合理设计<code>shard</code>数，保证<code>shard</code>均匀地分布在所有<code>node</code>上，充分利用<code>node</code>资源：<ul><li><code>index.routing.allocation.total_shards_per_node</code>：限定每个索引在每个<code>node</code>上可分配的主副分片数，</li><li>如：有<code>5</code>个<code>node</code>，某索引有<code>10</code>个主分片，<code>1</code>个副本(<code>10</code>个副分片)，则：<code>20/5=45</code>,但是实际要设置为<code>5</code>，预防某个<code>node</code>下线后分片迁移失败。</li></ul></li></ol></li></ol><blockquote><p>写性能优化，主要还是 index 级别的设置优化。<br>一般在 refresh、translog、flush 三个方面进行优化；</p></blockquote><h4 id="2-3-读性能优化"><a href="#2-3-读性能优化" class="headerlink" title="2.3 读性能优化"></a>2.3 读性能优化</h4><ul><li>主要受以下几方面影响：<ol><li>数据模型是否符合业务模型？</li><li>数据规模是否过大？</li><li>索引配置是否优化？</li><li>查询运距是否优化？</li></ol></li></ul><ol><li>高质量的数据建模<ol><li>将需通过<code>cripte</code>脚本动态计算的值，提前计算好作为字段存入文档中；</li><li>尽量使数据模型贴近业务模型</li></ol></li><li>根据不同数据规模设定不同的<code>SLA</code>(服务等级协议)，万级数据和千万级数据和亿万级数据性能上肯定有差异；</li><li>索引配置优化<ol><li>根据数据规模设置合理的分片数，可通过测试得到最适合的分片数；</li><li>分片数并不是越多越好</li></ol></li><li>查询语句优化<ol><li>尽量使用<code>Filter</code>上下文，减少算分场景(<code>Filter</code>有缓存机制，能极大地提升查询性能)；</li><li>尽量不用<code>cript</code>进行字段计算或算分排序等；</li><li>结合<code>profile</code>、<code>explain API</code>分析慢查询语句的症结所在，再去优化数据模型。</li></ol></li></ol><h4 id="2-4-其他优化点"><a href="#2-4-其他优化点" class="headerlink" title="2.4 其他优化点"></a>2.4 其他优化点</h4><ol><li>如何设定<code>shard</code>数？<ul><li><code>ES</code>的性能基本是线性扩展的，因此，只需测出一个<code>shard</code>的性能指标，然后根据实际的性能需求就可算出所需的<code>shard</code>数。</li><li>测试一个<code>shard</code>的流程如下：<ol><li>搭建与生产环境相同配置的单节点集群；</li><li>设定一个单分片<code>0</code>副本的索引；</li><li>写入实际生产数据进行测试，获取（写性能指标）；</li><li>针对数据进行查询操作，获取（读性能指标）。</li></ol></li></ul></li><li>压力测试工具，可以采用<code>ES</code>自带的<code>esrally</code>，从经验上讲：<ul><li>如果是搜索引擎场景，单<code>shard</code>大小不超过<code>15GB</code>；</li><li>如果是日志分析场景，单<code>shard</code>大小不超过<code>50GB</code>；</li><li>估算索引的总数据大小，除以上述单<code>shard</code>大小，也可得到经验上的分片数。</li></ul></li></ol><h4 id="2-5-ES-集群监控"><a href="#2-5-ES-集群监控" class="headerlink" title="2.5 ES 集群监控"></a>2.5 ES 集群监控</h4><p>使用官方免费插件<code>X-pack</code>。</p><ol><li>安装与启动：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X-pack的安装</span></span><br><span class="line"><span class="built_in">cd</span> ~/elasticsearch-6.1.1</span><br><span class="line">bin/elasticsearch-plugin install x-pack</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">cd</span> ~/kibana-6.1.1</span><br><span class="line">bin/kibana-plugin indtall x-pack</span><br></pre></td></tr></table></figure><p>之后重启<code>ES</code>集群即可。<br>在<code>kibana</code>的界面可以看到新增了工具，使用<code>Monitoring</code>进行集群监控。</p><h3 id="3-ElasticSearch-中-Search-的运行机制"><a href="#3-ElasticSearch-中-Search-的运行机制" class="headerlink" title="3. ElasticSearch 中 Search 的运行机制"></a>3. ElasticSearch 中 Search 的运行机制</h3><ul><li><code>Search</code>执行的时候，实际分为两个步骤执行：<ol><li><code>Query</code>阶段：搜索</li><li><code>Fetch</code>阶段：获取</li></ol></li></ul><h4 id="3-1-Query—Then—Fetch："><a href="#3-1-Query—Then—Fetch：" class="headerlink" title="3.1 Query—Then—Fetch："></a>3.1 Query—Then—Fetch：</h4><p>若集群<code>my_cluster</code>中存在三个节点 node1、node2、node3，其中<code>master</code>为 node1，其余的为<code>data</code>节点。</p><ul><li><p><code>Query</code>阶段:<br><img src="/2018/11/17/elastic-search/elastic-q.jpg"></p></li><li><p><code>Fetch</code>阶段:<br><img src="/2018/11/17/elastic-search/elastic-f.jpg"></p></li></ul><h4 id="3-2-相关性算分："><a href="#3-2-相关性算分：" class="headerlink" title="3.2 相关性算分："></a>3.2 相关性算分：</h4><p><strong>相关性算分在<code>shard</code>和<code>shard</code>之间是相互独立的</strong>。也就意味着：同一个单词<code>term</code>在不同的<code>shard</code>上的<code>TDF</code>等值也可能是不同的。得分与<code>shard</code>有关。<br>当文档数量不多时，会导致相关性算分严重不准的情况发生。</p><ul><li>解决方案：<ol><li>设置分片数为<code>1</code>个，从根本上排除问题。（此方案只适用于百万&#x2F;少千万级的少量数据）</li><li>使用<code>DFS Query-then-Fetch</code>查询方式。</li></ol></li><li><code>DFS Query-then-Fecth</code>：<ul><li>在拿到所有文档后，再重新进行完整的计算一次相关性得分，耗费更多的 CPU 和内存，<strong>执行性能也较低</strong>。所以也不推荐。</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用DLS Query-then-Fetch进行查询：</span></span><br><span class="line">GET my_index/_search？search_type=dfs_query_then_fetch</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-排序相关："><a href="#3-3-排序相关：" class="headerlink" title="3.3 排序相关："></a>3.3 排序相关：</h4><p>默认采用相关性算分结果进行排序。可通过<code>sort</code>参数自定义排序规则，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用sort关键词进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">  <span class="string">&quot;birth&quot;</span>:<span class="string">&quot;desc&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 或使用数组形式定义多字段排序规则</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:[    <span class="comment"># 使用数组</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;birth&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;order&quot;</span>:<span class="string">&quot;asc&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;order&quot;</span>:<span class="string">&quot;desc&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>直接按数字&#x2F;日期排序，如上例中<code>birth</code></li><li>按字符串进行排序：字符串排序较特殊，因为在<code>ES</code>中有<code>keyword</code>和<code>text</code>两种：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接对text类型进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>:<span class="string">&quot;desc&quot;</span>    <span class="comment"># 针对username字段进行倒序排序</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 针对keyword进行排序</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;username.keyword&quot;</span>:<span class="string">&quot;desc&quot;</span>    <span class="comment"># 针对username的子类型keyword类型进行倒叙排序</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-1-关于-fielddata-和-docvalues"><a href="#3-3-1-关于-fielddata-和-docvalues" class="headerlink" title="3.3.1 关于 fielddata 和 docvalues:"></a>3.3.1 关于 fielddata 和 docvalues:</h5><p>排序的实质是对字段的原始内容排序的过程，此过程中<strong>倒排索引无法发挥作用</strong>，需要用到<strong>正排索引</strong>。即：通过文档<code>ID</code>和字段得到原始内容。</p><ul><li>ES 提供 2 中实现方式：<ul><li><code>Fielddata</code>。     默认禁用。</li><li><code>DocValues</code>。     默认启用，除了 text 类型。</li></ul></li></ul><table><thead><tr><th>对比</th><th>Fielddata</th><th>DocValues</th></tr></thead><tbody><tr><td>创建时机</td><td>搜索时即时创建</td><td>创建索引时创建，和倒排索引创建时间一致</td></tr><tr><td>创建位置</td><td>JVM Heap</td><td>磁盘</td></tr><tr><td>优点</td><td>不占用额外磁盘空间</td><td>不占用 Heap 内存</td></tr><tr><td>缺点</td><td>文档较多时，同时创建会花费过多时间，占用过多 Heap 内存</td><td>减慢索引的速度，占用额外的磁盘空间</td></tr></tbody></table><h5 id="3-3-2-Fielddata-的开启"><a href="#3-3-2-Fielddata-的开启" class="headerlink" title="3.3.2 Fielddata 的开启:"></a>3.3.2 Fielddata 的开启:</h5><p><code>Fielddata</code><strong>默认关闭</strong>，可通过如下 api 进行开启，且在后续使用时随时可以开启&#x2F;关闭：</p><ul><li>使用场景：<strong>一般在对分词做聚合分析的时候开启</strong>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启字段的fielddata设置</span></span><br><span class="line">PUT my_index/_mapping/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;username&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">   <span class="string">&quot;fielddata&quot;</span>:<span class="literal">true</span>    <span class="comment"># 关键词</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-3-Docvalues-的关闭"><a href="#3-3-3-Docvalues-的关闭" class="headerlink" title="3.3.3 Docvalues 的关闭"></a>3.3.3 Docvalues 的关闭</h4><p><code>Docvalues</code><strong>默认开启</strong>，可在创建索引时关闭，且之后不能再打开，要打开只能做 reindex 操作。</p><ul><li>使用场景：当明确知道，不会使用这个字段排序或者不做聚合分析的时候，可关闭 doc_values，减少磁盘空间的占用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭字段的docvalues设置</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">     <span class="string">&quot;doc_values&quot;</span>:<span class="literal">false</span>    <span class="comment"># 关键词</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-分页与遍历"><a href="#3-4-分页与遍历" class="headerlink" title="3.4 分页与遍历"></a>3.4 分页与遍历</h4><p>ES 提供了三种方式来解决分页和遍历的问题： <code>from/size</code>，<code>scroll</code>，<code>search_after</code>。</p><h5 id="3-4-1-from-x2F-size"><a href="#3-4-1-from-x2F-size" class="headerlink" title="3.4.1 from&#x2F;size"></a>3.4.1 from&#x2F;size</h5><ul><li><code>from</code>：指明开始位置；</li><li><code>size</code>：指明获取总数</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用from——size</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;from&quot;</span>:1,    <span class="comment"># 从第2个开始搜索</span></span><br><span class="line"> <span class="string">&quot;size&quot;</span>:2     <span class="comment"># 获取2个长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>经典问题：<strong>深度分页</strong>。<ul><li>问题：如何在数据分片存储的情况下， 获取前 1000 个文档？</li><li>答案：<ul><li>先从每个分片上获取前 1000 个文档， 然后由处理节点聚合所有分片的结果之后，再排序获取前 1000 个文档。</li><li>此时页数越深，处理的文档就越多，占用的内存就越大，耗时就越长。这就是深度分页问题。</li><li>为了尽量避免深度分页为题，ES 通过设定<code>index.max_result_window</code>限定最多到 10000 条数据。</li></ul></li></ul></li><li>在设计分页系统时，有一个分页数十分重要：<ul><li><code>total_page=(total + page_size -1) / page_size</code></li><li>总分页数&#x3D; (文档总数+认为设定的文档大小-1) &#x2F; 人为设定的文档大小</li><li>但是在搜索引擎中的意义并不大，因为如果排在前面的结果都不能让用户满意，那么越往后，越不能让用户满意。</li></ul></li></ol><h5 id="3-4-2-scroll"><a href="#3-4-2-scroll" class="headerlink" title="3.4.2 scroll"></a>3.4.2 scroll</h5><ul><li>遍历文档集的<code>API</code>，以快照的方式来避免深度分页问题。<ol><li>不能用来做实时搜索，因为数据不是实时的；</li><li>尽量不用复杂的<code>sort</code>条件，使用<code>_doc</code>最高效；</li><li>使用比较复杂。</li></ol></li><li>步骤：<ol><li>发起一个<code>scroll search</code>，会返回后续会用到的<code>_scroll_id</code></li><li>调用<code>scroll search</code>的<code>api</code>，获取文档集合，不断迭代至返回<code>hits</code>数组为空时停止</li><li>之后不断返回新的<code>_scroll_id</code>，使用新的<code>_scroll_id</code>进行查询，直到返回数组为空。</li><li>当不断的进行迭代，会产生很多<code>scroll</code>，导致大量内存被占用，可以通过<code>clear api</code>进行删除</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发起一个scroll search</span></span><br><span class="line">GET my_index/_search?scroll=5m <span class="comment"># 该快照的有效时间为5min</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>1    <span class="comment"># 指明每次scroll返回的文档数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 调用scroll search 的api，获取文档集合</span></span><br><span class="line">POST _search/scroll</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;scroll&quot;</span>:<span class="string">&quot;5m&quot;</span>,    <span class="comment"># 指明有效时间</span></span><br><span class="line"> <span class="string">&quot;scroll_id&quot;</span>:<span class="string">&quot;xxxxxx&quot;</span>    <span class="comment"># 上一步返回的_scroll_id</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 使用clear api对scroll进行删除</span></span><br><span class="line">DELETE /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;scroll_id&quot;</span>:[</span><br><span class="line">   <span class="string">&quot;xxxxxx&quot;</span>,    <span class="comment"># _scroll_id</span></span><br><span class="line">   <span class="string">&quot;xxxxxx&quot;</span>,    <span class="comment"># _scroll_id</span></span><br><span class="line">   ......</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 删除所有的scroll</span></span><br><span class="line">DELETE /_search/scroll/_all</span><br></pre></td></tr></table></figure><h5 id="3-4-3-search-after"><a href="#3-4-3-search-after" class="headerlink" title="3.4.3 search_after"></a>3.4.3 search_after</h5><p>避免深度分页的性能问题，提供实时的下一页文档获取功能。</p><ul><li>缺点：不能使用 from 参数，即：不能指定页数。且只能下一页，不能上一页。</li><li>使用步骤：<ol><li>第一步：正常搜索，但是要指定 sort 值，并保证值唯一：</li><li>第二步：使用上一步最后一个文档的 sort 值进行查询：</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步，正常搜索</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:1,</span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;age&quot;</span>:<span class="string">&quot;desc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;desc&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 第二步，使用sort值进行查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;size&quot;</span>:1,</span><br><span class="line"> <span class="string">&quot;search_after&quot;</span>:[28,<span class="string">&quot;2&quot;</span>],<span class="comment"># 28,&quot;2&quot;，是上一次搜索返回的sort值</span></span><br><span class="line"> <span class="string">&quot;sort&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;age&quot;</span>:<span class="string">&quot;desc&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;desc&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4-4-如何避免深度分页问题"><a href="#3-4-4-如何避免深度分页问题" class="headerlink" title="3.4.4 如何避免深度分页问题:"></a>3.4.4 如何避免深度分页问题:</h5><p>这个问题目前连 google 都没能解决，所以只能最大程度避免，通过唯一排序值定位每次要处理的文档数都控制在 size 内：</p><ul><li>应用场景：<ol><li>from&#x2F;size:需实时获取顶部的部分文档，且需自由翻页（实时）；</li><li>scroll:需全部文档，如：导出所有数据的功能（非实时）；</li><li>search_after:需全部文档，不需自由翻页（实时）。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> ElasticStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Kibana </tag>
            
            <tag> ElasticStack </tag>
            
            <tag> LogStash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「ElasticStack」ElasticSearch入门</title>
      <link href="/2018/11/12/elastic-base.html"/>
      <url>/2018/11/12/elastic-base.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><h4 id="1-1-ElasticStack特点"><a href="#1-1-ElasticStack特点" class="headerlink" title="1.1 ElasticStack特点"></a>1.1 ElasticStack特点</h4><ol><li>使用门槛低，开发周期短，上线快</li><li>性能好，查询快，实时展示结果</li><li>扩容方便，快速支撑增长迅猛的数据<span id="more"></span></li></ol><h4 id="1-2-ElasticStack各组件作用"><a href="#1-2-ElasticStack各组件作用" class="headerlink" title="1.2 ElasticStack各组件作用"></a>1.2 ElasticStack各组件作用</h4><ol><li>**<code>Beats</code>**：数据采集</li><li><strong><code>LogStash</code></strong>: 数据处理</li><li><strong><code>ElasticSearch</code></strong>(核心引擎): 数据存储、查询和分析</li><li><strong><code>Kibana</code></strong>: 数据探索与可视化分析<!-- more --></li></ol><h4 id="1-3-ElasticStack使用场景"><a href="#1-3-ElasticStack使用场景" class="headerlink" title="1.3 ElasticStack使用场景"></a>1.3 ElasticStack使用场景</h4><ul><li>搜索引擎、日志分析、指标分析</li></ul><h4 id="1-4-ElasticStack安装启动"><a href="#1-4-ElasticStack安装启动" class="headerlink" title="1.4 ElasticStack安装启动"></a>1.4 ElasticStack安装启动</h4><ol><li><code>ElasticSearch</code>启动：解压到安装目录，启动<code>bin/elasticsearch</code>（默认端口:<code>http:\\localhost:9200</code>, 加参数<code>-d</code>后台启动）</li><li><code>ElasticSearch</code>集群：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/elasticsearch -d </span><br><span class="line">bin/elasticsearch -Ehttp.port=8200 -Epath.data=node2 -d</span><br><span class="line">bin/elasticsearch -Ehttp.port=7200 -Epath.data=node3 -d</span><br></pre></td></tr></table></figure><ol start="3"><li>Kibana启动：解压到安装目录，启动<code>bin/kibana</code>（默认端口:<code>http:\\localhost:5601</code>）</li></ol><h4 id="1-5-ElasticSearch常见术语"><a href="#1-5-ElasticSearch常见术语" class="headerlink" title="1.5 ElasticSearch常见术语"></a>1.5 ElasticSearch常见术语</h4><ol><li><code>Document</code>(文档)：用户存储在ES中的数据文档</li><li><code>Index</code>(索引)：由具有相同字段的文档列表组成</li><li><code>field</code>(字段)：包含具体数据</li><li><code>Node</code>(节点)：一个ES的实例，构成clister的单元</li><li><code>Cluster</code>(集群)：对外服务的一个&#x2F;多个节点</li></ol><h4 id="1-6-Document介绍"><a href="#1-6-Document介绍" class="headerlink" title="1.6 Document介绍"></a>1.6 Document介绍</h4><ol><li>常用数据类型：字符串、数值型、布尔型、日期型、二进制、范围类型</li><li>每个文档都有一个唯一<code>ID</code>标识。（可以自行指定，也可由ES自动生成）</li><li>元数据，用于标注文档的相关信息：<ul><li><code>_index</code>：文档所在的索引名</li><li><code>_type</code>：文档所在的类型名(后续的版本中type这个概念将会被移除，也不允许一个索引中有多个类型)</li><li><code>_id</code>：文档唯一标识</li><li><code>_source</code>：文档的原始JSON数据，可从这获取每个字段的内容</li><li><code>_all</code>：整合所有字段内容到该字段。（默认禁用）</li><li><code>_version</code>：文档字段版本号，标识被操作了几次</li></ul></li><li><code>Index</code>介绍：<ul><li>索引中存储相同结构的文档，且每个index都有自己的Mapping定义，用于定义字段名和类型；</li><li>一个集群中可以有多个inex，类似于可以有多个table。</li></ul></li><li><code>RESTful API</code>两种交互方式：<ol><li>CURL命令行：curl -XPUT xxx</li><li>Kibana DevTools————PUT xxx{ }</li></ol></li><li><code>Index API</code>： 用户创建、删除、获取索引配置等。<ol><li>创建索引：<ul><li><code>PUT /test_index</code> #创建一个名为<code>test_index</code>的索引</li></ul></li><li>查看索引：<ul><li><code>GET _cat/indices</code> #查看所有的索引</li></ul></li><li>删除索引：<ul><li><code>DELETE /test_index</code> #删除名为<code>test_index</code>的索引</li></ul></li></ol></li></ol><h4 id="1-7-CRUD操作（交互基于Kibana-DevTools）"><a href="#1-7-CRUD操作（交互基于Kibana-DevTools）" class="headerlink" title="1.7 CRUD操作（交互基于Kibana DevTools）"></a>1.7 CRUD操作（交互基于Kibana DevTools）</h4><ol><li>创建文档</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建ID为1的Document</span></span><br><span class="line">PUT /test_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>:<span class="string">&quot;24&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 不指定ID创建Document(ID会自动生成)</span></span><br><span class="line">POST /test_index/doc</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;username&quot;</span>:<span class="string">&quot;buzhiding&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查询文档：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看名为test_index的索引中id为1的文档</span></span><br><span class="line">GET /test_index/doc/1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 查询所有文档：</span></span><br><span class="line"><span class="comment"># 查询名为test_index的索引中所有文档,用到endpoint：_search，默认返回符合的前10条</span></span><br><span class="line"><span class="comment"># term和match的区别：term完全匹配，不进行分词器分析；match模糊匹配，进行分词器分析，包含即返回</span></span><br><span class="line">GET /test_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>批量操作文档：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 批量创建文档，用到endpoint：_bulk</span></span><br><span class="line"><span class="comment"># index和create的区别，如果文档存在时，使用create会报错，而index会覆盖</span></span><br><span class="line">POST _bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;test_index&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;doc&quot;</span>,<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;3&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;20&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;test_index&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;doc&quot;</span>,<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;update&quot;</span>:&#123;<span class="string">&quot;_id&quot;</span>:<span class="string">&quot;2&quot;</span>,<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;test_index&quot;</span>,<span class="string">&quot;_type&quot;</span>:<span class="string">&quot;doc&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;doc&quot;</span>:&#123;<span class="string">&quot;age&quot;</span>:<span class="string">&quot;30&quot;</span>&#125;&#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 批量查询文档，使用endpoint:_mget</span></span><br><span class="line">GET _mget</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;doc&quot;</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">   <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;doc&quot;</span>,</span><br><span class="line">   <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;_index&quot;</span>:<span class="string">&quot;test_index&quot;</span>,</span><br><span class="line">   <span class="string">&quot;_type&quot;</span>:<span class="string">&quot;doc&quot;</span>,</span><br><span class="line">   <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>删除文档：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据搜索内容删除文档,使用endpoint:_delete_by_query</span></span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;buzhiding&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 删除整个test_index的索引中的文档,依然使用endpoint:_delete_by_query</span></span><br><span class="line">POST /test_index/doc/_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match_all&quot;</span>:&#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-ElasticSearch倒排索引与分词"><a href="#2-ElasticSearch倒排索引与分词" class="headerlink" title="2. ElasticSearch倒排索引与分词"></a>2. ElasticSearch倒排索引与分词</h3><h4 id="2-1-倒排索引"><a href="#2-1-倒排索引" class="headerlink" title="2.1 倒排索引"></a>2.1 倒排索引</h4><ol><li>正排索引和倒排索引<ul><li>正排索引：文档ID —&gt; 文档内容</li><li>倒排索引：单词—&gt; 文档ID列表</li></ul></li><li>倒排索引组成：（单词词典，倒排列表）<ol><li>单词词典（<code>Term Dictionary</code>）<ul><li>记录所有文档的单词，记录了单词到倒排列表的关联信息，一般使用<code>B+Tree</code>实现。</li></ul></li><li>倒排列表（<code>Posting List</code>）<ul><li>记录单词对应的文档集合，由倒排索引项<code>Posting List</code>组成。</li><li>倒排索引项：<ol><li>文档<code>ID</code>：用于获取原始信息。</li><li>词频<code>TF</code>：记录该单词在该文档中的出现次数，用于计算相关性得分。</li><li>位置<code>Position</code>：记录单词在文档中的分词位置(多个)，用于词语搜索。</li><li>偏移<code>Offset</code>：记录单词在文档的开始和结束位置，用于高亮显示。</li></ol></li></ul></li></ol></li></ol><h4 id="2-2-分词Analysis"><a href="#2-2-分词Analysis" class="headerlink" title="2.2 分词Analysis"></a>2.2 分词Analysis</h4><p>分词：将文本转换成一系列单词<code>Term/Token</code>的过程，也可称作文本分析，ES中叫作：Analysis。</p><ul><li>一些概念：<ol><li><code>Token</code>(词元)：全文搜索引擎会用某种算法对要建索引的文档进行分析， 从文档中提取出若干Token(词元)。</li><li><code>Tokenizer</code>(分词器)：这些算法叫做Tokenizer(分词器)</li><li><code>Token Filter</code>(词元处理器)：这些Token会被进一步处理， 比如转成小写等， 这些处理算法被称为TokenFilter(词元处理器)</li><li><code>Term</code>(词)：被处理后的结果被称为Term(词)</li><li><code>Character Filter</code>(字符过滤器)：文本被Tokenizer处理前可能要做一些预处理， 比如去掉里面的HTML标记， 这些处理的算法被称为Character Filter(字符过滤器)</li><li><code>Analyzer</code>(分析器)：这整个的分析算法被称为Analyzer(分析器)，由Tokenizer(分词器)和Filter(过滤器)组成</li></ol></li><li>ES有很多<strong>内置<code>Analyzer</code></strong>,比如：<ol><li><code>standard</code>：按单词边界划分、支持多语言、小写处理、移除大部分标点符号，支持停用词</li><li><code>whitespace</code>：空格为分隔符</li><li><code>simple</code>：按非字母划分、小写处理</li><li><code>stop</code>：类似简单分词器，同时支持移除停用词(the、an、的、这等)</li><li><code>keyword</code>：不分词</li><li><code>pattern</code>：通过正则表达式自定义分隔符，默认\w+，即：非字词的符号作为分隔符</li></ol></li><li>第三方analyzer插件：常用的<strong>中文分词器</strong>有：<ol><li>IK：实现中英文分词，支持多模式，可自定义词库，支持热更新分词词典。</li><li>jieba。python中流行，支持繁体分词、并行分词，可自定义词典、词性标记等。</li></ol></li><li>ES提供了一个测试分词的API接口，使用<code>endpoint：_analyze</code>，不指定分词时，会使用默认的<code>standard</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定分词器进行分词测试</span></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span>,</span><br><span class="line"> <span class="string">&quot;text&quot;</span>:<span class="string">&quot;hello world!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 直接指定索引中字段：使用username字段的分词方式对text进行分词。</span></span><br><span class="line">POST test_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;field&quot;</span>:<span class="string">&quot;username&quot;</span>,</span><br><span class="line"> <span class="string">&quot;text&quot;</span>:<span class="string">&quot;hello world!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 自定义分词器，自定义Tokenizer、filter、等进行分词：</span></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;tokenizer&quot;</span>:<span class="string">&quot;standard&quot;</span>,</span><br><span class="line"> <span class="string">&quot;filter&quot;</span>:[<span class="string">&quot;lowercase&quot;</span>],</span><br><span class="line"> <span class="string">&quot;text&quot;</span>:<span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ElasticSearch的Mapping"><a href="#3-ElasticSearch的Mapping" class="headerlink" title="3. ElasticSearch的Mapping"></a>3. ElasticSearch的Mapping</h3><h4 id="3-1-Mapping简介"><a href="#3-1-Mapping简介" class="headerlink" title="3.1 Mapping简介"></a>3.1 Mapping简介</h4><p>Mapping：类似于数据库中的表结构</p><ol><li>主要作用如下：<ol><li>定义<code>Index</code>下的<code>Field Name</code>；</li><li>定义<code>Field</code>的类型，如：数值型、字符串型、布尔型等；</li><li>定义倒排索引的相关配置，如：是否有索引，记录position等。</li></ol></li><li>获取一个<code>mapping</code>，使用<code>endpoint：_mapping</code>，例如：<ul><li><code>GET /test_index/_mapping</code></li></ul></li></ol><h4 id="3-2-自定义Mapping"><a href="#3-2-自定义Mapping" class="headerlink" title="3.2 自定义Mapping"></a>3.2 自定义Mapping</h4><ol><li>使用<code>mappings</code>进行自定义<code>mapping</code>。</li><li><code>Mapping</code>中的字段类型一旦设定之后，<strong>禁止直接修改</strong>。<ul><li>因为<code>Luence</code>事先的倒排索引生成后不能修改。</li><li>如果一定要改，可以重新建立新的索引，然后对应修改<code>mapping</code>，之后将之前的数据进行<code>reindex</code>操作，导入新的文档。</li></ul></li><li>自定义<code>mapping</code>时允许新增字段。通过<code>dynamic</code>参数进行控制字段的新增，<code>dynamic</code>有三种配置：<ul><li><code>true</code>：默认配置，允许自动新增字段；</li><li><code>false</code>：不允许自动新增字段，文档可以正常写入，但不能进行查询等操作；</li><li><code>strict</code>：严格模式。文档不能写入，写入会报错。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建名为my_index的索引，并自定义mapping</span></span><br><span class="line"><span class="comment"># 使用dynamic参数控制字段的新增</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;        <span class="comment"># 关键字</span></span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;            <span class="comment"># 类型名</span></span><br><span class="line">   <span class="string">&quot;dynamic&quot;</span>:<span class="literal">false</span>,  <span class="comment"># 设置为false，索引不允许新增字段</span></span><br><span class="line">   <span class="string">&quot;properties&quot;</span>:&#123;    <span class="comment"># 字段名称及类型定义</span></span><br><span class="line">    <span class="string">&quot;title&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>   <span class="comment"># 字段类型</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;integer&quot;</span></span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-copy-to的使用"><a href="#3-3-copy-to的使用" class="headerlink" title="3.3 copy_to的使用"></a>3.3 copy_to的使用</h4><p>将该字段的值复制到目标字段，类似于6.0版本之前的<code>_all</code>的作用。且不会出现在<code>_source</code>，一般只用来进行搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy_to的使用</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;first_name&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">     <span class="string">&quot;copy_to&quot;</span>:<span class="string">&quot;full_name&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;last_name&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">     <span class="string">&quot;copy_to&quot;</span>:<span class="string">&quot;full_name&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;full_name&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 向索引写入数据</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;first_name&quot;</span>:<span class="string">&quot;John&quot;</span>,</span><br><span class="line"> <span class="string">&quot;last_name&quot;</span>:<span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查询索引my_index中full_name同时包含John 和 Smith的数据</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;full_name&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:<span class="string">&quot;John Smith&quot;</span>,</span><br><span class="line">    <span class="string">&quot;operator&quot;</span>:<span class="string">&quot;and&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-index参数的使用"><a href="#3-4-index参数的使用" class="headerlink" title="3.4 index参数的使用"></a>3.4 index参数的使用</h4><p>控制当前字段是否为索引，默认<code>true</code>，当设置为<code>false</code>的时候，不进行记录，此时该字段不能被搜索</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index参数的使用</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;cookie&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">     <span class="string">&quot;index&quot;</span>:<span class="literal">false</span>    <span class="comment"># 设置为false，该字段不能被搜索</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在进行数据写入和查询，不能进行该字段搜索。一般用来进行不想被查询的私密信息设置，如身份证号，电话号码等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向使用了index参数的字段写入信息</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;cookie&quot;</span>:<span class="string">&quot;name=alfred&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-index-options参数的使用："><a href="#3-5-index-options参数的使用：" class="headerlink" title="3.5 index_options参数的使用："></a>3.5 index_options参数的使用：</h4><p>控制倒排索引记录的内容，有如下四种配置：</p><ol><li><code>docs</code>：只记录文档ID</li><li><code>freqs</code>：记录文档ID和词频TF</li><li><code>positions</code>：记录文档ID、词频TF和分词位置</li><li><code>offsets</code>：记录文档ID、词频TF、分词位置和偏移<blockquote><p>其中：text类型默认的配置是positions，其他的比如integer等类型默认为docs，目的是为了节省空间。</p></blockquote></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index_options参数的使用</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;cookie&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">     <span class="string">&quot;index_options&quot;</span>:<span class="string">&quot;offsets&quot;</span>  <span class="comment"># 记录文档ID、词频TF、分词位置和偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-null-value参数的使用："><a href="#3-6-null-value参数的使用：" class="headerlink" title="3.6 null_value参数的使用："></a>3.6 null_value参数的使用：</h4><p>当字段遇到空值<code>null</code>时的处理策略。默认为<code>null</code>，即跳过。此时ES会忽略该值，可通过修改进行默认值的修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用null_value修改ES遇到null值时的默认返回值</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;properties&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;cookie&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">     <span class="string">&quot;null_value&quot;</span>:<span class="string">&quot;NULL&quot;</span>    <span class="comment"># 当遇到空值null的时候，返回一个字符串形式的NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-Field字段的数据类型："><a href="#3-7-Field字段的数据类型：" class="headerlink" title="3.7 Field字段的数据类型："></a>3.7 Field字段的数据类型：</h4><ol><li>核心数据类型<ol><li>字符串型：<code>text</code>(分词)，<code>keyword</code>(不分词)</li><li>数值型：<code>long,integer,short,byte,double,float,half_float,scaled_float</code></li><li>日期类型：<code>date</code></li><li>布尔类型：<code>boolean</code></li><li>二进制类型：binary</li><li>范围类型：<code>integer_range,float_range,long_range,double_range,date_range</code></li></ol></li><li>复杂数据类型<ol><li>数组类型：<code>array</code></li><li>对象类型：<code>object</code></li><li>嵌套类型：<code>nested object</code></li></ol></li><li>地理位置数据类型<ol><li>点：<code>geo-point</code></li><li>形状：<code>geo-shape</code></li></ol></li><li>专用类型<ol><li>记录ip地址：<code>ip</code></li><li>实现自动补全：<code>completion</code></li><li>记录分词数：<code>token_count</code></li><li>记录字符串hash值：<code>murmur3</code></li><li><code>perclator</code></li><li><code>join</code></li></ol></li><li>多字段特性：<ul><li>ES允许对同一个字段采用不同的配置，如：分词。举例：对一个人名实现拼音搜索，只需要在人名字段中新增一个子字段pinyin即可。</li></ul></li></ol><h4 id="3-8-ES的自动类型识别："><a href="#3-8-ES的自动类型识别：" class="headerlink" title="3.8 ES的自动类型识别："></a>3.8 ES的自动类型识别：</h4><ol><li>Dynamic Mapping：<ul><li>ES可以自动识别文档字段类型，从而降低用户使用成本。</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES的自动类型识别</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span>,    <span class="comment"># username字段自动识别为text类型</span></span><br><span class="line"> <span class="string">&quot;age&quot;</span>:20                <span class="comment"># age字段自动识别为long类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>ES依靠JSON文档的字段类型实现自动识别字段类型：</li></ol><table><thead><tr><th>JSON类型</th><th>ElasticSearch类型</th></tr></thead><tbody><tr><td>null</td><td>忽略</td></tr><tr><td>boolean</td><td>boolean</td></tr><tr><td>浮点类型</td><td>float</td></tr><tr><td>整数类型</td><td>long</td></tr><tr><td>object</td><td>object</td></tr><tr><td>array</td><td>由第一个非null的值的类型决定</td></tr><tr><td>String</td><td>匹配为日期，则为date类型(默认开启)<br>匹配为数字，则为long类型&#x2F;float类型(默认关闭)<br>都未匹配，则设为text类型，并附带keyword子字段</td></tr></tbody></table><ol start="3"><li>验证ES的字段类型自动识别：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 验证ES的字段类型自动识别</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span>,    <span class="comment"># 字符串类型text</span></span><br><span class="line"> <span class="string">&quot;age&quot;</span>:20,               <span class="comment"># 整数long</span></span><br><span class="line"> <span class="string">&quot;bitrh&quot;</span>:<span class="string">&quot;1998-10-10&quot;</span>,   <span class="comment"># 默认识别日期date</span></span><br><span class="line"> <span class="string">&quot;married&quot;</span>:<span class="literal">false</span>,        <span class="comment"># 布尔类型boolean</span></span><br><span class="line"> <span class="string">&quot;year&quot;</span>:<span class="string">&quot;18&quot;</span>             <span class="comment"># 默认不识别数字text</span></span><br><span class="line"> <span class="string">&quot;tags&quot;</span>:[<span class="string">&quot;boy&quot;</span>,<span class="string">&quot;fashion&quot;</span>],<span class="comment"># 数组中第一个不为null的元素为字符串类型，所以为text</span></span><br><span class="line"> <span class="string">&quot;money&quot;</span>:100.1           <span class="comment"># 浮点类型float</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#  再对my_index进行mapping查询，就会获得每个字段的类型：</span></span><br></pre></td></tr></table></figure><h4 id="3-9-ES中日期类型和数字的自动识别："><a href="#3-9-ES中日期类型和数字的自动识别：" class="headerlink" title="3.9 ES中日期类型和数字的自动识别："></a>3.9 ES中日期类型和数字的自动识别：</h4><p>ES中可自行配置日期的格式，默认：[“<code>strict_date_optional_time</code>“,”<code>yyyy/MM/dd HH:mm:ss Z</code>|| <code>yyyy/MM/dd z</code>“]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用dynamic_date_formats自定义日期格式</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;dynamic_date_formats&quot;</span>:[<span class="string">&quot;MM/dd/yyyy&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 写入符合自定义格式的日期数据，可识别为date类型</span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;create_time&quot;</span>:<span class="string">&quot;01/01/2019&quot;</span>    <span class="comment"># create_time字段识别为date类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  2. 使用date_detection可以关闭自动识别日期格式：</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;date_detection&quot;</span>:<span class="literal">false</span> </span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">PUT my_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;create_time&quot;</span>:<span class="string">&quot;01/01/2019&quot;</span>    <span class="comment"># create_time字段是text类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># ES中可配置数字是否识别，默认关闭：</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;numeric_detection&quot;</span>:<span class="literal">true</span>    <span class="comment"># 开启数字自动识别</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 写入数字数据，ES可以自动识别其类型</span></span><br><span class="line">PUT mu_index/doc/1</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;year&quot;</span>:<span class="string">&quot;18&quot;</span>,    <span class="comment"># year字段自动识别为long类型</span></span><br><span class="line"> <span class="string">&quot;money&quot;</span>:<span class="string">&quot;100.1&quot;</span>    <span class="comment"># money字段自动识别为float类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-ES中根据自动识别的数据类型，动态生成字符类型"><a href="#3-10-ES中根据自动识别的数据类型，动态生成字符类型" class="headerlink" title="3.10 ES中根据自动识别的数据类型，动态生成字符类型"></a>3.10 ES中根据自动识别的数据类型，动态生成字符类型</h4><p>例: </p><ol><li>字符串类型都设为keyword类型（不分词）</li><li>以message开头的字段都设为text类型（分词）</li><li>以long_开头的字段都设为long类型</li><li>自动匹配为double的类型都设为float类型。（为了节省空间）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES根据自动识别的数据类型、字段名等动态设定字符类型</span></span><br><span class="line">PUT test_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;mappings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;dynamic_template&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;strings&quot;</span>:&#123;</span><br><span class="line">      <span class="comment"># 匹配到所有的字符串类型，全部设为keyword类型</span></span><br><span class="line">      <span class="string">&quot;match_mapping_type&quot;</span>:<span class="string">&quot;string&quot;</span>,</span><br><span class="line">      <span class="string">&quot;mapping&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;type&quot;</span>:<span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匹配规则</strong>的参数：</p><ol><li><code>match_mapping_type</code>：匹配ES自动识别的字段类型，如boolean、long、string等</li><li><code>match</code>、<code>unmatch</code>：匹配字段名，比如”match”:”message*” &#x3D;&#x3D;&#x3D;&gt;以message开头的数据</li><li><code>path_match</code>、<code>path_unmatch</code>：匹配路径</li></ol><h4 id="3-11-自定义mapping的操作步骤"><a href="#3-11-自定义mapping的操作步骤" class="headerlink" title="3.11 自定义mapping的操作步骤"></a>3.11 自定义mapping的操作步骤</h4><ol><li>写入一条文档到ES的临时索引中，获取(复制)ES自动生成的mapping</li><li>修改获得的mapping，并在其中自定义相关配置</li><li>使用修改后的mapping创建实际所需索引。</li></ol><h3 id="4-ElasticSearch的Search-API"><a href="#4-ElasticSearch的Search-API" class="headerlink" title="4. ElasticSearch的Search API"></a>4. ElasticSearch的Search API</h3><p>在ES中，为了实现对存储的数据进行查询分析，使用<code>endpoint</code>：**<code>_search</code>**。</p><ol><li>实现对所有索引的泛查询：<code>GET /_search</code></li><li>实现对一个索引的单独查询：<code>GET /my_index/_search</code></li><li>实现对多个索引的指定查询：<code>GET /my_index1,my_index2/_search</code></li><li>实现对符合指定要求的索引进行查询：<code>GET /my_*/_search</code></li></ol><p>在进行查询的时候，主要有两种方式：(<code>URI Search</code>，<code>Request Body Search</code>)</p><ol><li>**<code>URI Search</code>**：操作简单，直接通过命令行方便测试，但仅包含部分查询语法；<ul><li>如：<code>GET /my_index/_search?q=username:alfred</code></li></ul></li><li>**<code>Request Body Search</code>**：ES提供的完备查询语法，使用<code>Query DSL(Domain Specific Language)</code>进行查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如：Request Body Search方式进行查询</span></span><br><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-URI-Search"><a href="#4-1-URI-Search" class="headerlink" title="4.1 URI Search"></a>4.1 URI Search</h4><ol><li>通过<code>url query</code>参数实现搜索，常用参数有：<ol><li>**<code>q</code>**：指定查询的语句，使用query string syntax语法</li><li>**<code>df</code>**：q中不指定字段时默认查询的字段（在不指定的时候默认查询所有字段）</li><li>**<code>sort</code>**：排序</li><li>**<code>timeout</code>**：指定超时时间，默认不超时 </li><li>**<code>from,size</code>**：用于分页</li></ol><ul><li>举例：<ul><li><code>GET my_index/_search?q=alfred&amp;df=username&amp;sort=age:asc&amp;from=4&amp;size=10&amp;timeout=1s</code></li><li>解释：查询索引<code>my_index</code>中<code>username</code>字段中包含<code>alfred</code>的文档，结果按<code>age</code>字段<code>升序排列</code>，返回第<code>5-14</code>个文档，若超过<code>1s</code>未结束，则以超时结束。</li></ul></li></ul></li><li><code>query string syntax</code>语法<ul><li>前置内容：<code>term:单词</code>，<code>phrase:词语</code>。</li><li>单词与词语语法：<ul><li>单词：<code>alfred way</code>等价于<code>alfred</code> OR <code>way</code></li><li>词语：<code>&quot;alfred way&quot;</code>语句查询，要求先后顺序</li><li>泛查询：不指定字段，会在所有字段中去匹配其单词</li><li>指定字段查询：指定字段，在指定字段中匹配单词</li></ul></li><li>Group分组设定，使用括号指定匹配的规则<ul><li>举例：<code>GET my_index/_search?q=username:(alfred OR way)AND lee</code></li></ul></li></ul></li></ol><h5 id="4-1-1-URI-Search-API"><a href="#4-1-1-URI-Search-API" class="headerlink" title="4.1.1 URI Search API"></a>4.1.1 URI Search API</h5><ol><li>泛查询：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search?q=alfred</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;profile&quot;</span>:<span class="literal">true</span> <span class="comment">#使用profile参数，可以明确地看到ES如何执行的查询条件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>指定字段查询：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.查询字段username中包含alfred的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># b.查询字段username中包含alfred或way的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred way</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># c.查询字段username为&quot;alfred way&quot;的文档</span></span><br><span class="line">GET my_index/_search?q=username:<span class="string">&quot;alfred way&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># d.分组后，查询字段username中包含alfred，包含way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(alfred way)</span><br><span class="line"><span class="comment"># 这个和b的结果一样，但是区别在于使用分组之后，不进行泛查询。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>布尔操作符AND(&amp;&amp;)、OR(||)、NOT(!)、+(must)、-(must_not)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询索引my_index中username包含alfred但是不包含way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(alfred NOT way)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 查询索引my_index中一定包含lee，一定不含alfred，可能有way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(way +lee -alfred)</span><br><span class="line"><span class="comment"># 或写成</span></span><br><span class="line">GET my_index/_search?q=username:((lee &amp;&amp; !alfred) || (way &amp;&amp; lee &amp;&amp; !alfred))</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 注意：url中，+(加号)会被解析成空格，所以要用 %2B ：</span></span><br><span class="line"><span class="comment"># 查询索引my_index中一定包含lee，一定不包含alfred，可能包含way的文档</span></span><br><span class="line">GET my_index/_search?q=username:(way %2Blee -alfred)</span><br></pre></td></tr></table></figure><ol start="4"><li>范围查询（支持数值和日期）<ul><li>区间写法：闭区间使用<code>[]</code>，开区间使用<code>&#123;&#125;</code><ol><li><code>age:[1 TO 10]</code>  # 1&lt;&#x3D; age &lt;&#x3D;10</li><li><code>age:[1 TO 10&#125;</code>  # 1&lt;&#x3D; age &lt;10</li><li><code>age:[1 TO ]</code>    # age &gt;&#x3D;1</li><li><code>age:[* TO 10]</code>  # age &lt;&#x3D;10</li></ol></li><li>算数符号写法：<ol><li><code>age:&gt;=1 </code></li><li><code>age:(&gt;=1 &amp;&amp; &lt;= 10) / age:(+ &gt;= 1 + &lt;= 10)</code></li></ol></li><li>还可以对日期进行范围查询，注意：年&#x2F;月是从1月1号&#x2F;1号开始算的：</li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a.查询索引my_index中username字段包含alfred_或_年龄大于20的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred age&gt;20</span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># b.查询索引my_index中username字段包含alfred_且_年龄大于20的文档</span></span><br><span class="line">GET my_index/_search?q=username:alfred AND age&gt;20</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 查询索引my_index中birth字段在1985和1990之间的文档</span></span><br><span class="line">GET my_index/_search?q=birth:(&gt;1985 AND &lt; 1990)</span><br></pre></td></tr></table></figure><ol start="5"><li><p>通配符查询</p><ul><li><code>?</code>代表一个字符，<code>*</code>代表0个或多个字符，如：<code>name:a?lfred</code>或<code>name:a*d</code>或<code>name:alfred*</code></li><li>注意：通配符匹配的执行效率较低，且占用内存较多，不建议使用，如果没有特殊要求，也不要将?或者*放在最前面，因为意味着要匹配所有文档，可能会造成OOM。</li></ul></li><li><p>正则表达式&#x2F;模糊匹配&#x2F;近似度查询</p><ul><li>正则表达式：举例：<code>/[a]?l.*/</code></li><li>模糊匹配：<code>fuzzy query</code></li><li>近似度查询：<code>proximity search</code></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模糊匹配。匹配与alfred差一个字符的词，比如：alfreds、alfret等</span></span><br><span class="line">GET my_index/_search?q=username:alfred~1</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 近似度查询，查询字段username和&quot;alfred way&quot;差n个单词的文档</span></span><br><span class="line">GET my_index/_search?q=username:<span class="string">&quot;alfred way&quot;</span> ~5</span><br></pre></td></tr></table></figure><blockquote><p>使用场景常见于用户输入词的纠错中。</p></blockquote><h4 id="4-2-Request-Body-Search"><a href="#4-2-Request-Body-Search" class="headerlink" title="4.2 Request Body Search"></a>4.2 Request Body Search</h4><p>ES自带的完备查询语句，将查询语句通过<code>http request body</code>发送到ES，主要参数有：</p><ol><li><code>query</code>：符合<code>Query DSL</code>语法的查询条件</li><li><code>from，size</code></li><li><code>timeout</code></li><li><code>sort</code></li></ol><ul><li><code>Query DSL</code>语法：<ul><li>基于<code>JSON</code>定义的查询语言，主要包含两个类型：<ol><li>字段类查询————如：<code>term</code>，<code>match</code>，<code>range</code>等。只针对一个字段进行查询</li><li>复合查询————如：<code>bool</code>查询等。包含一个&#x2F;多个字段类查询&#x2F;符合查询语句</li></ol></li></ul></li></ul><h5 id="4-2-1-字段类查询-全文匹配"><a href="#4-2-1-字段类查询-全文匹配" class="headerlink" title="4.2.1 字段类查询-全文匹配"></a>4.2.1 字段类查询-全文匹配</h5><p>针对<code>text</code>类型的字段进行全文检索，会对查询语句进行“先分词再查询”处理，如：<code>match</code>、<code>match_phrase</code>等</p><h6 id="4-2-1-1-match-query"><a href="#4-2-1-1-match-query" class="headerlink" title="4.2.1.1 match query"></a>4.2.1.1 match query</h6><ol><li>对字段进行全文检索(最基本和最常用的查询类型)，举例：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;query&quot;</span>:&#123;  </span><br><span class="line">   <span class="string">&quot;match&quot;</span>:&#123;                 <span class="comment"># 关键词</span></span><br><span class="line">    <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred way&quot;</span>  <span class="comment"># 字段名和查询语句</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从结果，可以返回匹配文件总数，返回文档列表，_score相关性得分等。<br>一般的执行流程为： 1.对查询语句分词&#x3D;&#x3D;&gt;2.根据字段的倒排索引列表，进行匹配算分&#x3D;&#x3D;&gt;3.汇总得分&#x3D;&#x3D;&gt;4.根据得分排序，返回匹配文档</p></blockquote><ol start="2"><li>使用<code>operator</code>参数，可以控制单词间关系，有<code>and/or</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用operator参数控制单词间关系</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred way&quot;</span>,</span><br><span class="line">   <span class="string">&quot;operator&quot;</span>:<span class="string">&quot;and&quot;</span>    <span class="comment"># and，同时包含alfred和way</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用<code>minimum_should_match</code>参数控制需匹配的单词数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用minimum_should_match参数控制需匹配的单词数</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred way&quot;</span>,</span><br><span class="line">   <span class="string">&quot;minimum_should_match&quot;</span>:<span class="string">&quot;2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-1-2-相关性算分，其本质就是一个排序问题"><a href="#4-2-1-2-相关性算分，其本质就是一个排序问题" class="headerlink" title="4.2.1.2 相关性算分，其本质就是一个排序问题"></a>4.2.1.2 相关性算分，其本质就是一个排序问题</h6><ul><li>计算文档与待查询语句之间的相关度，一般有四个重要概念：<ol><li><code>Term Frequency</code> 词频(正相关)</li><li><code>Document Frequency</code> 文档频率(负相关)</li><li><code>Inverse Term Frequency</code> 逆文本频率(正相关)</li><li><code>Field-length Norm</code> 文档长度(负相关)</li></ol></li><li>目前ES有两个相关性算分的模型：<ol><li><code>TF/IDF</code>模型：经典模型。</li><li><code>BM25</code>模型：5.x版本后的默认模型，是对TF&#x2F;IDF的优化模型。</li></ol></li></ul><ol><li><code>TF/IDF</code>模型：在使用kibana进行查询时，使用explain参数，可以查看具体的计算方法。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用explain参数，可以查看具体的相关性的得分是如何计算的</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;explain&quot;</span>:<span class="literal">true</span>,    <span class="comment"># 设置为true</span></span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：ES计算相关性得分是根据<code>shard</code>进行的，即分片的分数计算相互独立，所以在使用的时候要注意分片数，可以通过设定分片数为1来避免这个问题，主要是为了观察，不代表之后所有的分片全都设为1。一般放在创建索引后，未加数据之前。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定shards数量为1</span></span><br><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;settings&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;number_of_shards&quot;</span>:<span class="string">&quot;1&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>BM25模型。5.x版本后的默认模型，是对TF&#x2F;IDF的优化模型。<ul><li><code>best match，25</code>指：迭代了25次才计算。BM25的使用，降低了TF&#x2F;IDF中因为TF过大导致的负面影响，在BM25中，一个单词的TF一直增长，到一定程度就趋于0变化。</li></ul></li></ol><h6 id="4-2-1-3-match-phrase-query"><a href="#4-2-1-3-match-phrase-query" class="headerlink" title="4.2.1.3 match phrase query"></a>4.2.1.3 match phrase query</h6><p>对字段做全文检索，有顺序要求。</p><ol><li>使用<code>match——phrase</code>查询词语</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match_phrase&quot;</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">   <span class="string">&quot;job&quot;</span>:<span class="string">&quot;java engineer&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过使用<code>slop</code>参数，可以控制单词间间隔：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match_phrase&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;job&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;query&quot;</span>:<span class="string">&quot;java engineer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;slop&quot;</span>:<span class="string">&quot;1&quot;</span>    <span class="comment"># 关键词，设定单词间隔</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-1-4-query-string-query"><a href="#4-2-1-4-query-string-query" class="headerlink" title="4.2.1.4 query string query"></a>4.2.1.4 query string query</h6><p>类似于<code>URI Search</code>中的q参数查询，举例：</p><ol><li>使用<code>query_string</code>查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;query_string&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;default_field&quot;</span>:<span class="string">&quot;username&quot;</span>,</span><br><span class="line">   <span class="string">&quot;query&quot;</span>:&#123;alfred AND way<span class="string">&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">#* 或 */</span></span><br><span class="line"><span class="string">GET my_index/_search</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"> &quot;</span>query<span class="string">&quot;:&#123;</span></span><br><span class="line"><span class="string">  &quot;</span>query_string<span class="string">&quot;:&#123;</span></span><br><span class="line"><span class="string">   &quot;</span>fileds<span class="string">&quot;:[&quot;</span>username<span class="string">&quot;,&quot;</span>job<span class="string">&quot;],</span></span><br><span class="line"><span class="string">   &quot;</span>query<span class="string">&quot;:&quot;</span>alfred OR (java AND ruby)<span class="string">&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h6 id="4-2-1-5-simple-query-string-query"><a href="#4-2-1-5-simple-query-string-query" class="headerlink" title="4.2.1.5 simple query string query"></a>4.2.1.5 simple query string query</h6><p>类似于<code>query string</code>，但会忽略错误的查询语法，且仅支持部分查询语句。使用<code>+，|，-</code>分别代替<code>AND，OR，NOT</code>。</p><ol><li>使用simple query string query<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;simple_query_string&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;fields&quot;</span>:[username],</span><br><span class="line">   <span class="string">&quot;query&quot;</span>:<span class="string">&quot;alfred +way&quot;</span>    <span class="comment">#等价于 &quot;query&quot;:&quot;alfred AND way&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-2-2-字段类查询-单词匹配"><a href="#4-2-2-字段类查询-单词匹配" class="headerlink" title="4.2.2 字段类查询-单词匹配"></a>4.2.2 字段类查询-单词匹配</h5><h6 id="4-2-2-1-term-x2F-terms-query"><a href="#4-2-2-1-term-x2F-terms-query" class="headerlink" title="4.2.2.1 term&#x2F;terms query"></a>4.2.2.1 term&#x2F;terms query</h6><p>将待查询语句作为整个单词进行查询，不做分词处理，举例：</p><ol><li>使用term进行单查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用terms进行多查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;terms&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:[<span class="string">&quot;alfred&quot;</span>,<span class="string">&quot;way&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此时如果直接使用<code>alfred way</code>作为<code>username</code>查询条件，是不会返回任何文档的。因为在<code>username</code>的倒排索引列表中，存在<code>&quot;alfred&quot;</code>和<code>&quot;way&quot;</code>的索引，但是不存在<code>&quot;alfred way&quot;</code>的索引。</p></blockquote><h6 id="4-2-2-2-range-query"><a href="#4-2-2-2-range-query" class="headerlink" title="4.2.2.2 range query"></a>4.2.2.2 range query</h6><ul><li>范围查询，主要针对数值类型和日期类型。<ul><li><strong><code>gt</code></strong>: greater than 大于</li><li><strong><code>gte</code></strong>: greate than or equal to 大于等于</li><li><strong><code>lt</code></strong>: less than 小于</li><li><strong><code>lte</code></strong>: less than or equal to 小于等于</li></ul></li></ul><ol><li>对数值的查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range query对数值的查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;age&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;gte&quot;</span>:10,</span><br><span class="line">    <span class="string">&quot;lte&quot;</span>:20</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>对日期的查询</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range query对日期的查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;birth&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;lte&quot;</span>:<span class="string">&quot;1988-01-01&quot;</span> </span><br><span class="line">    <span class="comment"># 或者使用&quot;lte&quot;:&quot;now-30y&quot;,这种Date Math类型</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>Date Math</code>类型</strong>：针对日期提供的一种更友好的计算方式。<br>当前时间用<code>now</code>代替，具体时间的引用，需要使用<code>||</code>间隔。年、月、日、时、分、秒跟<code>date</code>一致：<code>y、M、w、d、h、m、s</code>。<br>举例：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设当前时间为2019-01-02 12:00:00</span></span><br><span class="line">now+1h   =&gt;   2019-01-02 13:00:00</span><br><span class="line">now-1h   =&gt;   2019-01-02 11:00:00</span><br><span class="line">now-1h/d =&gt;   2019-01-02 00:00:00</span><br><span class="line">2019-01-01||+1M/d  =&gt; 2019-02-01 00:00:00</span><br></pre></td></tr></table></figure><h5 id="4-2-3-复合查询"><a href="#4-2-3-复合查询" class="headerlink" title="4.2.3 复合查询"></a>4.2.3 复合查询</h5><p>包含一个&#x2F;多个字段类查询&#x2F;符合查询语句</p><h6 id="4-2-3-1-constant-score-query"><a href="#4-2-3-1-constant-score-query" class="headerlink" title="4.2.3.1 constant_score query"></a>4.2.3.1 constant_score query</h6><ol><li><code>constant_score query</code>: 将内部的查询结果文档得分全部设定为1或boost的值。返回的相关性得分全部为1或boost</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用constant_score query</span></span><br><span class="line">GET my_index/_Search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;constant_score&quot;</span>:&#123;    <span class="comment">#关键词</span></span><br><span class="line">   <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-2-bool-query"><a href="#4-2-3-2-bool-query" class="headerlink" title="4.2.3.2 bool query"></a>4.2.3.2 bool query</h6><p><code>bool query</code>: 由一个&#x2F;多个布尔子句组成，主要包含以下四个：</p><ol><li><code>filter</code>: 只过滤符合条件的文档，不计算相关性得分，返回的相关性得分全部为0；<ul><li><code>ES</code>会对<code>filter</code>进行智能缓存，因此执行效率较高，在做简单匹配查询且不考虑得分的时候没推荐使用<code>filter</code>代替<code>query</code></li></ul></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用filter查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>:&#123;    <span class="comment"># 关键词</span></span><br><span class="line">   <span class="string">&quot;filter&quot;</span>:[</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>must</code>: 文档必须符合<code>must</code>中的所有条件，影响相关性得分；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用must进行查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;must&quot;</span>:[    </span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;job&quot;</span>:<span class="string">&quot;specialist&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>must_not</code>: 文档必须排除must_not中的所有条件；</li></ol><p> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用must_not进行查询</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;must&quot;</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;job&quot;</span>:<span class="string">&quot;java&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;must_not&quot;</span>:[</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;job&quot;</span>:<span class="string">&quot;ruby&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>should</code>: 文档可以符合<code>should</code>中的条件，影响相关性得分，分为两种情况：同时配合<code>minimum_should_match</code>控制满足调价你的个数&#x2F;百分比。<ol><li><code>bool</code>查询中只有<code>should</code>，不包含<code>must</code>的情况</li><li>bool查询中既有should，又包含must的情况，文档不必满足should中的条件，但是如果满足的话则会增加相关性得分。</li></ol></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bool查询中只有should的情况</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;should&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;job&quot;</span>:<span class="string">&quot;java&quot;</span>&#125;    <span class="comment"># 条件1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;job&quot;</span>:<span class="string">&quot;ruby&quot;</span>&#125;    <span class="comment"># 条件3</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;job&quot;</span>:<span class="string">&quot;specialist&quot;</span>&#125;    <span class="comment"># 条件3</span></span><br><span class="line">    &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;minimum_should_match&quot;</span>:2    <span class="comment"># 至少需要满足两个条件</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># bool查询中同时包含should和must</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;should&quot;</span>:[    <span class="comment"># 同时包含should</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;job&quot;</span>:<span class="string">&quot;ruby&quot;</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;must&quot;</span>:[    <span class="comment"># 同时包含must</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;usernmae&quot;</span>:<span class="string">&quot;alfred&quot;</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当一个查询语句位于query或filter上下文的时候，ES的执行结果也不同。</p></blockquote><table><thead><tr><th>-</th><th>-</th><th>-</th></tr></thead><tbody><tr><td>query</td><td>查找和查询语句最匹配的文档，<br>并对所有文档计算相关性得分</td><td>query<br>bool中的：must&#x2F;should</td></tr><tr><td>filter</td><td>查找和查询语句最匹配的文档</td><td>bool中的：filter&#x2F;must_not<br>constant_score中的：filter</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># query和filter上下文</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;bool&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;must&quot;</span>:[    <span class="comment"># query上下文</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;title&quot;</span>:<span class="string">&quot;Search&quot;</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;content&quot;</span>:<span class="string">&quot;ElasticSearch&quot;</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="string">&quot;filter&quot;</span>:[    <span class="comment"># filter上下文</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;term&quot;</span>:&#123;<span class="string">&quot;status&quot;</span>:<span class="string">&quot;published&quot;</span>&#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">&quot;range&quot;</span>:&#123;</span><br><span class="line">     <span class="string">&quot;publish_date&quot;</span>:&#123;</span><br><span class="line">      <span class="string">&quot;gte&quot;</span>:<span class="string">&quot;2015-01-01&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-3-count-API"><a href="#4-2-3-3-count-API" class="headerlink" title="4.2.3.3 count API"></a>4.2.3.3 count API</h6><p><code>count API</code>: 获取符合条件的文档书，使用<code>endpoint：_count</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用_count获取符合条件的文档数</span></span><br><span class="line">GET my_index/_count    <span class="comment"># 关键词</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;query&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;match&quot;</span>:&#123;</span><br><span class="line">   <span class="string">&quot;username&quot;</span>:<span class="string">&quot;alfred&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-2-3-4-Source-Filtering"><a href="#4-2-3-4-Source-Filtering" class="headerlink" title="4.2.3.4 Source Filtering"></a>4.2.3.4 Source Filtering</h6><p><code>Source Filtering</code>: 过滤返回结果中的<code>_source</code>中的字段，主要由以下两种方式：</p><ol><li>GET my_index&#x2F;_search?_source&#x3D;username #url参数</li><li>使用Request Body Search：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不返回_source</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;_source&quot;</span>:<span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 返回_source部分字段</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;_source&quot;</span>:[<span class="string">&quot;username&quot;</span>,<span class="string">&quot;age&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 通配符匹配返回_source部分字段</span></span><br><span class="line">GET my_index/_search</span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;_source&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;includes&quot;</span>:<span class="string">&quot;*I*&quot;</span>,</span><br><span class="line">  <span class="string">&quot;encludes&quot;</span>:<span class="string">&quot;birth&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ElasticStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> Kibana </tag>
            
            <tag> ElasticStack </tag>
            
            <tag> LogStash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据库」MongoDB学习笔记</title>
      <link href="/2018/10/17/database-mongodb.html"/>
      <url>/2018/10/17/database-mongodb.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>在mongodb官网下载对应自己电脑系统的安装包，地址为： <a href="http://www.mongodb.org/downloads">http://www.mongodb.org/downloads</a>。</p><span id="more"></span> <p>1、以Windows64bit为例，下载.msi文件双击安装。<br>2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\MongoDB\bin)。<br>3、创建数据目录(D:\MongoDB\data\db),MongoDB默认数据目录\data\db。<br>4、连接数据库(命令行win+r cmd,到D:\MongoDB\bin目录下，执行代码：mongod –dbpath D:\MongoDB\data\db)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line"><span class="built_in">cd</span> D:\MongoDB\bin</span><br><span class="line">mongod --dbpath D:\MongoDB\data\db</span><br></pre></td></tr></table></figure><p>5、启动 MongoDB JavaScript 工具(D:\MongoDB\bin目录下,打开mongo,会看到：)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MongoDB shell version: 3.2.4  //mongodb版本</span><br><span class="line">connecting to: <span class="built_in">test</span>  //默认shell连接的是本机localhost 上面的<span class="built_in">test</span>库</span><br></pre></td></tr></table></figure><p>此时就可以操作数据库了。</p><h3 id="2-将MongoDB服务器作为Windows服务运行"><a href="#2-将MongoDB服务器作为Windows服务运行" class="headerlink" title="2. 将MongoDB服务器作为Windows服务运行"></a>2. 将MongoDB服务器作为Windows服务运行</h3><p>1、在D:\MongoDB目录下创建mongodb.config,写入如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 数据库文件目录</span></span><br><span class="line">dbpath=D:/MongoDB/data</span><br><span class="line"><span class="comment">## 日志目录</span></span><br><span class="line">logpath=D:/MongoDB/log/mongo.log</span><br><span class="line">diaglog=3</span><br></pre></td></tr></table></figure><p>2、常规命令(cmd管理员):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:\MongoDB\bin</span><br><span class="line">mongod --config D:\MongoDB\mongodb.config </span><br></pre></td></tr></table></figure><p>3、若常规方式失败，则sc方式(cmd管理员)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:</span><br><span class="line">cd D:\MongoDB\bin</span><br><span class="line">sc create mongodb binPath= &quot;D:\MongoDB\bin\mongod.exe --service --config=D:\mongoDB\mongodb.config&quot; </span><br></pre></td></tr></table></figure><p>访问地址：localhost:27017测试是否启动成功</p><h3 id="3-CRUD操作-Creat-Read-Update-Delete"><a href="#3-CRUD操作-Creat-Read-Update-Delete" class="headerlink" title="3. CRUD操作(Creat,Read,Update,Delete)"></a>3. CRUD操作(Creat,Read,Update,Delete)</h3><h4 id="3-1-MongoDB基础"><a href="#3-1-MongoDB基础" class="headerlink" title="3.1 MongoDB基础"></a>3.1 MongoDB基础</h4><p>1、document(文档)</p><p>MongoDB把所有数据存放在类似于JSON数据结构的文档内：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pencil&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;qty&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;no.2&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、collection(集合)</p><p>集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pencil&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;qty&quot;</span><span class="punctuation">:</span> <span class="number">500</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;no.1&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pencil2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;qty&quot;</span><span class="punctuation">:</span> <span class="number">550</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;no.2&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;item&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pencil3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;qty&quot;</span><span class="punctuation">:</span> <span class="number">800</span><span class="punctuation">,</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;no.3&quot;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3、database(数据库)</p><p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。</p><h4 id="3-2-数据库操作："><a href="#3-2-数据库操作：" class="headerlink" title="3.2 数据库操作："></a>3.2 数据库操作：</h4><p>连接及运行mongoDB<br>“<code>show dbs</code>“命令可以显示所有的数据的列表<br>“<code>db</code>“命令可以显示当前数据库对象或集合<br>“<code>use</code>“命令可以连接到一个指定的数据库<br>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。<br>  1.不能是空字符串（””)。<br>  2.不得含有’ ‘（空格)、.、$、&#x2F;、\和\0 (空宇符)。<br>  3.应全部小写。<br>  4.最多64字节。</p><p>1、创建数据库：<code>use Database_Name</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use <span class="built_in">test</span>  <span class="comment">##创建名为test的数据库</span></span><br></pre></td></tr></table></figure><p>2、删除当前数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure><h4 id="3-3-文档操作（以-Collection-Name-x3D-col-为例）"><a href="#3-3-文档操作（以-Collection-Name-x3D-col-为例）" class="headerlink" title="3.3 文档操作（以 Collection_Name &#x3D; col 为例）"></a>3.3 文档操作（以 Collection_Name &#x3D; col 为例）</h4><h5 id="3-3-1插入："><a href="#3-3-1插入：" class="headerlink" title="3.3.1插入："></a>3.3.1插入：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.col.insert(Document)     <span class="comment">##插入一条或多组数据</span></span><br><span class="line">db.col.insertOne(Document)  <span class="comment">##插入一条数据</span></span><br><span class="line">db.col.insertMany(Document) <span class="comment">##插入多条数据</span></span><br><span class="line"><span class="comment">##例如：</span></span><br><span class="line">    db.col.insertOne(&#123; <span class="string">&quot;item&quot;</span>: <span class="string">&quot;pencil&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;no.1&quot;</span> &#125;)</span><br><span class="line">    db.col.insertMany([</span><br><span class="line">    &#123; <span class="string">&quot;item&quot;</span>: <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;no.2&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;item&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;no.3&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;item&quot;</span>: <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;type&quot;</span>: <span class="string">&quot;no.4&quot;</span> &#125;</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h5 id="3-3-2-删除："><a href="#3-3-2-删除：" class="headerlink" title="3.3.2 删除："></a>3.3.2 删除：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.col.remove(&#123;&#125;)                    <span class="comment">##删除所有数据</span></span><br><span class="line">db.col.remove(query &lt;,options&gt;)</span><br><span class="line">    <span class="comment">#  query: 查询条件(数据索引或名字)</span></span><br><span class="line">    <span class="comment">#  ptions:两个可选参数</span></span><br><span class="line">    <span class="comment">#      &#123;justOne: &lt;boolean&gt;,     //默认false，删除所有匹配到的。</span></span><br><span class="line">    <span class="comment">#       writeConcern: &lt;document&gt;//抛出异常的级别。</span></span><br><span class="line">    <span class="comment">#      &#125;</span></span><br><span class="line">db.col.deleteOne(query &lt;,options&gt;)   <span class="comment">##同上，无justOne参数，只删除第一条</span></span><br><span class="line">db.col.deleteMany(query &lt;,options&gt;)  <span class="comment">##同上，无justOne参数，只删除多条</span></span><br></pre></td></tr></table></figure><h5 id="3-3-3-更新："><a href="#3-3-3-更新：" class="headerlink" title="3.3.3 更新："></a>3.3.3 更新：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">db.col.update(query, update &lt;,options&gt;)</span><br><span class="line">    <span class="comment">#  query:  查询条件(数据索引或名字)</span></span><br><span class="line">    <span class="comment">#  update: 更新的内容，语法：&#123;$set:query&#125;</span></span><br><span class="line">    <span class="comment">#  options:三个可选参数</span></span><br><span class="line">    <span class="comment">#      &#123;upsert: &lt;boolean&gt;,      //如果不存在update的记录，是否插入新数据，默认:false。</span></span><br><span class="line">    <span class="comment">#       multi: &lt;boolean&gt;,       //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。</span></span><br><span class="line">    <span class="comment">#       writeConcern: &lt;document&gt;//#抛出异常的级别。</span></span><br><span class="line">    <span class="comment">#      &#125;</span></span><br><span class="line"><span class="comment">##例如：</span></span><br><span class="line">    db.col.update(</span><br><span class="line">        &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;no.1&quot;</span>&#125;, </span><br><span class="line">        &#123;<span class="variable">$set</span>: &#123;<span class="string">&quot;item&quot;</span>: <span class="string">&quot;human&quot;</span>&#125;&#125;, </span><br><span class="line">        &#123;upsert: <span class="literal">true</span>, multi: <span class="literal">true</span>&#125;</span><br><span class="line">        )</span><br><span class="line">db.col.updateOne()                    <span class="comment">##同上，无multi参数，只更新第一条</span></span><br><span class="line">db.col.updateMany()                   <span class="comment">##同上，无multi参数</span></span><br><span class="line">db.col.replaceOne()                   <span class="comment">##同updateOne</span></span><br><span class="line">db.col.save(document &lt;,writeConcern&gt;) <span class="comment">##通过传入的文档整个替换</span></span><br></pre></td></tr></table></figure><h5 id="insert-与-save的区别"><a href="#insert-与-save的区别" class="headerlink" title="insert 与 save的区别"></a>insert 与 save的区别</h5><p>如果插入的数据的_id相同,save将会更新该文档,而insert将会报错</p><h5 id="update常用操作符"><a href="#update常用操作符" class="headerlink" title="update常用操作符"></a>update常用操作符</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$set</span>         <span class="comment">##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.</span></span><br><span class="line"><span class="variable">$unset</span>       <span class="comment">##删除文档中的一个字段.</span></span><br><span class="line"><span class="variable">$rename</span>      <span class="comment">##重命名某个列</span></span><br><span class="line"><span class="variable">$inc</span>         <span class="comment">##增长某个列</span></span><br><span class="line"><span class="variable">$setOnInsert</span> <span class="comment">##当upsert为true时,并且发生了insert操作时,可以补充的字段</span></span><br><span class="line"><span class="variable">$push</span>        <span class="comment">##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.</span></span><br><span class="line"><span class="variable">$pushAll</span>     <span class="comment">##将多个数值一次存入数组.上面的push只能一个一个的存入</span></span><br><span class="line"><span class="variable">$addToSet</span>    <span class="comment">##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.</span></span><br><span class="line"><span class="variable">$pop</span>         <span class="comment">##删除数组最后一个元素</span></span><br><span class="line"><span class="variable">$pull</span>        <span class="comment">##删除数组中的指定的元素,如果删除的字段不是数组,会报错</span></span><br><span class="line"><span class="variable">$pullAll</span>     <span class="comment">##删除数组中的多个值,跟pushAll与push的关系类似.</span></span><br></pre></td></tr></table></figure><h4 id="3-4-查询"><a href="#3-4-查询" class="headerlink" title="3.4 查询"></a>3.4 查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;&#125;)          <span class="comment">##查询所有文档</span></span><br><span class="line">db.col.find().pretty()   <span class="comment">##以易读的方式来读取数据</span></span><br><span class="line">db.collection.find(query, projection)</span><br><span class="line">    <span class="comment">#  query：查询条件(数据索引或名字)</span></span><br><span class="line">    <span class="comment">#  projection：可选。指定返回的字段。</span></span><br></pre></td></tr></table></figure><h5 id="3-4-1-深入查询表达式"><a href="#3-4-1-深入查询表达式" class="headerlink" title="3.4.1 深入查询表达式"></a>3.4.1 深入查询表达式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">db.col.find()<span class="comment">##查询所有</span></span><br><span class="line">db.col.find(&#123;filed: value&#125;)                              <span class="comment">##等值查询</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$ne</span>: value&#125;&#125;)                       <span class="comment">##不等于 $ne</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$nin</span>: [value1, value2, ...]&#125;&#125;)      <span class="comment">##不能包含给定的值 $nin</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$all</span>: [value1, value2, ...]&#125;&#125;)      <span class="comment">##必须包含所有给定的值 $all</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$in</span>: [value1, value2, ...]&#125;&#125;)       <span class="comment">##只要包含一个或多个给定的值 $in</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$exists</span>:1&#125;&#125;)                        <span class="comment">##存在filed字段的</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$exists</span>:0&#125;&#125;)                        <span class="comment">##不存在filed字段的</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$mod</span>:[3,1]&#125;&#125;)                       <span class="comment">##模三余一，$mod(取模操作)</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$or</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) <span class="comment">##或 $or</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$nor</span>: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)<span class="comment">##排除 $nor</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$size</span>: 3&#125;&#125;)                         <span class="comment">##返回值得数组是给定的长度(3) $size</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$where</span>: <span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> ...&#125;&#125;)            <span class="comment">##回调，隐式迭代，符合条件才返回</span></span><br><span class="line">db.col.find(&#123;<span class="variable">$where</span>: <span class="string">&#x27;...&#x27;</span>&#125;&#125;)                            <span class="comment">##同上</span></span><br><span class="line">db.col.find(&#123;age: &#123;<span class="variable">$lt</span>: 5&#125;&#125;).<span class="built_in">limit</span>(3)                    <span class="comment">##查询age的值小于5，限制3条</span></span><br><span class="line">    <span class="comment">#范围查询：</span></span><br><span class="line">    <span class="comment">#    $lt  （小于）</span></span><br><span class="line">    <span class="comment">#    $gt  （大于）</span></span><br><span class="line">    <span class="comment">#    $lte （小于等于）</span></span><br><span class="line">    <span class="comment">#    $gte （大于等于）</span></span><br><span class="line">    <span class="comment">#    limit（限制显示）</span></span><br><span class="line">db.col.find().skip(2).<span class="built_in">limit</span>(3)                           <span class="comment">##跳过前两个文档查询后面三个</span></span><br><span class="line">    <span class="comment">#  skip(num):表示跳过前面num个文档</span></span><br><span class="line">db.col.find().<span class="built_in">sort</span>(&#123;age: 1&#125;)                             <span class="comment">##查询后以age升序排列显示</span></span><br><span class="line">    <span class="comment">#  sort():排序，这里 1 代表升序, -1 代表降序.</span></span><br><span class="line">db.col.find(&#123;filed: /user.*/i&#125;)                          <span class="comment">##正则，查询filed以user开头不区分大小写（正则效率低）</span></span><br><span class="line">db.col.find(&#123;filed: &#123;<span class="variable">$type</span>: 1&#125;&#125;)                         <span class="comment">##查找filed为双精度的文档</span></span><br><span class="line">    <span class="comment"># 根据数据类型查询 $type</span></span><br><span class="line">    <span class="comment">#      |类型　　　　　　　　|编号|</span></span><br><span class="line">    <span class="comment">#      |双精度　　　　　　　|1 　|</span></span><br><span class="line">    <span class="comment">#      |字符串　　　　　　　|2 　|</span></span><br><span class="line">    <span class="comment">#      |对象　　　　　　　　|3   |</span></span><br><span class="line">    <span class="comment">#      |数组　　　　　　　　|4   |</span></span><br><span class="line">    <span class="comment">#      |二进制数据　　　　　|5   |</span></span><br><span class="line">    <span class="comment">#      |对象ID　　　　　　　|7   |</span></span><br><span class="line">    <span class="comment">#      |布尔值　　　　　　　|8   |</span></span><br><span class="line">    <span class="comment">#      |日期　　　　　　　　|9   |</span></span><br><span class="line">    <span class="comment">#      |空　　　　　　　　　|10  |</span></span><br><span class="line">    <span class="comment">#      |正则表达式　　　　　|11  |</span></span><br><span class="line">    <span class="comment">#      |JavaScript　　　　|13  |</span></span><br><span class="line">    <span class="comment">#      |符号　　　　　　　　|14  |</span></span><br><span class="line">    <span class="comment">#      |JavaScript(带范围)|15  |</span></span><br><span class="line">    <span class="comment">#      |32位整数　　　　　　|16  |</span></span><br><span class="line">    <span class="comment">#      |时间戳　　　　　　　|17  |</span></span><br><span class="line">    <span class="comment">#      |64位整数　　　　　　|18  |</span></span><br><span class="line">    <span class="comment">#      |最小键　　　　　　　|255 |</span></span><br><span class="line">    <span class="comment">#      |最大键　　　　　　　|127 |</span></span><br></pre></td></tr></table></figure><h5 id="3-4-2-group分组查询"><a href="#3-4-2-group分组查询" class="headerlink" title="3.4.2 group分组查询"></a>3.4.2 group分组查询</h5><p>group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group(&#123;</span><br><span class="line">  key:&#123;字段:1&#125;,</span><br><span class="line">  initial:&#123;变量:初始值&#125;,</span><br><span class="line">  <span class="variable">$reduce</span>:<span class="keyword">function</span>(doc,prev)&#123;函数代码&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中key下的字段代表,需要按哪个字段分组.<br>initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.<br>$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果.</p><p>栗子：如下我们按年龄分组,同级不同年龄的用户的多少:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">db.user.<span class="function"><span class="title">find</span></span>()</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b2&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user0&quot;</span>, <span class="string">&quot;age&quot;</span> : 0 &#125;</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b3&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : 1 &#125;</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;age&quot;</span> : 2 &#125;</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user3&quot;</span>, <span class="string">&quot;age&quot;</span> : 1 &#125;</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user4&quot;</span>, <span class="string">&quot;age&quot;</span> : 1 &#125;</span><br><span class="line">    &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b7&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user5&quot;</span>, <span class="string">&quot;age&quot;</span> : 2 &#125;</span><br><span class="line"></span><br><span class="line">db.user.group(&#123;</span><br><span class="line">    key:&#123;age:1&#125;,</span><br><span class="line">    initial:&#123;count:0&#125;,</span><br><span class="line">    <span class="variable">$reduce</span>:<span class="keyword">function</span>(doc,prev)&#123;</span><br><span class="line">        prev.count++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;); </span><br><span class="line">    [</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>: 0, <span class="string">&quot;count&quot;</span>: 1&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>: 1, <span class="string">&quot;count&quot;</span>: 3&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;age&quot;</span>: 2, <span class="string">&quot;count&quot;</span>: 2&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">db.user.group(&#123;</span><br><span class="line">    key:&#123;age:1&#125;,</span><br><span class="line">    initial:&#123;<span class="built_in">users</span>:[]&#125;,</span><br><span class="line">    reduce:<span class="keyword">function</span>(doc,prev)&#123;</span><br><span class="line">        prev.users.push(doc.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">  [</span><br><span class="line">      &#123;<span class="string">&quot;age&quot;</span>: 0, <span class="string">&quot;users&quot;</span>: [<span class="string">&quot;user0&quot;</span>]&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;age&quot;</span>: 1, <span class="string">&quot;users&quot;</span>: [<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;user3&quot;</span>, <span class="string">&quot;user4&quot;</span>]&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;age&quot;</span>: 2, <span class="string">&quot;users&quot;</span>: [<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;user5&quot;</span>]&#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>另外本函数还有两个可选参数 condition 和 finalize<br>condition就是分组的条件筛选类似mysql中的having</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.user.group(&#123;</span><br><span class="line">    key:&#123;age:1&#125;,</span><br><span class="line">    initial:&#123;<span class="built_in">users</span>:[]&#125;,</span><br><span class="line">    <span class="variable">$reduce</span>:<span class="keyword">function</span>(doc,prev)&#123;</span><br><span class="line">        prev.users.push(doc.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    condition:&#123;age:&#123;<span class="variable">$gt</span>:0&#125;&#125;&#125;)</span><br><span class="line">　<span class="comment">##筛选出age大于0的:</span></span><br><span class="line">[</span><br><span class="line">    &#123;<span class="string">&quot;age&quot;</span>: 1, <span class="string">&quot;users&quot;</span>: [<span class="string">&quot;user1&quot;</span>, <span class="string">&quot;user3&quot;</span>, <span class="string">&quot;user4&quot;</span>]&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;age&quot;</span>: 2, <span class="string">&quot;users&quot;</span>: [<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;user5&quot;</span>]&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="3-4-3-count统计"><a href="#3-4-3-count统计" class="headerlink" title="3.4.3 count统计"></a>3.4.3 count统计</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.goods.count()            <span class="comment">##统计该集合总数</span></span><br><span class="line">db.goods.count(&#123;cat_id: 3&#125;) <span class="comment">##统计cat_id=3的总数</span></span><br></pre></td></tr></table></figure><h5 id="3-4-4-distinct排重"><a href="#3-4-4-distinct排重" class="headerlink" title="3.4.4 distinct排重"></a>3.4.4 distinct排重</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.user.<span class="function"><span class="title">find</span></span>()</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b2&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user0&quot;</span>, <span class="string">&quot;age&quot;</span> : 0 &#125;</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b3&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user1&quot;</span>, <span class="string">&quot;age&quot;</span> : 1 &#125;</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b4&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user2&quot;</span>, <span class="string">&quot;age&quot;</span> : 2 &#125;</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b5&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user3&quot;</span>, <span class="string">&quot;age&quot;</span> : 1 &#125;</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b6&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user4&quot;</span>, <span class="string">&quot;age&quot;</span> : 1 &#125;</span><br><span class="line">   &#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5198c286c686eb50e2c843b7&quot;</span>), <span class="string">&quot;name&quot;</span> : <span class="string">&quot;user5&quot;</span>, <span class="string">&quot;age&quot;</span> : 2 &#125;</span><br><span class="line"></span><br><span class="line"> db.user.distinct(<span class="string">&quot;age&quot;</span>) <span class="comment">## 特殊,传入的参数直接是字符串,而不是对象;</span></span><br><span class="line">     [0, 1, 2]</span><br></pre></td></tr></table></figure><h5 id="3-4-5-子文档查询-elemMatch"><a href="#3-4-5-子文档查询-elemMatch" class="headerlink" title="3.4.5 子文档查询$elemMatch"></a>3.4.5 子文档查询$elemMatch</h5><p>elemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。<br>注意：<br>(1)数组中元素是内嵌文档。<br>(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。<br>假设集合school有如下数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> _id: 1,</span><br><span class="line"> zipcode: 63109,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">&quot;john&quot;</span>, school: 102, age: 10 &#125;,</span><br><span class="line">              &#123; name: <span class="string">&quot;jess&quot;</span>, school: 102, age: 11 &#125;,</span><br><span class="line">              &#123; name: <span class="string">&quot;jeff&quot;</span>, school: 108, age: 15 &#125;</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> _id: 2,</span><br><span class="line"> zipcode: 63110,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">&quot;ajax&quot;</span>, school: 100, age: 7 &#125;,</span><br><span class="line">              &#123; name: <span class="string">&quot;achilles&quot;</span>, school: 100, age: 8 &#125;,</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> _id: 3,</span><br><span class="line"> zipcode: 63109,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">&quot;ajax&quot;</span>, school: 100, age: 7 &#125;,</span><br><span class="line">              &#123; name: <span class="string">&quot;achilles&quot;</span>, school: 100, age: 8 &#125;,</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"> _id: 4,</span><br><span class="line"> zipcode: 63109,</span><br><span class="line"> students: [</span><br><span class="line">              &#123; name: <span class="string">&quot;barney&quot;</span>, school: 102, age: 7 &#125;,</span><br><span class="line">           ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; <span class="variable">$elemMatch</span>: &#123; school: 102 &#125; &#125; &#125; );</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>: 1, <span class="string">&quot;students&quot;</span>: [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;john&quot;</span>, <span class="string">&quot;school&quot;</span>:102, <span class="string">&quot;age&quot;</span>:10&#125;]&#125;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>: 3&#125;</span><br><span class="line">&#123;<span class="string">&quot;_id&quot;</span>: 4, <span class="string">&quot;students&quot;</span>: [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;barney&quot;</span>, <span class="string">&quot;school&quot;</span>:102, <span class="string">&quot;age&quot;</span>:7&#125;]&#125;</span><br></pre></td></tr></table></figure><p>查询结果说明：<br><code>_id为1的文档</code>，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。<br><code>_id为3的文档</code>，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。</p><p>$elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; <span class="variable">$elemMatch</span>: &#123; school: 102, age: &#123; <span class="variable">$gt</span>: 10&#125; &#125; &#125; &#125; );</span><br><span class="line"></span><br><span class="line">  &#123;<span class="string">&quot;_id&quot;</span>: 1, <span class="string">&quot;students&quot;</span>: [&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jess&quot;</span>, <span class="string">&quot;school&quot;</span>:102, <span class="string">&quot;age&quot;</span>:11&#125;]&#125;</span><br><span class="line">  &#123;<span class="string">&quot;_id&quot;</span>: 3&#125;</span><br><span class="line">  &#123;<span class="string">&quot;_id&quot;</span>: 4&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据库」嵌入式SQL语言</title>
      <link href="/2018/09/01/database-sql.html"/>
      <url>/2018/09/01/database-sql.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>交互式SQL语言有很多优点：记录集合操作、非过程性操作、一条语句就可实现复杂查询的结果，</li><li>然而，交互式SQL本身也有很多局限：<span id="more"></span><ul><li>从使用者角度：专业人员可熟练写出SQL语句，但大部分的普通用户并非可以</li><li>从SQL本身角度：特别复杂的检索结果难以用一条交互式SQL语句完成，此时需要结合高级语言中经常出现的顺序、分支和循环结构来帮助处理</li></ul></li><li>因此，高级语言+SQL语言：<ul><li>既继承高级语言的过程控制性</li><li>又结合SQL语言的复杂结果集操作的非过程性</li><li>同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作</li></ul></li><li>嵌入式SQL语言<ul><li>将SQL语言嵌入到某一种高级语言中使用</li><li>这种高级语言，如C&#x2F;C++, Java, PowerBuilder等，又称宿主语言(Host Language)</li><li>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</li></ul></li></ul><h3 id="1-变量声明与数据库连接"><a href="#1-变量声明与数据库连接" class="headerlink" title="1. 变量声明与数据库连接"></a>1. 变量声明与数据库连接</h3><ol><li>以宿主语言<strong>C语言</strong>为例，对比交互式SQL语言与嵌入式SQL语言<ul><li>交互式SQL:<code>select Sname, Sage from Student where Sname=&#39;张三&#39;;</code></li><li>嵌入式SQL:<code>exec sql select Sname, Sage into :vSname, :vSage from Student where Sname=&#39;张三&#39;;</code></li></ul></li><li>典型特点<ul><li><strong>exec sql</strong>引导SQL语句: 提供给C编译器，以便对SQL语句预编译成C编译器可识别的语句</li><li>增加一 <strong>into子句</strong>: 该子句用于指出接收SQL语句检索结果的程序变量</li><li>由冒号引导的<strong>程序变量</strong>,如: ‘:vSname’, ‘:vSage’</li></ul></li></ol><h4 id="1-1-变量的声明与使用"><a href="#1-1-变量的声明与使用" class="headerlink" title="1.1 变量的声明与使用"></a>1.1 变量的声明与使用</h4><ul><li>在嵌入式SQL语句中可以出现宿主语言语句所使用的变量，这些变量需要特殊的声明：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">begin</span> <span class="keyword">declare</span> section;</span><br><span class="line">    <span class="type">char</span> vSname[<span class="number">10</span>], specName[<span class="number">10</span>]<span class="operator">=</span>&quot;张三&quot;;</span><br><span class="line">    <span class="type">int</span> vSage;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">end</span> <span class="keyword">declare</span> section;</span><br></pre></td></tr></table></figure></li><li>变量声明和赋值中，要注意：<ul><li>宿主程序的字符串变量长度应比字符型字段的长度多1个。因宿主程序的字符串尾部多一个终止符为’\0’，而程序中用双引号来描述。</li><li>宿主程序变量类型与数据库字段类型之间有些是有差异的, 有些DBMS可支持自动转换，有些不能。</li></ul></li><li>声明的变量，可以在宿主程序中赋值，然后传递给SQL语句的where等子句中，以使SQL语句能够按照指定的要求(可变化的)进行检索。</li><li>嵌入式比交互式SQL语句灵活了一些：只需改一下变量值，SQL语句便可反复使用，以检索出不同结果。</li><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">begin</span> <span class="keyword">declare</span> section;</span><br><span class="line">    <span class="type">char</span> vSname[<span class="number">10</span>], specName[<span class="number">10</span>]<span class="operator">=</span>&quot;张三&quot;;</span><br><span class="line">    <span class="type">int</span> vSage;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">end</span> <span class="keyword">declare</span> section;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>用户可在此处基于键盘输入给specName赋值</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">select</span> Sname, Sage <span class="keyword">into</span> :vSname, :vSage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname <span class="operator">=</span> :specName;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>比较相应的交互式<span class="keyword">SQL</span>语句：</span><br><span class="line"><span class="keyword">select</span> Sname, Sage <span class="keyword">from</span> Student <span class="keyword">where</span> Sname <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-程序与数据库的连接和断开"><a href="#1-2-程序与数据库的连接和断开" class="headerlink" title="1.2 程序与数据库的连接和断开"></a>1.2 程序与数据库的连接和断开</h4><h5 id="1-2-1-数据库的连接connect"><a href="#1-2-1-数据库的连接connect" class="headerlink" title="1.2.1 数据库的连接connect"></a>1.2.1 数据库的连接connect</h5><p>在嵌入式SQL程序执行之前，首先要与数据库进行连接, 不同DBMS，具体连接语句的语法略有差异</p><ol><li>SQL标准中建议的连接语法为：<ul><li><code>exec sql connect to target-server as connect-name user user-name;</code></li><li>或 <code>exec sql connect to default;</code></li></ul></li><li>Oracle中数据库连接:<ul><li><code>exec sql connect  :user_name identified by :user_pwd;</code></li></ul></li><li>DB2 UDB中数据库连接:<ul><li><code>exec sql connect  to  mydb user  :user_name using  :user_pwd;</code></li></ul></li></ol><h5 id="1-2-1-数据库的断开disconnect"><a href="#1-2-1-数据库的断开disconnect" class="headerlink" title="1.2.1 数据库的断开disconnect"></a>1.2.1 数据库的断开disconnect</h5><p>在嵌入式SQL程序执行之后，需要与数据库断开连接</p><ol><li>SQL标准中建议的断开连接的语法为：<ul><li><code>exec sql disconnect connect-name;</code></li><li>或 <code>exec sql disconnect current;</code></li></ul></li><li>Oracle中断开连接:<ul><li><code>exec sql commit release;</code></li><li>或 <code>exec sql rollback release;</code></li></ul></li><li>DB2 UDB中断开连接:<ul><li><code>exec sql connect reset;</code></li><li><code>exec sql disconnect current;</code></li></ul></li></ol><h4 id="1-3-SQL执行的提交与撤消"><a href="#1-3-SQL执行的提交与撤消" class="headerlink" title="1.3 SQL执行的提交与撤消"></a>1.3 SQL执行的提交与撤消</h4><p>SQL语句在执行过程中，必须有提交和撤消语句才能确认其操作结果</p><ol><li>SQL执行的提交：<ul><li><code>exec  sql commit  work;</code></li></ul></li><li>SQL执行的撤消：<ul><li><code>exec  sql rollback  work;</code></li></ul></li><li>为此，很多DBMS都设计了捆绑提交&#x2F;撤消与断开连接在一起的语句,以保证在断开连接之前使用户确认提交或撤消先前的工作，例如Oracle中：<ul><li><code>exec  sql commit  release;</code></li><li>或 <code>exec  sql rollback  release;</code></li></ul></li></ol><h3 id="2-事务Transaction"><a href="#2-事务Transaction" class="headerlink" title="2. 事务Transaction"></a>2. 事务Transaction</h3><ol><li>从应用程序员角度：事务是一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务</li><li>从微观角度，或者从DBMS角度：事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</li><li>简单来说：事务是作为单个逻辑工作单元执行的一系列操作；多个操作作为一个整体向系统提交，要么都执行，要么都不执行；<strong>事务是一个不可分割的工作逻辑单元</strong>。</li></ol><h4 id="2-1-事务的特性-ACID"><a href="#2-1-事务的特性-ACID" class="headerlink" title="2.1 事务的特性: ACID"></a>2.1 事务的特性: ACID</h4><ol><li><strong>原子性</strong>Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对DB而言，要么都执行，要么都不执行</li><li><strong>一致性</strong>Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作规则，它是进一步由隔离性来保证的</li><li><strong>隔离性</strong>Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;或者先执行了T2, 再执行T1。</li><li><strong>持久性</strong>Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的。</li></ol><blockquote><p>换句话说：具有ACID特性的若干数据库基本操作的组合体被称为事务。</p></blockquote><h3 id="3-数据集与游标"><a href="#3-数据集与游标" class="headerlink" title="3. 数据集与游标"></a>3. 数据集与游标</h3><p>读取单行结果处理与多行结果处理的差异：Into子句与游标(Cursor)</p><ol><li>检索单行结果，可将结果直接传送到宿主程序的变量中(Into)<ul><li>示例：<code>exec sql select Sname,Sage into :vSname,:vSage from Student where Sname = :specName;</code></li></ul></li><li>检索多行结果，则需使用游标(Cursor)<ul><li>游标是指向某检索记录集的指针</li><li>通过这个指针的移动，每次读一行，处理一行，再读一行… , 直至处理完毕</li><li>读一行操作是通过Fetch…into语句实现的：每一次Fetch, 都是先向下移动指针，然后再读取</li><li>记录集有结束标识EOF, 用来标记后面已没有记录了</li></ul></li></ol><ul><li>游标(Cursor)的使用需要先定义、再打开(执行)、接着一条接一条处理，最后再关闭</li><li>游标可以定义一次，多次打开(多次执行)，多次关闭</li></ul><h4 id="3-1-游标的使用方法"><a href="#3-1-游标的使用方法" class="headerlink" title="3.1 游标的使用方法"></a>3.1 游标的使用方法</h4><ol><li><p>Cursor的定义：declare cursor</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    Subquery</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">    [<span class="keyword">FOR</span> [ READ <span class="keyword">ONLY</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> columnname [, columnname…]]]];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例:</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass<span class="operator">=</span> :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno</span><br><span class="line">    <span class="keyword">for</span> read <span class="keyword">only</span> ;</span><br></pre></td></tr></table></figure></li><li><p>Cursor的打开和关闭：open cursor &#x2F;&#x2F;close cursor</p><ul><li>EXEC SQL OPEN cursor_name;</li><li>EXEC SQL CLOSE cursor_name;</li></ul></li><li><p>Cursor的数据读取：Fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> cursor_name</span><br><span class="line">    <span class="keyword">INTO</span> host<span class="operator">-</span>variable , [host<span class="operator">-</span>variable, …];</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例:</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">declare</span> cur_student <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> Sno, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> Sclass<span class="operator">=</span> :vClass</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> Sno <span class="keyword">for</span> read <span class="keyword">only</span> ;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">open</span> cur_student;</span><br><span class="line">…</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">fetch</span> cur_student <span class="keyword">into</span> :vSno, :vSname, :vSage</span><br><span class="line">…</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">close</span> cur_student;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-可滚动游标"><a href="#3-2-可滚动游标" class="headerlink" title="3.2 可滚动游标"></a>3.2 可滚动游标</h4><ol><li>ODBC支持的可滚动Cursor<ul><li>标准的游标始终是自开始向结束方向移动的，每fetch一次，向结束方向移动一次；一条记录只能被访问一次；再次访问该记录只能关闭游标后重新打开</li><li>ODBC( Open DataBase Connectivity)是一种跨DBMS的DB操作平台，它在应用程序与实际的DBMS之间提供了一种通用接口</li><li>许多实际的DBMS并不支持可滚动游标，但通过ODBC可以使用该功能</li></ul></li><li>可滚动游标是可使游标指针在记录集之间灵活移动、使每条记录可以反复被访问的一种游标<ul><li>可滚动游标移动时需判断是否到结束位置，或到起始位置<ul><li>可通过判断是否到EOF位置(最后一条记录的后面), 或BOF位置(起始记录的前面)</li><li>如果不需区分，可通过whenever  not found语句设置来检测</li></ul></li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> cursor_name [<span class="keyword">INSENSITIVE</span>] [<span class="keyword">SCROLL</span>] <span class="keyword">CURSOR</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">HOLD</span>] <span class="keyword">FOR</span> Subquery</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> result_column [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>][, result_column …]</span><br><span class="line">[<span class="keyword">FOR</span> READ <span class="keyword">ONLY</span> <span class="operator">|</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> columnname [,</span><br><span class="line">columnname ]…];</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span></span><br><span class="line">[ NEXT <span class="operator">|</span> PRIOR <span class="operator">|</span> <span class="keyword">FIRST</span> <span class="operator">|</span> <span class="keyword">LAST</span></span><br><span class="line"><span class="operator">|</span> [ABSOLUTE <span class="operator">|</span> RELATIVE] value_spec ]</span><br><span class="line"><span class="keyword">FROM</span> cursor_name <span class="keyword">INTO</span> host<span class="operator">-</span>variable [, host<span class="operator">-</span>variable …];</span><br></pre></td></tr></table></figure><ul><li><code>NEXT</code>向结束方向移动一条；</li><li><code>PRIOR</code>向开始方向移动一条；</li><li><code>FIRST</code>回到第一条；</li><li><code>LAST</code>移动到最后一条；</li><li><code>ABSOLUT  value_spec</code>定向检索指定位置的行, value_spec由1至当前记录集最大值；</li><li><code>RELATIVE  value_spec</code>相对当前记录向前或向后移动，value_spec为正数向结束方向移动，为负数向开始方向移动</li></ul><h4 id="3-3-数据库记录的增删改"><a href="#3-3-数据库记录的增删改" class="headerlink" title="3.3 数据库记录的增删改"></a>3.3 数据库记录的增删改</h4><ol><li>数据库记录的删除<ul><li>一种是查找删除(与交互式DELETE语句相同)，一种是定位删除</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">WHERE</span> search_condition <span class="operator">|</span> <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例：查找删除</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">delete</span> <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city <span class="operator">=</span> ‘Harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid <span class="operator">=</span> c.cid);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例：定位删除</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">declare</span> delcust <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> cid <span class="keyword">from</span> customers c <span class="keyword">where</span> c.city <span class="operator">=</span>‘harbin’ <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> orders o <span class="keyword">where</span> o.cid <span class="operator">=</span> c.cid)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> cid;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">open</span> delcust</span><br><span class="line">While (<span class="literal">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">fetch</span> delcust <span class="keyword">into</span> :cust_id;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">delete</span> <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> delcust ; &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>数据库记录的更新<ul><li>一种是查找更新(与交互式Update语句相同)，一种是定位更新</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">UPDATE</span> tablename [corr_name]</span><br><span class="line">    <span class="keyword">SET</span> columnname <span class="operator">=</span> expr [, columnname <span class="operator">=</span> expr …]</span><br><span class="line">    [ <span class="keyword">WHERE</span> search_condition ] <span class="operator">|</span> <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> cursor_name;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例：查找更新</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">update</span> student s <span class="keyword">set</span> sclass <span class="operator">=</span> ‘<span class="number">035102</span>’</span><br><span class="line">    <span class="keyword">where</span> s.sclass <span class="operator">=</span> ‘<span class="number">034101</span>’</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 示例：定位更新</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">declare</span> stud <span class="keyword">cursor</span> <span class="keyword">for</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student s <span class="keyword">where</span> s.sclass <span class="operator">=</span>‘<span class="number">034101</span>’</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">update</span> <span class="keyword">of</span> sclass;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">open</span> stud</span><br><span class="line">While (<span class="literal">TRUE</span>) &#123;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">fetch</span> stud <span class="keyword">into</span> :vSno, :vSname, :vSclass;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">update</span> student <span class="keyword">set</span> sclass <span class="operator">=</span> ‘<span class="number">035102</span>’ <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> stud ; &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>数据库记录的插入<ul><li>只有一种类型的插入语句</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> tablename [ (columnname [,columnname, …] )]</span><br><span class="line">    [ <span class="keyword">VALUES</span> (expr [ , expr , …] ) <span class="operator">|</span> subqurey ] ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例：插入语句</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">insert</span> <span class="keyword">into</span> student ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">values</span> (‘<span class="number">03510128</span>’, ‘张三’, ‘<span class="number">035101</span>’) ;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>示例：插入语句</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">insert</span> <span class="keyword">into</span> masterstudent ( sno, sname, sclass)</span><br><span class="line">    <span class="keyword">select</span> sno, sname, sclass <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><h3 id="4-状态捕获及错误处理机制"><a href="#4-状态捕获及错误处理机制" class="headerlink" title="4. 状态捕获及错误处理机制"></a>4. 状态捕获及错误处理机制</h3><h4 id="4-1-基本机制"><a href="#4-1-基本机制" class="headerlink" title="4.1 基本机制"></a>4.1 基本机制</h4><ul><li><p>状态，是嵌入式SQL语句的执行状态，尤其指一些出错状态；有时程序需要知道这些状态并对这些状态进行处理</p></li><li><p>嵌入式 SQL程序中，状态捕获及处理有三部分构成</p><ol><li>设置SQL通信区: 一般在嵌入式SQL程序的开始处便设置<ul><li><code>exec sql include sqlca;</code></li></ul></li><li>设置状态捕获语句: 在嵌入式SQL程序的任何位置都可设置；可多次设置；但有作用域<ul><li><code>exec sql whenever sqlerror goto report_error;</code></li></ul></li><li>状态处理语句: 某一段程序以应对SQL操作的某种状态<ul><li><code>report_error: exec sql rollback;</code></li></ul></li></ol></li><li><p>SQL通信区: SQLCA</p><ol><li>SQLCA是一个已被声明过的具C语言的结构形式的内存信息区，其中的成员变量用来记录SQL语句执行的状态，便于宿主程序读取与处理</li><li>SQLCA是DBMS(执行SQL语句)与宿主程序之间交流的桥梁之一</li></ol></li><li><p>状态捕获语句: <code>exec sql whenever condition action;</code></p><ul><li>Whenever语句的作用是设置一个“条件陷阱”, 该条语句会对其后面的所有由Exec SQL语句所引起的对数据库系统的调用自动检查它是否满足条件(由condition指出).<ul><li>SQLERROR: 检测是否有SQL语句出错。其具体意义依赖于特定的DBMS</li><li>NOT FOUND: 执行某一SQL语句后，没有相应的结果记录出现</li><li>SQLWARNING: 不是错误，但应引起注意的条件</li></ul></li><li>如果满足condition, 则要采取一些动作(由action指出)<ul><li>CONTINUE: 忽略条件或错误，继续执行</li><li>GOTO 标号: 转移到标号所指示的语句，去进行相应的处理</li><li>STOP: 终止程序运行、撤消当前的工作、断开数据库的连接</li><li>DO函数或 CALL函数: 调用宿主程序的函数进行处理，函数返回后从引发该condition的Exec SQL语句之后的语句继续进行</li></ul></li></ul></li><li><p>状态捕获语句Whenever的作用范围是其后的所有Exec SQL语句，一直到程序中出现另一条相同条件的Whenever语句为止，后面的将覆盖前面的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">whenever</span> sqlerror stop;</span><br><span class="line">    … …</span><br><span class="line">    goto s1</span><br><span class="line">    … …</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">whenever</span> sqlerror continue;</span><br><span class="line">    s1: <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">update</span> agents <span class="keyword">set</span> <span class="keyword">percent</span> <span class="operator">=</span> <span class="keyword">percent</span> <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">    … …</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>S1标号指示的语句受第二个<span class="keyword">Whenever</span>语句约束。</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>注意：作用域是语句在程序中的位置，而不是控制流程(因是预编译程序处理条件陷阱)</span><br></pre></td></tr></table></figure></li><li><p>状态捕获语句Whenever的使用容易引发无限循环</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">whenever</span> sqlerror goto handle_error;</span><br><span class="line">    <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">create</span> <span class="keyword">table</span> customers(cid <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    cname <span class="type">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">    … …</span><br><span class="line">    handle_error:</span><br><span class="line">        <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">whenever</span> sqlerror continue;<span class="operator">/</span><span class="operator">/</span> 控制是否无限循环：无，则可能；有，则不会</span><br><span class="line">        <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">drop</span> customers;</span><br><span class="line">        <span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">disconnect</span>;</span><br><span class="line">        fprintf(stderr,”could <span class="keyword">not</span> <span class="keyword">create</span> customers <span class="keyword">table</span>\n”);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-2-状态信息"><a href="#4-2-状态信息" class="headerlink" title="4.2 状态信息"></a>4.2 状态信息</h4><p>典型DBMS系统记录状态信息的三种方法</p><ul><li>状态记录:<ol><li><code>sqlcode</code>: 典型DBMS都提供一个sqlcode变量来记录其执行sql语句的状态，但不同DBMS定义的sqlcode值所代表的状态意义可能是不同的。<ul><li>sqlcode&#x3D;&#x3D; 0, successful call;</li><li>sqlcode &lt; 0, error, e.g., from connect, database does not exist , –16;</li><li>sqlcode &gt; 0, warning, e.g., no rows retrieved from fetch</li></ul></li><li><code>sqlca.sqlcode</code>: 支持SQLCA的产品一般要在SQLCA中填写sqlcode来记录上述信息; 除此而外，sqlca还有其他状态信息的记录</li><li><code>sqlstate</code>: 有些DBMS提供的记录状态信息的变量是sqlstate或sqlca.sqlstate</li></ol></li><li>当我们不需明确知道错误类型，而只需知道发生错误与否，则我们只要使用前述的状态捕获语句即可，而无需关心状态记录变量(隐式状态处理)</li><li>但我们程序中如要自行处理不同状态信息时，则需要知道以上信息，但也需知道正确的操作方法(显式状态处理)</li></ul><h4 id="4-3-程序自身进行错误信息的处理"><a href="#4-3-程序自身进行错误信息的处理" class="headerlink" title="4.3 程序自身进行错误信息的处理"></a>4.3 程序自身进行错误信息的处理</h4><p>正确的显式状态处理示例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">begin</span> declar section;</span><br><span class="line">    <span class="type">char</span> <span class="keyword">SQLSTATE</span>[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">end</span> <span class="keyword">declare</span> section;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">whenever</span> sqlerror goto handle_error;</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">whenever</span> sqlerror continue;</span><br><span class="line"><span class="keyword">exec</span> <span class="keyword">sql</span> <span class="keyword">create</span> <span class="keyword">table</span> custs</span><br><span class="line">    (cid <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">not</span> <span class="keyword">null</span>, cname <span class="type">varchar</span>(<span class="number">13</span>), … … );</span><br><span class="line">if (strcmp(<span class="keyword">SQLSTATE</span>, “<span class="number">82100</span>”)<span class="operator">=</span><span class="operator">=</span><span class="number">0</span>)</span><br><span class="line">    <span class="operator">&lt;</span>处理<span class="number">82100</span>错误的程序<span class="operator">&gt;</span></span><br><span class="line">    … …</span><br></pre></td></tr></table></figure><p>上述的if 语句是能被执行的，因为create table发生错误时是继续向下执行的。</p><h3 id="5-动态SQL"><a href="#5-动态SQL" class="headerlink" title="5. 动态SQL"></a>5. 动态SQL</h3><h4 id="5-1-动态SQL的概念"><a href="#5-1-动态SQL的概念" class="headerlink" title="5.1 动态SQL的概念"></a>5.1 动态SQL的概念</h4><p>动态SQL是相对于静态SQL而言的</p><ul><li>静态SQL特点：SQL语句在程序中已经按要求写好，只需要把一些参数通过变量(高级语言程序语句中不带冒号) 传送给嵌入式SQL语句即可(嵌入式SQL语句中带冒号)</li><li>动态SQL特点：SQL语句可以在程序中动态构造，形成一个字符串，然后再交给DBMS执行，交给DBMS执行时仍旧可以传递变量</li></ul><h4 id="5-2-动态SQL的两种执行方式"><a href="#5-2-动态SQL的两种执行方式" class="headerlink" title="5.2 动态SQL的两种执行方式"></a>5.2 动态SQL的两种执行方式</h4><p>如SQL语句已经被构造在host-variable字符串变量中, 则：</p><ol><li><strong>立即执行语句</strong>: 运行时编译并执行<ul><li><code>EXEC SQL EXECUTE IMMEDIATE :host-variable;</code></li></ul></li><li><strong>Prepare-Execute-Using语句</strong>: PREPARE语句先编译，编译后的SQL语句允许动态参数，EXECUTE语句执行，用USING语句将动态参数值传送给编译好的SQL语句<ul><li><code>EXEC SQL PREPARE sql_temp FROM :host-variable;</code></li><li><code>EXEC SQL EXECUTE sql_temp USING :cond-variable</code></li></ul></li></ol><h3 id="6-数据字典与SQLDA"><a href="#6-数据字典与SQLDA" class="headerlink" title="6. 数据字典与SQLDA"></a>6. 数据字典与SQLDA</h3><h4 id="6-1-数据字典的概念"><a href="#6-1-数据字典的概念" class="headerlink" title="6.1 数据字典的概念"></a>6.1 数据字典的概念</h4><p>数据字典(Data dictionary)，又称为系统目录(System Catalogs)</p><ul><li>是系统维护的一些表或视图的集合，这些表或视图存储了数据库中各类对象的定义信息，这些对象包括用Create语句定义的表、列、索引、视图、权限、约束等, 这些信息又称数据库的元数据–关于数据的数据。</li><li>不同DBMS术语不一样：数据字典(Data Dictionary(Oracle))、目录表(DB2 UDB)、系统目录(INFORMIX)、系统视图(X&#x2F;Open)</li><li>不同DBMS中系统目录存储方式可能是不同的, 但会有一些信息对DBA公开。这些公开的信息, DBA可以使用一些特殊的SQL命令来检索。</li></ul><h4 id="6-2-数据字典的内容构成"><a href="#6-2-数据字典的内容构成" class="headerlink" title="6.2 数据字典的内容构成"></a>6.2 数据字典的内容构成</h4><p>数据字典通常存储的是数据库和表的元数据，即模式本身的信息：</p><ol><li>与关系相关的信息<ul><li>关系名字</li><li>每一个关系的属性名及其类型</li><li>视图的名字及其定义</li><li>完整性约束</li></ul></li><li>用户与账户信息，包括密码</li><li>统计与描述性数据：如每个关系中元组的数目</li><li>物理文件组织信息：<ul><li>关系是如何存储的(顺序&#x2F;无序&#x2F;散列等)</li><li>关系的物理位置</li></ul></li><li>索引相关的信息</li></ol><h4 id="6-3-数据字典的结构"><a href="#6-3-数据字典的结构" class="headerlink" title="6.3 数据字典的结构"></a>6.3 数据字典的结构</h4><ol><li>也是存储在磁盘上的关系</li><li>专为内存高效访问设计的特定的数据结构</li></ol><ul><li>可能的字典数据结构<ul><li><code>Relation_metadata</code> &#x3D; <code>(relation_name, number_of_attributes, storage_organization, location)</code></li><li><code>Attribute_metadata</code> &#x3D; <code>(attribute_name, relation_name, domain_type, position, length)</code></li><li><code>User_metadata</code> &#x3D; <code>(user_name, encrypted_password, group)</code></li><li><code>Index_metadata</code> &#x3D; <code>(index_name, relation_name, index_type, index_attributes)</code></li><li><code>View_metadata</code> &#x3D; <code>(view_name, definition)</code></li></ul></li></ul><h4 id="6-4-X-x2F-Open标准的系统目录"><a href="#6-4-X-x2F-Open标准的系统目录" class="headerlink" title="6.4 X&#x2F;Open标准的系统目录"></a>6.4 X&#x2F;Open标准的系统目录</h4><ol><li>X&#x2F;Open标准中有一个目录表Info_Schem.Tables, 该表中的一行是一个已经定义的表的有关信息<ul><li><code>Table_Schem</code>：表的模式名(通常是表所有者的用户名)</li><li><code>Table_Name</code>：表名</li><li><code>Table_Type</code>：<code>&#39;Base_Table&#39;</code>或<code>&#39;View&#39;</code></li></ul></li><li>可以使用SQL语句来访问这个表中的信息，比如了解已经定义了哪些表，可如下进行：<ul><li><code>Select Table_Name From Tables;</code></li></ul></li><li>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而不混淆。</li><li>一般而言，一个用户有一个模式。可以使用Create Schema语句来创建模式(用法参见相关文献)，在Create Table等语句可以使用所定义的模式名称。</li></ol><h4 id="6-5-Oracle的数据字典"><a href="#6-5-Oracle的数据字典" class="headerlink" title="6.5 Oracle的数据字典"></a>6.5 Oracle的数据字典</h4><ol><li>Oracle数据字典由视图组成，分为三种不同形式，由不同的前缀标识<ul><li><code>USER_</code> :用户视图，用户所拥有的对象，在用户模式中</li><li><code>ALL_</code>  :扩展的用户视图，用户可访问的对象</li><li><code>DBA_</code>  :DBA视图(所有用户都可访问的DBA对象的子集)</li></ul></li><li>Oracle数据字典中定义了三个视图<code>USER_Tables</code>, <code>ALL_Tables</code>, 和<code>DBA_Tables</code>供DBA和用户使用数据字典中关于<strong>表的信息</strong></li><li>同样, Oracle数据字典中也定义了三个视图<code>USER_TAB_Columns</code>, <code>ALL_TAB_Columns</code>(<code>Accessible_Columns</code>), 和<code>DBA_TAB_Columns</code>供DBA和用户使用数据字典中关于表的<strong>列的信息</strong></li><li>可以使用SQL语句来访问这些表中的信息：<ul><li><code>Select Column_Name From ALL_TAB_Columns Where Table_Name = ‘STUDENT’;</code></li></ul></li><li>Oracle数据字典中还定义了其他视图<ul><li><code>TABLE_PRIVILEDGE</code>(或<code>ALL_TAB_GRANTS</code>)</li><li><code>COLUMN_PRIVILEDGE</code>(或<code>ALL_COL_GRANTS</code>)可访问表的权限，列的权限</li><li><code>CONSTRAINT_DEFS</code>(或<code>ALL_CONSTRAINTS</code>)可访问表的各种约束</li></ul></li><li>可以使用下述命令获取Oracle定义的所有视图信息<ul><li><code>Select view_name from all_views where owner = ‘SYS’ and view_name like ‘ALL_%’ or view_name like ‘USER_%’;</code></li></ul></li><li>如果用户使用Oracle,可使用其提供的<code>SQL*PLUS</code>进行交互式访问</li><li>动态SQL: 表和列都已知，动态构造检索条件。</li><li>动态SQL:检索条件可动态构造，表和列也可动态构造。</li></ol><h4 id="6-6-SQLDA"><a href="#6-6-SQLDA" class="headerlink" title="6.6 SQLDA"></a>6.6 SQLDA</h4><p>构造复杂的动态SQL需要了解数据字典及SQLDA，已获知关系模式信息</p><ol><li>SQLDA: SQL Descriptor Area, SQL描述符区域。<ul><li>SQLDA是一个内存数据结构，内可装载关系模式的定义信息，如列的数目，每一列的名字和类型等等</li><li>通过读取SQLDA信息可以进行更为复杂的动态SQL的处理</li><li>不同DBMS提供的SQLDA格式并不是一致的。</li></ul></li></ol><h3 id="7-ODBC简介"><a href="#7-ODBC简介" class="headerlink" title="7. ODBC简介"></a>7. ODBC简介</h3><h4 id="7-1-ODBC定义"><a href="#7-1-ODBC定义" class="headerlink" title="7.1 ODBC定义"></a>7.1 ODBC定义</h4><p>ODBC：Open DataBase Connection，ODBC是一种标准—不同语言的应用程序与不同数据库服务器之间通讯的标准。</p><ul><li>一组API(应用程序接口)，支持应用程序与数据库服务器的交互</li><li>应用程序通过调用ODBC API, 实现<ol><li>与数据服务器的连接</li><li>向数据库服务器发送SQL命令</li><li>一条一条的提取数据库检索结果中的元组传递给应用程序的变量</li></ol></li><li>具体的DBMS提供一套驱动程序，即Driver库函数，供ODBC调用，以便实现数据库与应用程序的连接。</li><li>ODBC可以配合很多高级语言来使用，如C,C++, C#, Visual Basic, PowerBuilder等等；</li></ul><h4 id="7-2-通过ODBC连接数据库"><a href="#7-2-通过ODBC连接数据库" class="headerlink" title="7.2 通过ODBC连接数据库"></a>7.2 通过ODBC连接数据库</h4><ol><li>ODBC应用前，需要确认具体DBMS Driver被安装到ODBC环境中</li><li>当应用程序调用ODBC API时，ODBC API会调用具体DBMS Driver库函数，DBMS Driver库函数则与数据库服务器通讯，执行相应的请求动作并返回检索结果</li><li>ODBC应用程序首先要分配一个SQL环境，再产生一个数据库连接句柄</li><li>应用程序使用SQLConnect()，打开一个数据库连接，SQLConnect()的具体参数:<ul><li><code>connection handle</code>, 连接句柄</li><li><code>the server</code>，要连接的数据库服务器</li><li><code>the user identifier</code>，用户</li><li><code>password</code> ，密码</li><li><code>SQL_NTS</code> 类型说明前面的参数是空终止的字符串</li></ul></li><li>示例<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ODBCexample()&#123;</span><br><span class="line">    RETCODE error; <span class="comment">/* 返回状态吗 */</span></span><br><span class="line">    HENV env; <span class="comment">/* 环境变量 */</span></span><br><span class="line">    HDBC conn; <span class="comment">/* 连接句柄 */</span></span><br><span class="line">    SQLAllocEnv(<span class="operator">&amp;</span>env);</span><br><span class="line">    SQLAllocConnect(env, <span class="operator">&amp;</span>conn);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>分配数据库连接环境</span><br><span class="line">    SQLConnect(conn, &quot;aura.bell-labs.com&quot;, SQL_NTS, &quot;avi&quot;, SQL_NTS, avipasswd&quot;, SQL_NTS);</span><br><span class="line">    //打开一个数据库连接</span><br><span class="line">    &#123; …. Do actual work … &#125;</span><br><span class="line">    //与数据库通讯</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    //断开连接与释放环境</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-3-通过ODBC与数据库服务器进行通讯"><a href="#7-3-通过ODBC与数据库服务器进行通讯" class="headerlink" title="7.3 通过ODBC与数据库服务器进行通讯"></a>7.3 通过ODBC与数据库服务器进行通讯</h4><ol><li>应用程序使用SQLExecDirect()向数据库发送SQL命令；</li><li>使用SQLFetch()获取产生的结果元组；</li><li>使用SQLBindCol()绑定C语言变量与结果中的属性<ul><li>当获取一个元组时，属性值会自动地传送到相应的C语言变量中</li></ul></li><li>SQLBindCol()的参数：<ul><li>ODBC定义的stmt变量, 查询结果中的属性位置</li><li>SQL到C的类型变换, 变量的地址. </li><li>对于类似字符数组一样的可变长度类型，应给出<ul><li>•变量的最大长度</li><li>•当获取到一个元组后，实际长度的存储位置.</li><li>•注: 当返回实际长度为负数，说明是一个空值。</li></ul></li></ul></li><li>示例<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> branchname[<span class="number">80</span>]; <span class="type">float</span> balance;</span><br><span class="line"><span class="type">int</span> lenOut1, lenOut2;</span><br><span class="line">HSTMT stmt;</span><br><span class="line">SQLAllocStmt(conn, <span class="operator">&amp;</span>stmt);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>分配一个与指定数据库连接的新的语句句柄</span><br><span class="line"><span class="type">char</span> <span class="operator">*</span> sqlquery <span class="operator">=</span> &quot;select branch_name, sum (balance)</span><br><span class="line">    from account</span><br><span class="line">    group by branch_name&quot;;</span><br><span class="line">error <span class="operator">=</span> SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行查询，stmt句柄指向结果集合</span><br><span class="line">if (error <span class="operator">=</span><span class="operator">=</span> SQL_SUCCESS) &#123;</span><br><span class="line">SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, branchname , <span class="number">80</span>, <span class="operator">&amp;</span>lenOut1);</span><br><span class="line">SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, <span class="operator">&amp;</span>balance, <span class="number">0</span> , <span class="operator">&amp;</span>lenOut2);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>绑定高级语言变量与stmt句柄中的属性</span><br><span class="line">while (SQLFetch(stmt) <span class="operator">&gt;=</span> SQL_SUCCESS) &#123;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>提取一条记录，结果数据被存入高级语言变量中</span><br><span class="line">    printf (&quot; %s %g\n&quot;, branchname, balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>释放语句句柄</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-4-ODBC的其他功能"><a href="#7-4-ODBC的其他功能" class="headerlink" title="7.4 ODBC的其他功能"></a>7.4 ODBC的其他功能</h4><ol><li>动态SQL语句的预编译-动态参数传递功能</li><li>获取元数据特性<ul><li>发现数据库中的所有关系的特性 以及</li><li>发现每一个查询结果的列的名字和类型等；</li></ul></li><li>默认, 每一条SQL语句都被作为一个独立的能够自动提交的事务来处理。<ul><li>应用程序可以关闭一个连接的自动提交特性<ul><li><code>SQLSetConnectOption(conn, SQL_AUTOCOMMIT, 0)&#125;</code></li></ul></li><li>此时事务要显式地给出提交和撤销的命令<ul><li><code>SQLTransact(conn, SQL_COMMIT)</code> or <code>SQLTransact(conn, SQL_ROLLBACK)</code></li></ul></li></ul></li></ol><h3 id="8-JDBC简介"><a href="#8-JDBC简介" class="headerlink" title="8. JDBC简介"></a>8. JDBC简介</h3><h4 id="8-1-JDBC定义"><a href="#8-1-JDBC定义" class="headerlink" title="8.1 JDBC定义"></a>8.1 JDBC定义</h4><p>JDBC：Java DataBase Connection，JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p><ul><li>JDBC API 分成两个程序包：<ul><li>Java.sql 核心API –J2SE(Java2标准版)的一部分。使用<code>java.sql.DriverManager</code>类、<code>java.sql.Driver</code>和<code>java.sql.Connection</code>接口连接到数据库</li><li>Javax.sql 可选扩展API–J2EE(Java2企业版)的一部分。包含了基于<code>JNDI(Java Naming and Directory Interface, Java命名和目录接口)</code>的资源，以及管理连接池、分布式事务等，使用DataSource接口连接到数据库。</li></ul></li></ul><h4 id="8-2-JDBC的功能"><a href="#8-2-JDBC的功能" class="headerlink" title="8.2 JDBC的功能"></a>8.2 JDBC的功能</h4><ol><li><code>java.sql.DriverManager</code>——处理驱动的调入并且对产生新数据库连接提供支持</li><li><code>Java.sql.Driver</code>——通过驱动进行数据库访问，连接到数据库的应用程序必须具备该数据库的特定驱动。</li><li><code>java.sql.Connection</code>——代表对特定数据库的连接。</li><li><code>Try &#123;…&#125; Catch &#123;…&#125;</code> ——异常捕获及其处理</li><li><code>java.sql.Statement</code>——对特定的数据库执行SQL语句</li><li><code>java.sql.PreparedStatement</code> —— 用于执行预编译的SQL语句</li><li><code>java.sql.CallableStatement</code> ——用于执行对数据库内嵌过程的调用。</li><li><code>java.sql.ResultSet</code>——从当前执行的SQL语句中返回结果数据。</li></ol><h4 id="8-3-使用JDBC-API访问数据库的过程"><a href="#8-3-使用JDBC-API访问数据库的过程" class="headerlink" title="8.3 使用JDBC API访问数据库的过程"></a>8.3 使用JDBC API访问数据库的过程</h4><ol><li><p>概念性的基本过程</p><ul><li>打开一个连接；创建“Statement”对象，并设置查询语句；使用Statement对象执行查询，发送查询给数据库服务器和返回结果给应用程序；处理错误的例外机制</li></ul></li><li><p>具体实施过程</p><ol><li>•传递一个Driver给DriverManager，加载数据库驱动。<ul><li><code>Class.forName()</code></li></ul></li><li>•通过URL得到一个Connection对象, 建立数据库连接<ul><li><code>DriverManager.getConnection(sDBUrl)</code></li><li><code>DriverManager.getConnection(sDBUrl,sDBUserID,sDBPassword)</code></li></ul></li><li>•接着创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库。<ul><li><code>Statement stmt=con.createStatement()</code></li></ul></li><li>•查询返回一个ResultSet。<ul><li><code>ResultSet rs=stmt.executeQuery(sSQL)</code></li></ul></li></ol></li><li><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span><br><span class="line">&#123; <span class="keyword">try</span> &#123; <span class="comment">//错误捕获</span></span><br><span class="line">    Class.forName (<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, userid, passwd);</span><br><span class="line">    <span class="comment">//加载数据库驱动，建立数据库连接</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="comment">//创建一个语句对象</span></span><br><span class="line">    … Do Actual Work ….</span><br><span class="line">    <span class="comment">//进行SQL语句的执行与处理工作</span></span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">    <span class="comment">//关闭语句对象，关闭连接</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完整的示例程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String dbid, String userid, String passwd)</span></span><br><span class="line">&#123; <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName (<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">        <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, userid, passwd);</span><br><span class="line">    <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stmt.executeUpdate( <span class="string">&quot;insert into instructor values</span></span><br><span class="line"><span class="string">        (‘77987&#x27;, ‘Kim&#x27;, ‘Physics’,98000)&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入错误:&quot;</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">        <span class="string">&quot;select dept_name, avg(salary) from instructor group by dept_name&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> ( rset.next() ) &#123;</span><br><span class="line">        System.out.println(rset.getString(“dept_name<span class="string">&quot;) + &quot;</span> <span class="string">&quot; + rset.getFloat(2));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    stmt.close();</span></span><br><span class="line"><span class="string">    conn.close();</span></span><br><span class="line"><span class="string">&#125; catch (SQLException sqle) &#123;</span></span><br><span class="line"><span class="string">    System.out.println(&quot;</span>SQLException:<span class="string">&quot; + sqle);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="9-嵌入式SQL-ODBC-JDBC三者比较"><a href="#9-嵌入式SQL-ODBC-JDBC三者比较" class="headerlink" title="9. 嵌入式SQL-ODBC-JDBC三者比较"></a>9. 嵌入式SQL-ODBC-JDBC三者比较</h3><p>执行一条SQL语句，读取执行的结果集合</p><ol><li>嵌入式SQL的思维模式<ol><li>建立数据库连接</li><li>声明一个游标</li><li>打开游标</li><li>读取一条记录(循环)</li><li>关闭游标</li><li>断开数据库连接</li></ol></li><li>ODBC的思维模式<ol><li>建立数据库连接</li><li>分配语句句柄</li><li>用句柄执行SQL</li><li>建立高级语言变量与句柄属性的对应</li><li>读取一条记录(循环)</li><li>释放语句句柄</li><li>断开数据库连接</li></ol></li><li>JDBC的思维模式<ol><li>建立数据库连接</li><li>创建语句对象</li><li>用语句对象执行SQL，并返回结果对象</li><li>从结果对象获取一条记录</li><li>提取对象的属性值传给高级语言变量(返回上一步)</li><li>释放语句对象</li><li>断开数据库连接</li></ol></li></ol><ul><li>相同点: 都是建立数据库连接, 执行sql, 处理结果, 释放连接, 流程基本一致</li><li>不同点, 操作方式的不同:<ul><li>嵌入式SQL按照语句进行操作</li><li>ODBC按照函数来进行操作</li><li>JDBC按照对象来进行操作</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据库」数据库语言SQL</title>
      <link href="/2018/08/27/database-language.html"/>
      <url>/2018/08/27/database-language.html</url>
      
        <content type="html"><![CDATA[<h3 id="SQL语言概述"><a href="#SQL语言概述" class="headerlink" title="SQL语言概述"></a>SQL语言概述</h3><p><strong>结构化查询语言</strong>(Structured Query Language)简称SQL，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><ul><li>SQL语言是集DDL、DML和DCL于一体的数据库语言<span id="more"></span><ol><li><strong>DDL语句</strong>引导词：Create(建立)，Alter(修改)，Drop(撤消)<ul><li>模式的定义和删除，包括定义Database，Table，View，Index,完整性约束条件等，也包括定义对象(RowType行对象，Type列对象)</li></ul></li><li><strong>DML语句</strong>引导词：Insert ，Delete, Update, Select<ul><li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入</li><li>各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li><li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li></ul></li><li><strong>DCL语句</strong>引导词：Grant，Revoke<ul><li>安全性控制：授权和撤消授权</li></ul></li></ol></li></ul><h3 id="1-利用SQL建立数据库"><a href="#1-利用SQL建立数据库" class="headerlink" title="1. 利用SQL建立数据库"></a>1. 利用SQL建立数据库</h3><p>DDL：数据定义语言（Data Definition Language)，<br>DDL通常由**DBA(数据库管理员)**来使用，也有经DBA授权后由应用程序员来使用</p><ol><li>创建数据库(DB)：<strong>Create Database</strong><ul><li>数据库(Database)是若干具有相互关联关系的Table&#x2F;Relation的集合</li><li>简单语法形式：<code>create database database 数据库名;</code></li></ul></li><li>创建DB中的Table(定义关系模式)：<strong>Create Table</strong><ul><li><code>Create table 表名(列名 数据类型 [Primary key|Unique] [Not null][,列名 数据类型 [Not null], …]);</code><ul><li><code>[]</code>表示其括起的内容可以省略，<code>|</code>表示其隔开的两项可取其一</li><li><code>Primary key</code>: 主键约束。每个表只能创建一个主键约束</li><li><code>Unique</code>: 唯一性约束(即候选键)。可以有多个唯一性约束</li><li><code>Not null</code>: 非空约束。</li></ul></li></ul></li><li><strong>数据类型</strong>（SQL-92标准）<ul><li><code>char(n)</code>:固定长度的字符串</li><li><code>varchar(n)</code>:可变长字符串</li><li><code>int</code>:整数 &#x2F;&#x2F;有时不同系统也写作integer</li><li><code>numeric(p，q)</code>:固定精度数字，小数点左边p位，右边(p-q)位</li><li><code>real</code>:浮点精度数字 &#x2F;&#x2F;有时不同系统也写作<code>float(n)</code>，小数点后保留n位</li><li><code>date</code>:日期 (如 2003-09-12)</li><li><code>time</code>:时间 (如 23:15:003)<blockquote><p>注意: 现行商用DBMS的数据类型有时有些差异</p></blockquote></li></ul></li></ol><h3 id="2-利用SQL简单查询"><a href="#2-利用SQL简单查询" class="headerlink" title="2. 利用SQL简单查询"></a>2. 利用SQL简单查询</h3><p>DML：数据操纵语言（Data Manipulation Language)，<br>DML通常由<strong>用户或应用程序员</strong>使用，访问经授权的数据库</p><ol><li><p>向Table中添加数据(追加元组)：<strong>Insert into</strong></p><ul><li><strong><code>insert into insert into 表名[(列名[, 列名] …] values (值[,值], …);</code></strong><ul><li>values值的排列，须与列名排列一致</li><li>若所有列名省略，则values值的排列须与该表存储中的列名排列一致</li></ul></li></ul></li><li><p>单表查询<strong>Select</strong></p><ul><li><strong><code>Select Select 列名[[,列名] …] From 表名[Where 检索条件];</code></strong><ul><li>语义：从表名所给出的表中，查询出满足检索条件的元组，并按给定的列名及顺序进行投影显示。</li><li>相当于：<code>Π[列名,...,列名](σ检索条件(表名))</code></li></ul></li><li>Select语句中的select … , from… , where…, 等被称为子句，在以上基本形式基础上会增加许多构成要素，也会增加许多新的子句，满足不同的需求。</li></ul></li><li><p>检索条件的书写<strong>Where</strong></p><ul><li>与选择运算<code>σF(R)</code>的条件F书写一样，只是其逻辑运算符用 and,or,not 来表示, 同时也要注意运算符的优先次序及括弧的使用。书写要点是注意对自然语言检索条件的正确理解。</li><li><code>Select Tname From Teacher Where Salary &gt; 2000 and D# = ’03’;</code>&#x2F;&#x2F;检索教师表中所有工资大于2000元 并且是03系的教师姓名</li></ul></li><li><p>排重(<code>DISTINCT</code>)</p><ul><li>关系模型不允许出现重复元组。但现实DBMS，却允许出现重复元组。</li><li>在Table中要求无重复元组是通过定义Primary key或Unique来保证的;</li><li>而在检索结果中要求无重复元组, 是通过<strong>DISTINCT保留字</strong>的使用来实现的。</li><li><code>Select DISTINCT S# From SC Where Score &gt; 80; </code></li></ul></li><li><p>排序(<code>ORDER BY</code>)</p><ul><li>Select语句中结果排序是通过增加<strong>order by</strong>子句实现的</li><li><code>order by 列名 [asc|desc]</code></li><li>意义为检索结果按指定列名进行排序，若后跟asc或省略，则为升序；若后跟desc, 则为降序。</li></ul></li><li><p>模糊查询(<code>*LIKE*</code>)</p><ul><li><code>_</code>：一个字符，<code>%</code>：任意长度字符。</li><li><code>Select Sname From Student Where Sname Like &#39;张_ _&#39;;</code>&#x2F;&#x2F;检索名字为张某某的所有同学姓名</li><li><code>Select Sname From Student Where Sname Not Like &#39;张%&#39;;</code>&#x2F;&#x2F;检索名字不姓张的所有同学姓名</li></ul></li></ol><h3 id="3-利用SQL多表联合查询"><a href="#3-利用SQL多表联合查询" class="headerlink" title="3. 利用SQL多表联合查询"></a>3. 利用SQL多表联合查询</h3><p>多表联合检索可以通过连接运算来完成，而连接运算又可以通过广义笛卡尔积后再进行选择运算来实现。</p><ul><li>检索语句: <strong><code>Select 列名[[,列名] …] From 表名1,表名2,… Where 检索条件;</code></strong></li><li>相当于<code>Π[列名,...,列名](σ检索条件(表名1 × 表名2 × …))</code></li><li>检索条件中要包含连接条件，通过不同的连接条件可以实现等值连接、不等值连接及各种θ-连接</li></ul><ol><li><p>θ-连接之<strong>等值连接</strong></p><ul><li>多表连接时，如两个表的属性名相同，则需采用**<code>表名.属性名</code>**方式来限定该属性是属于哪一个表</li><li><code>Select Sname From Student, SC Where Student.S#=SC.S# and SC.C#=&#39;001&#39; Order By Score DESC;</code>&#x2F;&#x2F;按“001”号课成绩由高到低顺序显示所有学生的姓名(二表连接)</li></ul></li><li><p>属性重名重名处理(表别名)</p><ul><li>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名(同一表的连接)等，因此需要使用**<code>别名</code>**以便区分</li><li><code>Select 列名 as 列别名[[,列名 as 列别名] …] From 表名1 as 表别名1,表名2 as 表别名2,… Where Where 检索条件;</code></li><li>当定义了别名后，在检索条件中可以使用别名来限定属性</li><li>as 可以省略</li></ul></li><li><p>θ-连接之<strong>不等值连接</strong></p><ul><li><code>Select T1.Tname as Teacher1, T2.Tname as Teacher2 From Teacher T1, Teacher T2 Where T1.Salary&gt;T2.Salary;</code>&#x2F;&#x2F;求有薪水差额的任意两位教师</li></ul></li><li><p>实例：</p><ul><li><code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=&#39;001&#39; and S2.C#=&#39;002&#39; and S1.Score &gt; S2.Score;</code>&#x2F;&#x2F;求“001”号课成绩比“002”号课成绩高的所有学生的学号</li></ul></li></ol><h3 id="4-利用SQL进行增-删-改"><a href="#4-利用SQL进行增-删-改" class="headerlink" title="4. 利用SQL进行增-删-改"></a>4. 利用SQL进行增-删-改</h3><ol><li>SQL-之<strong>更新操作</strong><ul><li>元组新增Insert：新增一个或一些元组到数据库的Table中</li><li>元组更新Update: 对某些元组中的某些属性值进行重新设定</li><li>元组删除Delete：删除某些元组</li></ul></li></ol><blockquote><ul><li>SQL-DML既能单一记录操作，也能对记录集合进行批更新操作</li><li>SQL-DML之更新操作需要利用前面介绍的子查询(Subquery)的概念，以便处理“一些”、“某些”等</li></ul></blockquote><ol start="2"><li>SQL-之<strong>INSERT</strong><ul><li>单一元组新增命令形式：插入一条指定元组值的元组<ul><li><strong><code>insert into 表名 [(列名[,列名]…)] values (值 [,值]…);</code></strong></li></ul></li><li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元组由子查询给出。<ul><li><strong><code>insert into 表名 [(列名[，列名]…)] 子查询;</code></strong></li><li>示例：<code>Insert Into St (S#,Sname) Select S#,Sname From Student Where Sname like &#39;%伟&#39;;</code>&#x2F;&#x2F;将检索到的满足条件的同学新增到该表中</li></ul></li></ul></li></ol><blockquote><p>注意：当新增元组时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作。</p></blockquote><ol start="3"><li><p>SQL-之<strong>DELETE</strong></p><ul><li>元组删除Delete命令: 删除满足指定条件的元组</li><li><strong><code>Delete From 表名 [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则删除所有的元组(清空表)。</li><li>示例：<code>Delete From Student Where S# in ( Select S# From SC Where Score &lt; 60 Group by S# Having Count(*)&gt;= 4);</code>&#x2F;&#x2F;删除有四门不及格课程的所有同学</li></ul></li><li><p>SQL-之<strong>UPDATE</strong></p><ul><li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条件的元组的指定列的值</li><li><strong><code>Update 表名 Set 列名=表达式 | (子查询) [[,列名=表达式 | (子查询) ] …] [ Where 条件表达式];</code></strong></li><li>如果Where条件省略，则更新所有的元组。</li><li>示例：<code>Update Teacher Set Salary=Salary*1.1 Where D# in (Select D# From Dept Where Dname=&#39;计算机&#39;);</code>&#x2F;&#x2F;将所有计算机系的教师工资上调10%</li></ul></li></ol><h3 id="5-利用SQL语言修正与撤销数据库"><a href="#5-利用SQL语言修正与撤销数据库" class="headerlink" title="5. 利用SQL语言修正与撤销数据库"></a>5. 利用SQL语言修正与撤销数据库</h3><ol><li><p>修正基本表的定义</p><ul><li><strong><code>alter table tablename</code></strong></li><li><strong><code>[add &#123;colname datatype, …&#125;]</code></strong> &#x2F;&#x2F;增加新列</li><li><strong><code>[drop &#123;完整性约束名&#125;]</code></strong> &#x2F;&#x2F;删除完整性约束</li><li><strong><code>[modify &#123;colname datatype, …&#125;]</code></strong> &#x2F;&#x2F;修改列定义</li><li>示例：<code>Alter Table Student Drop Unique(Sname);</code>删除学生姓名必须取唯一值的约束</li><li>示例：<code>Alter Table Student Add Saddr char[40],PID char[18];</code>在学生表Student上增加二列Saddr, PID</li></ul></li><li><p>SQL-DDL之撤销与修改</p><ul><li><code>drop table 表名;</code> &#x2F;&#x2F;撤消基本表</li><li><code>drop database 数据库名;</code> &#x2F;&#x2F;撤消数据库</li></ul></li><li><p>SQL-DDL之数据库指定与关闭命令</p><ul><li>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能。</li><li><code>use 数据库名;</code> &#x2F;&#x2F;指定当前数据库</li><li><code>close 数据库名;</code> &#x2F;&#x2F;关闭当前数据库</li></ul></li></ol><h3 id="6-SQL-Server介绍"><a href="#6-SQL-Server介绍" class="headerlink" title="6. SQL Server介绍"></a>6. SQL Server介绍</h3><p>SQL Server 是 Microsoft提供的一款关系数据库管理系统</p><ol><li>SQL Server 的系统数据库<ul><li>Master：是SQL Server中最重要的系统数据库，存储SQL Server中的元数据。</li><li>Model：模板数据库，在创建新的数据库时，SQL Server将会复制此数据库作为新数据库的基础。</li><li>Msdb：代理服务数据库，提供一个存储空间。</li><li>Tempdb：临时数据库，为所有的临时表、临时存储过程及其他临时操作提供存储空间，断开连接时，临时表与存储过程自动被删除。</li></ul></li><li>SQL Server的数据库<ul><li>文件：有三种文件扩展名：.mdf、.ndf、.ldf<ul><li>主数据库文件：扩展名为.mdf，是存储数据库的启动信息和部分或全部数据。一个数据库可以有多个数据库文件，但主数据库文件只有一个。</li><li>辅助数据文件：扩展名为.ndf，用于放置主数据库文件中所定义数据库的其它数据，可有多个。在数据庞大时，可以帮助存储数据。</li><li>日志文件：扩展名.ldf。每个数据库至少有一个事务日志文件。</li></ul></li><li>页面：是SQL Server存储的最小单位。一页为8K或8192字节。</li><li>空间(extent)：是8个连续的页面，即64K数据，是分配数据表存储空间的一种单位</li></ul></li></ol><h4 id="6-1-SQL-Server数据库的创建-删除与维护"><a href="#6-1-SQL-Server数据库的创建-删除与维护" class="headerlink" title="6.1 SQL Server数据库的创建-删除与维护"></a>6.1 SQL Server数据库的创建-删除与维护</h4><ol><li>创建数据库<ul><li>语法形式：Create Database 库名</li><li>可视化操作(查询分析器)：Database(鼠标右键) -&gt; new Database… -&gt; 填写数据库名及配置</li><li>创建数据库的过程就是为数据库设计名称、设计所占用存储空间和存 放文件位置的过程。特别是在网络数据库中，对数据库的设计显得尤为重要。如估计数据可能占用的磁盘空间有多大，日志文件及其他要占用多大空间。</li><li>创建数据库的用户自动成为数据库的拥有者。</li></ul></li><li>删除数据库<ul><li>语法形式：Drop Database 库名</li><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Delete</li><li>对不再需要的数据库，应删除以释放空间。删除的结果将是所有数据库文件都一并被删除。</li><li>当数据库处于正在使用或正在恢复状态时，不能删除。</li></ul></li><li>备份数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Back Up…</li><li>备份就是对数据库或事务日志进行备份。SQL的备份是动态的，备份的过程还可以让用户继续改写。只有系统管理员、数据库的拥有者及数据库的备份者才有权限进行数据备份。可以通过企业管理器进行数据库备份。<ul><li>完全数据库备份：完全备份数据文件和日志文件。</li><li>差异备份（增量备份）：对最近一次数据库备份以来发生的数据变化进行备份。这要在完全备份的基础上进行。特点是速度快。</li><li>事务日志备份：对数据库发生的事务进行备份。包括从上次进行事务日志备份、差异备份和数据库完全备份之后，所有已经完成的事务。能尽可能的恢复最新的数据库记录。特点是所需磁盘空间小，时间少。</li><li>数据库文件和文件组备份：用在数据库相当大的情况下。</li></ul></li></ul></li><li>恢复数据库<ul><li>可视化操作(查询分析器)：数据库名(鼠标右键) -&gt; Tasks -&gt; Restore</li><li>数据库的恢复是指将数据库备份加载到系统中的过程。在根据数据库备份文件恢复过程中，系统将自动执行安全性检查、重建数据库结构及完成填写数据库内容。</li><li>数据库的恢复是静态的。所以在恢复前，应将需要恢复的数据库访问属性设为单用户，不要让其他用户操作。</li><li>可以通过企业管理器来完成数据库恢复。</li></ul></li><li>数据库授权: <ul><li>语法形式：grant 权限 on 表名 to 用户名</li><li>权限有：select,update,insert,delete,exec,dri。</li><li>对被授权的用户，要先成为该数据库的使用者，即要把用户加到数据库里,才能授权.</li></ul></li></ol><h4 id="6-2-SQL-Server数据表的创建-与增-x2F-删-x2F-改-x2F-查"><a href="#6-2-SQL-Server数据表的创建-与增-x2F-删-x2F-改-x2F-查" class="headerlink" title="6.2 SQL Server数据表的创建-与增&#x2F;删&#x2F;改&#x2F;查"></a>6.2 SQL Server数据表的创建-与增&#x2F;删&#x2F;改&#x2F;查</h4><ol><li>创建表<ul><li>同一用户不能建立同一个表名的表，同一表名的表可有多个拥有者。但在使用时，需要在这些表上加上所有者的表名。</li><li>用T-SQL语句创建表，语法形式：<code>CREATE TABLE [数据库名.所有者名.]表名 (&#123;&lt;列名 数据类型&gt;&#125; [缺省值][约束][是否为空] …)</code><blockquote><p>注意：T-SQL是SQL Server软件的SQL语言，与标准版有些差异。但标准版SQL，一般情况下SQL Server软件也都支持</p></blockquote></li><li>可视化操作(查询分析器)：数据库名 -&gt; Tables -&gt; New Table…</li></ul></li><li>增加、修改表字段<ul><li>语法形式：<code>ALTER TABLE ADD | ALTER 字段名 &lt;类型&gt;</code></li></ul></li><li>创建、删除与修改约束<ul><li>约束是SQL提供自动保持数据库完整性的一种方法，共5种。</li><li>用T-SQL语句建立约束，语法形式：<code>CONSTRAINT 约束名 约束类型 (列名)</code><ul><li>约束名：在库中应该唯一，如不指定，系统会给出</li><li>约束类型 (5种)：<ul><li>primary key constraint (主键值)</li><li>unique constraint (唯一性)</li><li>check constraint (检查性)</li><li>default constraint (默认)</li><li>foreign key constraint (外部键)</li></ul></li><li>列名：要约束的字段名</li></ul></li><li>示例:<code>Create Table Course ( C# char(3) , Cname char(12), Chours integer, Credit float(1), T# char(3) ) constraint pk primary key(C# ));</code></li></ul></li></ol><h3 id="7-SQL语言-子查询"><a href="#7-SQL语言-子查询" class="headerlink" title="7. SQL语言-子查询"></a>7. SQL语言-子查询</h3><ul><li>子查询：出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。</li><li>三种类型的子查询：(NOT) IN-子查询；θ-Some&#x2F;θ-All子查询；(NOT) EXISTS子查询</li></ul><h4 id="7-1-NOT-IN子查询"><a href="#7-1-NOT-IN子查询" class="headerlink" title="7.1 (NOT) IN子查询"></a>7.1 (NOT) IN子查询</h4><ol><li>基本语法：<code>表达式 [not] in (子查询)</code><ul><li>语法中，表达式的最简单形式就是列名或常数。</li><li>语义：判断某一表达式的值是否在子查询的结果中。</li><li>示例：<ul><li><code>Select * From Student Where Sname in (&#39;张三&#39;, &#39;王三&#39;);</code>&#x2F;&#x2F;列出张三、王三同学的所有信息</li><li><code>Select S#, Sname From Student Where S# in (Select S# From SC Where C#=&#39;001&#39;);</code>&#x2F;&#x2F;列出选修了001号课程的学生的学号和姓名</li></ul></li></ul></li><li>非相关子查询：内层查询独立进行，没有涉及任何外层查询相关信息的子查询前面的子查询示例都是非相关子查询</li><li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行的子查询</li><li>外层向内层传递的参量需要使用外层的表名或表别名来限定<ul><li>示例：<code>Select Sname From Student Stud Where S# in ( Select S# From SC Where S# = Stud.S# and C#=&#39;001&#39;);</code>&#x2F;&#x2F;求学过001号课程的同学的姓名</li></ul></li></ol><blockquote><p>注意：相关子查询只能由外层向内层传递参数，而不能反之；这也称为变量的作用域原则。</p></blockquote><h4 id="7-2-θ-Some-x2F-θ-All子查询"><a href="#7-2-θ-Some-x2F-θ-All子查询" class="headerlink" title="7.2 θ-Some&#x2F;θ-All子查询"></a>7.2 θ-Some&#x2F;θ-All子查询</h4><ol><li>基本语法：<code>表达式 θ some (子查询)</code> &#x2F; <code>表达式 θ all (子查询)</code><ul><li>语法中，θ是比较运算符：<code>&lt;, &gt;, &gt;=, &lt;=, =, &lt;&gt;</code>。</li><li>语义：将表达式的值与子查询的结果进行比较：<ul><li>如果表达式的值至少与子查询结果的某一个值相比较满足 关系，则<code>表达式 θ some (子查询)</code>的结果便为真</li><li>如果表达式的值与子查询结果的所有值相比较都满足 关系，则<code>表达式 θ all (子查询)</code>的结果便为真</li></ul></li><li>示例：<ul><li><code>Select Tname From Teacher Where Salary &lt;= all ( Select Salary From Teacher);</code>&#x2F;&#x2F;找出工资最低的教师姓名</li><li><code>Select S# From SC Where C# = “001” and Score &lt; some ( Select Score From SC Where C#=&#39;001&#39;);</code>&#x2F;&#x2F;找出001号课成绩不是最高的所有学生的学号</li></ul></li></ul></li></ol><blockquote><p>在SQL标准中，也有θ-Any 谓词，但由于其语义的模糊性：any, “任一”是指所有呢？还是指某一个？不清楚，所以被θ-Some替代以求更明晰。</p></blockquote><ol start="2"><li>等价性变换需要注意<ul><li><code>表达式 = some (子查询)</code>和<code>表达式 in (子查询)</code>含义<strong>相同</strong></li><li><code>表达式 &lt;&gt; some (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>不同</strong></li><li><code>表达式 &lt;&gt; all (子查询)</code>和<code>表达式 not in (子查询)</code>含义<strong>相同</strong></li></ul></li></ol><h4 id="7-3-NOT-EXISTS子查询"><a href="#7-3-NOT-EXISTS子查询" class="headerlink" title="7.3 (NOT) EXISTS子查询"></a>7.3 (NOT) EXISTS子查询</h4><ol><li>基本语法：<code>[not] Exists [not] Exists (子查询)</code><ul><li>语义：子查询结果中有无元组存在</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：检索选修了赵三老师主讲课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SC, Course, Teacher</span><br><span class="line">        <span class="keyword">Where</span> SC.C#<span class="operator">=</span>Course.C# <span class="keyword">and</span> SC. S#<span class="operator">=</span>Student.S#</span><br><span class="line">        <span class="keyword">and</span> Course.T# <span class="operator">=</span> Teacher.T# <span class="keyword">and</span> Tname<span class="operator">=</span><span class="string">&#x27;赵三&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--示例：检索学过001号教师主讲的所有课程的所有同学的姓名</span></span><br><span class="line"><span class="keyword">Select</span> Sname <span class="keyword">From</span> Student</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>不存在</span><br><span class="line">        ( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> Course <span class="operator">/</span><span class="operator">/</span>有一门<span class="number">001</span>教师主讲课程</span><br><span class="line">        <span class="keyword">Where</span> Course.T# <span class="operator">=</span> ‘<span class="number">001</span>’ <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> <span class="operator">/</span><span class="operator">/</span>该同学没学过</span><br><span class="line">            ( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SC</span><br><span class="line">            <span class="keyword">Where</span> S# <span class="operator">=</span> Student.S# <span class="keyword">and</span> C# <span class="operator">=</span> Course.C#));</span><br><span class="line"><span class="comment">--上述语句的意思：不存在有一门001号教师主讲的课程该同学没学过</span></span><br></pre></td></tr></table></figure><h3 id="8-SQL语言-结果计算与聚集计算"><a href="#8-SQL语言-结果计算与聚集计算" class="headerlink" title="8. SQL语言-结果计算与聚集计算"></a>8. SQL语言-结果计算与聚集计算</h3><h4 id="8-1-结果计算"><a href="#8-1-结果计算" class="headerlink" title="8.1 结果计算"></a>8.1 结果计算</h4><p>Select-From-Where语句中，Select子句后面不仅可是列名，而且可是一些计算表达式或聚集函数，表明在投影的同时直接进行一些运算</p><ul><li><code>Select Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ] From 表名1 [, 表名2 … ] [ Where Where 检索条件 ];</code><ul><li>expr可以是常量、列名、或由常量、列名、特殊函数及算术运算符构成的算术运算式。特殊函数的使用需结合各自DBMS的说明书</li><li>agfunc()是一些聚集函数</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求有差额(差额&gt;0)的任意两位教师的薪水差额</span></span><br><span class="line"><span class="keyword">Select</span> T1.Tname <span class="keyword">as</span> TR1, T2.Tname <span class="keyword">as</span> TR2, T1.Salary – T2.Salary</span><br><span class="line">    <span class="keyword">From</span> Teacher T1, Teacher T2</span><br><span class="line">    <span class="keyword">Where</span> T1.Salary <span class="operator">&gt;</span> T2.Salary;</span><br></pre></td></tr></table></figure><h4 id="8-2-聚集函数"><a href="#8-2-聚集函数" class="headerlink" title="8.2 聚集函数"></a>8.2 聚集函数</h4><p>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc, 分别是：COUNT、SUM、AVG、MAX、MIN</p><table><thead><tr><th>聚合函数</th><th>支持的数据类型</th><th>描述</th></tr></thead><tbody><tr><td>count()</td><td>任何类型&#x2F;*</td><td>计算结果集中的总行数</td></tr><tr><td>sum()</td><td>Numeric</td><td>计算指定列中所有非空值的总和</td></tr><tr><td>avg()</td><td>numeric</td><td>计算指定列中所有非空值的平均值</td></tr><tr><td>max()</td><td>char&#x2F;numeric</td><td>返回指定列中最大值</td></tr><tr><td>min()</td><td>char&#x2F;numeric</td><td>返回指定列中最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：求教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="built_in">Sum</span>(Salary) <span class="keyword">From</span> Teacher;</span><br><span class="line"><span class="comment">--示例：求计算机系教师的工资总额</span></span><br><span class="line"><span class="keyword">Select</span> <span class="built_in">Sum</span>(Salary) <span class="keyword">From</span> Teacher T, Dept</span><br><span class="line">    <span class="keyword">Where</span> Dept.Dname <span class="operator">=</span> ‘计算机’ <span class="keyword">and</span> Dept.D# <span class="operator">=</span> T.D#;</span><br><span class="line"><span class="comment">--示例：求数据库课程的平均成绩</span></span><br><span class="line"><span class="keyword">Select</span> <span class="built_in">AVG</span>(Score) <span class="keyword">From</span> Course C, SC</span><br><span class="line">    <span class="keyword">Where</span> C.Cname <span class="operator">=</span> ‘数据库’ <span class="keyword">and</span> C.C# <span class="operator">=</span> SC.C#;</span><br></pre></td></tr></table></figure><h3 id="9-SQL语言-分组查询与分组过滤"><a href="#9-SQL语言-分组查询与分组过滤" class="headerlink" title="9. SQL语言-分组查询与分组过滤"></a>9. SQL语言-分组查询与分组过滤</h3><h4 id="9-1-分组查询"><a href="#9-1-分组查询" class="headerlink" title="9.1 分组查询"></a>9.1 分组查询</h4><p>分组：SQL可以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，同时处理多个组或集合的聚集运算。</p><ol><li><p>分组的基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 <span class="operator">|</span> expr <span class="operator">|</span> agfunc(列名) [[, 列名 <span class="operator">|</span> expr <span class="operator">|</span> agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 ] ;</span><br></pre></td></tr></table></figure></li><li><p>分组条件可以是：<code>列名1, 列名2, …</code></p></li><li><p>示例： 求每一个学生的平均成绩</p><ul><li><code>Select S#, AVG(Score) From SC Group by S#;</code></li></ul></li></ol><h4 id="9-2-分组过滤"><a href="#9-2-分组过滤" class="headerlink" title="9.2 分组过滤"></a>9.2 分组过滤</h4><p>聚集函数是不允许用于Where子句中的：Where子句是对每一元组进行条件过滤，而不是对集合进行条件过滤</p><ul><li>分组过滤：若要对集合(即分组)进行条件过滤，即满足条件的集合&#x2F;分组留下，不满足条件的集合&#x2F;分组剔除。</li><li>Having子句，又称分组过滤子句。需要有Group by子句支持，换句话说，没有Group by子句，便不能有Having子句。</li></ul><ol><li><p>基本语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 <span class="operator">|</span> expr <span class="operator">|</span> agfunc(列名) [[, 列名 <span class="operator">|</span> expr <span class="operator">|</span> agfunc(列名) ] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [, 表名<span class="number">2</span> … ]</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ]</span><br><span class="line">    [ <span class="keyword">Group</span> <span class="keyword">by</span> <span class="keyword">Group</span> <span class="keyword">by</span> 分组条件 [ <span class="keyword">Having</span> <span class="keyword">Having</span> 分组过滤条件] ] ;</span><br></pre></td></tr></table></figure></li><li><p>示例：求不及格课程超过两门的同学的学号</p><ul><li><code>Select S# From SC Where Score&lt;60 Group by S# Having Count(*)&gt;2;</code></li></ul></li></ol><h4 id="9-3-where子句与having子句的区别"><a href="#9-3-where子句与having子句的区别" class="headerlink" title="9.3 where子句与having子句的区别"></a>9.3 where子句与having子句的区别</h4><ol><li>聚合函数是比较where、having 的关键。在from后面的执行顺序：<ul><li><code>where -&gt; 聚合函数(sum,min,max,avg,count) -&gt;having</code></li></ul></li><li>列出group by来比较二者:<ul><li>where子句：是在分组之前使用，表示从所有数据中筛选出部分数据，以完成分组的要求，在where子句中不允许使用统计函数，没有group by子句也可以使用。</li><li>having子句：是在分组之后使用的，表示对分组统计后的数据执行再次过滤，可以使用统计函数，有group by子句之后才可以出现having子句。</li></ul></li></ol><blockquote><p>注意事项 ： </p><ol><li>where 后不能跟聚合函数，因为where执行顺序大于聚合函数。 </li><li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，条件中不能包含聚组函数，使用where条件显示特定的行。 </li><li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件显示特定的组，也可以使用多个分组标准进行分组。</li></ol></blockquote><h3 id="10-SQL语言实现关系代数操作"><a href="#10-SQL语言实现关系代数操作" class="headerlink" title="10. SQL语言实现关系代数操作"></a>10. SQL语言实现关系代数操作</h3><p>SQL语言：并运算UNION, 交运算INTERSECT, 差运算EXCEPT。</p><ul><li>基本语法形式：<ul><li><code>子查询 &#123;Union [ALL] | Intersect [ALL] | Except [ALL] 子查询&#125;</code></li></ul></li><li>通常情况下自动删除重复元组：不带ALL。若要保留重复的元组，则要带ALL。<ul><li>假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则该元组在：<ul><li>子查询1 Union ALL 子查询2 ，出现m + n次</li><li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li><li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li></ul></li></ul></li></ul><blockquote><p>UNION运算符是Entry-SQL92的一部分, INTERSECT、EXCEPT运算符是Full-SQL92的一部分,它们都是Core-SQL99的一部分，但<strong>有些DBMS并不支持</strong>这些运算，使用时要注意。</p></blockquote><h4 id="10-1-SQL并运算-UNION"><a href="#10-1-SQL并运算-UNION" class="headerlink" title="10.1 SQL并运算(UNION)"></a>10.1 SQL并运算(UNION)</h4><ol><li>示例：已知两个表<ul><li>Customers(Cid, Cname, City, Discnt)</li><li>Agents(Aid, Aname, City, Percent)</li></ul></li><li>求客户所在的或者代理商所在的城市<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Customers</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">Select</span> City <span class="keyword">From</span> Agents;</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-2-SQL交运算-INTERSECT"><a href="#10-2-SQL交运算-INTERSECT" class="headerlink" title="10.2 SQL交运算(INTERSECT)"></a>10.2 SQL交运算(INTERSECT)</h4><ol><li><p>示例：求既学过002号课，又学过003号课的同学学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> S# <span class="keyword">From</span> SC <span class="keyword">Where</span> C# <span class="operator">=</span> ‘<span class="number">002</span>’</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">Select</span> S# <span class="keyword">From</span> SC <span class="keyword">Where</span> C# <span class="operator">=</span> ‘<span class="number">003</span>’;</span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><ul><li><code>Select S# From SC Where C# = ‘002’ and S# IN (Select S# From SC Where C# = ‘003’);</code></li></ul></li><li><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也可以用其他方式表达同样的查询需求。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-3-SQL差运算-EXCEPT"><a href="#10-3-SQL差运算-EXCEPT" class="headerlink" title="10.3 SQL差运算(EXCEPT)"></a>10.3 SQL差运算(EXCEPT)</h4><ol><li><p>示例： 假定所有学生都有选课，求没学过002号课程的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S# <span class="keyword">From</span> SC</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">Select</span> S# <span class="keyword">From</span> SC <span class="keyword">Where</span> C# <span class="operator">=</span> ‘<span class="number">002</span>’;</span><br></pre></td></tr></table></figure></li><li><p>上述语句也可采用如下不用INTERSECT的方式来进行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">DISTINCT</span> S# <span class="keyword">From</span> SC SC1</span><br><span class="line">    <span class="keyword">Where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> SC</span><br><span class="line">        <span class="keyword">Where</span> C# <span class="operator">=</span> ‘<span class="number">002</span>’ <span class="keyword">and</span> S# <span class="operator">=</span> SC1.S#);</span><br></pre></td></tr></table></figure></li><li><p>差运算符Except也没有增强SQL的表达能力，没有Except， SQL也可以用其他方式表达同样的查询需求。只是有了Except更容易表达一些，但增加了SQL语言的不唯一性。</p></li></ol><h4 id="10-4-空值的处理"><a href="#10-4-空值的处理" class="headerlink" title="10.4 空值的处理"></a>10.4 空值的处理</h4><p>空值是其值不知道、不确定、不存在的值；数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p><ol><li>在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来标记，使用特殊的空值检测函数来获得某列的值是否为空值。</li><li>空值检测：<ul><li><code>is [not ] null</code> &#x2F;&#x2F;测试指定列的值是否为空值</li></ul></li><li>示例：找出年龄值为空的学生姓名<ul><li><code>Select Sname From Student Where Sage is null;</code></li></ul></li><li>现行DBMS的空值处理小结<ul><li>除is [not] null之外，空值不满足任何查找条件</li><li>如果null参与算术运算，则该算术表达式的值为null</li><li>如果null参与比较运算，则结果可视为false。在SQL-92中可看成unknown</li><li>如果null参与聚集运算，则除count(*)之外其它聚集函数都忽略null</li></ul></li></ol><h4 id="10-5-内连接、外连接"><a href="#10-5-内连接、外连接" class="headerlink" title="10.5 内连接、外连接"></a>10.5 内连接、外连接</h4><ol><li>标准SQL语言中连接运算通常为：<ul><li><code>Select Select 列名[[,列名]… ] From 表名1,表名2,… Where 检索条件;</code></li><li>即相当于采用<code>Π[列名,…,列名](σ 检索条件(表名1 × 表名2 × …))</code>。</li></ul></li><li>SQL的高级语法中引入了内连接与外连接运算，具体形式：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Select</span> 列名 [ [, 列名] … ]</span><br><span class="line">    <span class="keyword">From</span> 表名<span class="number">1</span> [<span class="keyword">NATURAL</span>]</span><br><span class="line">    [ <span class="keyword">INNER</span> <span class="operator">|</span> &#123; <span class="keyword">LEFT</span> <span class="operator">|</span> <span class="keyword">RIGHT</span> <span class="operator">|</span> <span class="keyword">FULL</span>&#125; [<span class="keyword">OUTER</span>]] <span class="keyword">JOIN</span> 表名<span class="number">2</span></span><br><span class="line">    &#123; <span class="keyword">ON</span> 连接条件 <span class="operator">|</span> <span class="keyword">Using</span> (Colname &#123;, Colname …&#125;) &#125;</span><br><span class="line">    [ <span class="keyword">Where</span> <span class="keyword">Where</span> 检索条件 ] … ;</span><br></pre></td></tr></table></figure></li><li>由 <strong>连接类型</strong> 和 <strong>连接条件</strong> 构成连接运算。<ul><li>**<code>Natural</code>**：出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li><li><strong><code>Inner Join</code></strong>: 即关系代数中的θ-连接运算</li><li><strong><code>Left Outer Join, Right Outer Join, Full Outer Join</code></strong>: 即关系代数中的外连接运算</li><li>**<code>on &lt;连接条件&gt;</code>**：出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li><li>**<code>using (Col1, Col2, …, Coln)</code>**：Col是两个连接关系的公共属性的子集，元组在(Col1,Col2,…,Coln)上取值相等，且(Col1,Col2,…,Coln)只出现一次</li></ul></li><li>示例:</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (Inner Join)求所有教师的任课情况并按教师号排序(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher.T#, Tname, Cname</span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Inner</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T# <span class="operator">=</span> Course.T#</span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T# <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--(Outer Join)求所有教师的任课情况(没有任课的教师也需列在表中)</span></span><br><span class="line"><span class="keyword">Select</span> Teacher. T#, Tname, Cname</span><br><span class="line">    <span class="keyword">From</span> Teacher <span class="keyword">Left</span> <span class="keyword">Outer</span> <span class="keyword">Join</span> Course</span><br><span class="line">        <span class="keyword">ON</span> Teacher.T# <span class="operator">=</span> Course.T#</span><br><span class="line">    <span class="keyword">Order</span> <span class="keyword">by</span> Teacher.T# <span class="keyword">ASC</span> ;</span><br></pre></td></tr></table></figure><h3 id="11-SQL语言之视图及其应用"><a href="#11-SQL语言之视图及其应用" class="headerlink" title="11. SQL语言之视图及其应用"></a>11. SQL语言之视图及其应用</h3><ol><li>数据库的三级模式两层映像<ul><li>三级模式：数据库系统是由外模式、模式(概念模式)和内模式三级构成</li><li>应用–&gt; <strong>外模式</strong>(多个) –&gt; <strong>概念模式</strong>(一个) –&gt; <strong>内模式</strong>(一个) –&gt; 数据库</li><li>两层映像：<code>E-C</code>映像(外模式-&gt;概念模式)、<code>C-I</code>映像(概念模式-&gt;内模式)。</li></ul></li><li>对应概念模式的数据在SQL中被称为<strong>基本表(Table)</strong>, 而对应外模式的数据称为<strong>视图(View)<strong>。</strong>视图不仅包含外模式，而且包含其E-C映像</strong>。</li><li><strong>基本表</strong>是实际存储于存储文件中的表，基本表中的<strong>数据是需要存储的</strong></li><li><strong>视图</strong>在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，其<strong>数据并不存储</strong>，而是在运行过程中动态产生与维护的</li><li>对视图数据的更改最终要反映在对基本表的更改上。</li></ol><h4 id="11-1-视图的定义"><a href="#11-1-视图的定义" class="headerlink" title="11.1 视图的定义"></a>11.1 视图的定义</h4><p>视图需要“先定义，再使用”；定义视图，有时可方便用户进行检索操作。</p><ol><li>定义视图: <code>create view view_name [(列名[列名] …)] as 子查询 [with check option]</code><ul><li>如果视图的属性名缺省，则默认为子查询结果中的属性名；也可以显式指明其所拥有的列名。</li><li>with check option指明当对视图进行insert，update，delete时，要检查进行insert&#x2F;update&#x2F;delete的元组是否满足视图定义中子查询中定义的条件表达式</li></ul></li><li>示例：定义一个视图 CompStud 为计算机系的学生，通过该视图可以将Student表中其他系的学生屏蔽掉<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">View</span> CompStud <span class="keyword">AS</span></span><br><span class="line">    (<span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> Student</span><br><span class="line">        <span class="keyword">Where</span> D# <span class="keyword">in</span> (<span class="keyword">Select</span> D# <span class="keyword">From</span> Dept</span><br><span class="line">            <span class="keyword">Where</span> Dname <span class="operator">=</span> ‘计算机’));</span><br></pre></td></tr></table></figure></li></ol><h4 id="11-2-视图的使用"><a href="#11-2-视图的使用" class="headerlink" title="11.2 视图的使用"></a>11.2 视图的使用</h4><p>使用视图：定义好的视图，可以像Table一样，在SQL各种语句中使用</p><ul><li>示例：检索计算机系的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud;</code></li></ul></li><li>示例：检索计算机系的年龄小于20的所有学生，我们可使用CompStud<ul><li><code>Select * From CompStud Where Sage&lt;20;</code></li></ul></li></ul><h4 id="11-3-视图的更新"><a href="#11-3-视图的更新" class="headerlink" title="11.3 视图的更新"></a>11.3 视图的更新</h4><p>SQL视图更新：是比较复杂的问题，因视图不保存数据，对视图的更新最终要反映到对基本表的更新上，而有时，视图定义的映射不是可逆的。</p><ol><li>SQL视图更新的可执行性<ul><li>如果视图的select目标列包含聚集函数，则不能更新</li><li>如果视图的select子句使用了unique或distinct，则不能更新</li><li>如果视图中包括了group by子句，则不能更新</li><li>如果视图中包括经算术表达式计算出来的列，则不能更新</li><li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li></ul></li><li>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选择、投影操作导出的，并且包含了基本表的主键，则可以更新</li><li>可更新SQL视图示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CStud(S#, Sname, Sclass)</span><br><span class="line"><span class="keyword">as</span> ( <span class="keyword">select</span> S#, Sname, Sclass <span class="keyword">from</span> Student <span class="keyword">where</span> D# <span class="operator">=</span><span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"><span class="comment">-- 更新视图</span></span><br><span class="line"><span class="keyword">Insert</span> <span class="keyword">into</span> CStud <span class="keyword">Values</span> (<span class="string">&#x27;98030104&#x27;</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="string">&#x27;980301&#x27;</span>);</span><br><span class="line"><span class="comment">-- 更新视图 将转换为 更新基本表</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Student <span class="keyword">values</span> (<span class="string">&#x27;98030104&#x27;</span>, <span class="string">&#x27;张三丰&#x27;</span>, <span class="keyword">Null</span>, <span class="keyword">Null</span>, <span class="string">&#x27;03&#x27;</span>, <span class="string">&#x27;980301&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="11-4-视图的撤销"><a href="#11-4-视图的撤销" class="headerlink" title="11.4 视图的撤销"></a>11.4 视图的撤销</h4><p>已经定义的视图也可以撤消</p><ul><li>撤消视图：<code>Drop View view_name</code></li></ul><p>不仅视图可以撤消，基本表、数据库等都可以撤消</p><ul><li>撤消基本表：<code>Drop Table 表名</code></li></ul><h3 id="12-数据库完整性"><a href="#12-数据库完整性" class="headerlink" title="12. 数据库完整性"></a>12. 数据库完整性</h3><p>数据库完整性(DB Integrity)是指：DBMS应保证的DB的一种特性–在任何情况下的正确性、有效性和一致性</p><ul><li>广义完整性：语义完整性、并发控制、安全控制、DB故障恢复等</li><li>狭义完整性：专指语义完整性，DBMS通常有专门的完整性管理机制与程序来处理语义完整性问题。</li></ul><h4 id="12-1-基本概念"><a href="#12-1-基本概念" class="headerlink" title="12.1 基本概念"></a>12.1 基本概念</h4><p>关系模型中有完整性要求：实体完整性、参照完整性、用户自定义完整性</p><ol><li>数据库完整性管理的作用<ul><li>防止和避免数据库中不合理数据的出现</li><li>DBMS应尽可能地自动防止DB中语义不合理现象</li><li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li></ul></li><li>DBMS怎样自动保证完整性：<ul><li>DBMS允许用户定义一些完整性约束规则(用SQL-DDL来定义)</li><li>当有DB更新操作时，DBMS自动按照完整性约束条件进行检查，以确保更新操作符合语义完整性</li></ul></li><li><strong>完整性约束条件</strong>(或称完整性约束规则)的一般形式：Integrity Constraint::&#x3D;(O,P,A,R)<ul><li>O：数据集合：约束的对象(列、多列(元组)、元组集合)</li><li>P：谓词条件：需要定义什么样的约束</li><li>A：触发条件：默认更新时检查</li><li>R：响应动作：默认拒绝</li></ul></li></ol><h4 id="12-2-数据库完整性的分类"><a href="#12-2-数据库完整性的分类" class="headerlink" title="12.2 数据库完整性的分类"></a>12.2 数据库完整性的分类</h4><ol><li><p>按约束对象分类:</p><ul><li>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</li><li>关系完整性约束条件：施加于关系&#x2F;table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</li></ul></li><li><p>按约束来源分类:</p><ul><li>结构约束：来自于模型的约束，例如函数依赖约束、主键约束(实体完整性)、外键约束(参照完整性)，只关心数值相等与否、是否允许空值等；</li><li>内容约束：来自于用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等。</li></ul></li><li><p>按约束状态分类:</p><ul><li>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150(假定人活最大年龄是150)。</li><li>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元。</li></ul></li></ol><h3 id="13-数据库的静态完整性-约束"><a href="#13-数据库的静态完整性-约束" class="headerlink" title="13. 数据库的静态完整性(约束)"></a>13. 数据库的静态完整性(约束)</h3><ol><li><p>SQL语言支持的约束类别：</p><ul><li>静态约束<ul><li>列完整性—域完整性约束</li><li>表完整性–关系完整性约束</li></ul></li><li>动态约束<ul><li>触发器</li></ul></li></ul></li><li><p>Create Table有三种功能：定义关系模式、定义完整性约束 和定义物理存储特性</p><ul><li>定义完整性约束条件：列完整性、表完整性</li></ul></li><li><p>列约束：一种<strong>域约束类型</strong>，对单一列的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span>                  <span class="operator">/</span><span class="operator">/</span>列值非空</span><br><span class="line">[ <span class="keyword">CONSTRAINT</span> constraintname ] <span class="operator">/</span><span class="operator">/</span>为约束命名，便于以后撤消</span><br><span class="line">&#123; <span class="keyword">UNIQUE</span>                      <span class="operator">/</span><span class="operator">/</span>列值是唯一</span><br><span class="line"><span class="operator">|</span> <span class="keyword">PRIMARY</span> KEY                 <span class="operator">/</span><span class="operator">/</span>列为主键</span><br><span class="line"><span class="operator">|</span> <span class="keyword">CHECK</span> (search_cond)         <span class="operator">/</span><span class="operator">/</span>列值满足条件,条件只能使用列当前值</span><br><span class="line"><span class="operator">|</span> <span class="keyword">REFERENCES</span> tablename [(colname) ]</span><br><span class="line">[<span class="keyword">ON</span> <span class="keyword">DELETE</span> &#123; CASCADE <span class="operator">|</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> &#125; ] &#125; &#125; </span><br></pre></td></tr></table></figure></li><li><p>表约束：一种<strong>关系约束类型</strong>，对多列或元组的值进行约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">CONSTRAINT</span> constraintname ]       <span class="operator">/</span><span class="operator">/</span>为约束命名，便于以后撤消</span><br><span class="line">&#123; <span class="keyword">UNIQUE</span> (colname &#123;,colname…&#125;)      <span class="operator">/</span><span class="operator">/</span>几列值组合在一起是唯一</span><br><span class="line"><span class="operator">|</span> <span class="keyword">PRIMARY</span> KEY (colname &#123;,colname…&#125;) <span class="operator">/</span><span class="operator">/</span>几列联合为主键</span><br><span class="line"><span class="operator">|</span> <span class="keyword">CHECK</span> (search_condition)          <span class="operator">/</span><span class="operator">/</span>元组多列值共同满足条件</span><br><span class="line">                                    <span class="operator">/</span><span class="operator">/</span>条件中只能使用同一元组的不同列当前值</span><br><span class="line"><span class="operator">|</span> <span class="keyword">FOREIGN</span> KEY (colname &#123;,colname…&#125;)</span><br><span class="line"><span class="keyword">REFERENCES</span> tablename [(colname &#123;,colname…&#125;)]<span class="operator">/</span><span class="operator">/</span>引用另一表tablename的若干列的值作为外键</span><br></pre></td></tr></table></figure><blockquote><p>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</p></blockquote></li><li><p>Create Table中定义的表约束或列约束可以在以后根据需要进行撤消或追加。撤消或追加约束的语句是 Alter Table(不同系统可能有差异)</p><ul><li>示例：撤消SC表的ctscore约束(由此可见，未命名的约束是不能撤消)<ul><li><code>Alter Table SC DROP CONSTRAINT ctscore;</code></li></ul></li><li>有些DBMS支持独立的追加约束, 注意书写格式可能有些差异<ul><li>示例：<code>Alter Table SC Add Constraint nctscore check (Score&gt;=0.0 and Score&lt;=150.0));</code></li></ul></li></ul></li><li><p>现约束的方法-断言ASSERTION</p><ul><li>一个断言就是一个谓词表达式，它表达了希望数据库总能满足的条件</li><li>表约束和列约束就是一些特殊的断言</li><li>SQL还提供了复杂条件表达的断言。其语法形式为：<ul><li><code>CREATE ASSERTION &lt;assertion-name&gt; CHECK &lt;predicate&gt;</code></li></ul></li><li>当一个断言创建后，系统将检测其有效性，并在每一次更新中测试更新是否违反该断言。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例: “每个分行的贷款总量必须小于该分行所有账户的余额总和”</span></span><br><span class="line"><span class="keyword">create</span> assertion sum_constraint <span class="keyword">check</span></span><br><span class="line">    (<span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> branch</span><br><span class="line">    <span class="keyword">where</span> (<span class="keyword">select</span> <span class="built_in">sum</span>(amount ) <span class="keyword">from</span> loan</span><br><span class="line">        <span class="keyword">where</span> loan.branch_name <span class="operator">=</span> branch.branch_name )</span><br><span class="line">    <span class="operator">&gt;=</span> (<span class="keyword">select</span> <span class="built_in">sum</span> (balance ) <span class="keyword">from</span> account</span><br><span class="line">        <span class="keyword">where</span> account.branch_name <span class="operator">=</span> branch.branch_name )))</span><br><span class="line"><span class="comment">-- 数据表：</span></span><br><span class="line">account(branch_name, account_number,…, balance) <span class="operator">/</span><span class="operator">/</span>分行，账户及其余额</span><br><span class="line">loan(branch_name , loan_number, amount,) <span class="operator">/</span><span class="operator">/</span>分行的每一笔贷款</span><br><span class="line">branch(branch_name, … ) <span class="operator">/</span><span class="operator">/</span>分行</span><br></pre></td></tr></table></figure><blockquote><p>断言测试增加了数据库维护的负担，要小心使用复杂的断言。</p></blockquote><h3 id="14-数据库的动态完整性-触发器"><a href="#14-数据库的动态完整性-触发器" class="headerlink" title="14. 数据库的动态完整性(触发器)"></a>14. 数据库的动态完整性(触发器)</h3><p>实现数据库动态完整的方法—触发器Trigger</p><ol><li><p>触发器Trigger</p><ul><li>Create Table中的表约束和列约束基本上都是静态的约束，也基本上都是对单一列或单一元组的约束(尽管有参照完整性)，为实现动态约束以及多个元组之间的完整性约束，就需要触发器技术Trigger</li><li>Trigger是一种过程完整性约束(相比之下，Create Table中定义的都是非过程性约束),是一段程序，该程序可以在特定的时刻被自动触发执行，比如在一次更新操作之前执行，或在更新操作之后执行。</li></ul></li><li><p>基本语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name BEFORE <span class="operator">|</span> AFTER</span><br><span class="line">    &#123; <span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> colname &#123;, colname...&#125;] &#125;</span><br><span class="line">    <span class="keyword">ON</span> tablename [<span class="keyword">REFERENCING</span> corr_name_def &#123;, corr_name_def...&#125; ]</span><br><span class="line">    [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="operator">|</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT]</span><br><span class="line">                <span class="operator">/</span><span class="operator">/</span>对更新操作的每一条结果(前者)，或整个更新操作完成(后者)</span><br><span class="line">    [<span class="keyword">WHEN</span> (search_condition)]           <span class="operator">/</span><span class="operator">/</span>检查条件，如满足执行下述程序</span><br><span class="line">    &#123; statement         <span class="operator">/</span><span class="operator">/</span>单行程序直接书写，多行程序要用下行方式</span><br><span class="line">    <span class="operator">|</span> <span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span> statement; &#123; statement;...&#125; <span class="keyword">END</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>触发器Trigger意义：</p><ul><li>当某一事件发生时(Before|After),对该事件产生的结果(或是每一元组，或是整个操作的所有元组), 检查条件<code>search_condition</code>,如果满足条件，则执行后面的程序段。条件或程序段中引用的变量可用<code>corr_name_def</code>来限定。</li></ul></li><li><p>事件：BEFORE | AFTER { INSERT | DELETE | UPDATE …}</p><ul><li>当一个事件(Insert, Delete, 或Update)发生之前Before或发生之后After触发</li><li>操作发生，执行触发器操作需处理两组值：更新前的值和更新后的值，这两个值由<code>corr_name_def</code>的使用来区分</li></ul></li><li><p><code>corr_name_def</code>的定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">OLD</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] old_row_corr_name <span class="operator">/</span><span class="operator">/</span>更新前的旧元组命别名为</span><br><span class="line"><span class="operator">|</span> <span class="keyword">NEW</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] new_row_corr_name <span class="operator">/</span><span class="operator">/</span>更新后的新元组命别名为</span><br><span class="line"><span class="operator">|</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] old_table_corr_name <span class="operator">/</span><span class="operator">/</span>更新前的旧<span class="keyword">Table</span>命别名为</span><br><span class="line"><span class="operator">|</span> <span class="keyword">NEW</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] new_table_corr_name <span class="operator">/</span><span class="operator">/</span>更新后的新<span class="keyword">Table</span>命别名为</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>corr_name_def</code>将在检测条件或后面的动作程序段中被引用处理</p></blockquote></li><li><p>示例1: 设计一个触发器当进行Teacher表更新元组时, 使其工资只能升不能降</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> teacher_chgsal before <span class="keyword">update</span> <span class="keyword">of</span> salary</span><br><span class="line">    <span class="keyword">on</span> teacher</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> x, <span class="keyword">old</span> y</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span> <span class="keyword">when</span> (x.salary <span class="operator">&lt;</span> y.salary)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    raise_application_error(<span class="number">-20003</span>, <span class="string">&#x27;invalid salary on update&#x27;</span>);</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span>此条语句为Oracle的错误处理函数</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例2: 假设student(S#, Sname, SumCourse), SumCourse为该同学已学习课程的门数，初始值为0，以后每选修一门都要对其增1 。设计一个触发器自动完成上述功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> sumc after <span class="keyword">insert</span> <span class="keyword">on</span> sc</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">new</span> <span class="type">row</span> newi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> SumCourse <span class="operator">=</span> SumCourse <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span> S# <span class="operator">=</span> :newi.S# ;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></li><li><p>示例3：假设student(S#, Sname, SumCourse), 当删除某一同学S#时，该同学的所有选课也都要删除。设计一个触发器完成上述功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delS# after <span class="keyword">delete</span> <span class="keyword">on</span> Student</span><br><span class="line">    <span class="keyword">referencing</span> <span class="keyword">old</span> oldi</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> sc <span class="keyword">where</span> S# <span class="operator">=</span> :oldi.S# ;</span><br><span class="line"><span class="keyword">end</span>; </span><br></pre></td></tr></table></figure></li></ol><h3 id="15-数据库索引"><a href="#15-数据库索引" class="headerlink" title="15. 数据库索引"></a>15. 数据库索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种<strong>数据结构</strong>（最常见的是B-Tree）</p><ol><li>索引的作用<ol><li>快速取数据；</li><li>保证数据记录的唯一性；</li><li>实现表与表之间的参照完整性；</li><li>在使用ORDER by、group by子句进行数据检索时，利用索引可以减少排序和分组的时间。</li></ol></li><li>创建索引：<code>CREATE INDEX  索引名称  on 表名(字段名);</code></li><li>删除索引：<code>DROP INDEX 索引名称</code></li><li>索引注意事项：<ol><li>查询时减少使用<code>*</code>返回全部列，不要返回不需要的列</li><li>where表达式子句包含索引的表达式置前</li><li>避免在Order by中使用表达式</li><li>索引技术是数据库自动使用，一个表格只存在一个索引就够了</li></ol></li><li>缺点<ol><li>索引的缺点是创建和维护索引需要耗费时间和空间</li><li>索引可以提高查询速度，会减慢写入速度</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</li></ol></li></ol><h4 id="15-1-索引主要种类"><a href="#15-1-索引主要种类" class="headerlink" title="15.1 索引主要种类"></a>15.1 索引主要种类</h4><p>根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。提示：尽管唯一索引有助于定位信息，但为获得最佳性能结果，建议改用主键或唯一约束。</p><ol><li>唯一索引<ul><li>唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。</li></ul></li><li>主键索引<ul><li>数据库表经常有一列或多列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。</li></ul></li><li>聚集索引<ul><li>在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。聚集索引和非聚集索引的区别，如字典默认按字母顺序排序，读者如知道某个字的读音可根据字母顺序快速定位。因此聚集索引和表的内容是在一起的。如读者需查询某个生僻字，则需按字典前面的索引，举例按偏旁进行定位，找到该字对应的页数，再打开对应页数找到该字。这种通过两个地方而查询到某个字的方式就如非聚集索引。</li></ul></li><li>索引列<ul><li>可以基于数据库表中的单列或多列创建索引。多列索引可以区分其中一列可能有相同值的行。如果经常同时搜索两列或多列或按两列或多列排序时，索引也很有帮助。例如，如果经常在同一查询中为姓和名两列设置判据，那么在这两列上创建多列索引将很有意义。</li></ul></li></ol><h3 id="16-数据库序列"><a href="#16-数据库序列" class="headerlink" title="16. 数据库序列"></a>16. 数据库序列</h3><p>序列(SEQUENCE)是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。创建序列需要<code>CREATE SEQUENCE</code>系统权限。</p><h4 id="16-1-Oracle中的序列（Sequence）"><a href="#16-1-Oracle中的序列（Sequence）" class="headerlink" title="16.1 Oracle中的序列（Sequence）"></a>16.1 Oracle中的序列（Sequence）</h4><ol><li><p>创建序列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> sequence 序列名 </span><br><span class="line">    [increment <span class="keyword">by</span> n]   <span class="comment">--每次增加n个，默认为1</span></span><br><span class="line">    [<span class="keyword">start</span> <span class="keyword">with</span> n]     <span class="comment">--起始值n，默认为1</span></span><br><span class="line">    [&#123;maxvalue n <span class="operator">|</span> nomaxvalue&#125;]  <span class="comment">--最大值设置，递增默认10的27次方，递减默认-1</span></span><br><span class="line">    [&#123;minvalue n <span class="operator">|</span> nominvalue&#125;]  <span class="comment">--最小值设置，递增默认1，递减默认-10的26次方</span></span><br><span class="line">    [&#123;<span class="keyword">cycle</span> <span class="operator">|</span> nocycle&#125;]   <span class="comment">--是否循环</span></span><br><span class="line">    [&#123;cache n <span class="operator">|</span> nocache&#125;] <span class="comment">--是否对序列进行内存缓冲，默认为20</span></span><br></pre></td></tr></table></figure></li><li><p>查询序列</p><ul><li><code>NEXTVAL</code>:返回序列中下一个有效的值，任何用户都可以引用。</li><li><code>CURRVAL</code>:中存放序列的当前值,NEXTVAL 应在 CURRVAL 之前指定 ，二者应同时有效。</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询下一个将要使用的序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.nextval <span class="keyword">from</span> dual</span><br><span class="line"><span class="comment">--查询当前序列</span></span><br><span class="line"><span class="keyword">select</span> 序列名.currval <span class="keyword">from</span> dual </span><br></pre></td></tr></table></figure><blockquote><ul><li>Oracle将sequence的定义存储在数据字典之中。</li><li>Sequence是独立于事务的，就是说序列的增加不需要等待事务的完成，也就是说序列是异步于事务而增长的。这说明，你访问不到别的用户使用该sequence产生的值，也就是说你只能访问到你当前产生的值，即使其他用户已经增加了sequence的值；还说明如果事务回滚，sequence不会回滚，它所发生的改变是一维的。</li></ul></blockquote><ol start="3"><li>删除序列：<code>Drop sequence 序列名</code></li><li>更改序列：<code>Alter sequence 序列名 [其余参数同创建序列]</code></li><li>使用序列示例：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.直接使用</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person (id, name, password) <span class="keyword">values</span> (序列名.nextval, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.也可以通过建立触发器，当有数据插入表person时，使用oracle序列为其去的递增的主键值</span></span><br><span class="line"><span class="comment">-- 2.1创建触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">trigger</span> 触发器名 before <span class="keyword">insert</span> <span class="keyword">on</span> person</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> 序列名.nextval <span class="keyword">into</span> :new.id <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 2.2插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person ( username, age, password) <span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;zhang123&#x27;</span>)</span><br></pre></td></tr></table></figure><ol start="6"><li>注意点：<ul><li>一个序列可以被多张别使用，不过一般建议为每个表建立单独的序列。</li><li>当使用到序列的事务发生回滚。会造成序列号不连续。在用生成的序列值作为编号做插入数据库操作时，可能遇到事务提交失败，从而导致序号不连续。</li><li>大量语句发生请求，申请序列时，为了避免序列在运用层实现序列而引起的性能瓶颈。Oracle序列允许将序列提前生成 n个先存入内存，在发生大量申请序列语句时，可直接到运行最快的内存中去得到序列。但cache个数最好不要设置过大，因为在数据库重启时，会清空内存信息，预存在内存中的序列会丢失，当数据库再次启动后，序列从上次内存中最大的序列号+1 开始存入n个。这种情况也能会在数据库关闭时也会导致序号不连续。</li></ul></li></ol><h4 id="16-2-Mysql中的序列（AUTO-INCREMENT）"><a href="#16-2-Mysql中的序列（AUTO-INCREMENT）" class="headerlink" title="16.2 Mysql中的序列（AUTO_INCREMENT）"></a>16.2 Mysql中的序列（AUTO_INCREMENT）</h4><p>MySQL中最简单使用序列的方法就是使用<code>AUTO_INCREMENT</code>来定义列。</p><ol><li>orale没有类似mysql的AUTO_INCREMENT这样的自增长字段，实现插入一条记录，自动增加1.oracle是通过sequence（序列）来完成的。</li><li>首先mysql的自增长“序列”和序列是两回事，mysql本身不提供序列机制。</li><li>mysql的AUTO_INCREMENT可以设置起始值，但是不能设置步长，其步长默认就是1.</li><li>mysql一个表只能有一个自增长字段。自增长只能被分配给固定表的固定的某一字段，不能被多个表共用。并且只能是数字型。</li></ol><h3 id="17-数据库安全性"><a href="#17-数据库安全性" class="headerlink" title="17. 数据库安全性"></a>17. 数据库安全性</h3><p>数据库安全性是指DBMS应该保证的数据库的一种特性(机制或手段)：免受非法、非授权用户的使用、泄漏、更改或破坏</p><ol><li>数据库安全性管理涉及许多方面<ol><li>社会法律及伦理方面：私人信息受到保护，未授权人员访问私人信息会违法</li><li>公共政策&#x2F;制度方面：例如，政府或组织的信息公开或非公开制度</li><li>安全策略：政府、企业或组织所实施的安全性策略，如集中管理和分散管理，需者方知策略(也称最少特权策略)</li><li>数据的安全级别: 绝密(Top Secret), 机密(Secret),可信(Confidential)和无分类(Unclassified)</li><li>数据库系统DBS的安全级别：物理控制、网络控制、操作系统控制、DBMS控制</li></ol></li><li>DBMS的安全机制<ol><li><strong>自主安全性机制</strong>：存取控制(Access Control)<ul><li>通过权限在用户之间的传递，使用户自主管理数据库安全性</li></ul></li><li><strong>强制安全性机制</strong>：<ul><li>通过对数据和用户强制分类，使得不同类别用户能够访问不同类别的数据</li></ul></li><li>推断控制机制：<ul><li>防止通过历史信息，推断出不该被其知道的信息；</li><li>防止通过公开信息(通常是一些聚集信息)推断出私密信息(个体信息)，通常在一些由个体数据构成的公共数据库中此问题尤为重要</li></ul></li><li>数据加密存储机制：<ul><li>通过加密、解密保护数据，密钥、加密&#x2F;解密方法与传输</li></ul></li></ol></li><li>DBA的责任和义务<ul><li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li><li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应，</li><li><strong>划分好数据的安全级别以及用户的安全级别</strong></li><li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li></ul></li></ol><h3 id="18-数据库自主安全性机制"><a href="#18-数据库自主安全性机制" class="headerlink" title="18. 数据库自主安全性机制"></a>18. 数据库自主安全性机制</h3><ul><li>通常情况下，自主安全性是通过授权机制来实现的。</li><li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作; 同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。<ul><li>授权者：决定用户权利的人</li><li>授权：授予用户访问的权利</li></ul></li></ul><ol><li>DBMS自动实现自主安全性：<ul><li>DBMS允许用户定义一些安全性控制规则(用SQL-DCL来定义)</li><li>当有DB访问操作时，DBMS自动按照安全性控制规则进行检查，检查通过则允许访问，不通过则不允许访问</li></ul></li><li>DBMS将权利和用户(账户)结合在一起，形成一个访问规则表，依据该规则表可以实现对数据库的安全性控制<ul><li><code>AccessRule ::=(S, O, t, P)</code><ul><li>S: 请求主体(用户)</li><li>O: 访问对象</li><li>t: 访问权利</li><li>P: 谓词</li></ul></li><li>{ AccessRule｝通常存放在数据字典或称系统目录中，构成了所有用户对DB的访问权利; </li><li>用户多时，可以按用户组建立访问规则</li><li>访问对象可大可小(目标粒度Object  granularity):属性&#x2F;字段、记录&#x2F;元组、关系、数据库</li><li>权利：包括创建、增、删、改、查等</li><li>谓词：拥有权利需满足的条件</li></ul></li><li><strong>示例</strong>：员工管理数据库的安全性控制示例<code>Employee(P#,Pname,Page,Psex,Psalary,D#,HEAD)</code><ul><li>示例要求：<ul><li>员工管理人员：能访问该数据库的所有内容，便于维护员工信息</li><li>收发人员：访问该数据库以确认某员工是哪一个部门的，便于收发工作，只能访问基本信息，其他信息不允许其访问</li><li>每个员工：允许其访问关于自己的记录，以便查询自己的工资情况，但不能修改</li><li>部门领导：能够查询其所领导部门人员的所有情况</li><li>高层领导：能访问该数据库的所有内容，但只能读</li></ul></li><li>两种控制示例<ul><li>按名控制安全性：存储矩阵</li><li>按内容控制安全性：视图</li></ul></li><li>视图是安全性控制的重要手段</li><li>通过视图可以限制用户对关系中某些数据项的存取, 例如：<ul><li>视图1：Create  EmpV1  as  select   *  from  Employee</li><li>视图2：Create  EmpV2  as  select  Pname, D#  from Employee</li></ul></li><li>通过视图可将数据访问对象与谓词结合起来，限制用户对关系中某些元组的存取，例如：<ul><li>视图1： Create  EmpV3  as  select  *  from  Employee  where P# &#x3D; :UserId</li><li>视图2： Create  EmpV4  as  select  *  from  Employee  where Head &#x3D; :UserId</li></ul></li><li>用户定义视图后，视图便成为一新的数据对象，参与到存储矩阵与能力表中进行描述</li></ul></li></ol><h4 id="18-1-SQL语言的用户与权利"><a href="#18-1-SQL语言的用户与权利" class="headerlink" title="18.1 SQL语言的用户与权利"></a>18.1 SQL语言的用户与权利</h4><ol><li><p>SQL语言包含了DDL, DML和DCL。数据库安全性控制是属于DCL范畴</p></li><li><p>授权机制—自主安全性；视图的运用</p></li><li><p>关系级别(普通用户) &lt;– 账户级别(程序员用户) &lt;– 超级用户(DBA) </p><ul><li>(级别1)Select : 读(读DB, Table, Record, Attribute, … )</li><li>(级别2)Modify : 更新<ul><li>Insert : 插入(插入新元组, … )</li><li>Update : 更新(更新元组中的某些值, …)</li><li>Delete : 删除(删除元组, …)</li></ul></li><li>(级别3)Create : 创建(创建表空间、模式、表、索引、视图等)<ul><li>Create : 创建</li><li>Alter : 更新</li><li>Drop : 删除</li></ul></li></ul></li><li><p>级别高的权利自动包含级别低的权利。如某人拥有更新的权利，它也自动拥有读的权利。在有些DBMS中，将级别3的权利称为账户级别的权利，而将级别1和2称为关系级别的权利。</p></li><li><p>授权命令<code>GRANT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &#123;<span class="keyword">all</span> PRIVILEGES <span class="operator">|</span> privilege &#123;,privilege…&#125;&#125;</span><br><span class="line">    <span class="keyword">ON</span> [<span class="keyword">TABLE</span>] tablename <span class="operator">|</span> viewname</span><br><span class="line">    <span class="keyword">TO</span> &#123;public <span class="operator">|</span> <span class="keyword">user</span><span class="operator">-</span>id &#123;, <span class="keyword">user</span><span class="operator">-</span>id…&#125;&#125;</span><br><span class="line">    [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br></pre></td></tr></table></figure><ul><li>user-id ，某一个用户账户，由DBA创建的合法账户</li><li>public, 允许所有有效用户使用授予的权利</li><li>privilege是下面的权利<ul><li>SELECT | INSERT | UPDATE | DELETE | ALL PRIVILEDGES</li></ul></li><li>WITH GRANT OPTION选项是允许被授权者传播这些权利</li></ul></li><li><p>SQL-DCL的控制安全性-授权示例:</p><ul><li>假定高级领导为Emp0001, 部门领导为Emp0021, 员工管理员为Emp2001,收发员为Emp5001(均为UserId, 也即员工的P#)<ul><li>Grant All Priviledges ON Employee TO Emp2001;</li><li>Grant SELECT ON EmpV2 TO Emp5001;</li><li>Grant SELECT ON EmpV3 TO public;</li><li>Grant SELECT ON EmpV4 TO Emp0021;</li></ul></li><li>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别)</li><li>授权者授予的权利必须是授权者已经拥有的权利</li></ul></li><li><p>收回授权命令<code>REVOKE</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &#123;<span class="keyword">all</span> privilEges <span class="operator">|</span> priv &#123;, priv…&#125; &#125; </span><br><span class="line">    <span class="keyword">ON</span> tablename <span class="operator">|</span> viewname</span><br><span class="line">    <span class="keyword">FROM</span> &#123;public <span class="operator">|</span> <span class="keyword">user</span> &#123;, <span class="keyword">user</span>…&#125; &#125;; </span><br></pre></td></tr></table></figure><ul><li>示例: <code>revoke select on employee from UserB;</code></li></ul></li></ol><h4 id="18-2-自主安全性的授权过程及其问题"><a href="#18-2-自主安全性的授权过程及其问题" class="headerlink" title="18.2 自主安全性的授权过程及其问题"></a>18.2 自主安全性的授权过程及其问题</h4><h5 id="18-2-1-授权过程"><a href="#18-2-1-授权过程" class="headerlink" title="18.2.1 授权过程:"></a>18.2.1 授权过程:</h5><ol><li>第一步：DBA创建DB, 并为每一个用户创建一个账户<ul><li>假定建立了五个用户：UserA, UserB, UserC, UserD, UserE</li></ul></li><li>第二步：DBA授予某用户账户级别的权利<ul><li>假定授予UserA</li></ul></li><li>第三步：具有账户级别的用户可以创建基本表或视图, 他也自动成为该表或该视图的属主账户，拥有该表或该视图的所有访问 权利<ul><li>假定UserA创建了Employee, 则UserA就是Employee表的属主账户</li></ul></li><li>第四步：拥有属主账户的用户可以将其中的一部分权利授予另外的用户，该用户也可将权利进一步授给其他的用户…<ul><li>假定UserA将读权限授予UserB, 而userB又将其拥有的权限授予UserC,如此将权利不断传递下去。</li></ul></li></ol><ul><li>注意授权的传播范围<ul><li>传播范围包括两个方面：水平传播数量和垂直传播数量<ul><li>水平传播数量是授权者的再授权用户数目(树的广度)</li><li>垂直传播数量是授权者传播给被授权者，再被传播给另一个被授权者, …传播的深度(树的深度)</li></ul></li><li>有些系统提供了传播范围控制，有些系统并没有提供，SQL标准中也并没有限制。</li><li>当一个用户的权利被收回时，通过其传播给其他用户的权利也将被收回</li><li>如果一个用户从多个用户处获得了授权，则当其中某一个用户收回授权时，该用户可能仍保有权利。例如UserC从UserB和UserE处获得了授权，当UserB收回时，其还将保持UserE赋予其的权利。</li></ul></li></ul><h5 id="18-2-2-强制安全性机制"><a href="#18-2-2-强制安全性机制" class="headerlink" title="18.2.2 强制安全性机制"></a>18.2.2 强制安全性机制</h5><ol><li>强制安全性机制<ul><li>强制安全性通过对数据对象进行安全性分级<ul><li>绝密(Top Secret), 机密(Secret), 可信(Confidential) 和 无分类(Unclassified)</li></ul></li><li>同时对用户也进行上述的安全性分级</li><li>从而强制实现不同级别用户访问不同级别数据的一种机制</li></ul></li><li>强制安全性机制的实现<ul><li>DBMS引入强制安全性机制, 可以通过扩展关系模式来实现<ul><li>关系模式: R(A1: D1, A2: D2, …, An:Dn)</li><li>对属性和元组引入安全性分级特性或称分类特性<ul><li>R(A1: D1, C1, A2: D2, C2…, An:Dn, Cn, TC)其中 C1,C2,…,Cn分别为属性D1,D2,…,Dn的安全分类特性; TC为元组的分类特性</li></ul></li></ul></li><li>这样, 关系中的每个元组, 都将扩展为带有安全分级的元组</li><li>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧，在使用中需注意仔细研究。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「数据库」数据库系统基础</title>
      <link href="/2018/08/22/database-base.html"/>
      <url>/2018/08/22/database-base.html</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>数据库 是 电子化信息的集合</li></ol><ul><li>将信息规范化并使之电子化，形成电子信息’库’，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。</li></ul><ol start="2"><li>表(Table)：以按行按列形式组织及展现的数据<span id="more"></span></li></ol><ul><li>数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据–&gt;关系</li></ul><ol start="3"><li>数据库系统的构成（概念层次）:</li><li>数据库(DB):Database：相互之间有关联关系的数据的集合</li><li>数据库管理系统(DBMS):Database Management System</li><li>数据库应用(DBAP):Database Application</li><li>数据库管理员(DBA):Database Asministrator</li><li>计算机基本系统</li></ol><h3 id="1-数据库管理系统-DBMS"><a href="#1-数据库管理系统-DBMS" class="headerlink" title="1. 数据库管理系统(DBMS)"></a>1. 数据库管理系统(DBMS)</h3><h4 id="1-1-从用户角度看DBMS-数据库管理系统"><a href="#1-1-从用户角度看DBMS-数据库管理系统" class="headerlink" title="1.1 从用户角度看DBMS(数据库管理系统)"></a>1.1 从用户角度看DBMS(数据库管理系统)</h4><ol><li>数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等</li></ol><ul><li>DBMS提供了一套<strong>数据定义语言(DDL</strong>: Data Definition Language)给用户</li><li>用户使用DDL描述其所要建立的表的格式</li><li>DBMS依照用户的定义，创建数据库及其中的表</li></ul><ol start="2"><li>数据库操作：向数据库的Table中增加&#x2F;删除&#x2F;更新数据及对数据进行查询、检索、统计等</li></ol><ul><li>DBMS提供了一套<strong>数据库操纵语言(DML</strong>: Data Manipulation Language)给用户</li><li>用户使用DML描述其所要进行的增、删、改、查等操作</li><li>DBMS依照用户的操作描述，实际执行这些操作</li></ul><ol start="3"><li>数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)</li></ol><ul><li>DBMS提供了一套<strong>数据控制语言(DCL</strong>: Data Control Language)给用户</li><li>用户使用DCL描述其对数据库所要实施的控制</li><li>DBMS依照用户描述，实际ijnx控制</li></ul><ol start="4"><li>数据库维护：转储&#x2F;恢复&#x2F;重组&#x2F;性能监测&#x2F;分析…</li></ol><ul><li>DBMS提供了一系列程序(实用程序&#x2F;例行程序)给用户</li><li>在这些程序中提供了对数据库维护的各种功能</li><li>用户使用这些程序进行各种数据库维护操作</li><li>(数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)</li></ul><h4 id="1-2-数据库语言"><a href="#1-2-数据库语言" class="headerlink" title="1.2 数据库语言"></a>1.2 数据库语言</h4><ul><li>使用者使用数据库语言，利用DBMS操纵数据库</li><li>SQL语言：结构化的数据库语言</li><li>高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用</li></ul><h4 id="1-3-从系统实现角度看DBMS的功能"><a href="#1-3-从系统实现角度看DBMS的功能" class="headerlink" title="1.3 从系统实现角度看DBMS的功能"></a>1.3 从系统实现角度看DBMS的功能</h4><ol><li>数据库管理系统的实现：形式 –&gt; 构造 –&gt; 自动化</li><li>DBMS为完成DB管理，在后台运行着一系列程序…</li></ol><ul><li><strong>语言编译器</strong>：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等</li><li><strong>查询优化</strong>(执行引擎)与<strong>查询实现</strong>(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序</li><li><strong>数据存取与索引</strong>：提供数据在磁盘&#x2F;磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引&#x2F;文件和记录管理器等</li><li><strong>通信控制</strong>：提供网络环境下数据库操作与数据传输的手段</li><li><strong>事务管理</strong>：提供提高可靠性并避免并发操作错误的手段</li><li><strong>故障恢复</strong>：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序</li><li><strong>安全性控制</strong>：提供合法性检验，避免非授权非法用户访问数据库的手段</li><li><strong>完整性控制</strong>：提供数据及数据操作正确性检查的手段</li><li><strong>数据字典管理</strong>：管理用户已经定义的信息</li><li>**应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段</li><li><strong>数据库数据装载、重组等实用程序</strong></li><li><strong>数据库性能分析</strong>：统计在运行过程中数据库的各种性能数据，便于优化运行</li></ul><blockquote><p>典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL </p></blockquote><h3 id="2-数据库系统的标准结构"><a href="#2-数据库系统的标准结构" class="headerlink" title="2. 数据库系统的标准结构"></a>2. 数据库系统的标准结构</h3><p>DBMS管理数据的三个层次：</p><ol><li>External Level &#x3D; User Level（外部级别 &#x3D; 用户级别）</li></ol><ul><li>某一用户能够看到与处理的数据,   全局数据中的某一部分</li></ul><ol start="2"><li>Conceptual Level &#x3D; Logic level（概念级别 &#x3D; 逻辑级别）</li></ol><ul><li>从全局角度理解&#x2F;管理的数据, 含相应的关联约束</li></ul><ol start="3"><li>Internal Level &#x3D; Physical level（内部级别 &#x3D; 物理级别）</li></ol><ul><li>存储在介质上的数据，含存储路径、存储方式 、索引方式等</li></ul><h3 id="3-三级模式两层映像"><a href="#3-三级模式两层映像" class="headerlink" title="3. 三级模式两层映像"></a>3. 三级模式两层映像</h3><p>数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成</p><ul><li>应用–&gt; 外模式(多个) –&gt; 模式(一个) –&gt; 内模式(一个) –&gt; 数据库</li></ul><h4 id="3-1-数据-视图-与模式-数据的结构"><a href="#3-1-数据-视图-与模式-数据的结构" class="headerlink" title="3.1 数据(视图)与模式(数据的结构)"></a>3.1 数据(视图)与模式(数据的结构)</h4><ul><li>模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息</li><li>视图(View)&#x2F;数据(Data)：某一种表现形式下表现出来的数据库中的数据</li></ul><h4 id="3-2-三级模式-三级视图"><a href="#3-2-三级模式-三级视图" class="headerlink" title="3.2 三级模式(三级视图)"></a>3.2 三级模式(三级视图)</h4><ol><li>External Schema —-(External) View</li></ol><ul><li>外模式：某一用户能够看到与处理的数据的结构描述</li></ul><ol start="2"><li>(Conceptual) Schema —- Conceptual View</li></ol><ul><li>模式(概念模式)：从全局角度理解&#x2F;管理的数据的结构描述, 含相应的关联约束</li><li>体现在数据之间的内在本质联系</li></ul><ol start="3"><li>Internal Schema —- Internal  View</li></ol><ul><li>内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等</li></ul><h4 id="3-3-两层映像"><a href="#3-3-两层映像" class="headerlink" title="3.3 两层映像"></a>3.3 两层映像</h4><ol><li>E-C Mapping：External Schema-Conceptual Schema Mapping</li></ol><ul><li>将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换</li><li>便于用户观察和使用</li></ul><ol start="2"><li>C-I Mapping：Conceptual Schema-Internal Schema Mapping</li></ol><ul><li>将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换</li><li>便于计算机进行存储和处理</li></ul><h4 id="3-4-标准结构的两个独立性"><a href="#3-4-标准结构的两个独立性" class="headerlink" title="3.4 标准结构的两个独立性"></a>3.4 标准结构的两个独立性</h4><ol><li>逻辑数据独立性</li></ol><ul><li>当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序</li></ul><ol start="2"><li>物理数据独立性</li></ol><ul><li>当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式</li></ul><h3 id="4-数据模型"><a href="#4-数据模型" class="headerlink" title="4. 数据模型"></a>4. 数据模型</h3><ol><li>数据模型：模式 与 模式的结构</li></ol><ul><li>规定模式统一描述方式的模型，包括：数据结构、操作和约束</li><li>数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象</li><li>比如：关系模型：所有模式都可为抽象表(Table)的形式[<strong>数据结构</strong>]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[<strong>操作</strong>]和[<strong>约束</strong>]</li></ul><ol start="2"><li>三大经典数据模型</li></ol><ul><li>关系模型：<strong>表</strong>的形式组织数据</li><li>层次模型：<strong>树</strong>的形式组织数据</li><li>网状模型：<strong>图</strong>的形式组织数据</li></ul><h3 id="5-关系模型"><a href="#5-关系模型" class="headerlink" title="5. 关系模型"></a>5. 关系模型</h3><ol><li>形象地说，<strong>一个关系(relation)就是一个Table</strong>，关系模型就是处理Table的，它由三个部分组成：</li></ol><ul><li>描述DB各种数据的基本结构形式(Table&#x2F;Relation)</li><li>描述Table与Table之间所可能发生的各种操作(关系运算)</li><li>描述这些操作所应遵循的约束条件(完整性约束)</li></ul><ol start="2"><li>关系模型的三个要素：</li></ol><ul><li>基本结构：Relation&#x2F;Table</li><li>基本操作：Relation Operator<ul><li>基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。</li><li>扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算</li></ul></li><li>完整性约束：实体完整性、参照完整性和用户自定义的完整性</li></ul><ol start="3"><li>表(Table)的基本构成要素</li></ol><ul><li>列&#x2F;字段&#x2F;属性&#x2F;数据项：列名，列值</li><li>行&#x2F;元组&#x2F;记录</li><li>标题&#x2F;模式</li></ul><h4 id="5-1-“表”的严格定义"><a href="#5-1-“表”的严格定义" class="headerlink" title="5.1 “表”的严格定义"></a>5.1 “表”的严格定义</h4><ul><li>域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型</li><li>笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组</li><li>关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)</li></ul><h4 id="5-2-关系模式与关系"><a href="#5-2-关系模式与关系" class="headerlink" title="5.2 关系模式与关系"></a>5.2 关系模式与关系</h4><ul><li>同一关系模式下，可有很多的关系</li><li>关系模式是关系的结构, 关系是关系模式在某一时刻的数据</li><li>关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的</li></ul><h4 id="5-3-关系的特性"><a href="#5-3-关系的特性" class="headerlink" title="5.3 关系的特性"></a>5.3 关系的特性</h4><ul><li>列是同质：即每一列中的分量来自同一域，是同一类型的数据</li><li>不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</li><li>列位置互换性：区分哪一列是靠列名</li><li>行位置互换性：区分哪一行是靠某一或某几列的值(关键字&#x2F;键字&#x2F;码字)</li><li>关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分</li><li>理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。</li><li>属性不可再分特性:又被称为关系第一范式</li></ul><h4 id="5-4-关系的一些重要概念"><a href="#5-4-关系的一些重要概念" class="headerlink" title="5.4 关系的一些重要概念"></a>5.4 关系的一些重要概念</h4><ol><li>候选码(Candidate Key)&#x2F;候选键</li></ol><ul><li>关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉<br>任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。</li></ul><ol start="2"><li>主码(Primary Key)&#x2F;主键</li></ol><ul><li>当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组</li></ul><ol start="3"><li>主属性与非主属性</li></ol><ul><li>包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性</li><li>最简单的，候选码只包含一个属性；</li><li>极端的，所有属性构成这个关系的候选码，称为全码(All-Key)</li></ul><ol start="4"><li>外码(Foreign Key)&#x2F;外键</li></ol><ul><li>关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</li><li>两个关系通常是靠外码连接起来的。</li></ul><h3 id="6-关系模型中的完整性"><a href="#6-关系模型中的完整性" class="headerlink" title="6. 关系模型中的完整性"></a>6. 关系模型中的完整性</h3><h4 id="6-1-实体完整性"><a href="#6-1-实体完整性" class="headerlink" title="6.1 实体完整性"></a>6.1 实体完整性</h4><ul><li>关系的主码中的属性值不能为空值；</li><li>意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。</li></ul><h4 id="6-2-参照完整性"><a href="#6-2-参照完整性" class="headerlink" title="6.2 参照完整性"></a>6.2 参照完整性</h4><ul><li>如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值</li><li>意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在</li></ul><h4 id="6-3-用户自定义完整性"><a href="#6-3-用户自定义完整性" class="headerlink" title="6.3 用户自定义完整性"></a>6.3 用户自定义完整性</h4><ul><li>用户针对具体的应用环境定义的完整性约束条件</li></ul><h4 id="6-4-DBMS对关系完整性的支持"><a href="#6-4-DBMS对关系完整性的支持" class="headerlink" title="6.4 DBMS对关系完整性的支持"></a>6.4 DBMS对关系完整性的支持</h4><ul><li>实体完整性和参照完整性由DBMS系统自动支持</li><li>DBMS系统通常提供了如下机制：<ol><li>它使用户可以自行定义有关的完整性约束条件</li><li>当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</li></ol></li></ul><h3 id="7-关系代数"><a href="#7-关系代数" class="headerlink" title="7. 关系代数"></a>7. 关系代数</h3><h4 id="7-1-关系代数的特点"><a href="#7-1-关系代数的特点" class="headerlink" title="7.1 关系代数的特点"></a>7.1 关系代数的特点</h4><ul><li>基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作</li><li>以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。</li><li>关系代数操作以一个或多个关系为输入，结果是一个新的关系。</li><li>用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。</li><li>是一种抽象的语言，是学习其他数据库语言，如SQL等的基础</li></ul><h4 id="7-2-关系代数的约束"><a href="#7-2-关系代数的约束" class="headerlink" title="7.2 关系代数的约束"></a>7.2 关系代数的约束</h4><p>某些关系代数操作，如并、差、交等，需满足”并相容性”</p><ul><li>并相容性：<ol><li>参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性</li><li>定义：关系R与关系S存在相容性，当且仅当：</li></ol><ul><li>(1) 关系R和关系S的属性数目必须相同；</li><li>(2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同</li></ul><ul><li>示例：关系R：STUDENT(SID <strong>char(10)</strong>, Sname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li><li>示例：关系S：TEACHER(TID <strong>char(10)</strong>, Tname <strong>char(8)</strong>, Age <strong>char(3)</strong>)</li></ul></li></ul><h4 id="7-3-关系代数的基本操作"><a href="#7-3-关系代数的基本操作" class="headerlink" title="7.3 关系代数的基本操作"></a>7.3 关系代数的基本操作</h4><ol><li>集合操作</li></ol><ul><li>并（UNIO）：R∪S</li><li>交（INTERSECTION）：R∩S</li><li>差（DIFFERENCE）：R-S</li><li>笛卡儿积（Cartesian PRODUCT）：R×S</li></ul><ol start="2"><li>纯关系操作</li></ol><ul><li>选择（SELECT）：σF(R)</li><li>投影（PROJECT）：ΠA(R)</li><li>连接（JOIN）：R⋈S</li><li>除（DIVISION）：R÷S</li></ul><h5 id="7-3-1-并-Union-操作"><a href="#7-3-1-并-Union-操作" class="headerlink" title="7.3.1 并(Union) 操作"></a>7.3.1 并(Union) 操作</h5><ul><li>定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**<code>R∪S</code>**, 它由 或者出现在关系R中，或者出现在S中的元组构成。</li><li>数学描述：<code>R∪S=&#123;t|t∈R∨t∈S&#125;</code>，其中t是元组</li><li>并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。</li><li>汉语中的“或者…或者…”通常意义是并运算的要求。</li><li><code>R∪S</code> 与 <code>S∪R</code> 运算的结果是<strong>同</strong>一个关系</li></ul><h5 id="7-3-2-差-Difference-操作"><a href="#7-3-2-差-Difference-操作" class="headerlink" title="7.3.2 差(Difference) 操作"></a>7.3.2 差(Difference) 操作</h5><ul><li>定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**<code>R-S</code>**, 它由出现在关系R中但不出现在关系S中的元组构成。</li><li>数学描述：<code>R－S=&#123;t|t∈R∧t∉S&#125;</code>，其中t是元组</li><li>汉语中的“是…但不含…”通常意义是差运算的要求。</li><li><code>R-S</code> 与 <code>S-R</code> 是<strong>不同</strong>的</li></ul><h5 id="7-3-3-交（Intersection-Referential-integrity）-操作"><a href="#7-3-3-交（Intersection-Referential-integrity）-操作" class="headerlink" title="7.3.3  交（Intersection Referential integrity） 操作"></a>7.3.3  交（Intersection Referential integrity） 操作</h5><ul><li>定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。</li><li>数学描述：<code>R∩S=&#123;t|t∈R∧t∈S&#125;</code>，其中t是元组</li></ul><h5 id="7-3-4-广义笛卡尔积-Extended-cartesian-product-操作"><a href="#7-3-4-广义笛卡尔积-Extended-cartesian-product-操作" class="headerlink" title="7.3.4 广义笛卡尔积(Extended cartesian product) 操作"></a>7.3.4 广义笛卡尔积(Extended cartesian product) 操作</h5><ul><li>定义：关系<code>R(&lt;a1,a2, …,an&gt;)</code>与关系<code>S(&lt;b1,b2, …,bm &gt;)</code>的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**<code>RxS</code>**；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。</li><li>数学描述：<code>RxS = &#123;&lt;a1,a2,…,an,b1,b2,…,bm&gt;|&lt;a1,a2,…,an&gt;∈R ∧ &lt;b1,b2,…,bm&gt;∈S&#125;</code></li><li><code>RxS=SxR</code>：RxS为R中的每一个元组都和S中的所有元组进行串接。<code>SxR</code>为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。</li><li>两个关系R和S，它们的<strong>属性个数</strong>分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数&#x3D;n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).</li><li>两个关系R和S，它们的<strong>元组个数</strong>分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数&#x3D;x×y。(R×S的基数是x×y).</li></ul><h5 id="7-3-5-选择-Select"><a href="#7-3-5-选择-Select" class="headerlink" title="7.3.5 选择(Select)"></a>7.3.5 选择(Select)</h5><ul><li>定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作**<code>σF(R)</code>**, 它从关系R中选择出满足给定条件condition的元组构成。</li><li>数学描述：<code>σF(R) = &#123;t|t∈R ∧ F(t)=&#39;真&#39;&#125;</code>,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。</li><li>选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ <code>括弧()；θ；¬；∧；∨</code> }</li></ul><h5 id="7-3-6-投影-Project"><a href="#7-3-6-投影-Project" class="headerlink" title="7.3.6 投影(Project)"></a>7.3.6 投影(Project)</h5><ul><li>定义：给定一个关系R, 投影运算结果也是一个关系，记作**<code>A(R)</code>**, 它从关系R中选出属性包含在A中的列构成。</li><li>数学描述：<code>ΠA(R) = &#123;t[A] | t∈R&#125;</code>,其中A为R中的属性列</li><li>投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系</li></ul><h4 id="7-4-关系代数的扩展操作"><a href="#7-4-关系代数的扩展操作" class="headerlink" title="7.4 关系代数的扩展操作"></a>7.4 关系代数的扩展操作</h4><h5 id="7-4-1-交-Intersection"><a href="#7-4-1-交-Intersection" class="headerlink" title="7.4.1 交(Intersection)"></a>7.4.1 交(Intersection)</h5><ul><li><strong>定义</strong>：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**<code>R∩S</code>**, 它由同时出现在关系R和关系S中的元组构成。</li><li>数学描述：<code>R∩S = &#123;t|t∈R ∧ t∈S&#125;</code>，其中t是元组</li><li>R∩S 和 S∩R 运算的结果是同一个关系</li><li>交运算可以通过差运算来实现：<code>R∩S = R-(R-S) = S-(S-R)</code></li><li>汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求</li></ul><h5 id="7-4-2-θ-连接-θ-Join-theta-Join"><a href="#7-4-2-θ-连接-θ-Join-theta-Join" class="headerlink" title="7.4.2 θ-连接(θ-Join, theta-Join)"></a>7.4.2 θ-连接(θ-Join, theta-Join)</h5><ul><li>投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作</li><li><strong>定义</strong>：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **<code>R⋈S[AθB]</code>**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。</li><li>数学描述：<code>R⋈S[AθB] = σ t[A]θs[B] (R×S)</code>，σF(RxS)其中t是R中的元组，s是S中的元组</li><li>在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用</li><li><strong>特别注意</strong>：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。</li></ul><h5 id="7-4-3-等值连接-Equi-Join"><a href="#7-4-3-等值连接-Equi-Join" class="headerlink" title="7.4.3 等值连接(Equi-Join)"></a>7.4.3 等值连接(Equi-Join)</h5><ul><li><strong>定义</strong>：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**<code>R⋈S[A=B]</code>**：(括号内A&#x3D;B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S[A=B] = σ t[A]=s[B] (R×S)</code></li><li>当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；</li><li>广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用<strong>θ-连接&#x2F;等值连接</strong>运算可大幅度降低中间结果的保存量，提高速度。</li></ul><h5 id="7-4-4-自然连接-Natural-Join"><a href="#7-4-4-自然连接-Natural-Join" class="headerlink" title="7.4.4 自然连接(Natural-Join)"></a>7.4.4 自然连接(Natural-Join)</h5><ul><li>定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。</li><li>数学描述：<code>R⋈S = σ t[B]=s[B] (R×S)</code></li><li>自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列</li></ul><h4 id="7-5-关系代数的基本书写思路"><a href="#7-5-关系代数的基本书写思路" class="headerlink" title="7.5 关系代数的基本书写思路"></a>7.5 关系代数的基本书写思路</h4><ol><li>选出将用到的关系&#x2F;表</li><li>做”积”运算（可用连接运算替换）</li><li>做选择运算保留所需的行&#x2F;元组</li><li>做投影运算保留所需的列&#x2F;属性</li></ol><ul><li>基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可</li><li>如涉及多个表，则检查：<ul><li>能否使用自然连接，将多个表连接起来(多数情况是这样的)</li><li>如不能，能否使用等值或不等值连接(θ-连接)</li><li>还不能，则使用广义笛卡尔积，注意相关条件的书写</li></ul></li><li>连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作</li></ul><h4 id="7-6-关系代数之复杂扩展操作"><a href="#7-6-关系代数之复杂扩展操作" class="headerlink" title="7.6 关系代数之复杂扩展操作"></a>7.6 关系代数之复杂扩展操作</h4><h5 id="7-6-1-除-Division"><a href="#7-6-1-除-Division" class="headerlink" title="7.6.1 除(Division)"></a>7.6.1 除(Division)</h5><ul><li>除法运算经常用于求解“查询… 全部的&#x2F;所有的…”问题</li><li>前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m &lt; n。</li><li>定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。</li><li>数学描述：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R÷S = &#123;t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) &#125;</span><br><span class="line">    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)</span><br></pre></td></tr></table></figure><blockquote><p>其中[R-S]为投影Π的下标(属性)</p></blockquote></li></ul><h5 id="7-6-2-外连接-Outer-Join"><a href="#7-6-2-外连接-Outer-Join" class="headerlink" title="7.6.2 外连接(Outer-Join)"></a>7.6.2 外连接(Outer-Join)</h5><ul><li>定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。</li><li>外连接 &#x3D; 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)</li><li>外连接的形式：左外连接、右外连接、全外连接<ul><li>左外连接 &#x3D; 自然连接(或连接) + 左侧表中失配的元组</li><li>右外连接 &#x3D; 自然连接(或连接) + 右侧表中失配的元组</li><li>全外连接 &#x3D; 自然连接(或连接) + 两侧表中失配的元组</li><li>左外连接(Left Outer Join)记为：⋊</li><li>右外连接(Right Outer Join)记为：⋉</li><li>全外连接(Full Outer Join)记为：⋊⋉</li></ul></li></ul><h3 id="8-关系演算"><a href="#8-关系演算" class="headerlink" title="8. 关系演算"></a>8. 关系演算</h3><p>关系演算是<strong>描述关系运算</strong>的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的</p><ul><li>按照谓词变量的不同，可分为关系元组演算和关系域演算<ol><li>关系元组演算是以<strong>元组变量</strong>作为谓词变量的基本对象</li><li>关系域演算是以<strong>域变量</strong>作为谓词变量的基本对象</li></ol></li></ul><h4 id="8-1-关系元组演算"><a href="#8-1-关系元组演算" class="headerlink" title="8.1 关系元组演算"></a>8.1 关系元组演算</h4><ol><li>关系元组演算公式：{ t | P(t) }</li></ol><ul><li>表示：所有使谓词 P 为真的元组 t 的集合</li><li>t 是元组变量</li><li>t ∈ r 表示元组 t 在关系 r 中</li><li>t[A] 表示元组 t 的分量，即 t 在属性 A 上的值</li><li>P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式</li></ul><ol start="2"><li>关系元组演算公式的基本形式：{ t | P(t) }</li><li>P(t)可以是如下三种形式之一的原子公式：</li></ol><ul><li>t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}</li><li>s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符&lt;,&lt;&#x3D;,&#x3D;,&lt;&gt;,&gt;,&gt;&#x3D;</li><li>s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，</li></ul><ol start="4"><li>P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造</li></ol><ul><li>如果F是一个公式，则 ¬F 也是公式</li><li>如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式</li></ul><ol start="5"><li>P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例</li><li>构造P(t)还有两个运算符：∃(存在)、∀(任意)</li></ol><ul><li>如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式</li><li>如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式</li><li>运算符∃和∀，又称为量词，前者称“<strong>存在量词</strong>”，后者称“<strong>全称量词</strong>”</li><li>而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“<strong>约束变量</strong>”，否则被称为“<strong>自由变量</strong>”。</li></ul><ol start="7"><li>元组演算的等价性变换<ul><li>符号<code>&lt;=&gt;</code>表示表示等价于,如：<code>¬(A&gt;B) &lt;=&gt; A&lt;=B  &lt;=&gt; A&lt;B∨A=B</code></li></ul></li></ol><h4 id="8-2-关系域演算"><a href="#8-2-关系域演算" class="headerlink" title="8.2 关系域演算"></a>8.2 关系域演算</h4><ol><li>关系域演算公式的基本形式：<code>&#123;&lt;x1,x2, …,xn&gt; | P(x1,x2, …,xn)&#125;</code>,其中 xi 代表域变量或常量, P为以xi为变量的公式。</li><li>元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；</li><li>域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。</li><li>公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。</li><li>元组演算和域演算可以等价互换。</li></ol><h5 id="8-2-1-基于关系域演算的QBE语言"><a href="#8-2-1-基于关系域演算的QBE语言" class="headerlink" title="8.2.1 基于关系域演算的QBE语言"></a>8.2.1 基于关系域演算的QBE语言</h5><p>QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。</p><ol><li>特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可</li><li>QBE操作框架由四个部分构成<ul><li>关系名区：用于书写欲待查询的关系名</li><li>属性名区：用于显示对应关系名区关系的所有属性名</li><li>操作命令区：用于书写查询操作的命令</li><li>查询条件区：用于书写查询条件</li></ul></li><li>QBE的操作命令<ul><li>Print 或 P.   —- 显示输出操作</li><li>Delete或D.   —- 删除操作</li><li>Insert或I.     —- 插入操作</li><li>Update或U. —- 更新操作</li></ul></li><li>构造查询的几个要素 <ul><li>示例元素: 即域变量， 一定要加下划线 </li><li>示例元素是这个域中可能的一个值， 它不必是查询结果中的元素</li><li>打印操作符P.: 指定查询结果所含属性列 </li><li>查询条件: 不用加下划线</li><li>可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略</li><li>排序要求 <ul><li>升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高</li></ul></li></ul></li></ol><h4 id="8-3-安全性"><a href="#8-3-安全性" class="headerlink" title="8.3 安全性"></a>8.3 安全性</h4><p>关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的</p><ol><li>关系代数是一种集合运算，是安全的<ul><li>集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。</li></ul></li><li>关系演算不一定是安全的<ul><li>如：{t|¬(R(t))}, {t R(t)∨t[2]&gt;3}可能表示无限关系</li></ul></li><li>需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。</li></ol><h5 id="8-3-1-安全约束有限集合DOM"><a href="#8-3-1-安全约束有限集合DOM" class="headerlink" title="8.3.1 安全约束有限集合DOM"></a>8.3.1 安全约束有限集合DOM</h5><ol><li>DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。</li><li>DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。</li><li>安全元组演算表达式，满足三个条件：<ul><li>只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。<ul><li>{ t|ψ(t) }中t的取值只能是DOM中的值，有限的。</li></ul></li><li>对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。<ul><li>{ t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。</li></ul></li><li>对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。<ul><li>{ t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。</li></ul></li></ul></li></ol><h4 id="8-4-关于三种关系运算的一些观点"><a href="#8-4-关于三种关系运算的一些观点" class="headerlink" title="8.4 关于三种关系运算的一些观点"></a>8.4 关于三种关系运算的一些观点</h4><ol><li>关系运算有三种：关系代数、关系元组演算和关系域演算</li><li>三种关系运算都是抽象的数学运算，体现了三种不同的思维<ul><li>关系代数—以集合为对象的操作思维，由集合到集合的变换</li><li>元组演算—以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环</li><li>域演算—以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件</li></ul></li><li>三种运算之间是等价的<ul><li>关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等<br>价的。即一种形式的表达式可以被等价地转换为另一种形式</li></ul></li><li>三种关系运算都可说是非过程性的<ul><li>相比之下：域演算的非过程性最好，元组演算次之，关系代数最差</li></ul></li><li>三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础<ul><li>一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的</li><li>目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等</li></ul></li><li>数据库语言可以基于这三种抽象运算来设计<ul><li>用“键盘符号”来替换抽象的数学符号</li><li>用易于理解的符号组合来表达抽象的数学符号</li><li>例如：ISBL语言—基于关系代数的数据库语言</li><li>再例如：Ingres系统的QUEL语言</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SpringBoot MVC应用</title>
      <link href="/2018/06/20/spring-boot-mvc.html"/>
      <url>/2018/06/20/spring-boot-mvc.html</url>
      
        <content type="html"><![CDATA[<p>对Spring Web MVC封装，简化MVC结构web应用开发。</p><span id="more"></span><h3 id="1-SpringBoot-MVC开发Restful服务（前后分离）"><a href="#1-SpringBoot-MVC开发Restful服务（前后分离）" class="headerlink" title="1. SpringBoot MVC开发Restful服务（前后分离）*"></a>1. SpringBoot MVC开发Restful服务（前后分离）*</h3><p>按rest规则发送HTTP请求–&gt;Spring MVC–&gt;返回JSON结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web（springmvc、rest、jackson、tomcat）</li><li>在application.properties修改tomcat端口</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller、Service、Dao组件</li></ol><h3 id="2-SpringBoot-MVC开发JSP应用（PC浏览器）"><a href="#2-SpringBoot-MVC开发JSP应用（PC浏览器）" class="headerlink" title="2. SpringBoot MVC开发JSP应用（PC浏览器）"></a>2. SpringBoot MVC开发JSP应用（PC浏览器）</h3><p>HTTP请求–&gt;Spring MVC–&gt;JSP–&gt;HTML响应输出结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web、jasper解析器、jstl</li><li>在application.properties修改tomcat端口、viewResolver</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller组件，返回ModelAndView</li><li>在src&#x2F;main&#x2F;webapp下定义JSP组件</li></ol><h3 id="3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）"><a href="#3-SpringBoot-MVC开发Thymeleaf应用（PC浏览器）" class="headerlink" title="3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*"></a>3. SpringBoot MVC开发Thymeleaf应用（PC浏览器）*</h3><p>HTTP请求–&gt;Spring MVC–&gt;Thymeleaf模板–&gt;HTML响应输出结果</p><p>主要步骤：</p><ol><li>导入spring-boot-starter-web、spring-boot-starter-thymeleaf</li><li>在application.properties修改tomcat端口</li><li>定义启动类RunBoot，追加@SpringBootApplication</li><li>定义Controller组件，返回ModelAndView</li><li>在src&#x2F;main&#x2F;resources&#x2F;templates下定义模板文件<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;https://www.thymeleaf.org/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;data&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>th:text表达式作用：将模型中的数据以只读文本显示到元素中</li><li>th:text表达式作用：将模型中的数据以只读文本显示到元素中。</li><li>th:if 表达式作用：if判断逻辑</li><li>th:each 表达式作用：循环逻辑</li><li>th:href 表达式作用：动态生成href链接</li></ul></blockquote></li></ol><p>Thymeleaf模板和JSP区别</p><ol><li>运行机制不同<ul><li>JSP–&gt;Servlet–&gt;HTML</li><li>模板+数据–&gt;HTML输出</li></ul></li><li>模板简单易用;JSP相对复杂些<ul><li>JSP:9大内置对象、EL、JSTL、嵌入Java代码、框架标签</li><li>模板：模板表达式</li></ul></li><li>模板效率高,比JSP性能好<ul><li>模板：缓存</li></ul></li></ol><h3 id="4-SpringBoot-MVC静态资源处理"><a href="#4-SpringBoot-MVC静态资源处理" class="headerlink" title="4. SpringBoot MVC静态资源处理"></a>4. SpringBoot MVC静态资源处理</h3><p>静态资源包含图片、js、css等，动态资源servlet、jsp等。</p><p>SpringBoot中src&#x2F;main&#x2F;resources目录下有几个约定的静态资源存放位置</p><ul><li>META-INF&#x2F;resources（优先级最高）</li><li>resources</li><li>static</li><li>public（优先级最低）</li></ul><p>自定义静态资源访问路径，编写一个配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStaticConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">            .addResourceLocations(</span><br><span class="line">                <span class="string">&quot;classpath:/images/&quot;</span>,</span><br><span class="line">                <span class="string">&quot;classpath:/resources/&quot;</span>,</span><br><span class="line">                <span class="string">&quot;classpath:/static/&quot;</span>,</span><br><span class="line">                <span class="string">&quot;classpath:/public/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-SpringBoot-MVC异常处理"><a href="#5-SpringBoot-MVC异常处理" class="headerlink" title="5. SpringBoot MVC异常处理"></a>5. SpringBoot MVC异常处理</h3><ol><li><p>异常处理机制</p><ul><li>SpringBoot底层提供了异常处理机制。SpringBoot提供了一个ErrorMvcAutoConfiguration自动配置组件，创建了一个BasicErrorController对象，提供两个&#x2F;error请求处理，一个返回html，另一个返回json。当MVC底层遇到异常会用转发方式发出&#x2F;error请求。</li></ul></li><li><p>可以自定义ErrorController替代底层BasicErrorController，将错误提示转发到自定义提示界面(全局)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyErrorController</span> <span class="keyword">implements</span> <span class="title class_">ErrorController</span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/error&quot;,produces= MediaType.TEXT_HTML_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        mav.setViewName(<span class="string">&quot;myerror&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/error&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">error</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;程序发生了异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorPath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@ExceptionHandler异常处理（局部）</p><ul><li>ErrorController管理全局异常，@ExceptionHandler管理所在Controller组件的异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">error</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;type&quot;</span>, ex.getClass());</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>可以将上述方法封装成一个BasicController，通过@ControllerAdvice作用到所有Controller组件上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span><span class="comment">//等价于所有Controller都继承它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicController</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">error</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;发生异常&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;type&quot;</span>, ex.getClass());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-SpringBoot-AOP"><a href="#6-SpringBoot-AOP" class="headerlink" title="6. SpringBoot AOP"></a>6. SpringBoot AOP</h3><ol><li><p>引入spring-boot-starter-aop</p></li><li><p>定义一个切面组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将Bean组件纳入Spring容器</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//将Bean组件定义为Aspect切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspectBean</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;within(cn.xdl.controller.*)&quot;)</span><span class="comment">//前置通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----开始处理----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;within(cn.xdl.controller.*)&quot;)</span><span class="comment">//最终通知</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----处理完毕----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;within(cn.xdl.controller.*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">watch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        watch.start();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> pjp.proceed();<span class="comment">//调用目标组件方法</span></span><br><span class="line">        watch.stop();</span><br><span class="line">        System.out.println(<span class="string">&quot;处理时间:&quot;</span>+watch.getTotalTimeMillis()+<span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置切面组件</p><ul><li>@Aspect、@Before、@After、@Around、@AfterReturning、@AfterThrowing等</li></ul></li></ol><h3 id="7-SpringBoot-MVC拦截器"><a href="#7-SpringBoot-MVC拦截器" class="headerlink" title="7. SpringBoot MVC拦截器"></a>7. SpringBoot MVC拦截器</h3><ol><li><p>编写一个拦截器组件,实现HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了MyInterceptor拦截器&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> (String)request.getSession().getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">&quot;/tologin&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻止后续流程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//继续执行后续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptorConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyInterceptor my;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(my).addPathPatterns(<span class="string">&quot;/direction/list&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-SpringBoot整合Servlet-x2F-Filter"><a href="#8-SpringBoot整合Servlet-x2F-Filter" class="headerlink" title="8. SpringBoot整合Servlet&#x2F;Filter"></a>8. SpringBoot整合Servlet&#x2F;Filter</h3><h4 id="8-1-整合Servlet"><a href="#8-1-整合Servlet" class="headerlink" title="8.1 整合Servlet"></a>8.1 整合Servlet</h4><p>首先导入spring-boot-starter-web</p><h5 id="8-1-1-整合Servlet方式一："><a href="#8-1-1-整合Servlet方式一：" class="headerlink" title="8.1.1 整合Servlet方式一："></a>8.1.1 整合Servlet方式一：</h5><ol><li><p>编写一个Servlet组件，继承HttpServlet</p></li><li><p>在Servlet类定义前使用@WebServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(name=&quot;helloservlet&quot;,urlPatterns= &#123;&quot;/hello.do&quot;&#125;,loadOnStartup=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request,</span></span><br><span class="line"><span class="params">        HttpServletResponse response</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Hello SpringBoot Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunBoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="8-1-2-整合Servlet方式二："><a href="#8-1-2-整合Servlet方式二：" class="headerlink" title="8.1.2 整合Servlet方式二："></a>8.1.2 整合Servlet方式二：</h5><ol><li><p>编写一个Servlet组件，继承HttpServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(</span></span><br><span class="line"><span class="params">        HttpServletRequest request, </span></span><br><span class="line"><span class="params">        HttpServletResponse response</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;Hello Spring Some Servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ServletRegistrationBean+@Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunBoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="title function_">someservlet</span><span class="params">()</span>&#123;</span><br><span class="line">        ServletRegistrationBean&lt;Servlet&gt; bean = <span class="keyword">new</span> <span class="title class_">ServletRegistrationBean</span>&lt;Servlet&gt;();</span><br><span class="line">        bean.setServlet(<span class="keyword">new</span> <span class="title class_">SomeServlet</span>());</span><br><span class="line">        bean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        urls.add(<span class="string">&quot;/some.do&quot;</span>);</span><br><span class="line">        bean.setUrlMappings(urls);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="8-2-整合Filter"><a href="#8-2-整合Filter" class="headerlink" title="8.2 整合Filter"></a>8.2 整合Filter</h4><p>在SpringBoot整合Servlet的基础上整合Filter</p><h5 id="8-2-1-整合Filter方式一："><a href="#8-2-1-整合Filter方式一：" class="headerlink" title="8.2.1 整合Filter方式一："></a>8.2.1 整合Filter方式一：</h5><ol><li><p>编写一个Filter组件，继承Filter</p></li><li><p>在Filter类定义前使用@WebFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns=&quot;/hello.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----hello filter------servlet执行之前&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----hello filter------servlet执行之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类前需要使用@ServletComponentScan扫描@WebServlet配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span> <span class="comment">//扫描@WebServlet、@WebFilter、@WebListener组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunBoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="8-2-2-整合Filter方式二："><a href="#8-2-2-整合Filter方式二：" class="headerlink" title="8.2.2 整合Filter方式二："></a>8.2.2 整合Filter方式二：</h5><ol><li><p>编写一个Filter组件，继承Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(</span></span><br><span class="line"><span class="params">        ServletRequest request, ServletResponse response, FilterChain chain</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----som filter------servlet执行之前&quot;</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----som filter------servlet执行之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用FilterRegistrationBean+@Bean 注册过滤器并设置拦截的请求地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunBoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RunBoot.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;Filter&gt; <span class="title function_">somefilter</span><span class="params">()</span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;Filter&gt;();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> <span class="title class_">SomeFilter</span>());</span><br><span class="line">        <span class="comment">// 配置要拦截的请求</span></span><br><span class="line">        bean.addUrlPatterns(<span class="string">&quot;/some.do&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="9-SpringBoot-任务调度"><a href="#9-SpringBoot-任务调度" class="headerlink" title="9. SpringBoot 任务调度"></a>9. SpringBoot 任务调度</h3><h4 id="9-1-服务器启动后自动调用"><a href="#9-1-服务器启动后自动调用" class="headerlink" title="9.1 服务器启动后自动调用"></a>9.1 服务器启动后自动调用</h4><p>tomcat服务器启动后自动调用任务，可以使用ApplicationRunner或CommandLineRunner接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeTask1</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务器启动后自动执行SomeTask1任务---&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeTask2</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----服务器启动后自动执行SomeTask2任务-----&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多个Task任务，可以通过@Order指定先后顺序，多个任务是线程同步调用。</p></blockquote><h4 id="9-2-程序运行后定时调用任务"><a href="#9-2-程序运行后定时调用任务" class="headerlink" title="9.2 程序运行后定时调用任务"></a>9.2 程序运行后定时调用任务</h4><p>Spring提供了一个Spring Schedule模块，封装了任务调用，之前都是采用Quartz组件调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableScheduling</span><span class="comment">//开启Schedule模块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SomeTask3</span> &#123;</span><br><span class="line">    <span class="comment">//在服务器启动1秒后调用任务，每隔3秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay=1000,fixedRate=3000)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----周期性调用SomeTask3-----&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在服务器启动0秒后调用任务，每隔5秒调用一次</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/5 * * * * ?&quot;)</span><span class="comment">//秒 分 时 日 月 星期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----周期性调用SomeTask4-----&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Spring Schedule还需要指定cron表达式，表达式具体规则：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">秒   分    时    日   月   星期   年（可省略）</span><br><span class="line">0    0     10    1   10    ？</span><br><span class="line">秒： 0-59</span><br><span class="line">分： 0-59</span><br><span class="line">时： 0-23</span><br><span class="line">日： 1-31</span><br><span class="line">月： 1-12</span><br><span class="line">星期：1-7，1表示星期日，7表示星期六</span><br><span class="line">* ： 表示每一分、每一秒、每一天，任何一个可能值</span><br><span class="line">? ： 只用在日和星期部分，如果指定日，星期用？;如果指定星期，日用?，避免日和星期冲突 </span><br><span class="line">/ ： 表示增量，0/1表示0\1\2\3\4递增加1；0/5表示0\5\10\15；1/5表示1\6\11\16\21</span><br><span class="line">L ： 只用在日和星期部分，表示最后一天、周六</span><br></pre></td></tr></table></figure><p>cron表达式案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;30 * * * * ?&quot; 每半分钟触发任务</span><br><span class="line">&quot;30 10 * * * ?&quot; 每小时的10分30秒触发任务</span><br><span class="line">&quot;30 10 1 * * ?&quot; 每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 * ?&quot; 每月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? *&quot; 每年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 20 10 ? 2011&quot; 2011年10月20号1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 * 2011&quot; 2011年10月每天1点10分30秒触发任务</span><br><span class="line">&quot;30 10 1 ? 10 SUN 2011&quot; 2011年10月每周日1点10分30秒触发任务</span><br><span class="line">&quot;15,30,45 * * * * ?&quot; 每15秒，30秒，45秒时触发任务</span><br><span class="line">&quot;15-45 * * * * ?&quot; 15到45秒内，每秒都触发任务</span><br><span class="line">&quot;15/5 * * * * ?&quot; 每分钟的每15秒开始触发，每隔5秒触发一次</span><br><span class="line">&quot;15-30/5 * * * * ?&quot; 每分钟的15秒到30秒之间开始触发，每隔5秒触发一次</span><br><span class="line">&quot;0 0/3 * * * ?&quot; 每小时的第0分0秒开始，每三分钟触发一次</span><br><span class="line">&quot;0 15 10 ? * MON-FRI&quot; 星期一到星期五的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 L * ?&quot; 每个月最后一天的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 LW * ?&quot; 每个月最后一个工作日的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5L&quot; 每个月最后一个星期四的10点15分0秒触发任务</span><br><span class="line">&quot;0 15 10 ? * 5#3&quot; 每个月第三周的星期四的10点15分0秒触发任务</span><br></pre></td></tr></table></figure><h4 id="9-3-SpringBoot-Quartz"><a href="#9-3-SpringBoot-Quartz" class="headerlink" title="9.3 SpringBoot+Quartz"></a>9.3 SpringBoot+Quartz</h4><p>导入spring-boot-starter-quartz, 编写Job任务组件，继承QuartzJobBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTask5</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过Quartz工具调用定时任务&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Job组件（JobDetail、Tigger）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将MyTask5任务组件封装成JobDetail</span></span><br><span class="line">    <span class="keyword">public</span> JobDetail <span class="title function_">task5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(MyTask5.class)</span><br><span class="line">            .withIdentity(<span class="string">&quot;task5&quot;</span>).storeDurably().build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//为JobDetail指定触发时间cron表达式</span></span><br><span class="line">    <span class="keyword">public</span> Trigger <span class="title function_">task5Trigger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CronScheduleBuilder</span> <span class="variable">cronScheduleBuilder</span> <span class="operator">=</span> </span><br><span class="line">            CronScheduleBuilder.cronSchedule(<span class="string">&quot;0/5 46 10 * * ?&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(task5())</span><br><span class="line">                .withIdentity(<span class="string">&quot;task5&quot;</span>)</span><br><span class="line">                .withSchedule(cronScheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SpringBoot数据库访问</title>
      <link href="/2018/06/14/spring-boot-database.html"/>
      <url>/2018/06/14/spring-boot-database.html</url>
      
        <content type="html"><![CDATA[<p>Springboot对于数据访问层，无论是SQL还是NOSQL，都默认采用整合Spring Data的方式进行统一处理，Springboot添加大量自动配置，屏蔽了很多设置。并引入各种<em>Template，</em>Repository来简化我们对数据访问层的操作。</p><span id="more"></span><h3 id="1-SpringBoot数据库访问"><a href="#1-SpringBoot数据库访问" class="headerlink" title="1.SpringBoot数据库访问"></a>1.SpringBoot数据库访问</h3><h4 id="1-1-Spring-DAO-JdbcTemplate"><a href="#1-1-Spring-DAO-JdbcTemplate" class="headerlink" title="1.1 Spring DAO JdbcTemplate"></a>1.1 Spring DAO JdbcTemplate</h4><p>引入spring-boot-starter-jdbc后（hikari、spring-jdbc包），就可以借助DataSourceAutoConfiguration、JdbcTemplateAutoConfiguration自动配置组件创建出HikariDataSource、JdbcTemplate对象。</p><ol><li>引入jdbc启动器、驱动包，创建连接池</li><li>根据要操作表定义entity（pojo，属性名与字段名一致）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>定义Dao接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DirectionDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>定义Dao实现类，扫描并注入JdbcTemplate使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span><span class="comment">//通过组件扫描加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcDirectionDao</span> <span class="keyword">implements</span> <span class="title class_">DirectionDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template;<span class="comment">//通过自动配置加载到Spring容器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from direction&quot;</span>;</span><br><span class="line">        RowMapper&lt;Direction&gt; rowMapper = </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Direction&gt;(Direction.class);</span><br><span class="line">        <span class="keyword">return</span> template.query(sql, rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-Spring-MyBatis（XML-SQL版本）"><a href="#1-2-Spring-MyBatis（XML-SQL版本）" class="headerlink" title="1.2 Spring MyBatis（XML SQL版本）"></a>1.2 Spring MyBatis（XML SQL版本）</h4><ul><li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li><li>引入application.properties（连接池参数）</li><li>实体类(同上)</li><li>SQL定义</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.xdl.dao.DirectionMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;cn.xdl.entity.Direction&quot;</span>&gt;</span></span><br><span class="line">        select * from direction</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultType</span>=<span class="string">&quot;cn.xdl.entity.Direction&quot;</span>&gt;</span></span><br><span class="line">        select * from direction where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>Mapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DirectionMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Direction <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@MapperScan和mybatis.mapperLocations&#x3D;classpath:sql&#x2F;*.xml</p></li><li><p>在启动类前追加@MapperScan</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages=&quot;cn.xdl.dao&quot;)</span><span class="comment">//扫描Mapper接口创建对象加载到Spring容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunBoot</span> &#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在application.properties追加mybatis.mapperLocations</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis.mapperLocations</span>=<span class="string">classpath:sql/*.xml</span></span><br></pre></td></tr></table></figure><h4 id="1-3-Spring-MyBatis（注解-SQL版本）"><a href="#1-3-Spring-MyBatis（注解-SQL版本）" class="headerlink" title="1.3 Spring MyBatis（注解 SQL版本）"></a>1.3 Spring MyBatis（注解 SQL版本）</h4><ul><li>引入spring-boot-starter-jdbc、驱动包、mybatis-spring-boot-starter</li><li>引入application.properties（连接池参数）</li><li>实体类(同上)</li><li>定义Mapper接口，使用@Select、@Update、@Insert、@Delete注解定义SQL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DirectionMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from direction&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from direction where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Direction <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="meta">@Update(&quot;update direction set name=#&#123;name&#125; where id=#&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateName</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id,<span class="meta">@Param(&quot;name&quot;)</span>String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用@MapperScan（同上）</li></ul><h3 id="2-Spring-Data-JPA"><a href="#2-Spring-Data-JPA" class="headerlink" title="2. Spring Data JPA"></a>2. Spring Data JPA</h3><h4 id="2-1-Jpa"><a href="#2-1-Jpa" class="headerlink" title="2.1 Jpa"></a>2.1 Jpa</h4><p>Jpa (Java Persistence API) 是 Sun 官方提出的 Java 持久化规范。中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p><p>Sun引入新的JPA ORM规范主要是为了简化现有的持久化开发工作和整合 ORM 技术，结束现在 Hibernate，TopLink，JDO 等 ORM 框架各自为营的局面。</p><blockquote><p>注意:Jpa 是一套规范，不是一套产品，那么像 Hibernate,TopLink,JDO 他们是一套产品，如果说这些产品实现了这个 Jpa 规范，那么我们就可以叫他们为 Jpa 的实现产品。</p></blockquote><h4 id="2-2-Spring-Boot-Jpa"><a href="#2-2-Spring-Boot-Jpa" class="headerlink" title="2.2 Spring Boot Jpa"></a>2.2 Spring Boot Jpa</h4><p>Spring Boot Jpa 是 Spring 基于 ORM 框架、Jpa 规范的基础上封装的一套 Jpa 应用框架，可使开发者用极简的代码即可实现对数据的访问和操作。</p><blockquote><p>Spring Boot Jpa 让我们解脱了 DAO 层的操作，基本上所有 CRUD 都可以依赖于它来实现</p></blockquote><p>在Spring中使用JPA访问数据库，需要使用Spring Data模块支持。<br>    - SpringData是对Spring框架一个扩展模块，包含对JPA、Redis、MongoDB等技术的访问支持。</p><p>Spring Boot Jpa的使用 </p><ol><li><p>引入spring-boot-starter-jdbc、spring-boot-starter-data-jpa、驱动包</p></li><li><p>在application.properties定义db连接池参数（同上）</p></li><li><p>定义RunBoot启动类，使用@SpringBootApplication标记（同上）</p></li><li><p>根据要操作的表定义实体类，使用@Entity、@Table、@Id、@Column定义该对象和表结构之间的映射关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name=&quot;direction&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name=&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name=&quot;name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义Dao接口，可以选择继承JpaRepository、PagingAndSortingRepository、CrudRepository等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DirectionDao</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Direction, Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-Dao扩展操作"><a href="#2-3-Dao扩展操作" class="headerlink" title="2.3 Dao扩展操作"></a>2.3 Dao扩展操作</h4><p>分页查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//of(页数从0开始,记录条数)</span></span><br><span class="line">Page&lt;Direction&gt; page = dao.findAll(pageable);</span><br><span class="line">List&lt;Direction&gt; list = page.getContent();</span><br><span class="line">list.forEach(d-&gt;&#123;System.out.println(d.getId()+<span class="string">&quot; &quot;</span>+d.getName());&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;总记录数:&quot;</span>+page.getTotalElements()</span><br><span class="line">+<span class="string">&quot; 页数:&quot;</span>+(page.getNumber()+<span class="number">1</span>)+<span class="string">&quot;/&quot;</span>+page.getTotalPages());</span><br><span class="line">List&lt;Direction&gt; list1 = dao.findByIdGreaterThan2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>按方法名规则扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//where id&gt;?</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">findByIdGreaterThan</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>定义SQL语句扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(nativeQuery=true,value=&quot;select * from direction where id&gt;:id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">findByIdGreaterThan1</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>定义JPQL面向查询语句扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;from Direction where id&gt;:id&quot;)</span> <span class="comment">//使用类型名和属性名替代表名和字段名</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Direction&gt; <span class="title function_">findByIdGreaterThan2</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span><span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>按名称模糊查询，带分页支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(nativeQuery=true,value=&quot;select * from direction where name like :name&quot;</span></span><br><span class="line"><span class="meta">    ,countQuery=&quot;select count(*) from direction where name like :name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Direction&gt; <span class="title function_">findByNameLike1</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span>String name,Pageable pageable)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SpringBoot入门</title>
      <link href="/2018/06/06/spring-boot.html"/>
      <url>/2018/06/06/spring-boot.html</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 是由 Pivotal 团队提供的全新框架。Spring Boot 是所有基于 Spring Framework 5.0 开发的项目的起点。Spring Boot 的设计是为了简化新 Spring 应用的初始搭建以及开发过程，并且尽可能减少你的配置文件。</p><span id="more"></span><p>从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。用大佬的话来理解，就是 spring boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架，总结一下及几点：</p><ol><li>为所有 Spring 开发提供一个更快更广泛的入门体验。</li><li>零配置。无冗余代码生成和XML 强制配置，遵循“约定大于配置” 。</li><li>集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。</li><li>提供一系列大型项目常用的非功能性特征，如嵌入式服务器、安全性、度量、运行状况检查、外部化配置等。</li><li>Spring Boot 不是Spring 的替代者，Spring 框架是通过 IOC 机制来管理 Bean 的。Spring Boot 依赖 Spring 框架来管理对象的依赖。Spring Boot 并不是Spring 的精简版本，而是为使用 Spring 做好各种产品级准备。</li></ol><h3 id="1-项目管理工具Maven的基本使用"><a href="#1-项目管理工具Maven的基本使用" class="headerlink" title="1. 项目管理工具Maven的基本使用"></a>1. 项目管理工具Maven的基本使用</h3><p>Maven是一个使用java编写的开源的项目管理工具，可以方便灵活的控制项目，不必浪费时间去在不同的环境中配置依赖的jar包，而专心于业务逻辑。</p><h4 id="1-1-配置Maven的系统环境变量"><a href="#1-1-配置Maven的系统环境变量" class="headerlink" title="1.1 配置Maven的系统环境变量"></a>1.1 配置Maven的系统环境变量</h4><ol><li>下载并解压到目录，如<code>D:\apache-maven-3.6.1</code></li><li>添加新的系统环境变量MAVEN_HOME&#x3D;安装的目录：<code>MAVEN_HOME=D:\apache-maven-3.6.1</code></li><li>添加<code>%MAVEN_HOME%\bin</code>到系统PATH变量.</li><li>测试Maven配置是否成功，打开命令行窗口，输入<code>mvn -v</code>，如果有maven 版本信息输出则证明配置成功，否则请查看自己配置路径等是否正确。</li></ol><blockquote><p>注意：安装Maven前请确保已安装JDK并成功配置其环境变量。</p></blockquote><h4 id="1-2-maven中的术语"><a href="#1-2-maven中的术语" class="headerlink" title="1.2 maven中的术语"></a>1.2 maven中的术语</h4><ul><li><strong>maven插件</strong>：maven主要定义了项目对象模型的生命周期。实际上每个任务都是交由插件完成的。maven的生命周期与插件目标相互绑定，来完成每个具体的任务。</li><li><strong>maven坐标</strong>：就是对项目的定位。groupId：组id，机构名。artifactId：构建id ，产品名或者产品的id。version ：版本号。</li><li><strong>坐标形式</strong>：groupId + artifactId+ version</li><li><strong>maven仓库</strong>：存放maven共享构建的位置。<ol><li>本地仓库：localRepository（使用<code>conf/settings.xml</code>设置）</li><li>私服仓库：部署在局域网中的仓库，方便整个团队的开发使用。</li><li>中央仓库：远程仓库下载地址：<a href="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</a></li></ol></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- conf/settings.xml设置本地仓库路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">localRepository</span>&gt;</span>D:/apache-maven-3.6.1/.m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="1-3-maven构建的生命周期"><a href="#1-3-maven构建的生命周期" class="headerlink" title="1.3 maven构建的生命周期"></a>1.3 maven构建的生命周期</h4><p>清除–&gt; 编译–&gt; 测试–&gt; 报告–&gt; 打包(jar\war)–&gt; 安装–&gt; 部署</p><ol><li>清除：<code>mvn clean</code></li><li>编译：<code>mvn compile</code></li><li>测试：<code>mvn test</code></li><li>打包：<code>mvn package</code></li><li>安装：<code>mvn install</code></li><li>部署：<code>mvn deploy</code></li></ol><h4 id="1-4-MAVEN优点"><a href="#1-4-MAVEN优点" class="headerlink" title="1.4 MAVEN优点"></a>1.4 MAVEN优点</h4><ol><li>模块化项目<ul><li>项目非常大时，可借助Maven将一个项目拆分成多个工程，最好是一个模块对应一个工程，利于分工协作。而且模块可以通信。</li></ul></li><li>实现Jar包共享<ul><li>借助Maven，可将jar包仅仅保存在“仓库”中，有需要该文件时，就引用该文件接口，不需要复制文件过来占用空间。</li></ul></li><li>jar包的依赖<ul><li>借助Maven可以以规范的方式下载jar包，因为所有的知名框架或第三方工具的jar包已经按照统一的规范存放到了Maven的中央仓库中。</li></ul></li><li>jar包的自动导入<ul><li>通过xml定义引入jar包，Maven会自动导入jar包及其依赖jar包进来。</li></ul></li></ol><h4 id="1-5-MAVEN工具"><a href="#1-5-MAVEN工具" class="headerlink" title="1.5 MAVEN工具"></a>1.5 MAVEN工具</h4><ul><li>可以命令行使用，也可以结合Eclipse和Idea使用</li><li>简化项目搭建、编译、打包、发布等工作</li></ul><h3 id="2-SpringBoot基础"><a href="#2-SpringBoot基础" class="headerlink" title="2. SpringBoot基础"></a>2. SpringBoot基础</h3><ul><li>SpringBoot是对<strong>Spring框架的封装</strong>，用于<strong>简化</strong>Spring应用搭建和开发过程。</li><li>SpringBoot是pivotal公司产品、SpringCloud也是。</li></ul><h4 id="2-1-SpringBoot典型特点："><a href="#2-1-SpringBoot典型特点：" class="headerlink" title="2.1 SpringBoot典型特点："></a>2.1 SpringBoot典型特点：</h4><ul><li>去除XML配置，完全采用Java配置方式</li><li>内置tomcat服务器</li><li>利用自动配置创建很多对象（DataSource、JdbcTemplate、DispatcherServlet等）</li><li>提供一系列启动器（jar包集合）</li><li>采用properties或yml做配置文件</li><li>应用采用jar包发布</li></ul><h4 id="2-2-SpringBoot程序构成"><a href="#2-2-SpringBoot程序构成" class="headerlink" title="2.2 SpringBoot程序构成"></a>2.2 SpringBoot程序构成</h4><ul><li>创建工程，导入boot启动器（jar包）</li><li><code>spring-boot-starter</code> (核心、包含ioc、yml、自动配置、Log日志)</li><li><code>spring-boot-starter-parent</code>（包含参数设置、文件编码、jdk版本等）</li><li><code>spring-boot-starter-jdbc</code>（包含连接池、jdbcTemplate等）</li><li><code>spring-boot-starter-web</code>（包含mvc、restful、tomcat等）</li><li><code>spring-boot-starter-test</code>（包含junit、spring-test等）</li><li>添加配置文件<code>application.properties</code>或<code>application.yml</code></li></ul><h4 id="2-3-SpringBoot配置文件"><a href="#2-3-SpringBoot配置文件" class="headerlink" title="2.3 SpringBoot配置文件"></a>2.3 SpringBoot配置文件</h4><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure><h4 id="2-4-SpringBoot启动类"><a href="#2-4-SpringBoot启动类" class="headerlink" title="2.4 SpringBoot启动类"></a>2.4 SpringBoot启动类</h4><p>定义启动类，通过main方法启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Xxxx</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(Xxxx.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-SpringBoot数据库访问"><a href="#2-5-SpringBoot数据库访问" class="headerlink" title="2.5 SpringBoot数据库访问"></a>2.5 SpringBoot数据库访问</h4><p>在pom.xml定义spring-boot-starter-jdbc、mysql驱动包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.properties定义数据库连接参数</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/ydma</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>定义启动类，内部会根据自动配置机制生成DataSource和JdbcTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunBoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> </span><br><span class="line">                SpringApplication.run(RunBoot.class, args);</span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(ds.getConnection());</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getBean(JdbcTemplate.class);</span><br><span class="line">        System.out.println(template);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into paper_score (total_score,my_score,user_id) values (?,?,?)&quot;</span>;</span><br><span class="line">        Object[] params = &#123;<span class="number">100</span>,<span class="number">90</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        template.update(sql,params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提示：DataSource和JdbcTemplate都是基于自动配置机制产生，直接注入使用即可。</span></span><br></pre></td></tr></table></figure><h4 id="2-6-打包发布SpringBoot程序："><a href="#2-6-打包发布SpringBoot程序：" class="headerlink" title="2.6 打包发布SpringBoot程序："></a>2.6 打包发布SpringBoot程序：</h4><ol><li><p>在pom.xml定义spring-boot-maven-plugin插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击工程右键选择run as- maven build …</p></li><li><p>执行完毕后会在项目target目录下生成一个jar包，该包就是发布包</p><ul><li>可以采用java -jar xxxx.jar命令启动</li></ul></li></ol><blockquote><p>提示：eclipse设置jdk必须指向到JDK路径，不要JRE路径。</p></blockquote><h3 id="3-SpringBoot启动过程"><a href="#3-SpringBoot启动过程" class="headerlink" title="3. SpringBoot启动过程"></a>3. SpringBoot启动过程</h3><ol><li>调用SpringApplication的静态的run方法启动</li><li>静态的run方法调用SpringApplication对象的run方法<ul><li>(SpringApplication对象创建时加载spring.factories文件中Initializer和Application Listeners组件，判断程序类型servlet、reactive、default)</li></ul></li><li>对象的run方法会创建Spring的ApplicationContext容器对象<ul><li>获取启动Listener组件</li><li>获取environment环境参数</li><li>获取启动Logo信息Banner</li><li>根据程序类型不同创建不同类型的ApplicationContext对象</li><li>将Listener、environment、banner设置到ApplicationContext容器对象中</li><li>为ApplicationContext容器对象加载程序中各种Bean组件</li><li>开始执行启动任务ApplicationRunner、CommandLineRunner等</li><li>返回ApplicationContext容器对象</li></ul></li></ol><h3 id="4-SpringBootApplication作用"><a href="#4-SpringBootApplication作用" class="headerlink" title="4. @SpringBootApplication作用"></a>4. @SpringBootApplication作用</h3><p>SpringApplication.run方法在启动中，加载一个带有@SpringBootApplication标记的参数，该标记具有以下几种功能。</p><h4 id="4-1-SpringBootConfiguration（SpringBoot-Bean定义）"><a href="#4-1-SpringBootConfiguration（SpringBoot-Bean定义）" class="headerlink" title="4.1 @SpringBootConfiguration（SpringBoot Bean定义）"></a>4.1 @SpringBootConfiguration（SpringBoot Bean定义）</h4><ul><li>spring中bean定义<code>&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</code></li><li>SpringBoot通过<code>@Bean、@Primary</code>标记定义。</li></ul><p>案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span><span class="comment">//开启Bean定义功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//将返回的UserDao对象放入Spring容器，默认方法名为id</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userdao</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;dao2&quot;)</span><span class="comment">//将返回的UserDao对象放入Spring容器，指定id为dao2</span></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//默认注入该对象</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">userdao1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(&quot;userService&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@SpringBootConfiguration标记是对Spring的@Configuration封装，所以直接用@Configuration也可以。</p></blockquote><h4 id="4-2-ComponentScan（SpringBoot组件扫描）"><a href="#4-2-ComponentScan（SpringBoot组件扫描）" class="headerlink" title="4.2 @ComponentScan（SpringBoot组件扫描）"></a>4.2 @ComponentScan（SpringBoot组件扫描）</h4><ul><li>spring中组件扫描<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></li><li>SpringBoot通过@ComponentScan<ol><li>扫描指定包路径组件，带@Controller、@Service、@Repository、@Component注解标记组件<ul><li><code>@ComponentScan(basePackages= &#123;&quot;cn.xdl.dao&quot;,&quot;cn.xdl.service&quot;&#125;)</code></li></ul></li><li>扫描cn.xdl包及子包下的组件<ul><li><code>@ComponentScan(basePackages=&quot;cn.xdl&quot;)</code></li></ul></li><li>扫描当前包及子包下的组件<ul><li><code>@ComponentScan</code></li></ul></li><li>扫描当前包及子包组件，并且将DeptService组件纳入<ul><li><code>@ComponentScan(includeFilters= &#123;@Filter(type=FilterType.ASSIGNABLE_TYPE,classes=DeptService.class)&#125;)</code></li></ul></li><li>扫描当前包及子包组件，带有@Controller、@Service…、@MyComponent注解有效<ul><li><code>@ComponentScan(includeFilters= &#123;@Filter(type=FilterType.ANNOTATION,classes=MyComponent.class)&#125;)</code></li></ul></li></ol></li></ul><h4 id="4-3-EnableAutoConfiguration（SpringBoot自动配置）"><a href="#4-3-EnableAutoConfiguration（SpringBoot自动配置）" class="headerlink" title="4.3 @EnableAutoConfiguration（SpringBoot自动配置）"></a>4.3 @EnableAutoConfiguration（SpringBoot自动配置）</h4><p>自动配置机制是SpringBoot框架特有功能，能在启动后自动创建一些常用对象，例如DataSource、JdbcTemplate等。</p><ul><li>自动配置原理：<ol><li>在xxx-autoconfigure.jar包中META-INF目录下有一个spring.factories文件，其中定义了大量的XxxAutoConfiguration配置组件。当开启@EnableAutoConfiguration标记时，标记内部会触发AutoConfigurationImportSelector组件调用SpringFactoriesLoader加载spring.factories文件。</li><li>自动配置组件就是采用@Configuration+@Bean+@Primary标记事先定义好的配置组件，通过Boot启动自动去spring.factories文件加载，然后在Spring容器中创建出约定对象。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataSourceAutoConfiguration<span class="comment">//创建dataSource对象</span></span><br><span class="line">JdbcTemplateAutoConfiguration<span class="comment">//创建jdbcTemplate</span></span><br><span class="line">DispatcherServletAutoConfiguration<span class="comment">//创建DispatcherServlet对象</span></span><br><span class="line">RedisAutoConfiguration<span class="comment">//创建RedisTemplate对象</span></span><br></pre></td></tr></table></figure><ul><li>通过自动配置机制创建DataSource对象<ol><li>引入spring-boot-starter-jdbc（hikari）、驱动包</li><li>在application.properties文件追加db参数</li><li>在启动类使用@EnableAutoConfiguration标记<ul><li>DataSourceAutoConfiguration默认会创建Hikari、tomcat、dbcp2连接池对象，优先级hikari最高，依次tomcat、dbcp2.</li><li>如果通过spring.datasource.type属性指定其他类型连接池组件，SpringBoot可以按指定类型创建连接池。<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">org.apache.commons.dbcp2.BasicDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h4 id="4-4-MAVEN如何排除某个jar包（扩展）"><a href="#4-4-MAVEN如何排除某个jar包（扩展）" class="headerlink" title="4.4 MAVEN如何排除某个jar包（扩展）"></a>4.4 MAVEN如何排除某个jar包（扩展）</h4><p>在引入spring-boot-starter-jdbc启动器时，由于jar包依赖会自动引入HikariCP，可以通过&lt; exclusion&gt;标记排除依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」SSM框架整合(Spring+SpringMVC+MyBatis)</title>
      <link href="/2018/05/11/spring-ssm.html"/>
      <url>/2018/05/11/spring-ssm.html</url>
      
        <content type="html"><![CDATA[<p>SSM框架是spring MVC ，spring和mybatis框架的整合，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，DAO层。<span id="more"></span></p><ul><li>使用spring MVC负责请求的转发和视图管理</li><li>spring实现业务对象管理</li><li>mybatis作为数据对象的持久化引擎</li></ul><h3 id="1-搭建SSM架构步骤："><a href="#1-搭建SSM架构步骤：" class="headerlink" title="1.搭建SSM架构步骤："></a>1.搭建SSM架构步骤：</h3><ol><li>设计数据库</li><li>先写实体类entity，定义对象的属性，（参照数据库中表的字段来设置）。</li><li>编写Mapper.xml（Mybatis），定义功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li><li>编写Mapper.java(DAO接口)，将Mapper.xml中的操作按照id映射成Java函数。</li><li>配置spring和mybatis框架的整合(applicationContext.xml)</li><li>编写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li><li>配置SpringMVC(web.xml)</li><li>编写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li><li>编写JSP页面调用，请求哪些参数，需要获取什么数据。</li></ol><blockquote><p>DataBase –&gt; Entity –&gt; Mapper.xml –&gt; Mapper.Java(DAO) –&gt; Service.java –&gt; Controller.java –&gt; Jsp</p></blockquote><h3 id="2-搭建SSM架构实例（管理员登录）"><a href="#2-搭建SSM架构实例（管理员登录）" class="headerlink" title="2.搭建SSM架构实例（管理员登录）"></a>2.搭建SSM架构实例（管理员登录）</h3><h4 id="2-1-设计数据库-以MySql为例"><a href="#2-1-设计数据库-以MySql为例" class="headerlink" title="2.1 设计数据库(以MySql为例)"></a>2.1 设计数据库(以MySql为例)</h4><p>建立web项目，在src下新建sql脚本(admin.sql)，并在数据库中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE exam_sys;</span><br><span class="line"><span class="comment">/** 管理员表 */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> admin;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> admin(</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;管理员ID&#x27;</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;管理员账号&#x27;</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;管理员密码&#x27;</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_id_pk <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> et_admin_name_uk <span class="keyword">UNIQUE</span>(NAME)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/** 插入数据 */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> admin (name, password) <span class="keyword">VALUES</span>(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> admin;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-先写实体类entity，定义对象的属性"><a href="#2-2-先写实体类entity，定义对象的属性" class="headerlink" title="2.2 先写实体类entity，定义对象的属性"></a>2.2 先写实体类entity，定义对象的属性</h4><p>参照数据库中表的字段来设置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">exam</span>.<span class="property">entity</span>;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">    private int id;</span><br><span class="line">    private <span class="title class_">String</span> name;</span><br><span class="line">    private <span class="title class_">String</span> password;</span><br><span class="line">    <span class="comment">/** 添加 getter/setter方法</span></span><br><span class="line"><span class="comment">     *  添加 无参，有参构造</span></span><br><span class="line"><span class="comment">     *  重写toString()以便于测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-编写AdminMapper-xml（Mybatis），定义功能"><a href="#2-3-编写AdminMapper-xml（Mybatis），定义功能" class="headerlink" title="2.3 编写AdminMapper.xml（Mybatis），定义功能"></a>2.3 编写AdminMapper.xml（Mybatis），定义功能</h4><p>对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//ibatis.apache.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://ibatis.apache.org/dtd/ibatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace指定和哪个Mapper映射器接口对应 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.exam.mapper.AdminDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByNameAndPassword&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.exam.entity.Admin&quot;</span>&gt;</span></span><br><span class="line">        select * from admin where name=#&#123;name, jdbcType=VARCHAR&#125; and password=#&#123;password, jdbcType=VARCHAR&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。"><a href="#2-4-编写AdminDao-java，将AdminMapper-xml中的操作按照id映射成Java函数。" class="headerlink" title="2.4 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。"></a>2.4 编写AdminDao.java，将AdminMapper.xml中的操作按照id映射成Java函数。</h4><p>导入Mybatis相关jar包：mybatis.jar、mysql-connector-java.jar(数据库驱动)、mybatis-spring.jar(SM整合)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">exam</span>.<span class="property">mapper</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">apache</span>.<span class="property">ibatis</span>.<span class="property">annotations</span>.<span class="property">Param</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">exam</span>.<span class="property">entity</span>.<span class="property">Admin</span>;</span><br><span class="line"></span><br><span class="line">public interface <span class="title class_">AdminDao</span> &#123;</span><br><span class="line">    public <span class="title class_">Admin</span> <span class="title function_">findByNameAndPassword</span>(@<span class="title class_">Param</span>(<span class="string">&quot;name&quot;</span>) <span class="title class_">String</span> name, @<span class="title class_">Param</span>(<span class="string">&quot;password&quot;</span>) <span class="title class_">String</span> password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-配置spring和mybatis框架的整合"><a href="#2-5-配置spring和mybatis框架的整合" class="headerlink" title="2.5 配置spring和mybatis框架的整合"></a>2.5 配置spring和mybatis框架的整合</h4><p>导入Spring相关jar包：ioc&#x2F;aop&#x2F;dao&#x2F;连接池；添加Spring配置文件（applicationContext.xml）到src下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/exam_sys&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactoryBean来创建SqlSessionFactory</span></span><br><span class="line"><span class="comment">        属性dataSource：注入连接池对象</span></span><br><span class="line"><span class="comment">        属性mapperLocations：指定MyBatis的映射器XML配置文件的位置</span></span><br><span class="line"><span class="comment">        属性typeAliasesPackage：对应我们的实体类所在的包，配置此项可在Mapper映射器直接使用类名，而非包名.类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/exam/mapper/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.exam.entity&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.exam.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;annotationClass&quot; value=&quot;com.annotation.MyAnnotation&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启服务层组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.exam.service&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-6-编写Service-java，为控制层提供服务"><a href="#2-6-编写Service-java，为控制层提供服务" class="headerlink" title="2.6 编写Service.java，为控制层提供服务"></a>2.6 编写Service.java，为控制层提供服务</h4><p>接受控制层的参数，完成相应的功能，并返回给控制层。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">exam</span>.<span class="property">service</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">annotation</span>.<span class="property">Autowired</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">stereotype</span>.<span class="property">Service</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">exam</span>.<span class="property">mapper</span>.<span class="property">AdminDao</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Service</span>(<span class="string">&quot;adminService&quot;</span>)</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">AdminService</span> &#123;</span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private <span class="title class_">AdminDao</span> dao;</span><br><span class="line">    </span><br><span class="line">    public boolean <span class="title class_">Login</span>(<span class="title class_">String</span> name, <span class="title class_">String</span> password) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dao.<span class="title function_">findByNameAndPassword</span>(name, password)!=<span class="literal">null</span>?<span class="attr">true</span>:<span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="title class_">Exception</span> e) &#123;</span><br><span class="line">            e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-配置SpringMVC"><a href="#2-7-配置SpringMVC" class="headerlink" title="2.7 配置SpringMVC"></a>2.7 配置SpringMVC</h4><p>导入jar包（spring-web.jar，spring-webmvc.jar）,生成web.xml并配置DispatcherServlet分发请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置编码过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet分发请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在applicationContext.xml对静态资源进行放行 ：mvc:default-servlet-handler--&gt;</span></span><br></pre></td></tr></table></figure><p>在applicationContext.xml中开启组件扫描(com.controller)，开启标注形式mvc，配置视图处理器 并 对静态资源进行放行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启控制器组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.exam.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启标注形式mvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-8-编写Controller-java，连接页面请求和服务层"><a href="#2-8-编写Controller-java，连接页面请求和服务层" class="headerlink" title="2.8 编写Controller.java，连接页面请求和服务层"></a>2.8 编写Controller.java，连接页面请求和服务层</h4><p>获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。（导入Json相关包：jackson-core.jar，jackson-databind.jar，jackson-annotations.jar）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">exam</span>.<span class="property">controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.<span class="property">servlet</span>.<span class="property">http</span>.<span class="property">HttpServletRequest</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">beans</span>.<span class="property">factory</span>.<span class="property">annotation</span>.<span class="property">Autowired</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">stereotype</span>.<span class="property">Controller</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">web</span>.<span class="property">bind</span>.<span class="property">annotation</span>.<span class="property">RequestMapping</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">web</span>.<span class="property">bind</span>.<span class="property">annotation</span>.<span class="property">RequestMethod</span>;</span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">web</span>.<span class="property">bind</span>.<span class="property">annotation</span>.<span class="property">ResponseBody</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">exam</span>.<span class="property">entity</span>.<span class="property">Admin</span>;</span><br><span class="line"><span class="keyword">import</span> com.<span class="property">exam</span>.<span class="property">service</span>.<span class="property">AdminService</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Controller</span></span><br><span class="line">@<span class="title class_">RequestMapping</span>(<span class="string">&quot;/admin&quot;</span>)</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">AdminController</span> &#123;</span><br><span class="line">    @<span class="title class_">Autowired</span></span><br><span class="line">    private <span class="title class_">AdminService</span> <span class="keyword">as</span>;</span><br><span class="line">    </span><br><span class="line">    @<span class="title class_">RequestMapping</span>(<span class="string">&quot;/tologin&quot;</span>)</span><br><span class="line">    public <span class="title class_">String</span> <span class="title function_">toLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin/login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="title class_">RequestMapping</span>(value=<span class="string">&quot;/login&quot;</span>,method=<span class="title class_">RequestMethod</span>.<span class="property">POST</span>)</span><br><span class="line">    @<span class="title class_">ResponseBody</span></span><br><span class="line">    public boolean <span class="title function_">addUser</span>(<span class="params">Admin admin, HttpServletRequest request</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;add:&quot;</span>+admin);</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(admin.<span class="title function_">getName</span>()+<span class="string">&quot;---&quot;</span>+admin.<span class="title function_">getPassword</span>());</span><br><span class="line">        boolean bl = <span class="keyword">as</span>.<span class="title class_">Login</span>(admin.<span class="title function_">getName</span>(), admin.<span class="title function_">getPassword</span>());</span><br><span class="line">        <span class="keyword">if</span>(bl) &#123;</span><br><span class="line">            <span class="comment">//登录成功的逻辑</span></span><br><span class="line">            request.<span class="title function_">getSession</span>().<span class="title function_">setAttribute</span>(<span class="string">&quot;admin&quot;</span>, admin);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//登录失败的逻辑</span></span><br><span class="line">        request.<span class="title function_">setAttribute</span>(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-9-编写JSP页面调用"><a href="#2-9-编写JSP页面调用" class="headerlink" title="2.9 编写JSP页面调用"></a>2.9 编写JSP页面调用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    管理员: <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;aName&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;aPassword&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;loginBtn&quot;</span>  <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#loginBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&quot;admin/login&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: $(<span class="string">&quot;#aName&quot;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>: $(<span class="string">&quot;#aPassword&quot;</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(res);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」持久层框架Mybatis</title>
      <link href="/2018/05/06/spring-mybatis.html"/>
      <url>/2018/05/06/spring-mybatis.html</url>
      
        <content type="html"><![CDATA[<p>Mybatis支持普通sql操作，存储过程的调用，它是一个高级的ORM框架(Object Relation Mapping对象关系映射–以面向对象思想访问数据库)，是一个基于Java的持久层框架。</p><span id="more"></span><p>MyBatis封装了几乎所有的JDBC操作和参数的手工设置，它会对结果集自动封装成对象，以及直接把对象存入数据库，甚至可以做到对象与对象的关系维护；诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。</p><h3 id="1-Mybatis框架的构成"><a href="#1-Mybatis框架的构成" class="headerlink" title="1. Mybatis框架的构成"></a>1. Mybatis框架的构成</h3><ul><li>实体类 ： 封装记录信息（JavaBean）</li><li>SQL定义文件 ：定义sql语句（编写SQL语句的XML）</li><li>主配置文件 ：定义连接信息、加载SQL文件 以及其他设置的XML</li><li>框架API ：用于实现数据库增删改查操作（主要通过SqlSession）</li></ul><h3 id="2-使用Mybatis访问数据库"><a href="#2-使用Mybatis访问数据库" class="headerlink" title="2. 使用Mybatis访问数据库"></a>2. 使用Mybatis访问数据库</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p><ol><li><p>准备数据库及创建项目（需要mybatis的jar包和数据库驱动包）</p></li><li><p>根据表建立对应的实体类：<code>Emp(id,name,salary)</code></p></li><li><p>在「src」目录下创建 MyBaits 的主配置文件 mybatis-config.xml ，其主要作用是提供连接数据库用的驱动，数据名称，编码方式，账号密码等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;environment&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;environment&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> </span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/mapper/EmpMapper.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>在「src」包路径下创建配置文件（com&#x2F;mapper&#x2F;EmpMapper.xml）,然后根据需求定义sql</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mapper.EmpMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义SQL语句 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">&quot;com.mapper.Emp&quot;</span>&gt;</span></span><br><span class="line">         select * from emp32 where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">resultType</span>=<span class="string">&quot;com.mapper.Emp&quot;</span>&gt;</span></span><br><span class="line">         select * from emp32 where name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>parameterType：要求输入参数的类型</li><li>resultType：输出的类型</li></ul></blockquote></li><li><p>封装工具类获取SQLSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory ssf;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> SqlSessionUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        ssf = ssfb.build(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 获取SQLSession</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line">        <span class="keyword">return</span> ssf.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">ss</span> <span class="operator">=</span>SqlSessionUtil.getSqlSession();</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> ss.selectOne(<span class="string">&quot;findById&quot;</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>基本原理</p></blockquote><ul><li>应用程序找 MyBatis 要数据</li><li>MyBatis 从数据库中找来数据</li><li>通过 mybatis-config.xml 定位哪个数据库</li><li>通过 EmpMapper.xml 执行对应的 sql 语句</li><li>基于 EmpMapper.xml 把返回的数据库封装在 Emp 对象中</li><li>返回一个 Emp 对象</li></ul><h3 id="3-Mybatis的CRUD操作"><a href="#3-Mybatis的CRUD操作" class="headerlink" title="3. Mybatis的CRUD操作"></a>3. Mybatis的CRUD操作</h3><p>以员工表<code>Emp(id,name,salary)</code>为例</p><ol><li>第一步：配置EmpMapper.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmp&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.mapper.Emp&quot;</span>&gt;</span></span><br><span class="line">    insert into emp32(name, salary) values(#&#123;name&#125;, #&#123;salary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteEmpById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">    delete from emp32 where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmpById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.mapper.Emp&quot;</span>&gt;</span></span><br><span class="line">    update emp32 set name=#&#123;name&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mapper.Emp&quot;</span>&gt;</span></span><br><span class="line">     select * from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mapper.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp32</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>parameterType：要求输入参数的类型</li><li>resultType：输出的类型</li></ul></blockquote><ol start="2"><li>第二步：SQLSession实现增删改查</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先构建SQLSession工厂构建器</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="comment">// 构建SqlSessionFactory关联主配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> EmpTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;sqlmap-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">ssf</span> <span class="operator">=</span> ssfb.build(inputStream);</span><br><span class="line"><span class="comment">// 通过SqlSession 工厂对象 来获取SqlSession</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">ss</span> <span class="operator">=</span> ssf.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">0</span>,<span class="string">&quot;ef2&quot;</span>,<span class="number">50000</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">addRows</span> <span class="operator">=</span> ss.insert(<span class="string">&quot;insertEmp&quot;</span>, emp);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="type">int</span> <span class="variable">delRows</span> <span class="operator">=</span> ss.delete(<span class="string">&quot;deleteEmpById&quot;</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//更新</span></span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">1</span>,<span class="string">&quot;hello&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">updateRows</span> <span class="operator">=</span> ss.update(<span class="string">&quot;updateEmpById&quot;</span>, emp2);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> ss.selectOne(<span class="string">&quot;findById&quot;</span>, <span class="number">6</span>);</span><br><span class="line">List&lt;Emp&gt; empList = ss.selectList(<span class="string">&quot;findAll&quot;</span>);</span><br><span class="line"></span><br><span class="line">ss.commit();</span><br></pre></td></tr></table></figure><blockquote><p>SqlSession对象的操作方法如下：</p></blockquote><ul><li>insert(..) 插入操作</li><li>update(..) 更新操作</li><li>delete(..) 删除操作</li><li>selectOne(..) 单行查询操作</li><li>selectList(..) 多行查询操作</li><li>通过 session.commit() 来提交事务，也可以简单理解为更新到数据库</li></ul><h3 id="4-Mapper映射器"><a href="#4-Mapper映射器" class="headerlink" title="4. Mapper映射器"></a>4. Mapper映射器</h3><p>使用规则：</p><ol><li>接口的方法名和SQL定义文件中的id保持一致</li><li>接口方法的返回值类型 要和resultType 保持一致<ul><li>单行：<code>resultType</code></li><li>多行：<code>List&lt;resultType&gt;</code></li><li>增删改返回值，推荐int，也可以是void</li></ul></li><li>接口方法参数和parameterType保持 一致，如果没有parameterType则参数任意</li><li>SQL定义文件中的namespace必须包名.接口名</li></ol><h3 id="5-向mapper传多个参数"><a href="#5-向mapper传多个参数" class="headerlink" title="5. 向mapper传多个参数"></a>5. 向mapper传多个参数</h3><h4 id="5-1-第一种方案：-0-，-1-x2F-param1-和-param2"><a href="#5-1-第一种方案：-0-，-1-x2F-param1-和-param2" class="headerlink" title="5.1 第一种方案：#{0}，#{1} &#x2F; #{param1} 和 #{param2}"></a>5.1 第一种方案：#{0}，#{1} &#x2F; #{param1} 和 #{param2}</h4><p>DAO层的函数方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Emp <span class="title function_">findByIdAndName</span><span class="params">(<span class="type">int</span> id, String name)</span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIdAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;0&#125; and name = #&#123;1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。<br>也可以用#{param1} 和 #{param2}实现同意效果。</p><h4 id="5-2-第二种方案-param"><a href="#5-2-第二种方案-param" class="headerlink" title="5.2 第二种方案@param"></a>5.2 第二种方案@param</h4><p>Dao层的函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Emp <span class="title function_">findByIdAndName</span><span class="params">(<span class="meta">@param(&quot;id&quot;)</span><span class="type">int</span> id, <span class="meta">@param(&quot;name&quot;)</span>String name)</span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIdAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-第三种方案：采用对象或Map传多参数"><a href="#5-3-第三种方案：采用对象或Map传多参数" class="headerlink" title="5.3 第三种方案：采用对象或Map传多参数"></a>5.3 第三种方案：采用对象或Map传多参数</h4><p>Dao层的函数方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Emp <span class="title function_">findByIdAndName</span><span class="params">(Emp emp)</span>;</span><br><span class="line"><span class="keyword">public</span> Emp <span class="title function_">findByIdAndName2</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br></pre></td></tr></table></figure><p>对应的Mapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIdAndName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.bean.Emp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIdAndName2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp32 where id = #&#123;id&#125; and name = #&#123;name&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-结果集列名和属性名不一致的解决方法"><a href="#6-结果集列名和属性名不一致的解决方法" class="headerlink" title="6. 结果集列名和属性名不一致的解决方法"></a>6. 结果集列名和属性名不一致的解决方法</h3><p>在SQL定义中，resultType属性用于指定查询数据采用哪种类型封装，规则为结果集列名和属性名一致，如果不一致将不能接收查询结果。<br>解决方法：</p><ol><li>使用别名，select语句使用与属性一致的别名</li><li>使用resultMap替换resultType，用resultMap指定结果集列名和属性名的对应关系</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义resultMap将sql 结果集列名(数据库中的字段)和Emp类中的属性做一个映射关系</span></span><br><span class="line"><span class="comment">    type:resultMap最终所映射的Java对象类型，可以使用别名</span></span><br><span class="line"><span class="comment">    id:对resultMap的唯一标识 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.bean.Emp&quot;</span> <span class="attr">id</span>=<span class="string">&quot;empMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id表示查询结果集中唯一标识 </span></span><br><span class="line"><span class="comment">        column:查询出的列名</span></span><br><span class="line"><span class="comment">        property:type所指定的类中的属性名 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;e_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 对普通列的映射定义 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>  <span class="attr">column</span>=<span class="string">&quot;salary&quot;</span>  <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用resultMap --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findEmpById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empMap&quot;</span>&gt;</span></span><br><span class="line">         select * from  emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-类型的别名和日志输出"><a href="#7-类型的别名和日志输出" class="headerlink" title="7. 类型的别名和日志输出"></a>7. 类型的别名和日志输出</h3><p>在mybatis-config.xml中自定义类型的别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.bean.Emp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在EmpMapper.xml中使用别名 resultType&#x3D;”emp”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">    select id,name,salary sal from emp32 where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置MyBatis的日志输出到控制台</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置是否允许缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置日志输出的目标--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-JdbcType"><a href="#8-JdbcType" class="headerlink" title="8. JdbcType"></a>8. JdbcType</h3><p>在执行SQL时MyBatis会自动通过对象中的属性给SQL中参数赋值，它会自动将Java类型转换成数据库的类型。而一旦传入的是null它就无法准确判断这个类型应该是什么，就有可能将类型转换错误，从而报错。</p><ul><li>所以 MyBatis 插入空值时，需要指定JdbcType，这样相对来说是比较安全的。</li><li>一般情况下，我们没有必要按个字段去识别&#x2F;判断它是否可以为空，而是将所有的字段都当做可以为空，全部手动设置转换类型。</li><li>MyBatis包含的JdbcType类型，主要有下面这些：<ul><li>BIT、FLOAT、CHAR 、TIMESTAMP 、 OTHER 、UNDEFINEDTINYINT 、REAL 、VARCHAR 、BINARY 、BLOB NVARCHAR、SMALLINT 、DOUBLE 、LONGVARCHAR 、VARBINARY 、CLOB、NCHAR、INTEGER、 NUMERIC、DATE 、LONGVARBINARY 、BOOLEAN 、NCLOB、BIGINT 、DECIMAL 、TIME 、NULL、CURSOR</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from emp32 where name = #&#123;name, jdbcType=VARCHAR&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-Mabatis中-和-的区别"><a href="#9-Mabatis中-和-的区别" class="headerlink" title="9. Mabatis中#{}和${}的区别"></a>9. Mabatis中#{}和${}的区别</h3><ol><li><code>$&#123;&#125;</code>是字符串替换，底层使用的Statement（sql注入问题，效率低，编写sql复杂）<ul><li>支持${param1}或${变量名},不支持${0}，Dao层必须使用@Param(),用到字符串时需要手动加单引号</li></ul></li><li><code>#&#123;&#125;</code>是预编译处理命令，底层使用PreparedStatement（可以有效防止sql注入）<ul><li>不支持表名、排序方式等的占位，默认会将其当成字符串</li></ul></li></ol><h3 id="10-分页"><a href="#10-分页" class="headerlink" title="10. 分页"></a>10. 分页</h3><ol><li>在主配置文件中配置 分页拦截器（依赖于pageHelper、sqlparse相关jar）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置分页拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageHelper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>查询前使用分页API</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(2, 2);</span><br><span class="line">List<span class="tag">&lt;<span class="name">Emp</span>&gt;</span> emps = dao.orderBySalary();</span><br><span class="line">for(Emp emp: emps) &#123;</span><br><span class="line">    System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-Spring-MyBatis整合"><a href="#11-Spring-MyBatis整合" class="headerlink" title="11. Spring+MyBatis整合"></a>11. Spring+MyBatis整合</h3><p>Spring与MyBatis整合需要引入一个mybatis-spring.jar文件包，该包提供了下面几个与整合相关的API:</p><ol><li>SqlSessionFactoryBean<ul><li>创建SqlSessionFactory对象，为整合应用提供SqlSession对象资源</li><li>依赖于dataSource 和加载SQL定义文件</li></ul></li><li>MapperFactoryBean<ul><li>根据指定的某一个Mapper接口生成Bean实例</li><li>依赖于SqlSessionFactory 和 MApper接口</li></ul></li><li>MapperScannerConfigurer<ul><li>根据指定包批量扫描Mapper接口并生成实例</li></ul></li><li>SqlSessionTemplate<ul><li>类似于JdbcTemplate，便于程序员自己编写Mapper实现类</li></ul></li></ol><h3 id="12-Spring-MyBatis完成sql操作"><a href="#12-Spring-MyBatis完成sql操作" class="headerlink" title="12. Spring+MyBatis完成sql操作"></a>12. Spring+MyBatis完成sql操作</h3><p><strong>第一步</strong>：使用Mybatis（同上）</p><ul><li>导jar包(mybatis包&#x2F;数据库驱动包)，建立实体类，定义SQL文件，编写Mapper映射接口</li></ul><p><strong>第二步</strong>：配置SqlSessionFactoryBean</p><ul><li>导入jar包（mabatis-spring&#x2F;ioc&#x2F;aop&#x2F;dao&#x2F;连接池）</li><li>配置SqlSessionFactoryBean注入dataSource和指定sql定义文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/mapper/*.xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步</strong>：</p><ol><li>方式一： 使用SqlSessionFactoryBean结合接口和SqlSessionFactory<ul><li>最终产生Mapper接口的 实现类，注意这是实现类</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置SqlSessionFactoryBean 产生Mapper接口的 实现类  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;empDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dao.EmpDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;empDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dao.EmpDao2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><ol start="2"><li>方式二： MapperScannerConfigurer<ul><li>MapperFactoryBean一次只能生产一个DAO的实现类，可以通过MapperScannerConfigurer批量生产DAO接口实现类</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 批量生产DAO接口实现类  ,实现类id为类名首字母小写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScanner&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自定义注解可以让只让有注解的接口产生实现类，另一部分一部分不产生 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;annotationClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.annotation.MyAnnotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13-使用SqlSessionTemplate模板来完成DAO接口的实现类"><a href="#13-使用SqlSessionTemplate模板来完成DAO接口的实现类" class="headerlink" title="13. 使用SqlSessionTemplate模板来完成DAO接口的实现类"></a>13. 使用SqlSessionTemplate模板来完成DAO接口的实现类</h3><ol><li>使用Mybatis（同上）</li><li>配置SqlSessionFactoryBean（同上）</li><li>编写DAO接口的实现类<ul><li>开启组件扫描，注入SqlSessionTemplate,依赖于SqlSessionFactory</li><li>使用SqlSessionTemplate对应API完成增删改查</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.mapper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建SqlSessionTemplate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;empDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionTemplate.selectOne(<span class="string">&quot;findById&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」Spring MVC框架</title>
      <link href="/2018/04/27/spring-mvc.html"/>
      <url>/2018/04/27/spring-mvc.html</url>
      
        <content type="html"><![CDATA[<p>Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</p><span id="more"></span><h3 id="1-Spring-MVC基本概念"><a href="#1-Spring-MVC基本概念" class="headerlink" title="1. Spring MVC基本概念"></a>1. Spring MVC基本概念</h3><h4 id="1-1-Spring-MVC-五大核心组件"><a href="#1-1-Spring-MVC-五大核心组件" class="headerlink" title="1.1 Spring MVC 五大核心组件"></a>1.1 Spring MVC 五大核心组件</h4><p>Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。</p><ol><li>DispatcherServlet：控制器，请求入口</li><li>HandlerMapping：控制器，分发请求，让请求和控制器建立一一对应关系</li><li>Controller：控制器，处理请求</li><li>ModelAndView：封装了 数据信息和视图信息</li><li>ViewResolver：视图处理器</li></ol><p>他的两个核心是两个核心：</p><ul><li>处理器映射：选择使用哪个控制器来处理请求 </li><li>视图解析器：选择结果应该如何渲染<blockquote><p>通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。</p></blockquote></li></ul><h4 id="1-2-SpringMVC运行原理"><a href="#1-2-SpringMVC运行原理" class="headerlink" title="1.2 SpringMVC运行原理"></a>1.2 SpringMVC运行原理</h4><ol><li>Http请求：客户端请求提交到DispatcherServlet。 </li><li>寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 </li><li>调用处理器：DispatcherServlet将请求提交到Controller。 </li><li>调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。 </li><li>处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 </li><li>Http响应：视图负责将结果显示到客户端。</li></ol><h4 id="1-3-SpringMVC接口解释"><a href="#1-3-SpringMVC接口解释" class="headerlink" title="1.3 SpringMVC接口解释"></a>1.3 SpringMVC接口解释</h4><ol><li><strong>DispatcherServlet接口</strong>：Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。它是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。其主要工作有以下三项： <ol><li>截获符合特定格式的URL请求。 </li><li>初始化DispatcherServlet上下文对应WebApplicationContext，并将其与业务层、持久化层的WebApplicationContext建立关联。 </li><li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li></ol></li><li><strong>HandlerMapping接口</strong>：能够完成客户请求到Controller映射。 </li><li><strong>Controller接口</strong>： 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。 <ul><li>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。 </li><li>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。</li></ul></li><li><strong>ViewResolver接口</strong>：Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</li></ol><h4 id="1-4-SpringMVC配置"><a href="#1-4-SpringMVC配置" class="headerlink" title="1.4 SpringMVC配置"></a>1.4 SpringMVC配置</h4><ol><li><p>在web.xml文件中进行配置applicationContext.xml路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置applicationContext.xml，开启注解功能、配置试图解析器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;handlerMapping&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappings&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;/toHello.do&quot;</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.controller.MyHelleController&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图处理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Spring-MVC的编写步骤"><a href="#2-Spring-MVC的编写步骤" class="headerlink" title="2. Spring MVC的编写步骤"></a>2. Spring MVC的编写步骤</h3><ol><li>建立一个项目，导入jar包(ioc mvc) 拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</li><li>在web.xml中配置DisappearServlet，并通过contextConfigLocation这个初始化参数关联Spring容器对应的配置文件。</li><li>在 Spring配置文件中配置HandlerMapping的实现类SimpleUrlHandlerMapping需要通过mappings属性指定请求和控制器对应的关系。</li><li>编写一个类实现Controller接口，实现接口方法，返回ModelAndView，并且在容器创建Controller对象</li><li>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</li></ol><h3 id="3-标注-注解-形式的MVC"><a href="#3-标注-注解-形式的MVC" class="headerlink" title="3. 标注(注解)形式的MVC"></a>3. 标注(注解)形式的MVC</h3><ol><li><p>建立项目，导入jar(ioc aop mvc)，拷贝spring配置文件到src下，同时在WEB-INF下建立jsp文件。</p></li><li><p>在web.xml中配置DispatcherServlet，并通过contextConfigLocation关联配置文件。</p></li><li><p>开启组件扫描 和 标注形式mvc (容器帮你创建了一个HandlerMapping对象，类型时RequestMappingHandlerMapping)。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;包名&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个Java类，不用实现Controller接口，方法返回值类型可以时String也可以是ModelAndView（方法名与参数都自由了）</p><ul><li>使用<code>@Controller</code> 可以把普通Java类转换成控制器，同时在容器中创建对象</li><li>使用<code>@RequestMapping(&quot;/路径&quot;)</code> 设置方法上</li></ul></li><li><p>在Spring配置文件中配置ViewResolver的实现类InternalResourceViewResolver，需要配置前缀prefix和后缀suffix。</p></li></ol><h3 id="4-mvc控制器接收页面参数"><a href="#4-mvc控制器接收页面参数" class="headerlink" title="4. mvc控制器接收页面参数"></a>4. mvc控制器接收页面参数</h3><ol><li><p>使用HttpServletRequest类型的参数来接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">acc_no</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;acc_no&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">acc_pwd</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;acc_password&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接定义和页面请求参数同名的控制器参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login2.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login2</span><span class="params">(String acc_no,String acc_password, ModelAndView mav)</span> &#123;</span><br><span class="line">    mav.setViewName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当页面参数和控制器参数名字不一致，@RequestParam(“acc_no”) 让请求参数和控制器参数对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login3.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login3</span><span class="params">(<span class="meta">@RequestParam(&quot;acc_no&quot;)</span> String a,String acc_password, ModelAndView mav)</span> &#123;</span><br><span class="line">    mav.setViewName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制器中 直接定义对象类型的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login4.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login4</span><span class="params">(Account acc, ModelAndView mav)</span> &#123;</span><br><span class="line">    mav.setViewName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-mvc控制器把数据传递给页面"><a href="#5-mvc控制器把数据传递给页面" class="headerlink" title="5. mvc控制器把数据传递给页面"></a>5. mvc控制器把数据传递给页面</h3><p>使用EL表达式在jsp页面接收数据<code>&lt;h1&gt;欢迎 $&#123;acc_no&#125; &lt;/h1&gt;</code></p><ol><li><p>使用域对象 进行传输 (request session ServletContext )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login6.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login6</span><span class="params">(String acc_no, HttpServletRequest req)</span> &#123;</span><br><span class="line">    req.setAttribute(<span class="string">&quot;acc_no&quot;</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ModelAndView进行数据传输 </p><ul><li><code>mav.getModel().put(&quot;acc_no&quot;, acc_no);</code></li><li><code>mav.getModelMap().put(key, value);</code></li><li><code>mav.getModelMap().addAttribute(&quot;acc_no&quot;, acc_no);</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login7.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login7</span><span class="params">(String acc_no, ModelAndView mav)</span> &#123;</span><br><span class="line">    mav.setViewName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="comment">//mav.getModel().put(&quot;acc_no&quot;, acc_no);</span></span><br><span class="line">    <span class="comment">//mav.getModelMap().put(key, value)</span></span><br><span class="line">    mav.getModelMap().addAttribute(<span class="string">&quot;acc_no&quot;</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用Model进行数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login8.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login8</span><span class="params">(String acc_no, Model m)</span> &#123;</span><br><span class="line">    m.addAttribute(<span class="string">&quot;acc_no&quot;</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用ModelMap进行数据传输</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login9.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login9</span><span class="params">(String acc_no, ModelMap m)</span> &#123;</span><br><span class="line">    <span class="comment">//m.addAttribute(&quot;acc_no&quot;, acc_no);</span></span><br><span class="line">    m.put(<span class="string">&quot;acc_no&quot;</span>, acc_no);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用自定义的对象类型默认传输（默认名类型首字母小写，可以通过@ModelAttribute(“新名”)修改）</p><ul><li>默认名：<code>&lt;h1&gt;欢迎 $&#123; account.acc_no &#125; &lt;/h1&gt;</code></li><li>@ModelAttribute(“acc”)：<code>&lt;h1&gt;欢迎 $&#123; acc.acc_no &#125; &lt;/h1&gt;</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login10.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login10</span><span class="params">(<span class="meta">@ModelAttribute(&quot;acc&quot;)</span> Account acc)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Spring-MVC实现重定向"><a href="#6-Spring-MVC实现重定向" class="headerlink" title="6. Spring MVC实现重定向"></a>6. Spring MVC实现重定向</h3><ol><li>控制器方法返回String <ul><li>redirect:请求路径</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login11.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login11</span><span class="params">(<span class="meta">@ModelAttribute(&quot;acc&quot;)</span> Account acc)</span> &#123;</span><br><span class="line">    <span class="comment">//return &quot;forward:toMain.do&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:toMain.do&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toMain.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toMain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 干其它的事情</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>控制器方法返回ModelAndView <ul><li>使用RedirectView  完成</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login12.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login12</span><span class="params">(<span class="meta">@ModelAttribute(&quot;acc&quot;)</span> Account acc)</span> &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//重定向</span></span><br><span class="line">    <span class="type">RedirectView</span> <span class="variable">rv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedirectView</span>(<span class="string">&quot;toMain.do&quot;</span>);</span><br><span class="line">    mav.setView(rv);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Spring-MVC-中文参数的乱码问题"><a href="#7-Spring-MVC-中文参数的乱码问题" class="headerlink" title="7. Spring MVC 中文参数的乱码问题"></a>7. Spring MVC 中文参数的乱码问题</h3><p>tomcat8中 get 没有乱码问题，post 请求有乱码问题 </p><ol><li><p>参数为页面(HttpServletRequest request)与(HttpServletResponse response)时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>传入参数为<code>@RequestParam</code>时，可以通过字符串重新编码来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(string.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>方法名前出现<code>@RequestMapping(value=&quot;XXX&quot;)</code>时可以在value属性后再加一个属性<code>produces=&quot;text/html;charset=UTF-8&quot;</code>来解决</p></li><li><p>在web.xml或者dispatcher-servlet.xml或者其他配置servlet的配置文件中添加编码过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-<span class="number">8</span>&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.<span class="keyword">do</span>&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-Spring-MVC-拦截器"><a href="#8-Spring-MVC-拦截器" class="headerlink" title="8. Spring MVC 拦截器"></a>8. Spring MVC 拦截器</h3><ol><li>拦截器和fiter的作用几乎一样，它是Spring提供的一个组件，可以用在HandlerMapping组件之后（用于身份认证，登录检查，编码设置）</li><li>HandlerMapping接口<ul><li>preHandle：在HandlerMapping之后控制器之前调用，返回boolean(true:继续其他拦截器和处理器，false:终止后续调用)。</li><li>postHandle：处理器执行后、视图处理前调用。</li><li>afterCompletion：整个请求处理完毕后调用。</li></ul></li></ol><h3 id="9-Spring-MVC-拦截器的使用步骤"><a href="#9-Spring-MVC-拦截器的使用步骤" class="headerlink" title="9. Spring MVC 拦截器的使用步骤"></a>9. Spring MVC 拦截器的使用步骤</h3><ol><li>搭建一个基于标注的mvc</li><li>编写一个类实现HandlerInterceptor接口</li><li>在Spring配置文件中配置拦截器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/login.do&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xdl.interceptor.SomeInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="10-Spring-MVC异常处理"><a href="#10-Spring-MVC异常处理" class="headerlink" title="10. Spring MVC异常处理"></a>10. Spring MVC异常处理</h3><ol><li><p>配置spring系统提供的简单异常处理器 SimpleMappingExceptionResolver 处理所有Controller异常</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleExceptionResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.RuntimeException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.Exception&quot;</span>&gt;</span>error2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自定义异常处理器，实现HandlerExceptionResolver接口，处理所有Controller异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception e)</span> &#123;</span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"><span class="keyword">if</span>(e <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">mav.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">mav.setViewName(<span class="string">&quot;error2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@ExceptionHandler注解实现异常处理，处理某一个Controller异常public String execute(HttpServletRequest request, Exception ex)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Controller</span></span><br><span class="line"><span class="comment">//public class MyController &#123;</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="11-Spring-MVC文件上传"><a href="#11-Spring-MVC文件上传" class="headerlink" title="11. Spring MVC文件上传"></a>11. Spring MVC文件上传</h3><ol><li>jsp页面（method&#x3D;”POST” enctype&#x3D;”multipart&#x2F;form-data type&#x3D;”file”）<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload.do&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;head_img&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>控制器（MultipartFile类型来接收文件数据，需要配置文件解析器-需要依赖文件上传jar包-commons包）<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="12-文件上传与异常处理的结合"><a href="#12-文件上传与异常处理的结合" class="headerlink" title="12. 文件上传与异常处理的结合"></a>12. 文件上传与异常处理的结合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fileController</span> &#123;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/toFile.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">tofile</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;file&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/upload.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(String acc_no, MultipartFile head_img)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;acc_no:&quot;</span> + acc_no );</span><br><span class="line"><span class="keyword">if</span>(head_img.getSize()&gt;<span class="number">1024</span>*<span class="number">10</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;文件过大！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把文件写入磁盘</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uniqueStr</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">String</span> <span class="variable">oriFilename</span> <span class="operator">=</span> head_img.getOriginalFilename();</span><br><span class="line"><span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> oriFilename.substring(oriFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:/Eclipse/datas/&quot;</span>+uniqueStr+suffix);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">head_img.transferTo(file);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(oriFilename);</span><br><span class="line">System.out.println(file);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;file&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 局部异常 */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processError</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;error4&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-Spring-MVC响应JSON"><a href="#13-Spring-MVC响应JSON" class="headerlink" title="13. Spring MVC响应JSON"></a>13. Spring MVC响应JSON</h3><ol><li>搭建基于标注的mvc</li><li>在控制器中，设计控制方法，控制方法返回值数据类型对应的对象转换为JSON</li><li>给方法加@RequestMapping(“&#x2F;请求路径”)、@ResponseBody，它能把Java对象转换为JSON直接返回，依赖json转换包</li></ol><h3 id="14-REST"><a href="#14-REST" class="headerlink" title="14. REST"></a>14. REST</h3><p>REST即表述性状态传递（Representational State Transfer），使用这种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，便于分布式应用的开发。</p><ol><li>REST两个核心规范<ul><li>url请求路径的格式，由原来的基于操作的设计改变了基于资源的设计（如:<a href="http://test/source/1234%EF%BC%89">http://test/source/1234）</a></li><li>对http请求的方式做了规范，GET代表查询，POST增加，DELETE删除，PUT更新</li></ul></li><li>restful<ul><li>符合REST设计规范和风格的应用程序或设计 就是RESTful</li></ul></li><li>Spring MVC对REST的支持<ul><li>@RequestMapping支持URI的模板，以及http请求方式设定的支持<ul><li><code>@RequestMapping(value=&quot;/account/&#123;id&#125;&quot;,method=RequestMethod.POST)</code></li></ul></li><li>对URI上路径变量的处理的支持，@PathVariable<ul><li><code>@PathVariable(&quot;id&quot;) int id</code></li></ul></li><li>rest请求路径是没有后缀的，需要把url-parttern修改成<code>/</code></li><li><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></li><li>需要对静态资源进行放行<code>&lt;mvc:default-servlet-handler/&gt;</code></li></ul></li></ol><h3 id="15-REST实例"><a href="#15-REST实例" class="headerlink" title="15. REST实例"></a>15. REST实例</h3><ol><li>配置web.xml与applicationContext.xml(部分配置)</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改rest请求路径 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- web.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对静态资源进行放行 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写控制类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toLogin.do&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toLogin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id查询账户 GET */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/account/&#123;id&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">getAccountById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(id, <span class="string">&quot;test&quot;</span>+rm.nextInt(<span class="number">100</span>),<span class="string">&quot;123&quot;</span>, rm.nextInt(<span class="number">999</span>)+<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 新增账户 POST */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/account/&#123;id&#125;&quot;,method=RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAccount</span><span class="params">(Account acc)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;add:&quot;</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id删除帐户对象 DELETE */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/account/&#123;id&#125;&quot;,method=RequestMethod.DELETE)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteAccountById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;delete:&quot;</span>+id);</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/** 根据id更新帐户 PUT */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/account/&#123;id&#125;&quot;,method=RequestMethod.PUT)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putAccount</span><span class="params">(<span class="meta">@RequestBody</span> Account acc)</span> &#123;</span><br><span class="line">        <span class="comment">//@RequestBody将接收的ajax请求的json字符串写入Account对象中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;update:&quot;</span>+acc);</span><br><span class="line">        <span class="keyword">if</span>(acc.getId()&gt;<span class="number">100</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写jsp页面</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;accountId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;accountNo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;accountPassword&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;accountMoney&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;findBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;addBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;updateBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;delBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#findBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">findAccount</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#addBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">addAccount</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#updateBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updateAccount</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript">$(<span class="string">&quot;#delBtn&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">delAccount</span>();</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">getDatas</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> accountId = $(<span class="string">&quot;#accountId&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> accountNo = $(<span class="string">&quot;#accountNo&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> accountPassword = $(<span class="string">&quot;#accountPassword&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> accountMoney = $(<span class="string">&quot;#accountMoney&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">id</span>: accountId,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">acc_no</span>: accountNo,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">acc_password</span>: accountPassword,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">acc_money</span>: accountMoney</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">findAccount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> datas = <span class="title function_">getDatas</span>();</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&quot;account/&quot;</span> + datas.<span class="property">id</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#accountNo&quot;</span>).<span class="title function_">val</span>(res.<span class="property">acc_no</span>);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#accountPassword&quot;</span>).<span class="title function_">val</span>(res.<span class="property">acc_password</span>);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#accountMoney&quot;</span>).<span class="title function_">val</span>(res.<span class="property">acc_money</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">addAccount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> datas = <span class="title function_">getDatas</span>();</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&quot;account/&quot;</span> + datas.<span class="property">id</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: datas,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(res);</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">delAccount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> datas = <span class="title function_">getDatas</span>();</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>: <span class="string">&quot;account/&quot;</span> + datas.<span class="property">id</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>: <span class="string">&quot;delete&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(res);</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">updateAccount</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> datas = <span class="title function_">getDatas</span>();</span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&quot;account/&quot;</span>+ datas.<span class="property">id</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>:<span class="string">&quot;put&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(datas),</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">contentType</span>:<span class="string">&quot;application/json&quot;</span>,<span class="comment">//以json字符串提交数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(res);</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><ul><li>PUT需要以json字符串提交数据<code>contentType:&quot;application/json&quot;</code></li><li>@RequestBody将接收的ajax请求的json字符串写入Account对象中</li><li>JSON.stringify()：将json对象转换为json字符串</li><li>JSON.parse()：将json字符串转换为json对象</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」面向切面编程(AOP模块)</title>
      <link href="/2018/04/21/spring-aop.html"/>
      <url>/2018/04/21/spring-aop.html</url>
      
        <content type="html"><![CDATA[<p>AOP（Aspect Oriented Programming）：面向切面编程，<br>它是面向对象基础上发展来的技术，是面向对象更高层次的应用，<br>它可以在不修改原有代码的情况给组件增强功能。</p><span id="more"></span><h3 id="1-AOP涉及到的概念"><a href="#1-AOP涉及到的概念" class="headerlink" title="1. AOP涉及到的概念"></a>1. AOP涉及到的概念</h3><ul><li>Aspect：切面，用来封装共通业务逻辑；其类叫切面类，其创建的对象叫切面对象。</li><li>JoinPoint：连接点，用来封装切面所要嵌入的位置信息的对象，（主要封装了方法信息）</li><li>Pointcut：切点，是一堆连接点的集合，后面会使用切点表达式来表述切点</li><li>Target：目标，要被切入共通业务逻辑的对象</li><li>Proxy：代理，被增强之后的目标对象就是代理</li><li>Advice：通知，时机，切面逻辑在目标方法执行之前调用，执行之后调用，目标方法前后，目标方法最终，目标方法出现异常</li></ul><h3 id="2-编写AOP程序步骤"><a href="#2-编写AOP程序步骤" class="headerlink" title="2. 编写AOP程序步骤"></a>2. 编写AOP程序步骤</h3><ol><li>编写一个Sevice类，里面有登录和注册两个方法，然后使用Spring容器获取Service类对应的对象，调用登录和注册方法</li><li>在不修改登录和注册原有代码的情况下，让两个方法调用前输出<code>******</code><ol><li>添加aop的jar包到lib</li><li>编写一个类，定义共同业务逻辑</li><li>配置aplicationContext.xml，创建切面对象</li><li>配置aop:config，切面–&gt;通知–&gt;切点</li></ol></li></ol><h3 id="3-切点表达式"><a href="#3-切点表达式" class="headerlink" title="3. 切点表达式"></a>3. 切点表达式</h3><ol><li>Bean限定表达式<ul><li><code>bean(&quot;容器内组件id&quot;)</code>，支持通配符*，如：<code>bean(&quot;*Dao&quot;)</code>，<code>bean(&quot;acc*&quot;)</code></li></ul></li><li>类型限定表达式<ul><li><code>within(&quot;包名.类型&quot;)</code>，要求表达式最后一部分必须是类型，如：<code>com.dao.impl.类型</code>，<code>com.dao.impl.*</code>，<code>com.dao..*</code></li></ul></li><li>方法限定表达式<ul><li><code>execution(&quot;表达式&quot;)</code>，可以有 权限修饰 返回值类型 方法名(参数类型)throws 异常，必须有:<code>返回值类型 方法名()</code></li></ul></li></ol><h3 id="4-通知的五种类型"><a href="#4-通知的五种类型" class="headerlink" title="4. 通知的五种类型"></a>4. 通知的五种类型</h3><ol><li><code>&lt;aop:before</code>：前置通知，目标方法执行之前调用</li><li><code>&lt;aop:after-returning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li><li><code>&lt;aop:after-throwing</code>：异常通知，目标方法出异常才调用</li><li><code>&lt;aop:after</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li><li><code>&lt;aop:around</code>：环绕通知，目标方法执行前后都调用</li></ol><h3 id="5-标注形式AOP步骤"><a href="#5-标注形式AOP步骤" class="headerlink" title="5. 标注形式AOP步骤"></a>5. 标注形式AOP步骤</h3><ol><li>建项目，添加jar包(ioc,aop)，src下添加配置文件</li><li>编写一个Sevice类，里面有登录和注册两个方法</li><li>开启组件扫描，在类上打对应标注，创建Spring容器 测试逻辑</li><li>定义一个切面类，定义切面方法，并在容器中使用标注@Component创建切面对象</li><li>开启标注形式aop：<code>&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true|false&quot; /&gt;</code></li><li>使用切面对应的标注以及通知对应的标注结合切点表达式完成aop： <code>@Aspect，@Before...</code></li></ol><h3 id="6-AOP-通知对应的标注"><a href="#6-AOP-通知对应的标注" class="headerlink" title="6. AOP 通知对应的标注"></a>6. AOP 通知对应的标注</h3><ol><li><code>@Before</code>：前置通知，目标方法执行之前调用</li><li><code>@AfterReturning</code>：后置通知，目标方法执行之后调用（目标方法出异常，通知方法无法执行）</li><li><code>@AfterThrowing</code>：异常通知，目标方法出异常才调用</li><li><code>@After</code>：最终通知，目标方法之后<strong>一定</strong>会执行</li><li><code>@Around</code>：环绕通知，目标方法执行前后都调用</li></ol><h3 id="7-Around具体用法"><a href="#7-Around具体用法" class="headerlink" title="7. @Around具体用法"></a>7. @Around具体用法</h3><p>@Around既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;within(com..*)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">showAfterDate</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().getTime());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    System.out.println(<span class="string">&quot;结束时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>().getTime());</span><br><span class="line">    System.out.println(<span class="string">&quot;执行时间：&quot;</span>date2.getTime() - date.getTime());</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p></blockquote><h3 id="8-异常通知"><a href="#8-异常通知" class="headerlink" title="8. 异常通知"></a>8. 异常通知</h3><p>JoinPoint可以获取出异常的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;within(com..*)&quot;, throwing=&quot;e&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processException</span><span class="params">(JoinPoint jp, Exception e)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;捕获到异常&quot;</span> + jp.getSignature() + <span class="string">&quot;:\n「&quot;</span> + e +<span class="string">&quot;」&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」事务管理</title>
      <link href="/2018/04/15/spring-transaction.html"/>
      <url>/2018/04/15/spring-transaction.html</url>
      
        <content type="html"><![CDATA[<p>事务的基本概念：事务指的是逻辑上的一组操作，这组操作要么全部成功，要么全部失败。</p><span id="more"></span><h3 id="1-事务的特性-ACID"><a href="#1-事务的特性-ACID" class="headerlink" title="1. 事务的特性(ACID)"></a>1. 事务的特性(ACID)</h3><ul><li>事务的特性：<strong>原子性、一致性、隔离性、持久性</strong>。</li><li>原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。</li><li>隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离（数据库中相应的数据隔离级别，通过它避免事务间的冲突）。</li><li>持久性（Durability）:一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h3 id="2-Spring提供事务管理的3个接口："><a href="#2-Spring提供事务管理的3个接口：" class="headerlink" title="2. Spring提供事务管理的3个接口："></a>2. Spring提供事务管理的3个接口：</h3><ol><li><strong>PlatformTransactionManager</strong>：事务管理器，用来管理事务的接口，定义了事务的提交、回滚等方法。</li><li><strong>TransactionDefinition</strong>：事务定义信息（隔离级别、传播行为、是否超时、是否只读）。</li><li><strong>TransactionStatus</strong>：事务具体运行状态（事务是否提交，事务是否有保存点，事务是否是新事物等状态）。</li></ol><blockquote><p>Spring事务管理时，这三个接口是有联系的，Spring首先会根据事务定义信息TransactionDefinition获取信息,然后由事务管理器PlatformTransactionManager进行管理，在事务管理过程中，会产生一个事务的状态，这个状态就保存在事务具体运行状态TransactionStatus中了。</p></blockquote><h3 id="3-TransactionDefinition接口"><a href="#3-TransactionDefinition接口" class="headerlink" title="3. TransactionDefinition接口"></a>3. TransactionDefinition接口</h3><p>TransactionDefinition定义事务隔离级别(Isolation)、定义事务传播行为(Propagation)</p><ul><li>如果不考虑隔离性,就会引发安全问题：脏读、不可重复读、以及虚读或者叫做幻读。</li><li>事务的传播行为：解决业务层方法之间相互调用时,使用何种事务的问题。</li></ul><h4 id="3-1-安全问题"><a href="#3-1-安全问题" class="headerlink" title="3.1 安全问题"></a>3.1 安全问题</h4><ol><li>脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。</li><li>不可重复读：同一事务中，多次读取同一数据返回的结果有所不同（读取到另一个事务已经提交的更新的数据）。</li><li>幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。</li></ol><h4 id="3-2-事务的隔离级别-Isolation-："><a href="#3-2-事务的隔离级别-Isolation-：" class="headerlink" title="3.2 事务的隔离级别(Isolation)："></a>3.2 事务的隔离级别(Isolation)：</h4><ol><li><strong><code>READ_UNCOMMITED</code></strong>(读未提交)：允许读取未提交的改变了的数据（最低级别），可能导致脏读、不可重复读、幻读等。</li><li><strong><code>READ_COMMITED</code></strong>(读提交)：允许在并发事务提交后读取，可防止脏读，但可能导致不可重复读、幻读。</li><li><strong><code>REPEATABLE_READ</code></strong>(可重复读)：多次读取相同字段是一致的,除非数据被事务本身改变，可防止脏读、不可重复读，但可能导致幻读。</li><li><strong><code>SERIALIZABLE</code></strong>(序列化)：事务是串行的,完全服从ACID的级别隔离，确保不发生脏读、不可重复读、幻读等。这在所有的隔离基本中是最慢的，它是典型的通过完全锁定在事务中涉及的数据表来完成的。</li><li><code>DEFAULT</code>(Spring提供)：使用数据库默认的隔离级别（Mysql默认采用<code>REPEATABLE_READ</code>隔离级别，Oracle默认采用<code>READ_COMMITTED</code>隔离级别）。</li></ol><h4 id="3-3-事务的传播特性-Propagation-："><a href="#3-3-事务的传播特性-Propagation-：" class="headerlink" title="3.3 事务的传播特性(Propagation)："></a>3.3 事务的传播特性(Propagation)：</h4><ol><li>第一类：运行在同一个事务<ul><li>**<code>REQUIRED</code>**：默认，支持当前事务，如果当前没有事务，就新建一个事务。</li><li><code>SUPPORTS</code>：支持当前事务，如果当前没有事务，就不使用事务(以非事务方式执行)</li><li><code>MANDATORY</code>：支持当前事务，如果当前没有事务，就抛出异常</li></ul></li><li>第二类：运行在不同事务<ul><li>**<code>REQUIRES_NEW</code>**：新建事务，如果当前存在事务，把当前事务挂起</li><li><code>NOT_SUPPORTED</code>：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li><li><code>NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常</li></ul></li><li>第三类：嵌套执行–即外层事务如果失败，内层事务要么回滚到保存点要么回滚到初始状态<ul><li>**<code>NESTED</code>**：如果当前事务存在，则嵌套事务执行</li></ul></li></ol><h3 id="4-TransactionStatus接口"><a href="#4-TransactionStatus接口" class="headerlink" title="4. TransactionStatus接口"></a>4. TransactionStatus接口</h3><p>平台事务管理器(PlatformTransactionManager)会根据TransactionDefinition中定义的事务信息(包括隔离级别、传播行为)来进行事务的管理,在管理的过程中事务可能产生了保存点或事务是新的事务等情况,那么这些信息都会记录在TransactionStatus的对象中。</p><h3 id="5-PlatformTransactionManager接口（事务管理器）"><a href="#5-PlatformTransactionManager接口（事务管理器）" class="headerlink" title="5. PlatformTransactionManager接口（事务管理器）"></a>5. PlatformTransactionManager接口（事务管理器）</h3><p>该接口有许多实现类例如：DataSourceTransactionManager、HibernateTransactionManager等。</p><h4 id="5-1-Spring支持两种方式事务管理："><a href="#5-1-Spring支持两种方式事务管理：" class="headerlink" title="5.1 Spring支持两种方式事务管理："></a>5.1 Spring支持两种方式事务管理：</h4><ol><li>编程式事务管理<ul><li>手动编写代码进行事务管理，通过TransactionTemlate手动管理事务（很少使用）</li></ul></li><li>声明式事务管理<ul><li>基于TransactionProxyFactoryBean的方式（很少使用）</li><li>基于AspectJ的xml方式，配置稍复杂,但清晰可见事务使用范围（经常使用）</li><li>基于注解的方式，配置简单,需要在使用事务管理的业务层类或方法添加<code>@Transactional</code>注解（经常使用）</li></ul></li></ol><h3 id="6-基于AspectJ的xml方式的声明式事务管理"><a href="#6-基于AspectJ的xml方式的声明式事务管理" class="headerlink" title="6. 基于AspectJ的xml方式的声明式事务管理"></a>6. 基于AspectJ的xml方式的声明式事务管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbc连接池对象id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置事务的通知（事务的增强） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- propagation:事务传播行为</span></span><br><span class="line"><span class="comment">            isolation:事务的隔离级别</span></span><br><span class="line"><span class="comment">            read-only:只读</span></span><br><span class="line"><span class="comment">            rollback-for:发生哪些异常回滚</span></span><br><span class="line"><span class="comment">            no-rollback-for:发生哪些异常不回滚</span></span><br><span class="line"><span class="comment">            timeout:过期信息    --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;DEFAULT&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*cn.muke.spring.demo3.AccountService+.*(.))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-基于注解的声明式事务管理"><a href="#7-基于注解的声明式事务管理" class="headerlink" title="7. 基于注解的声明式事务管理"></a>7. 基于注解的声明式事务管理</h3><ol><li>配置事务管理器<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.创建一个事务管理器对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;事务管理器id&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbc连接池对象id&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2.开启声明式事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;事务管理器id&quot;</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true|false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>transaction-manager</strong>：指定事务管理器(由框架提供类，在容器中创建这个对象并依赖于dataSource)</li><li><strong>proxy-target-class</strong>：决定是基于接口的还是基于类的代理被创建；为true则是基于类的代理将起作用(需要cglib库)，为false(默认)则标准的JDK 基于接口的代理将起作用。</li></ul><ol start="2"><li>使用，在类上或者方法上标注<code>@Transactional</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor=&#123;Exception.class&#125;, </span></span><br><span class="line"><span class="meta">        readOnly=false, </span></span><br><span class="line"><span class="meta">        isolation=Isolation.DEFAULT,</span></span><br><span class="line"><span class="meta">        propagation=Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">()</span>&#123;..&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>@Transactional的属性<ul><li><strong>rollbackFor</strong>：设置检查异常也回滚</li><li><strong>noRollbackFor</strong>：指定运行时异常不回滚</li><li><strong>readOnly</strong>： 只读属性，当事务方法都是select语句时，可以将readOnly设置成true优化方法，提高方法执行效率。当有DML操作时这个属性必须时false。</li><li><strong>isolation</strong>：事务的隔离级别(枚举:DEFAULT,READ_UNCOMMITTED,READ_COMMITTED,REPEATABLE_READ,SERIALIZABLE)</li><li><strong>propagation</strong>：事务的传播特性(枚举:REQUIRED,SUPPORTS,MANDATORY,REQUIRES_NEW,NOT_SUPPORTED,NEVER)</li></ul></li><li>Spring中事务管理器默认值针对<strong>运行时异常</strong>回滚，对<strong>检查异常</strong>不回滚。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」JDBC详解</title>
      <link href="/2018/04/09/spring-jdbc.html"/>
      <url>/2018/04/09/spring-jdbc.html</url>
      
        <content type="html"><![CDATA[<p>Spring对JDBC做了简化和封装；简化了DAO实现类编写；提供了基于AOP的<strong>声明式</strong>事务管理；对JDBC中异常做了封装，把原来检查异常封装成了继承自RuntimeException的异常（DataAcessException）。</p><span id="more"></span><h3 id="1-数据源配置"><a href="#1-数据源配置" class="headerlink" title="1. 数据源配置"></a>1. 数据源配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.jdbc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">mysqlDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BasicDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(mysqlDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用XML配置来实现配置效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义jdbcTemplate对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.jdbc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-JdbcTemplate的使用"><a href="#2-JdbcTemplate的使用" class="headerlink" title="2. JdbcTemplate的使用"></a>2. JdbcTemplate的使用</h3><p>JdbcTemplate模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能。<br>JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。</p><p>基本的查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository(&quot;empDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from emp32&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="3-通过实现RowMapper接口把查询结果映射到Java对象"><a href="#3-通过实现RowMapper接口把查询结果映射到Java对象" class="headerlink" title="3. 通过实现RowMapper接口把查询结果映射到Java对象"></a>3. 通过实现RowMapper接口把查询结果映射到Java对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpRowMapper</span> <span class="keyword">implements</span> <span class="title class_">RowMapper</span>&lt;Emp&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">mapRow</span><span class="params">(ResultSet rs, <span class="type">int</span> n)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(</span><br><span class="line">            rs.getInt(<span class="string">&quot;id&quot;</span>),</span><br><span class="line">            rs.getString(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">            rs.getDouble(<span class="string">&quot;salary&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAO实现类</span></span><br><span class="line"><span class="meta">@Repository(&quot;empDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">getEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp32 where id=?&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">EmpRowMapper</span>(), id);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="4-JdbcTemplate对象的主要方法"><a href="#4-JdbcTemplate对象的主要方法" class="headerlink" title="4. JdbcTemplate对象的主要方法"></a>4. JdbcTemplate对象的主要方法</h3><ol><li><p>queryForInt()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个整数类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplateObject.queryForInt(<span class="string">&quot;select count(*) from emp32&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个使用绑定变量的简单查询</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> jdbcTemplateObject.queryForInt(<span class="string">&quot;select age from emp32 where id = ?&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">10</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>queryForLong()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询一个 long类型</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplateObject.queryForLong(<span class="string">&quot;select count(*) from emp32&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>queryForObject()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;select name from emp32 where id = ?&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">10</span>&#125;, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回一个对象：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;select * from emp32 where id = ?&quot;</span>;</span><br><span class="line"><span class="type">emp32</span> <span class="variable">student</span> <span class="operator">=</span> jdbcTemplateObject.queryForObject(SQL, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">10</span>&#125;, <span class="keyword">new</span> <span class="title class_">EmpRowMapper</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询并返回多个对象：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;select * from emp32&quot;</span>;</span><br><span class="line">List&lt;emp32&gt; students = jdbcTemplateObject.query(SQL, <span class="keyword">new</span> <span class="title class_">EmpRowMapper</span>());</span><br></pre></td></tr></table></figure></li><li><p>update()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表中插入一行：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;insert into emp32 (name, age) values (?, ?)&quot;</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;Zara&quot;</span>, <span class="number">11</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新表中的一行：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;update emp32 set name = ? where id = ?&quot;</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;Zara&quot;</span>, <span class="number">10</span>&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//从表中删除一行：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;delete emp32 where id = ?&quot;</span>;</span><br><span class="line">jdbcTemplateObject.update( SQL, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">20</span>&#125; );</span><br></pre></td></tr></table></figure></li><li><p>execute()：执行DDL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">SQL</span> <span class="operator">=</span> <span class="string">&quot;CREATE TABLE emp32(</span></span><br><span class="line"><span class="string">idINT AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">NAMEVARCHAR(30),</span></span><br><span class="line"><span class="string">salaryDOUBLE DEFAULT 5000,</span></span><br><span class="line"><span class="string">CONSTRAINT student_id_pk PRIMARY KEY(id),</span></span><br><span class="line"><span class="string">CONSTRAINT student_name_uk UNIQUE(NAME)</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-异常转换"><a href="#5-异常转换" class="headerlink" title="5. 异常转换"></a>5. 异常转换</h3><ul><li>Spring提供了自己的开箱即用的数据异常分层——DataAccessException作为根异常，它负责转换所有的原始异常。</li><li>所以开发者无需处理底层的持久化异常，因为Spring JDBC模块已经在DataAccessException类及其子类中封装了底层的异常。</li><li>这样可以使异常处理机制独立于当前使用的具体数据库。</li><li>除了默认的SQLErrorCodeSQLExceptionTranslator类，开发者也可以提供自己的SQLExceptionTranslator实现。</li></ul><p>例如：自定义SQLExceptionTranslator实现的简单例子，当出现完整性约束错误时自定义错误消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomSQLErrorCodeTranslator</span> <span class="keyword">extends</span> <span class="title class_">SQLErrorCodeSQLExceptionTranslator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> DataAccessException <span class="title function_">customTranslate</span></span><br><span class="line">      <span class="params">(String task, String sql, SQLException sqlException)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sqlException.getErrorCode() == -<span class="number">104</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DuplicateKeyException</span>(<span class="string">&quot;完整性约束冲突&quot;</span>, sqlException);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」IoC注解实现</title>
      <link href="/2018/04/03/spring-ioc-annotation.html"/>
      <url>/2018/04/03/spring-ioc-annotation.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-回顾xml方式管理Java-Bean"><a href="#1-回顾xml方式管理Java-Bean" class="headerlink" title="1. 回顾xml方式管理Java Bean"></a>1. 回顾xml方式管理Java Bean</h3><ol><li>将一个Bean交由Spring创建并管理<ul><li><code>&lt;baen id=&quot;bean&quot; class=&quot;包名.Bean&quot;&gt;&lt;/baen&gt;</code></li></ul></li><li>获取Spring上下文<ul><li><code>ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code></li></ul></li><li>获取Bean<ul><li><code>Bean bean = app.getBean(&quot;bean&quot;, Bean.class);</code></li></ul></li></ol><span id="more"></span><h3 id="2-注解方式管理Java-Bean"><a href="#2-注解方式管理Java-Bean" class="headerlink" title="2. 注解方式管理Java Bean"></a>2. 注解方式管理Java Bean</h3><p>一、创建一个class配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;</span><br><span class="line">    <span class="comment">//将一个Bean交由Spring创建并管理</span></span><br><span class="line">    <span class="meta">@Bean(name=&quot;bean1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean <span class="title function_">bean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">Bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、获取Spring上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);</span><br></pre></td></tr></table></figure><p>三、获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br></pre></td></tr></table></figure><h4 id="2-1-简化注解方式的步骤1"><a href="#2-1-简化注解方式的步骤1" class="headerlink" title="2.1 简化注解方式的步骤1"></a>2.1 简化注解方式的步骤1</h4><p>一、 开启组件扫描（去掉上述步骤1中MyConfiguration实例化Bean的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//该注解可理解当前class等同于一个xml文件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;包路径&quot;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在applicationContext.xml中开启组件扫描方式<code>&lt;context:component-scan base-package=&quot;包路径&quot;/&gt;</code>。</p></blockquote><p>二、 将交由Spring管理的类加上<code>@Component</code>注解，或（<code>@Repository</code>，<code>@Controller</code>，<code>@Service</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bean1&quot;)</span><span class="comment">//通过构造方法实例化Bean1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 </p><ul><li>@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 </li><li>@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 </li><li>@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。</li></ul></blockquote><h4 id="2-2-Bean别名"><a href="#2-2-Bean别名" class="headerlink" title="2.2 Bean别名"></a>2.2 Bean别名</h4><p>一、 xml形式：通过name属性或alias标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bean2,bean3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com...Bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;bean4&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>二、 注解形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean(name=&#123;&quot;bean1&quot;,&quot;bean2&quot;,&quot;bean3&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">Bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component只能指定一个名字，@Component默认值为<strong>类名首字母小写</strong>，也可以自定义，如:<code>@Component(&quot;bean1&quot;)</code>； 默认@scope为singleton单例，也可以进行指定</p></blockquote><h3 id="3-注解方式Bean的注入"><a href="#3-注解方式Bean的注入" class="headerlink" title="3. 注解方式Bean的注入"></a>3. 注解方式Bean的注入</h3><p>一、 **<code>@Value(&quot;值&quot;)</code>**：常用于基本数据类型值注入，<code>值</code>可用EL表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、 <strong><code>@Autowired</code><strong>：常用于复杂类型值的注入<br>    + <code>@Autowired</code>：可以用在</strong>成员变量</strong>，<strong>setter方法</strong>，<strong>构造方法</strong>上；优先按照类型进行匹配，匹配不上启用名字进行匹配。<br>    + <code>@Qualifier(&quot;名字&quot;)</code> 根据名字匹配，配合@Autowired，<strong>不能用在构造方法上</strong>；@Qualifier指定对象必须存在，否则程序报错，可以使用@Autowired的required属性来解除这种强依赖，<code>@Autowired(required=false)</code>:尽量去找，组件不存在也不报错。<br>    + @Autowired的<strong>原理</strong>：在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于成员变量 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;card1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于构造方法 */</span></span><br><span class="line">    <span class="comment">//@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(Card card)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用于setter方法 */</span></span><br><span class="line">    <span class="meta">@Autowired(required=false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCard</span><span class="params">(Card card)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、 <strong><code>@Resource</code><strong>：常用于复杂类型值的注入<br>    + @Resource：用在</strong>成员变量</strong>和<strong>setter方法</strong>上，是<strong>JDK</strong>1.6支持的注解，优先按照名字匹配，可以通过<code>@Resource(name=&quot;名&quot;)</code>指定；如果没有指定name属性，用在成员变量上默认取字段名，用在setter方法上默认取属性名进行装配。名字匹配不上，会动用类型匹配。但注意：如果name属性一旦指定，就只会按照名称进行装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">    <span class="meta">@Resource(name=&quot;card&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Card card;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合类型值注入实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;包路径&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#4-注解方式Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)"></a>4. 注解方式Bean的常用配置项(作用域,生命周期,懒加载等)</h3><h4 id="4-1-注解方式Bean的作用域"><a href="#4-1-注解方式Bean的作用域" class="headerlink" title="4.1 注解方式Bean的作用域"></a>4.1 注解方式Bean的作用域</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;包路径&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;bean1&quot;)</span></span><br><span class="line">    <span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">Bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-注解方式Bean的懒加载"><a href="#4-2-注解方式Bean的懒加载" class="headerlink" title="4.2 注解方式Bean的懒加载"></a>4.2 注解方式Bean的懒加载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;包路径&quot;)</span></span><br><span class="line"><span class="meta">@Lazy</span> <span class="comment">//相当于xml中default-lazy-init=&quot;true&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;bean1&quot;)</span></span><br><span class="line">    <span class="meta">@Lazy</span> </span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">Bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-Bean初始化和销毁"><a href="#4-3-Bean初始化和销毁" class="headerlink" title="4.3 Bean初始化和销毁"></a>4.3 Bean初始化和销毁</h4><p>一、实现InitializingBean和DisposableBean接口（xml和注解都支持）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、xml形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.Bean&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三、注解形式1，@Bean(initMethod&#x3D;”init”, destroyMethod&#x3D;”cleanup”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span>&#123;</span><br><span class="line">    <span class="meta">@Bean(initMethod=&quot;init&quot;, destroyMethod=&quot;cleanup&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean <span class="title function_">bean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四、注解形式2，添加@PostConstruct，@PreDestroy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Spring」IoC控制反转</title>
      <link href="/2018/03/27/spring-ioc.html"/>
      <url>/2018/03/27/spring-ioc.html</url>
      
        <content type="html"><![CDATA[<p>Spring是一个开源的轻量级控制反转(IOC)和面向切面(AOP)的容器框架，它主要是为了解决企业应用开发的复杂性而诞生的，但现在已不止应用于企业服务。</p><ul><li>IOC：Inversion Of Control（控制反转），构成Spring框架的核心基础<span id="more"></span></li><li>DAO：Data Access Object（数据 访问对象），Spring对JDBC访问数据库的简化和封装</li><li>WebMVC：Spring对Web部分(jsp,servlet,ajax)以及MVC设计模式的支持</li><li>AOP：是在面向对象的基础上发展来的更高级的技术</li><li>ORM：Object Relation Mapping（对象关系映射），以面向对象的思想来访问数据库</li><li>JEE：Java的消息服务，远程调用，邮件服务等</li></ul><h3 id="1-IoC（控制反转）"><a href="#1-IoC（控制反转）" class="headerlink" title="1. IoC（控制反转）"></a>1. IoC（控制反转）</h3><p><strong>IoC</strong>：(Inversion of Control),控制反转：控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护。</p><ol><li>控制：控制对象的创建及销毁（生命周期）</li><li>反转：将对象的控制权交给IoC容器</li></ol><p><strong>DI</strong>：(Dependence Injection),依赖注入(注射)是IoC控制反转的一种具体实现方法，通过参数的方式从外部传入依赖，将依赖的创建由主动变为被动。</p><ul><li>简单来说， 当 组件A 依赖 组件B 时，IoC容器通过设置A的属性，把B传入的过程叫依赖注入</li></ul><blockquote><p>IoC的好处：降低了组件的依赖程度，让组件之间变成低耦合设计。</p></blockquote><h3 id="2-Spring容器初始化"><a href="#2-Spring容器初始化" class="headerlink" title="2. Spring容器初始化"></a>2. Spring容器初始化</h3><p>任何Java类都可以在Spring容器中创建对象 并交由容器来进行管理和使用，Spring容器 实现了 IOC 和 AOP 机制，Spring容器的类型是 BeanFactory 或者 ApplicationContext</p><ul><li>BeanFactory提供配置结构和基本功能，加载并初始化Bean</li><li>ApplicationContext保存了Bean对象并在Spring中被广泛使用</li></ul><h4 id="2-1-初始化ApplicationContext的几种方式："><a href="#2-1-初始化ApplicationContext的几种方式：" class="headerlink" title="2.1 初始化ApplicationContext的几种方式："></a>2.1 初始化ApplicationContext的几种方式：</h4><ol><li>本地文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileSystemXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;F:/workspace/appcontext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>Classpath<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classath:applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>Web应用中依赖Servlet或Listener<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-2-Spring容器完成IOC的步骤"><a href="#2-2-Spring容器完成IOC的步骤" class="headerlink" title="2.2 Spring容器完成IOC的步骤"></a>2.2 Spring容器完成IOC的步骤</h4><ol><li>建立一个动态的Web项目，导入jar包(ioc) 拷贝Spring容器配置文件到src(Source classpath)下</li><li>在spring容器配置文件中配置文件中配置一个对象的创建</li></ol><ul><li><code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li></ul><ol start="3"><li>写一个测试类 创建Spring容器对象，然后从容去中获取创建的组件</li></ol><ul><li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code></li></ul><h3 id="3-spring容器创建对象-实例化"><a href="#3-spring容器创建对象-实例化" class="headerlink" title="3. spring容器创建对象(实例化)"></a>3. spring容器创建对象(实例化)</h3><h4 id="3-1-构造器方式实例化"><a href="#3-1-构造器方式实例化" class="headerlink" title="3.1 构造器方式实例化"></a>3.1 构造器方式实例化</h4><ul><li>配置文件：<code>&lt;baen id=&quot;对象引用名&quot; class=&quot;包名.类名&quot;&gt;&lt;/baen&gt;</code></li><li><code>applicationContext.getBean(&quot;对象引用名&quot;, 类名.class)</code>默认调用类型对应的无参构造方法<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;date&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;date&quot;</span>, Date.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-静态工厂方法实例化"><a href="#3-2-静态工厂方法实例化" class="headerlink" title="3.2 静态工厂方法实例化"></a>3.2 静态工厂方法实例化</h4><ul><li>使用一个类型对应的静态方法来获取这个类型的对象</li><li><code>&lt;bean id=&quot;对象引用名&quot; class=&quot;包名.工厂类名&quot; factory-method=&quot;静态方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cal&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Calendar&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;cal&quot;</span>, Calendar.class);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-实例工厂方法实例化"><a href="#3-3-实例工厂方法实例化" class="headerlink" title="3.3 实例工厂方法实例化"></a>3.3 实例工厂方法实例化</h4><ul><li>使用一个已经存在的对象，来调用对应的成员方法来获取另一个类型的对象</li><li><code>&lt;bean id=&quot;对象的引用名&quot; factory-bean=&quot;工厂方法的id&quot; factory-method=&quot;成员方法名&quot;&gt;&lt;/bean&gt;</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cal&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Calendar&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;time&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;cal&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> app.getBean(<span class="string">&quot;time&quot;</span>, Date.class);</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-Spring-DI注入的实现"><a href="#4-Spring-DI注入的实现" class="headerlink" title="4. Spring DI注入的实现"></a>4. Spring DI注入的实现</h3><p>Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为。<br>Bean属性值：基本数据类型用value，复杂数据类型用ref(传入组件id)。<br>DI的实现方法：设值注入(setter注入)、构造注入、自动化注入(自动装配)</p><ul><li>实例：准备两个实体类Card，Player：Card有suit(花色)和point(点数)，Player有name(名字)和card(牌)。</li></ul><h4 id="4-1-设值注入"><a href="#4-1-设值注入" class="headerlink" title="4.1 设值注入"></a>4.1 设值注入</h4><p>property(属性)的name参考对象set方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;card&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;黑桃&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;point&quot;</span> <span class="attr">value</span>=<span class="string">&quot;A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其setCard方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Player&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;玩家1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;card&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-构造注入（Constructor-arguments）"><a href="#4-2-构造注入（Constructor-arguments）" class="headerlink" title="4.2 构造注入（Constructor arguments）"></a>4.2 构造注入（Constructor arguments）</h4><p>构建对象时赋值，参考对应构造方法（name为构造方法参数名，也可以用index:0开始）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;card2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;suit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;红桃&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;point&quot;</span> <span class="attr">value</span>=<span class="string">&quot;K&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player参考其构造方法Player(name,card) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Player&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;玩家2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;card2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-自动化注入（Autowiring-mode）"><a href="#4-3-自动化注入（Autowiring-mode）" class="headerlink" title="4.3 自动化注入（Autowiring mode）"></a>4.3 自动化注入（Autowiring mode）</h4><p>一般用来解决复杂值的注入，可以通过bean标记的autowrie属性(autowire&#x3D;”byName&#x2F;byType&#x2F;constructor”)指定对应的自动化的注入方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.exampleBean&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>自动装配autowire</strong>属性 有五种自动装配的方式：</p><ul><li><p>No：默认，需要通过<code>ref</code>属性来连接bean。</p></li><li><p><strong>byName</strong>： 与当前组件属性名 和 容器中其他组件的id 一致的bean，自动装配。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;card3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;方片&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;point&quot;</span> <span class="attr">value</span>=<span class="string">&quot;J&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player中必须要有setCard3 方法(setter方法名要与注入组件id对应)</span></span><br><span class="line"><span class="comment">    否则Spring会将id为card的bean通过setter方法进行自动装配(若有setCard方法)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Player&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>byType</strong>：与当前组件属性类型 和 容器中其他组件的class 一致的bean，自动装配，如果存在多个则抛出异常。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;bean.Card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;方片&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;point&quot;</span> <span class="attr">value</span>=<span class="string">&quot;J&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring会将类型为Card的bean通过setter方法进行自动装配(setter参数类型与注入组件类型对应) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Player&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>constructor</strong>：与当前组件 构造方法的参数 容器中其他组件的id 一致的bean，自动装配，不匹配再和 容器中其他组件的class 一致的bean，自动装配（如果存在多个则不装配），如果构造方法中第一个参数不匹配，则终止后续赋值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;card5&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;方片&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;point&quot;</span> <span class="attr">value</span>=<span class="string">&quot;J&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Player添加构造方法Player(Card card5)，构造方法参数名与注入组件id对应，不匹配再用构造方法参数类型和注入组件class匹配，如果存在多个则不装配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;player5&quot;</span> <span class="attr">class</span>=<span class="string">&quot;bean.Player&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>autodetect</strong>：如果有默认的构造器，则通过constructor方式进行自动装配，否则使用byType方式进行自动装配。</p></li></ul><h3 id="5-DI的参数的注入"><a href="#5-DI的参数的注入" class="headerlink" title="5. DI的参数的注入"></a>5. DI的参数的注入</h3><p>Bean对象 注入类型 可以是 字符串、集合、bean对象。</p><h4 id="5-1-注入字符串"><a href="#5-1-注入字符串" class="headerlink" title="5.1 注入字符串"></a>5.1 注入字符串</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xdl.bean.OracleDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;scott&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>tiger<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-注入集合"><a href="#5-2-注入集合" class="headerlink" title="5.2 注入集合"></a>5.2 注入集合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;friends&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;friends2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phones&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1594546454&quot;</span> <span class="attr">value</span>=<span class="string">&quot;值1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1594546464&quot;</span> <span class="attr">value</span>=<span class="string">&quot;值2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phones2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;164545564&quot;</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;164546756&quot;</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-集合参数的单独定义"><a href="#5-3-集合参数的单独定义" class="headerlink" title="5.3 集合参数的单独定义"></a>5.3 集合参数的单独定义</h4><p>注入集合–引入：List、Set、Map、Properties集合也可以先独立定义，再注入的方式使用，这样便于重复利用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 定义list集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;ref_friends&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 定义set集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:set</span> <span class="attr">id</span>=<span class="string">&quot;ref_buddys&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:set</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 定义map集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:map</span> <span class="attr">id</span>=<span class="string">&quot;ref_phones&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;159454644&quot;</span> <span class="attr">value</span>=<span class="string">&quot;值1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;1594546454&quot;</span> <span class="attr">value</span>=<span class="string">&quot;值2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:map</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 4. props集合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">&quot;ref_phonePro&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;164545564&quot;</span>&gt;</span>值1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;16454675665564&quot;</span>&gt;</span>值2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">&quot;ref_db&quot;</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">util:properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phones&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ref_phones&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;phones2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ref_phonePro&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-Spring的’EL’表达式"><a href="#5-3-Spring的’EL’表达式" class="headerlink" title="5.3 Spring的’EL’表达式"></a>5.3 Spring的’EL’表达式</h4><p>它和EL在语法上很 相似，可以读取一个bean对象&#x2F;集合中的数据。<br>Spring EL 采用 #{Sp Expression Language} 即 <code>#&#123;spring表达式&#125;</code>，可在xml配置和注解中使用。</p><ul><li>Spring EL配置连接池对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">util:properties</span> <span class="attr">id</span>=<span class="string">&quot;db&quot;</span> <span class="attr">location</span>=<span class="string">&quot;classpath:db.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.xdl.bean.OracleDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;db.name&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;db.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;db.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Bean的常用配置项-作用域-生命周期-懒加载等"><a href="#6-Bean的常用配置项-作用域-生命周期-懒加载等" class="headerlink" title="6. Bean的常用配置项(作用域,生命周期,懒加载等)"></a>6. Bean的常用配置项(作用域,生命周期,懒加载等)</h3><p>Bean的常用配置项：Id、Class、Scope、Constructor arguments、Propertties、Autowiring mode、Lazy-initialization mode、Initialization&#x2F;destruction method</p><h4 id="6-1-Bean作用域（Scope）"><a href="#6-1-Bean作用域（Scope）" class="headerlink" title="6.1 Bean作用域（Scope）"></a>6.1 Bean作用域（Scope）</h4><ol><li>Singleton作用域<ul><li>单例，指一个Bean容器只存在一份</li></ul></li><li>prototype作用域<ul><li>每次请求(使用)创建新的实例，destroy方式不生效</li></ul></li><li>Web环境作用域：<ul><li>request作用域：每个request请求都会创建一个单独的实例。</li><li>session作用域：每个session都会创建一个单独的实例。</li><li>application作用域：每个servletContext都会创建一个单独的实例。</li><li>websocket作用域：每个websocket连接都会创建一个单独的实例。</li></ul></li><li>自定义作用域<ul><li>SimpleThreadScope作用域：每个线程都会创建一个单独的实例。</li></ul></li></ol><h4 id="6-2-Bean的生命周期（Initialization-x2F-destruction-method）"><a href="#6-2-Bean的生命周期（Initialization-x2F-destruction-method）" class="headerlink" title="6.2 Bean的生命周期（Initialization&#x2F;destruction method）"></a>6.2 Bean的生命周期（Initialization&#x2F;destruction method）</h4><p>Bean的生命周期：定义 –&gt; 初始化 –&gt; 使用 –&gt; 销毁</p><h5 id="6-2-1-Bean初始化"><a href="#6-2-1-Bean初始化" class="headerlink" title="6.2.1 Bean初始化"></a>6.2.1 Bean初始化</h5><p>如果需要在Bean实例化之后执行一些逻辑，有两种方法：</p><ul><li>实现InitializingBean接口(org.springframework.beans.factory.InitializingBean)，覆盖afterPropertiesSet方法，在afterPropertiesSet中执行一些初始化后的工作。</li><li><strong>配置init-method</strong><ul><li>配置**<code>beans</code>**的<code>default-init-method</code>属性 来指定一个初始化方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的初始化方法程序也不会报错。</li><li>配置**<code>bean</code>**的<code>init-method</code>来指定初始化方法，这样只影响包含init-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个初始化方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleId&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.exampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些初始化后的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="6-2-2-Bean销毁"><a href="#6-2-2-Bean销毁" class="headerlink" title="6.2.2 Bean销毁"></a>6.2.2 Bean销毁</h5><p>如果需要在Bean销毁之前执行一些逻辑，有两种方法：</p><ul><li>实现DisposableBean接口(org.springframework.beans.factory.DisposableBean)覆盖destroy方法，，在destroy中执行一些销毁前的工作。</li><li><strong>配置destroy-method</strong><ul><li>配置**<code>beans</code>**的<code>default-destroy-method</code>属性 来指定一个销毁方法，这个指定针对容器中所有的对象，由于这样影响的范围比较广，所以当对象没有对应的销毁方法程序也不会报错。</li><li>配置**<code>bean</code>**的<code>destroy-method</code>来指定销毁方法，这样只影响包含destroy-method属性所在的bean标记创建的对象，这样控制的对象比较精准，所以当类型中没有这个销毁方法则程序崩溃。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleId&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.exampleBean&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;cleanup&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cleanup</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行一些销毁前的工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>注意：销毁方法只针对单例模式的对象</p></blockquote><h4 id="6-3-Bean的懒加载（Lazy-initialization-mode）"><a href="#6-3-Bean的懒加载（Lazy-initialization-mode）" class="headerlink" title="6.3 Bean的懒加载（Lazy-initialization mode）"></a>6.3 Bean的懒加载（Lazy-initialization mode）</h4><p>Spring容器会在创建容器时提前初始化<code>Singleton作用域</code>的bean，可以通过bean标记<code>lazy-init=&quot;true&quot;</code>延迟实例化(对象被使用时才创建)。</p><ul><li><p><strong>配置lazy-init</strong></p><ul><li>配置**<code>beans</code>**的<code>default-lazy-init=&quot;true&quot;</code>为所有Bean设定懒加载。</li><li>配置**<code>bean</code>**的<code>lazy-init=&quot;true&quot;</code>为单独的某个Bean设定懒加载。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.exampleBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>适用场景：如果某个Bean在程序整个运行周期都可能不会被使用，可以考虑设定该Bean为懒加载</p><ul><li>优点：尽可能的节约了资源</li><li>缺点：可能导致某个操作响应时间增加</li></ul></li></ul><h4 id="6-4-Bean装配的Aware接口"><a href="#6-4-Bean装配的Aware接口" class="headerlink" title="6.4 Bean装配的Aware接口"></a>6.4 Bean装配的Aware接口</h4><p>实现了Aware接口的bean在初始化后可以获取相应资源并进行相应的操作。</p><ol><li>ApplicationContextAware<ul><li>接口方法：setApplicationContext</li><li>作用：通常用来获取上下文对象，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li><li>实现过程：创建一个类并实现ApplicationContextAware接口，重写setApplicationContext方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li></ul></li><li>BeanNameAware<ul><li>接口方法：setBeanName</li><li>作用：获取声明的类名，声明全局变量后在方法中对变量进行初始化并供其他方法调用</li><li>实现过程：创建一个类并实现BeanNameAware接口，重写setBeanName方法；在xml文件中配置该类；当spring加载该配置文件时即调用接口方法。</li></ul></li></ol><h4 id="6-4-Bean装配之Resource"><a href="#6-4-Bean装配之Resource" class="headerlink" title="6.4 Bean装配之Resource"></a>6.4 Bean装配之Resource</h4><p><strong>Resources</strong>（针对于资源文件的统一接口）</p><ol><li>UrlResource：URL 对应的资源，根据一个 URL 地址即可获取</li><li>ClassPathResource：获取类路径下的资源</li><li>FileSystemResource：获取文件系统里面的资源</li><li>ServletContextResource：ServletContext 封装的资源，用于访问 ServletContext 环境下的资源</li><li>InputStreamResource：获取输入流封装的资源</li><li>ByteArrayResource：获取字节数组封装的资源</li></ol><p>ResourceLoader: 所有的 application contexts 都实现了 ResourceLoader 接口，因此所有的 application contexts 都能通过getResource()获取Resource实例。</p><ul><li>getResource()参数：<ul><li>classPath方式：”classPath:class路径下文件”</li><li>file方式： “file:本地磁盘文件绝对地址”</li><li>url方式： “url:URL地址下文件”</li><li>没有前缀时依赖applicationContext的配置文件路径: “文件全名”</li></ul></li><li>eg:<code>applicationContext.getResource(&quot;classpath:config.txt&quot;)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」Web编程基础</title>
      <link href="/2017/06/20/java-web.html"/>
      <url>/2017/06/20/java-web.html</url>
      
        <content type="html"><![CDATA[<p>JavaWeb是用Java技术来解决相关web互联网领域的技术总和。Java提供了技术方案可以解决客户端和服务器端的实现，特别是服务器的应用，比如Servlet，JSP和第三方框架等等。</p><span id="more"></span><h3 id="1-http协议"><a href="#1-http协议" class="headerlink" title="1. http协议"></a>1. http协议</h3><p>超文本传输协议，是一种应用层的网络传输协议</p><ul><li>http协议的特点：<ol><li>简单，快速：支持多种不同的的数据提交方式，如get&#x2F;post</li><li>数据传输灵活，支持任意类型数据的传输</li><li>无连接协议：每次连接，只处理一次请求，进行一次响应，响应完毕，立即断开。</li><li>无状态协议：处理请求与响应时没有记忆能力，如果需要处理之间的信息，只能重新传递。</li></ol></li><li>http协议的组成部分：<ol><li>请求：浏览器连接服务器的过程</li><li>响应：服务器回复浏览器的过程</li></ol></li><li>http协议的请求：<ol><li>请求头：描述客户端的信息</li><li>请求体：GET没有请求体，请求体用于存储POST请求发送的数据。</li><li>请求空行：请求头与请求体之间的一行空白</li><li>请求行：描述请求方式，服务器地址，协议版本等</li></ol></li><li>http协议的响应：<ol><li>响应头：描述服务器的信息</li><li>响应体：响应的内容，文本，json数据等。</li><li>响应行：描述服务器协议版本，响应状态码，以及响应成功或失败的解释。</li></ol></li></ul><h3 id="2-Servlet"><a href="#2-Servlet" class="headerlink" title="2. Servlet"></a>2. Servlet</h3><p>servlet是一个运行在tomcat上的Java类，用户通过浏览器输入地址，触发这个类，这个类执行完毕，准备一个响应体，发送给浏览器。</p><h4 id="2-1-Servlet编写步骤："><a href="#2-1-Servlet编写步骤：" class="headerlink" title="2.1 Servlet编写步骤："></a>2.1 Servlet编写步骤：</h4><ol><li>编写一个Java类，继承HttpServlet类</li><li>重新service方法</li><li>在service方法中，对用户请求进行响应。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解：添加访问的网址</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//1.设置响应体的编码，以及内容类型</span></span><br><span class="line">res.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//2.得到响应体输出的打印流</span></span><br><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> res.getWriter();</span><br><span class="line"><span class="comment">//3.打印文字</span></span><br><span class="line">out.println(<span class="string">&quot;&lt;h1&gt;Hello Servlet!&lt;/h1&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-配置ervlet类的访问网址"><a href="#2-2-配置ervlet类的访问网址" class="headerlink" title="2.2 配置ervlet类的访问网址"></a>2.2 配置ervlet类的访问网址</h4><ul><li>web3.0版本之后使用注解的方式配置ervlet类的访问网址</li><li>web3.0版本之前配置Servlet访问网址的方式：<ul><li>将Servlet类，配置到web.xml中，告知tomcat，servlet的类名 </li><li>配置Servlet类的别名，并给指定别名的Servlet添加映射网址。</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将servlet类，配置到web.xml中，告知tomcat，servlet的类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet类别名，用于后续添加映射网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Servlet类全名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>day01_Servlet.demo1.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给指定别名的Servlet添加映射网址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-Servlet生命周期"><a href="#2-3-Servlet生命周期" class="headerlink" title="2.3 Servlet生命周期"></a>2.3 Servlet生命周期</h4><ul><li>实例化 –&gt; 初始化(init) –&gt; 服务(service) –&gt; 销毁(销毁之前调用destory) –&gt; 不可用</li><li>创建时机：默认情况下，当用户第一次访问Servlet的映射网址是Servlet对象被创建，后续用户再次访问，是重复利用此对象。</li><li>销毁时机：当tomcat关闭时 或 应用从tomcat卸载时。</li><li>tomcat为了便于我们进行资源的合理缓存，为生命周期事件提供了三个方法：<ul><li>init(); 当Servlet对象被创建时，方法执行，通常在这里进行一些可重用资源的初始化工作。</li><li>service(); 服务方法，当用户每次发起请求时，此方法用于处理请求，并进行响应，此方法每次都执行在新的线程中。</li><li>destory(); 当Servlet即将被销毁时，方法执行，释放资源的代码可写在此方法中。</li></ul></li></ul><h4 id="2-4-get和post区别"><a href="#2-4-get和post区别" class="headerlink" title="2.4 get和post区别"></a>2.4 get和post区别</h4><ul><li>GET请求：<ul><li>没有请求体，请求时携带参数在url中，参数在url地址的?后，参数由&#x3D;连接的键值对组成，&amp;连接键值对。</li><li>只能传输字符串类型参数</li><li>浏览器url地址最大长度4kb</li><li>数据传输时，参数在url中明文显示，不安全。</li></ul></li><li>POST请求：<ul><li>有请求体，是一个单独的数据包，用于存储请求中的多个参数</li><li>可传输任意类型的数据，进行文件上传必须POST请求</li><li>可以传递的数据大小，理论上没有上限</li><li>数据传输时在单独的数据包，较为安全。</li></ul></li></ul><h4 id="2-5-接收请求中的参数"><a href="#2-5-接收请求中的参数" class="headerlink" title="2.5 接收请求中的参数"></a>2.5 接收请求中的参数</h4><ol><li>根据参数的名称，接收参数的单个值</li></ol><ul><li>String value &#x3D; <strong>request.getParameter(String name)</strong>;</li></ul><ol start="2"><li>根据参数的名称，接收一组参数的值</li></ol><ul><li>String[] values &#x3D; <strong>request.getParameterValues(String name)</strong>;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">  request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">  response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">  <span class="comment">//1.接收</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">  String[] password = request.getParameterValues(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">  <span class="comment">//2.打印</span></span><br><span class="line">  System.out.println(<span class="string">&quot;username:&quot;</span> + username);</span><br><span class="line">  System.out.println(<span class="string">&quot;password:&quot;</span> + password[<span class="number">0</span>]);</span><br><span class="line">  System.out.println(<span class="string">&quot;password2:&quot;</span> + password[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">//3.浏览器输出</span></span><br><span class="line">  response.getWriter().append(<span class="string">&quot;&lt;div&gt;很遗憾注册失败，点击&lt;a href=\&quot;demo1.html\&quot;&gt;重新注册&lt;/a&gt;&lt;/div&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-乱码处理"><a href="#2-6-乱码处理" class="headerlink" title="2.6 乱码处理"></a>2.6 乱码处理</h4><h4 id="2-6-1-乱码情况："><a href="#2-6-1-乱码情况：" class="headerlink" title="2.6.1 乱码情况："></a>2.6.1 乱码情况：</h4><ul><li>浏览器提交表单时，会对中文参数值进行自动编码。Tomcat服务器接收到的浏览器请求后，默认使用iso-8859-1去解码，当编码与解码方式不一致时，就会乱码。</li><li>tomcat8版本之前(不包含tomcat8版本), GET请求乱码</li><li>任何版本, POST请求乱码</li></ul><h4 id="2-6-2-请求乱码处理："><a href="#2-6-2-请求乱码处理：" class="headerlink" title="2.6.2 请求乱码处理："></a>2.6.2 请求乱码处理：</h4><ul><li>适用于所有乱码问题：(Tomcat8之后get无乱码)<ol><li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li><li>将接收到的中文乱码重新编码：</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;userName&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>( name.getByte(<span class="string">&quot;ISO-8859-1&quot;</span>),<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>仅适用于POST请求：<ol><li>指定浏览器打开页面的编码<code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>;</li><li>Servlet接收之前设置解码（需在调用request.getParameter(“key”)之前设置）<code>request.setCharacterEncoding(&quot;utf-8&quot;)</code>;</li></ol></li></ul><h4 id="2-6-3-响应乱码的处理："><a href="#2-6-3-响应乱码的处理：" class="headerlink" title="2.6.3 响应乱码的处理："></a>2.6.3 响应乱码的处理：</h4><ul><li>方式一：设置响应的内容类型, 以及编码格式:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>;</li><li>方式二：进设置编码格式, 不设置响应内容类型:<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code>(常用于客户端不是浏览器的情况, 如果在浏览器的环境下设置, 有部分浏览器无法识别, 依然会乱码);</li></ul><h4 id="2-7-Servlet的创建时机"><a href="#2-7-Servlet的创建时机" class="headerlink" title="2.7 Servlet的创建时机"></a>2.7 Servlet的创建时机</h4><ul><li>通过web.xml配置Servlet, 可以修改Servlet加载的时机。</li><li>可以给Servlet节点，添加<code>&lt;load-on-startup&gt;</code>节点来制定servlet启动顺序。</li><li>节点中的值为数字：<ul><li><code>-1</code>：默认-1，表示当用户第一次请求时，创建对象</li><li><code>&gt;=0</code>：大于等于0，当服务器启动时，创建对象，值越小创建越早，值相同按web.xml配置顺序创建</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>demo.ServletDemo<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>s1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/s1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-请求的转发与重定向"><a href="#3-请求的转发与重定向" class="headerlink" title="3. 请求的转发与重定向"></a>3. 请求的转发与重定向</h3><h4 id="3-1-请求对象request的常用操作"><a href="#3-1-请求对象request的常用操作" class="headerlink" title="3.1 请求对象request的常用操作"></a>3.1 请求对象request的常用操作</h4><ol><li>getMethod() : 得到请求的方式</li><li>getRequestURI() : 获取浏览器请求地址</li><li>getRemoteAddr() : 获取客户端ip地址</li><li>getRemoteHost() : 获取客户端名称</li><li>getServerName() : 获取服务器名称</li><li>getServerPort() : 获取服务器端口号</li><li>getQueryString() : 获取get请求参数字符串，其他请求返回null</li></ol><h4 id="3-1-请求的转发与重定向注意事项"><a href="#3-1-请求的转发与重定向注意事项" class="headerlink" title="3.1 请求的转发与重定向注意事项"></a>3.1 请求的转发与重定向注意事项</h4><ul><li>请求转发与重定向操作，必须要有出口。</li><li>当一个请求在servlet中进行了重定向，那么这个servlet就不要再进行响应了</li></ul><h4 id="3-2-转发"><a href="#3-2-转发" class="headerlink" title="3.2 转发*"></a>3.2 转发*</h4><ul><li>一个web组件，将未处理完毕的请求，通过tomcat转交给另一个web组件处理</li><li>步骤：<ol><li>获取请求转发器：<code>RequestDispather rd = request.getRequestDispacher(&quot;转发地址&quot;);</code></li><li>进行转发操作：<code>rd.forward(request, response);</code></li></ol></li><li>因为通常请求转发器获取后, 只会使用一次 , 一般不给对象起名, 简写:<ul><li><code>request.getRequestDispacher(&quot;转发地址&quot;).forward(request, response);</code></li></ul></li><li>特点：<ul><li>转发过程中，多个web组件之间共享一个请求对象request与响应对象response</li><li>在转发过程中，无论转发多少次，浏览器只发起了一次请求，所以浏览器地址不会改变</li><li>转发不能跨项目实现</li><li>比重定向效率更高</li></ul></li></ul><h4 id="3-3-重定向"><a href="#3-3-重定向" class="headerlink" title="3.3 重定向*"></a>3.3 重定向*</h4><ul><li>一个web组件，处理完毕请求后，告知浏览器，将请求转向另一个地址</li><li>格式：<code>response.sendRedirect(&quot;重定向地址&quot;)</code>；</li><li>原理：当客户端请求服务器时，发起重定向流程：<ol><li>给浏览器响应302的状态码 , 以及一个键值对, 键为: location , 值为重定向新地址.</li><li>当浏览器接收到302的状态码时, HTTP协议规定了浏览器会寻找location对象的新地址.</li><li>浏览器自动发起新的请求 , 跳转到新地址.</li></ol></li><li>特点：<ol><li>重定向会产生两个请求对象，多个请求对象中数据不互通</li><li>浏览器地址发生了改变</li><li>重定向可以跨域实现</li><li>比转发效率低</li></ol></li></ul><h3 id="4-上下文对象ServletContext"><a href="#4-上下文对象ServletContext" class="headerlink" title="4. 上下文对象ServletContext"></a>4. 上下文对象ServletContext</h3><ul><li>用于关联多个servlet，是servlet之间通讯的桥梁，用于多个servlet之间的信息共享</li><li>每一个项目运行时，tomcat会为这个项目创建一个servletContext，项目关闭时销毁。</li></ul><p>获取ServletContext对象：<code>ServletContext context = getServletContext();</code></p><ul><li>常用方法<ul><li>context.setAttributes(String key, Objexct value); &#x2F;&#x2F;设置替换数据</li><li>context.getAttributes(String key); &#x2F;&#x2F;获取数据</li><li>context.removeAttributes(String key); &#x2F;&#x2F;删除数据</li><li>context.getRealPath(“&#x2F;“); &#x2F;&#x2F;获取项目运行时所在文件路径</li></ul></li></ul><h3 id="5-会话跟踪（状态管理）"><a href="#5-会话跟踪（状态管理）" class="headerlink" title="5. 会话跟踪（状态管理）"></a>5. 会话跟踪（状态管理）</h3><ul><li><p>存在两种实现：</p><ol><li>cookie: 将浏览器产生的状态存储在浏览器中</li><li>Session: 将浏览器产生的状态存储在服务器中</li></ol></li><li><p>cookie技术原理：</p><ul><li>服务器向客户端响应时，将数据以set-Cookie消息头（响应头）的方式发给浏览器，</li><li>浏览器接收到cookie后，会将这些数据以文本文件的方式（.txt文件）保存起来</li><li>当浏览器再次发起相同请求时，浏览器会将之前存储的cookie,添加到请求头，发给服务器</li></ul></li><li><p>Session技术原理：</p><ul><li>当浏览器访问服务器时，服务器可以选择为用户创建一个Session对象(类似于map集合)，</li><li>该Session对象有一个id属性，称之为SessionId，服务器会将这个SessionId以cookie方式发送给浏览器</li><li>浏览器再次访问服务器时，同时会传递SessionId的cookie给i服务器，服务器根据sessionId找到Session对象，供程序使用。</li></ul></li></ul><h4 id="5-1-Cookie"><a href="#5-1-Cookie" class="headerlink" title="5.1 Cookie"></a>5.1 Cookie</h4><ul><li>创建Cookie：Cookie在Java中是一个类，每个cookie的对象都表示一个键值对<ul><li><code>Cookie cookie = new Cookie(String key, String value);</code></li><li>注意：tomcat8.5版本之前，cookie无法出场中文</li></ul></li><li>通过响应对象，将cookie添加到响应头,可添加多个<ul><li><strong>response.addCookie(Cookie cookie)</strong>;</li></ul></li><li>通过请求头得到cookie数组，没有则返回null<ul><li><strong>Cookie[] cookies &#x3D; request.getCookies()</strong>;</li><li>取键：cookie.getName();</li><li>取值：cookie.getValue()</li></ul></li><li>Cookie的存储时长：<ul><li>cookie.setMaxAge(int 秒)；<ul><li>正数：倒计时秒数</li><li>0：表示立即删除此cookie，常用于覆盖一个存活时长较长的cookie,用于删除它</li><li>负数：默认-1，表示会话结束时自动删除（关闭浏览器）</li></ul></li></ul></li><li>Cookie的存储路径问题<ul><li>存储的cookie发送到服务器时，判断是否发送的依据是：域名相同，路径相同</li><li>为了避免路径问题，通常会将cookie设置统一路径为根路径：cookie.setPath(“&#x2F;“);</li></ul></li></ul><h4 id="5-2-Cookie的优缺点"><a href="#5-2-Cookie的优缺点" class="headerlink" title="5.2 Cookie的优缺点"></a>5.2 Cookie的优缺点</h4><ul><li>缺点：<ol><li>Cookie技术存储的数据类型，只能是字符串，且早期版本(8.5之前)不可存储中文。</li><li>数据存储在客户的计算机中，不安全，不建议存储安全敏感数据</li><li>保存数据量有限制，大约4kb左右</li><li>依赖于用户的浏览器设置，用户可以金庸cookie，可能被用户主动删除</li></ol></li><li>优点：<ol><li>分散服务器的压力</li></ol></li></ul><h4 id="5-3-Session"><a href="#5-3-Session" class="headerlink" title="5.3 Session"></a>5.3 Session</h4><ul><li>获取Session<ul><li>格式1：<strong>request.getSession()</strong>;&#x2F;&#x2F;等价参数传true</li><li>格式2：request.getSession(boolean isNew);<ul><li>true，根据浏览器的SessionId查找一个session，若没有就新创建一个对象并返回</li><li>false，根据浏览器的SessionId查找一个session，若没有就返回null</li></ul></li></ul></li><li>Session常用方法<ul><li><strong>session.setAttribute(String key, object value)</strong>;&#x2F;&#x2F;设置&#x2F;替换值</li><li><strong>session.getAttribute(String key)</strong>;&#x2F;&#x2F;获取值</li><li>session.invalidate();&#x2F;&#x2F;销毁</li></ul></li><li>设置session存活时长<ul><li>默认会话时长30分钟，当浏览器最后一次访问服务器后30分钟后，若没有再次连接，则session被销毁。</li><li>可以通过修改配置文件，修改所有的session时长<ul><li>修改<code>conf/web.xml</code>的<code>&lt;session-config&gt;&lt;session-tiomeout&gt;数值分钟&lt;/session-tiomeout&gt;&lt;/session-config&gt;</code></li></ul></li><li>可以通过session对象，修改单个对象的session时长<ul><li>void session.setMaxInactiveInterval(int seconds)</li></ul></li></ul></li></ul><h4 id="5-4-Session的优缺点"><a href="#5-4-Session的优缺点" class="headerlink" title="5.4 Session的优缺点"></a>5.4 Session的优缺点</h4><ul><li>缺点：<ul><li>数据存储在服务器端，当用户量大时，对服务器造成极大的压力，很容易耗尽服务器资源</li></ul></li><li>优点：<ol><li>数据存储在服务器中，安全</li><li>数据类型为Object，在Java中表示可以存储所有类型的数据</li><li>session存储的数据大小，理论上无限的。</li></ol></li></ul><h4 id="5-5-Cookie和Session的使用"><a href="#5-5-Cookie和Session的使用" class="headerlink" title="5.5 Cookie和Session的使用"></a>5.5 Cookie和Session的使用</h4><ul><li>Cookie和Session不是互斥的，是相辅相成的</li><li>在项目开发时：<ul><li>对安全敏感的数据，存储在session中</li><li>对安全不敏感的字符串数据，可以选择存储在Cookie中</li><li>对于大的数据，应该存在数据库和文件中</li></ul></li></ul><blockquote><p>注意：cookie和session是为了管理状态而非存储数据。</p></blockquote><h3 id="6-JSP"><a href="#6-JSP" class="headerlink" title="6.JSP"></a>6.JSP</h3><h4 id="6-1-JSP语法基础"><a href="#6-1-JSP语法基础" class="headerlink" title="6.1 JSP语法基础"></a>6.1 JSP语法基础</h4><ul><li><p>Java Server Pages：java动态网页技术</p></li><li><p>JSP引擎原理：JSP引擎读取JSP文件，将文件转换为Servlet，由servlet给用户响应</p></li><li><p>注意：</p><ol><li>JSP文件的转换 发生在服务器启动时，当用户访问JSP时，其实访问的是JSP文件转换的Servlet</li><li>执行流程：浏览器请求–&gt;tomcat–&gt;JSP引擎转换为Servlet–&gt;转换的Servlet–&gt;准备响应体–&gt;响应给浏览器–&gt;浏览器解析html</li></ol></li><li><p>JSP语法结构</p><ol><li>html代码</li><li>Java代码</li><li>Jsp特有的语法结构</li></ol></li><li><p>Java代码声明区：指的是类的成员位置</p></li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">  <span class="comment">// Java代码声明区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>Java代码执行区：指的是Servlet的service方法中，每次用户请求，执行区的代码都会执行起来</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">  <span class="comment">// Java代码执行区</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><ul><li>JSP输出表达式<ul><li>用于快速的将Java中的数据，输出到网页中..</li><li>语法格式：<code>&lt;%=数据 %&gt;</code>，编译后被转换成out.print(数据)</li></ul></li><li>JSP注释：<ul><li>html中可以用<code>&lt;!-- --&gt;</code></li><li>java中可以用<code>//，/**/，/** */</code></li><li>jsp注释<code>&lt;%-- --%&gt;</code><ul><li>html和java注释会被编译，其中html注释会被编译到页面，jsp注释编译器会自动忽略</li></ul></li></ul></li></ul><h4 id="6-2-JSP三大指令"><a href="#6-2-JSP三大指令" class="headerlink" title="6.2 JSP三大指令"></a>6.2 JSP三大指令</h4><ul><li>page指令</li><li>include指令</li><li>taglib指令</li></ul><ul><li>指令使用格式：&lt;%@ 指令名称 属性1&#x3D;值 属性2&#x3D;值 属性n&#x3D;值 %&gt;<br>*语法上，JSP允许在单个页面出现多个相同的JSP指令</li></ul><h5 id="6-2-1-page指令"><a href="#6-2-1-page指令" class="headerlink" title="6.2.1 page指令"></a>6.2.1 page指令</h5><ul><li>用于配置页面信息</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page</span><br><span class="line">  language=<span class="string">&quot;java&quot;</span>：语言</span><br><span class="line">  contentType=<span class="string">&quot;text/html;charset=utf-8&quot;</span>：响应的内容类型，以及响应的编码格式</span><br><span class="line">  pageEncoding=<span class="string">&quot;UTF-8&quot;</span>：文件存储的编码格式</span><br><span class="line">  extends=<span class="string">&quot;继承的父类&quot;</span></span><br><span class="line">  buffer=<span class="string">&quot;数字/none&quot;</span>：是否允许缓存，默认值8kb</span><br><span class="line">  autoFlush=<span class="string">&quot;true/false&quot;</span>：是否自动清除缓存，默认<span class="literal">true</span></span><br><span class="line">  session=<span class="string">&quot;true/false&quot;</span>：是否提前准备session对象，默认<span class="literal">true</span></span><br><span class="line">  isThreadSafe=<span class="string">&quot;true/false&quot;</span>：是否线程安全的</span><br><span class="line">  <span class="keyword">import</span>=<span class="string">&quot;java.util.List&quot;</span>：用于导包，多个包使用<span class="string">&quot;,&quot;</span>隔开</span><br><span class="line">  errorPage=<span class="string">&quot;网址&quot;</span>：当页面发生BUG后，显示哪个页面</span><br><span class="line">  isErrorPage=<span class="string">&quot;true/false&quot;</span>：当前页面是否是一个错误处理页面，如果结果为<span class="literal">true</span>，当别的页面产生错误，跳转到此页面，会提前准备好一个对象exception，此对象封装了错误信息</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h4 id="6-3-项目发生错误时，统一的处理方式"><a href="#6-3-项目发生错误时，统一的处理方式" class="headerlink" title="6.3 项目发生错误时，统一的处理方式"></a>6.3 项目发生错误时，统一的处理方式</h4><ol><li>打开项目的web.xml</li><li>加入子节点<code>&lt;error-page&gt;&lt;error-code&gt;错误码&lt;/error-code&gt;&lt;location&gt;处理网址&lt;/location&gt;&lt;/error-page&gt;</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>include指令：用于将jsp或html引入到另一个jsp中<ul><li>语法格式：<code>&lt;%@ include file=&quot;地址&quot; %&gt;</code></li></ul></li><li>include动作：用于将jsp或html引入到另一个jsp中<ul><li>语法格式：<code>&lt;jsp:include page=&quot;地址&quot;&gt;</code></li></ul></li></ul><blockquote><p>include指令 与 include动作区别：</p></blockquote><ul><li>include指令：引入文件操作，是在JSP引擎的转换时发生，将多个jsp文件，生产为了一个Servlert（多个jsp &#x3D;&gt; 一个Servlet）</li><li>include动作：引入文件操作，是在浏览器请求时，将引用文件的响应体添加到了请求文件的响应体中（多个jsp &#x3D;&gt; 多个Servlet）</li></ul><h3 id="7-内置对象-隐含对象"><a href="#7-内置对象-隐含对象" class="headerlink" title="7.内置对象(隐含对象)"></a>7.内置对象(隐含对象)</h3><ul><li>在JSP中，我们的代码执行在service中，所谓内置对象，指的是在JSP引擎转换时期，在我们代码生成位置的上面，提前准备好的一些变量，对象。</li><li>内置对象通常是我们会主动创建的对象</li></ul><h4 id="7-1-九大内置对象"><a href="#7-1-九大内置对象" class="headerlink" title="7.1 九大内置对象"></a>7.1 九大内置对象</h4><ol><li>request</li></ol><ul><li>对象类型：java.servlet.<strong>HttpServletRequest</strong></li><li>request内置对象中包含了有关浏览器请求的信息，提供了大量get方法，用于获取cookie、header以及session内数据等。</li></ul><ol start="2"><li>response</li></ol><ul><li>对象类型：javax.servlet.<strong>HttpServletResponse</strong></li><li>response对象提供了多个方法用来处理HTTP响应，可以调用response中的方法修改ContentType中的MIME类型以及实现页面的跳转等。</li></ul><ol start="3"><li>config</li></ol><ul><li>对象类型：javax.servlet.<strong>ServletConfig</strong></li><li>在Servlet初始化的时候，JSP引擎通过config向它传递信息。这种信息可以是属性名&#x2F;值匹配的参数，也可以是通过ServletContext对象传递的服务器的有关信息。</li></ul><ol start="4"><li>out</li></ol><ul><li>对象类型：javax.servlet.jsp.<strong>JspWriter</strong></li><li>在JSP开发过程中使用得最为频繁的对象</li></ul><ol start="5"><li>page</li></ol><ul><li>对象类型：java.lang.<strong>Object</strong></li><li>page对象有点类似于Java编程中的this指针，就是指当前JSP页面本身。</li></ul><ol start="6"><li>pageContext</li></ol><ul><li>对象类型：<strong>pageContext</strong></li><li>pageContext对象是一个比较特殊的对象。它相当于页面中所有其他对象功能的最大集成者，即使用它可以访问到本页面中所有其他对象</li></ul><ol start="7"><li>session</li></ol><ul><li>对象类型：java.servlet.http.<strong>HttpSession</strong></li><li>session是与请求有关的会话期，用来表示和存储当前页面的请求信息。</li></ul><ol start="8"><li>application</li></ol><ul><li>对象类型：javax.servlet.<strong>ServletContext</strong></li><li>用于实现用户之间的数据共享（多使用于网络聊天系统）。</li></ul><ol start="9"><li>exception</li></ol><ul><li>对象类型：java.lang.<strong>Throwable</strong></li><li>作用 exception内置对象是用来处理页面出现的异常错误。</li></ul><h4 id="7-2-JSP四大域对象"><a href="#7-2-JSP四大域对象" class="headerlink" title="7.2 JSP四大域对象"></a>7.2 JSP四大域对象</h4><ul><li>九大内置对象中，存在四个较为特殊的对象，这四个对象用户在不同的作用域中存储数据，获取数据，删除数据</li><li>域对象的特点：每一个内置对象，都类似一个Map集合，可以存取删除数据，都具备如下三个方法：<ol><li>存储数据：setAttribute(String key, Object value);</li><li>获取数据：Object value &#x3D; getAttribute(String);</li><li>删除数据： removeAttribute(String key);</li></ol></li><li>四大内置对象，分别指的是：<ol><li>pageContext: (作用域：1个页面)</li></ol><ul><li>页面上下文，存储在pageContext中的数据, 作用域是最小的,  pageContext在JSP代码执行时 创建, 在JSP代码执行完毕时, 销毁.</li></ul><ol start="2"><li>request: (作用域：一次请求，如果请求被转发，可能跨越多个页面)</li></ol><ul><li>请求对象, 存储在请求对象中的数据, 域范围是一次请求, 请求一旦进行了响应, 就会被销毁.</li></ul><ol start="3"><li>session: (作用域：一次会话，一次会话可能包含多个请求)</li></ol><ul><li>会话对象，存储在会话对象中的数据，只有在当前用户会话中可以使用，用户再次访问服务器的时间间隔超过30分钟，session就销毁了。</li></ul><ol start="4"><li>application: (域范围：一次服务，应用从启动到关闭application一直都在)</li></ol><ul><li>Servlet上下文对象, 存储在application中的数据, 域范围是最大的. 在应用关闭之前 都可以使用.</li></ul></li></ul><h4 id="7-3-EL表达式"><a href="#7-3-EL表达式" class="headerlink" title="7.3 EL表达式"></a>7.3 EL表达式</h4><ul><li>用于将计算的结果输出到网页，也常用于快速的从域对象中取出数据，并输出到网页。</li><li>格式：<code>$&#123;表达式&#125;</code></li><li>EL表达式用于运算<ul><li>在JSP中, 可以直接使用el表达式运算一些数据，例如: ${123+123} , 最终网页中显示的效果是:   246</li></ul></li><li>用于取出域对象中的数据<ul><li>取出数据直接输出：<code>$&#123;域对象中存储的键&#125;</code></li><li>如果取出的数据不存在, 则不输出 (不可能显示null)</li></ul></li><li>取出对象数据的属性值:<ul><li>格式1： ${对象存储的键.属性名}</li><li>格式2： ${对象存储的键[“属性名”]}</li><li>格式3(动态取值)： ${对象存储的键[属性存储的键]}</li></ul></li><li>取出集合中的数据<ul><li>格式: ${集合存储时的key[下标]}</li></ul></li></ul><h4 id="7-4-EL表达式取出数据的流程"><a href="#7-4-EL表达式取出数据的流程" class="headerlink" title="7.4 EL表达式取出数据的流程"></a>7.4 EL表达式取出数据的流程</h4><ul><li>四个域对象之间, 有时数据的键可能重复,优先从域范围较小的对象中, 取出数据.</li><li>步骤:<ol><li>先从pageContext中, 寻找数据是否存在.</li><li>如果pageContext中数据不存在, 则去request中寻找数据是否存在</li><li>如果request 中数据不存在, 则去session中寻找数据是否存在</li><li>如果session中数据不存在, 则去application中寻找数据是否存在</li><li>如果application中数据不存在,则不输出任何数据.</li></ol></li></ul><h3 id="8-taglib指令"><a href="#8-taglib指令" class="headerlink" title="8. taglib指令"></a>8. taglib指令</h3><p>用于在JSP文件中，引入标签库文件。</p><ul><li>格式： <code>&lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot; %&gt;</code><ul><li>prefix: 是引入标签库后，标签库的名称。作用是用于区分引入的多个标签库，在使用标签库中的标签时，标签的写法：<code>&lt;标签库名称:标签名&gt;</code></li><li>uri: 每个标签库，都会拥有一个uri，它是用于区分标签库的，我们在引入这个库时，需要匹配uri属性</li></ul></li><li>JSTL(JSP Standard Tag Library): JSP标准标签库<ul><li>使用时，需要引入jar文件</li><li>if 标签，格式：&lt;库名称:if text&#x3D;”${ booble }”&gt;</li><li>forEach 标签，格式：&lt;库名称:forEach items&#x3D;”${ List }” var&#x3D;”item”&gt;</li></ul></li><li>自定义标签库:<ol><li>编写一个Java类, 继承SimpleTagSupport类.</li><li>重写父类的doTag方法.</li><li>在doTag方法中, 通过getJspContext方法,  的到JSP页面的上下文</li><li>通过上下文对象, 得到JSP中的out对象, </li><li>通过out对象,  向网页中输出内容</li><li>编写tld文件 , 描述标签库 以及 标签.</li></ol></li></ul><p>自定义标签库案例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTag1</span> <span class="keyword">extends</span> <span class="title class_">SimpleTagSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> ArrayList&lt;String&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        data.add(<span class="string">&quot;流水在碰到底处时才会释放活力。——歌德&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doTag</span><span class="params">()</span> <span class="keyword">throws</span> JspException, IOException &#123;</span><br><span class="line">        <span class="type">JspContext</span> <span class="variable">context</span> <span class="operator">=</span> getJspContext();</span><br><span class="line">        <span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> context.getOut();</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> r.nextInt(data.size());</span><br><span class="line">        out.println(<span class="string">&quot;&lt;span&gt;&quot;</span>+data.get(index)+<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是对于标签库的介绍 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>我们这个标签库, 是闲的慌 , 所以写的.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述标签库的名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>11.88<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 建议的短命名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>xdl<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签库的表示, 用于引入时匹配标签库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://shuidianshuisg.com<span class="tag">&lt;/<span class="name">uri</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开始描述标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对于标签的介绍 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>这个标签用于随机向网页中, 输出一句名言<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>heiheihei<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签所对应的的Java类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag-class</span>&gt;</span>cn.xdl.tag.MyTag1<span class="tag">&lt;/<span class="name">tag-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 标签的内容 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="name">body-content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-JavaWeb三大组件-Servlet-filter-Lister"><a href="#9-JavaWeb三大组件-Servlet-filter-Lister" class="headerlink" title="9. JavaWeb三大组件(Servlet,filter,Lister)"></a>9. JavaWeb三大组件(Servlet,filter,Lister)</h3><h4 id="9-1-Filter过滤器"><a href="#9-1-Filter过滤器" class="headerlink" title="9.1 Filter过滤器"></a>9.1 Filter过滤器</h4><ul><li>请求的过滤器，面向切面编程思想（AOP）</li><li>使用步骤：<ol><li>编写一个类，实现Filter接口</li><li>通过注解或web.xml配置过滤器规则</li></ol></li><li>过滤器链：<ul><li>当多个过滤器，过滤同一个请求地址时，就形成了过滤器链，所有过滤器都放行后，servlet才会处理用户请求</li></ul></li><li>过滤器链执行顺序：（若同时包含注解与web.xml,优先执行web.xml）<ul><li>注解方式：按照类名的自然顺序先后</li><li>web.xml配置方式：按照web.xml配置顺序，先后执行</li></ul></li><li>案例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/home.jsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter即将销毁时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有新的请求, 满足了过滤器的过滤规则,  正在过滤</span></span><br><span class="line"><span class="comment">     * 参数1.   请求对象</span></span><br><span class="line"><span class="comment">     * 参数2. 响应对象</span></span><br><span class="line"><span class="comment">     * 参数3.  过滤器链对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤管理员登录的过滤器 正在执行&quot;</span>);</span><br><span class="line">        <span class="comment">//1.    从请求中, 得到session</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">req</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">//2.    判断session中是否存在username</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//3.    如果存在, 且值为admin , 则放行 </span></span><br><span class="line">        <span class="keyword">if</span>(username !=<span class="literal">null</span> &amp;&amp; username.equals(<span class="string">&quot;admin&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.    否则拦截, 并响应, 提示请先以管理员身份登录</span></span><br><span class="line">            response.getWriter().append(<span class="string">&quot;&lt;script&gt;alert(&#x27;请先以管理员身份登录, 再访问管理页面&#x27;);window.location.href=&#x27;login.jsp&#x27;&lt;/script&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当Filter初始化时 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>web.xml配置方式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>cn.xdl.demo1.EnCodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/home.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-2-Listener监听器"><a href="#9-2-Listener监听器" class="headerlink" title="9.2 Listener监听器"></a>9.2 Listener监听器</h4><ul><li>监听服务器的一些状态事件，事件驱动机制。</li><li>分为两类状态事件：<ul><li>服务器中组件的生命周期</li><li>一些域对象中数据变化的事件</li></ul></li><li>监听服务器的启动与关闭：ServletContextListener</li><li>监听ServletContext中数据的增加,删除,以及替换：ServletContextAttributeListener</li><li>监听Session会话的开启与关闭：HttpSessionListener </li><li>监听session中数据的增加,删除,以及替换：HttpSessionAttributeListener</li></ul><h3 id="10-JSON在Java中的使用"><a href="#10-JSON在Java中的使用" class="headerlink" title="10. JSON在Java中的使用"></a>10. JSON在Java中的使用</h3><ul><li>JSON：JavaScript Object Notation</li><li>GSON.jar，将Java中的对象转换为JSON字符串，将JSON字符串转换为Java中的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入jar文件</span></span><br><span class="line"><span class="type">Gson</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> g.toJson(Java对象);<span class="comment">//转换JSON字符串</span></span><br><span class="line">类型 对象名 = g.fromJson(Json字符串, 类型.class);<span class="comment">//转换为Java对象</span></span><br></pre></td></tr></table></figure><h3 id="11-AJAX"><a href="#11-AJAX" class="headerlink" title="11. AJAX"></a>11. AJAX</h3><ul><li>一种用于网页异步请求的技术，用于与服务器进行异步交互以及对网页局部刷新操作</li><li>Ajax请求的状态（readyState）<ul><li>0：正在初始化</li><li>1：请求正在发送</li><li>2：请求发送完毕</li><li>3：服务器开始响应</li><li>4：响应接收完毕，连接断开</li></ul></li><li>Ajax响应的状态（status）<ul><li>200：成功</li><li>404：找不到资源</li><li>500：服务器错误</li></ul></li></ul><h4 id="11-1-GET请求AJAX"><a href="#11-1-GET请求AJAX" class="headerlink" title="11.1 GET请求AJAX"></a>11.1 GET请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;地址?参数列表&quot;</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure><h4 id="11-2-POST请求AJAX"><a href="#11-2-POST请求AJAX" class="headerlink" title="11.2 POST请求AJAX"></a>11.2 POST请求AJAX</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;地址&quot;</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line">      <span class="comment">//通过xhr.responseText接收响应体</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//失败处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//POST请求设置请求头</span></span><br><span class="line">xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>); </span><br><span class="line">xhr.<span class="title function_">send</span>(参数列表); <span class="comment">//发送请求参数</span></span><br></pre></td></tr></table></figure><h4 id="11-2-Jquery中的AJAX"><a href="#11-2-Jquery中的AJAX" class="headerlink" title="11.2 Jquery中的AJAX"></a>11.2 Jquery中的AJAX</h4><ol><li><code>$.ajax(&#123;url,[settings]&#125;)</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;请求的网址&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&quot;请求方式GET/POST...&quot;</span>,</span><br><span class="line">    <span class="attr">async</span>:<span class="string">&quot;请求是否异步, 默认true&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;请求的参数列表, 格式与GET请求?后的格式一致&quot;</span>,</span><br><span class="line">    <span class="attr">dataType</span>:<span class="string">&quot;TEXT或JSON&quot;</span>,<span class="comment">//服务器返回的数据类型</span></span><br><span class="line">    <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">data</span>)&#123;<span class="comment">//当服务器响应状态码在200-299之间时, 这里执行</span></span><br><span class="line">        <span class="comment">//参数data:就是响应的内容, 当dataType为TEXT时, 类型为string , 当dataType为JSON时, 类型为Object</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">error</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="comment">//当服务器响应状态码不再200-299之间时, 这里执行</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>$.get(url, [data], [callback], [type])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">get</span>(<span class="string">&quot;请求的网址&quot;</span>, &#123; 请求参数键值对 &#125;,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>$.post(url, [data], [callback], [type])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">post</span>(<span class="string">&quot;请求的网址&quot;</span>, &#123; 请求参数键值对 &#125;,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;, <span class="string">&quot;json&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="4"><li><code>$.getJSON(url, [data], [callback])</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">getJSON</span>(<span class="string">&quot;请求的网址&quot;</span>, &#123; 请求参数键值对 &#125;,<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="comment">//data:响应的内容</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><code>jquery对象.load(url, [data], [callback])</code></li></ol><ul><li>载入远程 HTML 文件代码并插入至 DOM 中，load函数是使用jquery对象来调用.返回的结果无需解析, 直接显示到调用函数的jquery对象中。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#dom&quot;</span>).<span class="title function_">load</span>(<span class="string">&quot;请求的网址&quot;</span>, &#123; 请求参数键值对 &#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">//加载成功</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="11-3-Vue中的AJAX"><a href="#11-3-Vue中的AJAX" class="headerlink" title="11.3 Vue中的AJAX"></a>11.3 Vue中的AJAX</h4><ul><li>使用vue的ajax , 除了需要引入vue.js以外, 还需要引入vue-resource.js</li><li>不创建Vue对象的情况下, 使用的ajax:<ul><li><code>Vue.http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li><li><code>Vue.http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],&#123;&quot;emulateJSON&quot;:true&#125;).then(success,error)</code>;</li></ul></li><li>创建Vue实例, 使用ajax<ul><li><code>this.$http.get(&quot;请求地址&quot;,[&quot;请求的参数&quot;]).then(success,error)</code>;</li><li><code>this.$http.post(&quot;请求地址&quot;,[&quot;请求的参数&quot;],&#123;&quot;emulateJSON&quot;:true&#125;).then(success,error)</code>;</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GET请求: 传递参数列表: </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">        参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable constant_">POST</span>请求: 传递参数列表:</span><br><span class="line">&#123;</span><br><span class="line">    参数名<span class="number">1</span>:值<span class="number">1</span>,</span><br><span class="line">    参数名<span class="number">2</span>:值<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>success函数 与 error函数<ul><li>格式: function(res){} &#x2F;&#x2F;res , 就是响应对象, 包含了响应的相关信息</li><li>响应对象的常用属性:<ol><li>url : 响应的网址</li><li>body : 响应的内容 (响应体) , 如果是JSON格式, 则返回对象, 否则返回string</li><li>ok  : boolean值, 响应码在200-299之间时  为 true</li><li>status : 响应码, 例如: 200,302,404,500</li><li>statusText :响应码对应的文字信息, 例如: 状态码为200时, 信息为ok</li></ol></li><li>响应对象的常用函数:<ol><li>text() : 以字符串的形式, 返回响应体</li><li>json() : 以对象的形式, 返回响应体</li><li>blob() : 以二进制的形式 , 返回响应体.</li></ol></li></ul></li></ul><h4 id="11-4-AJAX缓存问题"><a href="#11-4-AJAX缓存问题" class="headerlink" title="11.4 AJAX缓存问题"></a>11.4 AJAX缓存问题</h4><ul><li>浏览器ajax得到响应结果后, 会缓存起来，当再次访问相同地址时, 会优先使用缓存。</li><li>缓存的原理, 是按照网址来缓存的, 我们只要让我们每次请求的网址都不一样, 就可以避免缓存出现。</li><li>在请求地址加上随机参数可以比避免缓存，如:<code>&quot;s1.do?time=&quot;+new Date().getTime();</code></li></ul><h4 id="11-5-AJAX跨域问题"><a href="#11-5-AJAX跨域问题" class="headerlink" title="11.5 AJAX跨域问题"></a>11.5 AJAX跨域问题</h4><ul><li>默认编写的Servlet . 不允许其他网站的ajax跨域请求.</li><li>我们只需要给servlet的响应头中加入两个键值 , 就可以允许跨域:<ul><li><code>response.addHeader(&quot;Access-Control-allow-Origin&quot;,&quot;*&quot;)</code>;</li><li><code>response.addHeader(&quot;Access-Control-allow-Methods&quot;,&quot;GET,POST&quot;)</code>;</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」数据结构与算法入门</title>
      <link href="/2017/06/05/java-algorithm.html"/>
      <url>/2017/06/05/java-algorithm.html</url>
      
        <content type="html"><![CDATA[<p>数据结构，它是储存数据的一种结构体，在此结构中储存一些数据，而这些数据之间有一定的关系。<br>算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或者多个操作。</p><span id="more"></span><h3 id="1-Java数据结构-Data-Structure"><a href="#1-Java数据结构-Data-Structure" class="headerlink" title="1.Java数据结构(Data Structure)"></a>1.Java数据结构(Data Structure)</h3><h4 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h4><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。<br>而各数据元素之间的相互关系，又包括三个组成成分，数据的<strong>逻辑结构</strong>，数据的<strong>存储结构</strong>和数据<strong>运算结构</strong>。<br>而一个数据结构的设计过程分成抽象层、数据结构层和实现层。</p><h4 id="1-2-Java数据结构"><a href="#1-2-Java数据结构" class="headerlink" title="1.2 Java数据结构"></a>1.2 Java数据结构</h4><ul><li>数据结构在Java的语言体系中按数据的逻辑结构可以分为两大类：线性数据结构和非线性数据结构。<ol><li>线性数据结构：常见的有：一维数组，线性表，栈，队列，双队列，串。</li><li>非线性数据结构：常见的有：多维数组，集合，树，图，散列表(hash)。</li></ol></li><li>按数据的存储结构分为：顺序存储结构和链式存储结构<ol><li>顺序存储结构:用数据元素在存储器中的相对位置来表示数据元素之间的逻辑关系。 </li><li>链式存储结构：在每一个数据元素中增加一个存放地址的指针，用此指针来表示数据元素之间的逻辑关系。</li></ol></li></ul><h4 id="1-3-线性数据结构"><a href="#1-3-线性数据结构" class="headerlink" title="1.3 线性数据结构"></a>1.3 线性数据结构</h4><p>常见的线性数据结构有：一维数组，线性表，栈，队列，双队列，串。</p><h5 id="1-3-1-一维数组"><a href="#1-3-1-一维数组" class="headerlink" title="1.3.1 一维数组"></a>1.3.1 一维数组</h5><p>数组是根据下标进行操作的，insert根据下标插入到具体位置，它后面的元素都往后面移动一位。</p><ul><li>插入&#x2F;更新&#x2F;删除效率比较低，而查询效率非常高; 查询效率时间复杂度是1。</li><li>Java中: String [],int [],ArrayList,Vector,CopyOnWriteArrayList等</li></ul><h5 id="1-3-2-线性表"><a href="#1-3-2-线性表" class="headerlink" title="1.3.2 线性表"></a>1.3.2 线性表</h5><p>线性表是<strong>有序</strong>的储存结构、链式的储存结构。链表的物理储存空间是不连续的，链表的每一个节点都知道上一个节点、或者下一个节点是谁，通常用Node表示。<br>常见的方法有：add(index,element),addFirst(element),addLast(element)。getFirst(),getLast(),get(element)等。</p><ul><li>插入效率比较高，插入的时候只需要改变节点的前后节点的连接即可; 而查询效率就比较低。</li><li>Java中: LinkedList，LinkedMap等(两个JDK底层也做了N多优化)</li></ul><h5 id="1-3-3-栈Stack"><a href="#1-3-3-栈Stack" class="headerlink" title="1.3.3 栈Stack"></a>1.3.3 栈Stack</h5><p>栈, 最主要的是要实现先进后出，后进先出的逻辑结构。来保证一些场景对逻辑顺序的要求。<br>常用的方法有push(element)压栈，pop()出栈。</p><ul><li>Java中: java.util.Stack, Jvm里面的线程栈</li></ul><h5 id="1-3-4-队列"><a href="#1-3-4-队列" class="headerlink" title="1.3.4 队列"></a>1.3.4 队列</h5><p>队列是一种特殊的线性数据结构，队列只能允许在队头，队尾进行添加和查询等相关操作。<br>队列又有单项有序队列，双向队列，阻塞队列等。<br>基本操作方法有：add(E e)加入队列，remove(),poll()等方法。</p><ul><li>Java中: 线程池，MQ，连接池等。</li></ul><h5 id="1-3-5-串"><a href="#1-3-5-串" class="headerlink" title="1.3.5 串"></a>1.3.5 串</h5><p>串：也称字符串，是由N个字符组成的优先序列。</p><ul><li>在Java里面就是指String, 而String里面是由chat[]来进行储存(KMP算法)。</li><li>KMP算法: 一种 字符串的查找匹配算法<ul><li>算法关键点: 在字符串比对的时候，主串的比较位置不需要回退(利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间)</li></ul></li></ul><h4 id="1-4-非线性数据结构"><a href="#1-4-非线性数据结构" class="headerlink" title="1.4 非线性数据结构"></a>1.4 非线性数据结构</h4><p>常见的线性数据结构有：多维数组，集合，树，图，散列表(hash)。</p><h5 id="1-4-1-多维数组"><a href="#1-4-1-多维数组" class="headerlink" title="1.4.1 多维数组"></a>1.4.1 多维数组</h5><p>多维数组无非就是String [][],int[][]等</p><ul><li>Java里面很少提供这样的工具类，而java里面tree和图底层的native方法用了多维数组来储存。</li></ul><h5 id="1-4-2-集合"><a href="#1-4-2-集合" class="headerlink" title="1.4.2 集合"></a>1.4.2 集合</h5><ul><li>由一个或多个确定的元素所构成的整体叫做集合。在Java里面可以去广义的去理解为实现了Collection接口的类都叫集合。</li></ul><h5 id="1-4-3-树"><a href="#1-4-3-树" class="headerlink" title="1.4.3 树"></a>1.4.3 树</h5><ol><li>树的特点: 有且仅有一个根节点; 其他结点有且只有一个直接父节点; 可以有任意多个直接子节点</li><li>树的数据结构又分为：<ol><li>自由树&#x2F;普通树：对子节点没有任何约束。</li><li>二叉树：每个节点最多含有两个子节点的树称为二叉树。<ul><li>一般二叉树, 完全二叉树, 满二叉树</li></ul></li><li>二叉搜索树&#x2F;BST：binary search tree,又称二叉排序树、二叉查找树。是有序的。<ul><li>二叉平衡树，AVL树，红黑树</li></ul></li><li>B-tree：又称B树、B-树, 又叫平衡(balance)多路查找树, 每个节点存储M&#x2F;2到M个关键字，所有关键字在整颗树中出现，且只出现一次，非叶子节点可以命中；</li><li>B+tree：又称B+树, 在B树基础上，为叶子节点增加链表指针，所有关键字都在叶子节点中出现(有序)，叶子节点才命中；</li><li>B<em>tree：又称B</em>树, 在B+树基础上，为非叶子节点也增加兄弟链表指针，将节点的最低利用率从1&#x2F;2提高到2&#x2F;3；</li></ol></li><li>红黑树的5条性质：<ul><li>每个结点要么是红的，要么是黑的。</li><li>根结点是黑的。</li><li>每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。</li><li>如果一个结点是红的，那么它的俩个儿子都是黑的。</li><li>对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</li></ul></li><li>B+树的三个特点：<ol><li>关键字数和子树相同<ul><li>在 B+ 树中，节点的关键字代表子树的最大值，因此关键字数等于子树数。</li></ul></li><li>非叶子节点仅用作索引，它的关键字和子节点有重复元素<ul><li>除叶子节点外的所有节点的关键字，都在它的下一级子树中同样存在，最后所有数据都存储在叶子节点中。</li><li>根节点的最大关键字其实就表示整个 B+ 树的最大元素。</li></ul></li><li>叶子节点用指针连在一起<ul><li>叶子节点包含了全部的数据，并且按顺序排列，B+ 树使用一个链表将它们排列起来，这样在查询时效率更快。</li></ul></li></ol></li></ol><h5 id="1-4-4-Hash"><a href="#1-4-4-Hash" class="headerlink" title="1.4.4 Hash"></a>1.4.4 Hash</h5><ul><li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），变换成固定长度的输出，该输出就是散列值。一般通过Hash算法实现。（如：MD5,SHA1,加解密算法等）</li><li>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li><li>Java中的hashCode：<ul><li>默认情况就是native方法通过对象的内存的+对象的值然后通过hash散列算法计算出来个int的数字。最大的特性是：不同的对象，不同的值有可能计算出来的hashCode可能是一样的。</li></ul></li><li>Hash表：<ul><li>Hash表综合了数组和链表两种数据结构。如：HashTable,HashMap。哈希表具有较快（常量级）的查询速度，及相对较快的增删速度，所以很适合在海量数据的环境中使用。一般实现哈希表的方法采用“拉链法”，我们可以理解为“链表的数组”。</li></ul></li><li>需要注意的是，相同的内容算出来的hash一定是一样的。既：幂等性。</li></ul><h5 id="1-4-4-5-图"><a href="#1-4-4-5-图" class="headerlink" title="1.4.4.5 图"></a>1.4.4.5 图</h5><ul><li>图状结构或网状结构：结构中的数据元素之间存在多对多的关系。</li></ul><h3 id="2-时间复杂度与空间复杂度"><a href="#2-时间复杂度与空间复杂度" class="headerlink" title="2. 时间复杂度与空间复杂度"></a>2. 时间复杂度与空间复杂度</h3><p>理解了Java数据结构，还必须要掌握一些常见的基本算法。 理解算法之前必须要先理解的几个算法的概念：</p><ul><li>空间复杂度：一句来理解就是，此算法在规模为n的情况下额外消耗的储存空间。</li><li>时间复杂度：一句来理解就是，此算法在规模为n的情况下，一个算法中的语句执行次数称为语句频度或时间频度。</li><li>稳定性：主要是来描述算法，每次执行完，得到的结果都是一样的，但是可以不同的顺序输入，可能消耗的时间复杂度和空间复杂度不一样。</li></ul><h4 id="2-1-时间复杂度"><a href="#2-1-时间复杂度" class="headerlink" title="2.1 时间复杂度"></a>2.1 时间复杂度</h4><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为<strong>语句频度或时间频度</strong>。记为<strong>T(n)</strong></p><p>在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。</p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)&#x2F;f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)&#x3D;O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称<strong>时间复杂度</strong>。</p><p>有时候，算法中基本操作重复执行的次数还随问题的输入数据集不同而不同，如在冒泡排序中，输入数据有序而无序，其结果是不一样的。此时，我们计算平均值。</p><p>常见的算法的时间 复杂度之间的关系为：<code>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlog n)&lt;O(n2)&lt;O(2n)&lt;O(n!)&lt;O(nn)</code></p><h4 id="2-2-空间复杂度"><a href="#2-2-空间复杂度" class="headerlink" title="2.2 空间复杂度"></a>2.2 空间复杂度</h4><p>空间复杂度：算法所需存储空间的度量，记作：<code>S(n)=O( f(n) )</code>，其中 n 为问题的规模。</p><p>一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。如果额外空间相对于输入数据量来说是个常数，则称此算法是原地工作。</p><p>算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。</p><h3 id="3-算法的基本概念"><a href="#3-算法的基本概念" class="headerlink" title="3.算法的基本概念"></a>3.算法的基本概念</h3><ul><li>算法: 简单来说就是解决问题的步骤。</li><li>算法的五个特征:有穷性，确定性，可行性，有输入，有输出<ol><li>有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</li><li>确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</li><li>可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</li><li>有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</li><li>有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</li></ol></li><li>算法的设计原则：正确性，可读性，健壮性，高效率与低存储量需求<ul><li>描述算法的速度必须要和数据项的个数联系起来。</li><li>算法的存储量，包括： 程序本身所占空间； 输入数据所占空间； 辅助变量所占空间；</li><li>一个算法的效率越高越好，而存储量是越低越好。</li></ul></li></ul><h3 id="4-常用的查找算法"><a href="#4-常用的查找算法" class="headerlink" title="4. 常用的查找算法"></a>4. 常用的查找算法</h3><h4 id="4-1-线性（顺序）查找算法"><a href="#4-1-线性（顺序）查找算法" class="headerlink" title="4.1 线性（顺序）查找算法"></a>4.1 线性（顺序）查找算法</h4><ol><li>使用目标元素与样本数列中第一个元素起依次进行比较</li><li>若目标元素等于样本元素，则表示查找成功</li><li>若目标元素与样本元素比较完毕也不相等，则表示查找失败</li></ol><h4 id="4-2-二分查找算法"><a href="#4-2-二分查找算法" class="headerlink" title="4.2 二分查找算法"></a>4.2 二分查找算法</h4><p>二分查找又称折半查找，优点是比较次数少，查找速度快，平均性能好，占用系统内存较少；其缺点是要求待查表为有序表，且插入删除困难。</p><ul><li>普通循环实现二分查找算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找普通循环实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray 有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span> srcArray[], <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> srcArray.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (key == srcArray[mid]) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> srcArray.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        mid = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二分查找算法如果没有用到递归方法的话，只会影响CPU。对内存模型来说影响不大。时间复杂度log2n，2的开方。空间复杂度是2。一定要牢记这个算法。应用的地方也是非常广泛，平衡树里面大量采用。</p></blockquote><ul><li>递归实现二分查找递归实现算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> srcArray[] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">28</span>,<span class="number">30</span>,<span class="number">32</span>,<span class="number">50</span>,<span class="number">64</span>,<span class="number">78</span>,<span class="number">81</span>,<span class="number">95</span>,<span class="number">101</span>&#125;;</span><br><span class="line">    System.out.println(binSearch(srcArray, <span class="number">0</span>,<span class="number">15</span>,<span class="number">28</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcArray  有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start 数组低地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end   数组高地址下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  查找元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 查找元素不存在返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binSearch</span><span class="params">(<span class="type">int</span> srcArray[], <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end - start) / <span class="number">2</span> + start;</span><br><span class="line">    <span class="keyword">if</span> (srcArray[mid] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, mid + <span class="number">1</span>, end, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; srcArray[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> binSearch(srcArray, start, mid - <span class="number">1</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>递归不光影响的CPU。JVM里面的线程栈空间也会变大。所以当递归的调用链长的时候需要-Xss设置线程栈的大小。</p></blockquote><h3 id="4-常用的排序算法"><a href="#4-常用的排序算法" class="headerlink" title="4. 常用的排序算法"></a>4. 常用的排序算法</h3><ul><li>八大排序算法<ul><li>一、直接插入排序（Insertion Sort）</li><li>二、希尔排序（Shell Sort）</li><li>三、选择排序（Selection Sort）</li><li>四、堆排序（Heap Sort）</li><li>五、冒泡排序（Bubble Sort）</li><li>六、快速排序（Quick Sort）</li><li>七、归并排序（Merging Sort）</li><li>八、基数排序（Radix Sort）</li></ul></li></ul><h4 id="4-1-冒泡排序算法"><a href="#4-1-冒泡排序算法" class="headerlink" title="4.1 冒泡排序算法"></a>4.1 冒泡排序算法</h4><p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><ul><li><p>算法描述：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//声明标志位</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">          arr[j++<span class="number">1</span>] = temp;</span><br><span class="line">          flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//若此轮结束flag还是为true,则证明已经有序</span></span><br><span class="line">      <span class="keyword">if</span>(flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>冒泡排序算法复杂度:</p><ul><li>平均时间复杂度O(n²)，最好情况O(n)，最坏情况O(n²)，空间复杂度O(1)</li><li>冒泡排序是最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近n²&#x2F;2次, 时间复杂度为O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为O(n). 平均来讲, 时间复杂度为O(n²). 由于冒泡排序中只有缓存的temp变量需要内存空间, 因此空间复杂度为常量O(1).</li></ul></li></ul><blockquote><p>Tips:由于冒泡排序只在相邻元素大小不符合要求时才调换他们的位置, 它并不改变相同元素之间的相对顺序, 因此它是稳定的排序算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」常用设计模式</title>
      <link href="/2017/05/30/java-design.html"/>
      <url>/2017/05/30/java-design.html</url>
      
        <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p><span id="more"></span><h3 id="1-常用的设计原则"><a href="#1-常用的设计原则" class="headerlink" title="1.常用的设计原则"></a>1.常用的设计原则</h3><ul><li><strong>开闭原则</strong>：对扩展开放，对修改关闭</li><li><strong>里氏代换原则</strong>：任何父类出现的的地方，子类一定可以出现（多使用继承和多态）</li><li><strong>依赖倒转原则</strong>：尽量多依赖于抽象类或接口而不是具体实现类，对子类具有强制性和规范性</li><li><strong>接口隔离原则</strong>：尽量多依赖小接口而不是大接口</li><li><strong>迪米特法则</strong>（最少知道原则）：一个实体应当少与其他实体之间发生相互作用，使系统功能模块相对独立。高内聚，低耦合。</li><li><strong>合成复用原则</strong>：尽量多使用合成&#x2F;聚合的方式，而不是继承的方式。</li></ul><h3 id="2-设计模式分类"><a href="#2-设计模式分类" class="headerlink" title="2.设计模式分类"></a>2.设计模式分类</h3><h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><ul><li>设计模式是一套被反复使用多数人知晓，经过分类编目，代码设计经验的总结。</li><li>设计模式用来解决某些特定场景下的某一类问题–&gt;通用的解决方案。</li><li>设计模式可以让代码更容易被理解，确保了复用性、可靠性、可扩展性</li></ul><h4 id="2-2-具体分类"><a href="#2-2-具体分类" class="headerlink" title="2.2 具体分类"></a>2.2 具体分类</h4><ol><li><strong>创建型模式</strong>：<em>用于对象创建的过程</em></li></ol><ul><li><strong>单例模式</strong>、<strong>工厂方法模式</strong>、抽象工厂模式、建造者模式(生成器模式)、原型模式</li></ul><ol start="2"><li><strong>结构型模式</strong>：<em>用于把类或对象通过某种形式结合在一起，构成某种复杂或合理的结构</em></li></ol><ul><li>适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式(过滤器&#x2F;标准模式)</li></ul><ol start="3"><li><strong>行为型模式</strong>：<em>用于解决类或对象之间的交互，更合理的优化类或对象之间的关系</em></li></ol><ul><li>责任链模式、命令模式、迭代子模式(迭代器模式)、观察者模式、中介者模式、解析器模式、状态模式、空对象模式、策略模式、<strong>模板模式</strong>、访问者模式、备忘录模式、</li></ul><ol start="4"><li>JEE 设计模式</li></ol><ul><li>数据访问对象模式</li></ul><h3 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3.单例模式（Singleton）"></a>3.单例模式（Singleton）</h3><h4 id="3-1-实现流程："><a href="#3-1-实现流程：" class="headerlink" title="3.1 实现流程："></a>3.1 实现流程：</h4><ol><li>私有的构造方法</li><li>私有的静态的当前类的对象作为属性</li><li>共有的静态方法返回当前对象<h4 id="3-1-实现方式："><a href="#3-1-实现方式：" class="headerlink" title="3.1 实现方式："></a>3.1 实现方式：</h4></li><li>饿汉式：立即加载，对象启动时就加载</li><li>懒汉式：延迟加载，对象什么时候用到时才会加载</li><li>生命周期托管：单例对象交给别人处理</li></ol><h3 id="4-模板模式"><a href="#4-模板模式" class="headerlink" title="4.模板模式"></a>4.模板模式</h3><p>在模板模式中，父抽象类公开几个抽象方法供子类实现。在父抽象类中有另一个方法或几个方法使用抽象方法来实现业务逻辑。</p><ul><li>eg: 对于使用不同的软件，我们只需要从抽象类继承并提供详细的实现,模板模式是一种行为模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Software</span> &#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>&#123;</span><br><span class="line">      initialize();</span><br><span class="line">      start();</span><br><span class="line">      end();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 不同子类以不同方法实现抽象类的的方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Browser</span> <span class="keyword">extends</span> <span class="title class_">Software</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Browser Finished!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Browser Initialized!.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Browser Started.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Editor</span> <span class="keyword">extends</span> <span class="title class_">Software</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Editor Finished!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Editor Initialized!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Editor Started!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Software</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Browser</span>();</span><br><span class="line">      s1.play();</span><br><span class="line">      s1 = <span class="keyword">new</span> <span class="title class_">Editor</span>();</span><br><span class="line">      s1.play();    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-模板方法模式优缺点："><a href="#4-1-模板方法模式优缺点：" class="headerlink" title="4.1 模板方法模式优缺点："></a>4.1 模板方法模式优缺点：</h4><ol><li>优点</li></ol><ul><li>模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码。子类实现算法的某些细节，有助于算法的扩展。通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合“开放-封闭原则”。</li></ul><ol start="2"><li>缺点</li></ol><ul><li>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象。</li></ul><ol start="3"><li>适用场景</li></ol><ul><li>在某些类的算法中，用了相同的方法，造成代码的重复。控制子类扩展，子类必须遵守算法规则。</li></ul><h3 id="5-工厂模式"><a href="#5-工厂模式" class="headerlink" title="5. 工厂模式"></a>5. 工厂模式</h3><ol><li>简单工厂模式：一个工厂方法，依据传入的参数，生成对应的产品对象；</li><li>工厂方法模式：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定；</li><li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。</li></ol><h4 id="5-1-简单工厂模式的实现："><a href="#5-1-简单工厂模式的实现：" class="headerlink" title="5.1 简单工厂模式的实现："></a>5.1 简单工厂模式的实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123; <span class="keyword">void</span> <span class="title function_">whatIm</span><span class="params">()</span>; &#125;</span><br><span class="line">  <span class="comment">// 具体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whatIm</span><span class="params">()</span> &#123; <span class="comment">/*苹果*/</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">whatIm</span><span class="params">()</span> &#123; <span class="comment">/* 梨 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createFruit</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;apple&quot;</span>)) &#123;<span class="comment">//生产苹果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;pear&quot;</span>)) &#123;<span class="comment">//生产梨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line"><span class="type">FruitFactory</span> <span class="variable">mFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FruitFactory</span>();</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple) mFactory.createFruit(<span class="string">&quot;apple&quot;</span>);<span class="comment">//获得苹果</span></span><br><span class="line"><span class="type">Pear</span> <span class="variable">pear</span> <span class="operator">=</span> (Pear) mFactory.createFruit(<span class="string">&quot;pear&quot;</span>);<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure><blockquote><p>简单工厂只适合于产品对象较少，且产品固定的需求</p></blockquote><h4 id="5-2-工厂方法模式实现："><a href="#5-2-工厂方法模式实现：" class="headerlink" title="5.2 工厂方法模式实现："></a>5.2 工厂方法模式实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    Fruit <span class="title function_">createFruit</span><span class="params">()</span>;<span class="comment">//生产水果</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">implements</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PearFactory</span> <span class="keyword">implements</span> <span class="title class_">FruitFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Fruit <span class="title function_">createFruit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 使用</span></span><br><span class="line"><span class="type">AppleFactory</span> <span class="variable">appleFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line"><span class="type">PearFactory</span> <span class="variable">pearFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PearFactory</span>();</span><br><span class="line"><span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> (Apple) appleFactory.createFruit();<span class="comment">//获得苹果</span></span><br><span class="line"><span class="type">Pear</span> <span class="variable">pear</span> <span class="operator">=</span> (Pear) pearFactory.createFruit();<span class="comment">//获得梨</span></span><br></pre></td></tr></table></figure><blockquote><p>工厂方法模式虽然遵循了开闭原则，但如果产品很多的话，需要创建非常多的工厂</p></blockquote><h4 id="5-3-抽象工厂模式实现："><a href="#5-3-抽象工厂模式实现：" class="headerlink" title="5.3 抽象工厂模式实现："></a>5.3 抽象工厂模式实现：</h4><ul><li>抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列；</li><li>eg：假如生产小米手机，小米手机有很多系列，小米note、红米note等；假如小米note生产需要的配件有825的处理器，6英寸屏幕，而红米只需要650的处理器和5寸的屏幕就可以了；用抽象工厂来实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// cpu接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cpu650</span> <span class="keyword">implements</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">/* 625 也厉害 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Cpu825</span> <span class="keyword">implements</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">/* 825 处理更强劲 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 屏幕接口和实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Screen5</span> <span class="keyword">implements</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">size</span><span class="params">()</span> &#123;<span class="comment">/* 5寸 */</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Screen6</span> <span class="keyword">implements</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">size</span><span class="params">()</span> &#123; <span class="comment">/* 6寸 */</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    Cpu <span class="title function_">getCpu</span><span class="params">()</span>;<span class="comment">//使用的cpu</span></span><br><span class="line">    Screen <span class="title function_">getScreen</span><span class="params">()</span>;<span class="comment">//使用的屏幕</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 具体工厂实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cpu</span>.Cpu825();<span class="comment">//高性能处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Screen <span class="title function_">getScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Screen</span>.Screen6();<span class="comment">//6寸大屏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HongMiFactory</span> <span class="keyword">implements</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cpu</span>.Cpu650();<span class="comment">//高效处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Screen <span class="title function_">getScreen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Screen</span>.Screen5();<span class="comment">//小屏手机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；</p></blockquote><h4 id="5-4-三种工厂方式总结："><a href="#5-4-三种工厂方式总结：" class="headerlink" title="5.4 三种工厂方式总结："></a>5.4 三种工厂方式总结：</h4><ol><li>对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；</li><li>抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；</li></ol><h3 id="6-适配器模式（Adapter）"><a href="#6-适配器模式（Adapter）" class="headerlink" title="6.适配器模式（Adapter）"></a>6.适配器模式（Adapter）</h3><ul><li>适配器模式Adapter是结构型模式的一种，分为<strong>类适配器模式</strong>，<strong>对象适配器模式</strong>，<strong>缺省适配器模式</strong>。<ul><li>类的适配器模式把适配的类的API转换成为目标类的API。使用对象继承的方式，是静态的定义方式；</li><li>对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系，而是使用委派关系。一个适配器可以把多种不同的源适配到同一个目标。</li></ul></li></ul><blockquote><p>适配器模式的缺点<br><br>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p></blockquote><h4 id="6-1-缺省适配器模式"><a href="#6-1-缺省适配器模式" class="headerlink" title="6.1 缺省适配器模式"></a>6.1 缺省适配器模式</h4><ul><li>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</li><li>缺省适配模式是一种“平庸”化的适配器模式。(实现类不必实现接口所有方法或留空的方法，可以有选择性了)</li><li>适配器(通常是一个抽象类)添加某些具体实现(需要缺省的方法内部抛出异常)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」网络编程基础</title>
      <link href="/2017/05/22/java-net.html"/>
      <url>/2017/05/22/java-net.html</url>
      
        <content type="html"><![CDATA[<p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。<br>java.net 包中的类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p><span id="more"></span><h3 id="1-网络编程常识"><a href="#1-网络编程常识" class="headerlink" title="1. 网络编程常识"></a>1. 网络编程常识</h3><h4 id="1-1-七层网络模型"><a href="#1-1-七层网络模型" class="headerlink" title="1.1 七层网络模型"></a>1.1 七层网络模型</h4><p>为了保证数据传输的可靠和安全，ISO(国际标准委员会组织)将数据的传递从逻辑上划分为以下7层：<br><br>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><ul><li>当发送数据时，需要按照上述七层模型从上到下层层加包再发送出去；</li><li>当接收数据时，需要按照上述七层模型从下到上层层拆包再显示出来；</li></ul><h4 id="1-2-IP地址"><a href="#1-2-IP地址" class="headerlink" title="1.2 IP地址"></a>1.2 IP地址</h4><ul><li>IP地址：是互联网中的唯一地址标识，也就是根据IP地址可以定位到具体某一台设备，IP地址本质上是32位二进制组成的整数叫做IPv4，当然也有128位二进制组成的整数叫做IPv6，目前主流的还是IPv4。</li><li>日常生活中采用<strong>点分十进制</strong>表示法进行IP地址的描述，也就是将每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。如：192.168.1.1</li></ul><h4 id="1-3-端口号"><a href="#1-3-端口号" class="headerlink" title="1.3 端口号"></a>1.3 端口号</h4><ul><li>根据IP地址可以定位到具体某一台设备，而该设备中启动的进程可能很多，此时可以使用端口号来定位该设备中的具体某一个进程。</li><li>网络编程需要提供：IP地址 和 端口号</li><li>端口号是16位二进制组成的整数，表示范围是：0 ~ 65535，其中0 ~ 1024之间通常被系统占用，因此网络编程需要从1025开始使用。</li></ul><h4 id="1-4-tcp协议与udp协议"><a href="#1-4-tcp协议与udp协议" class="headerlink" title="1.4 tcp协议与udp协议"></a>1.4 tcp协议与udp协议</h4><ul><li>TCP（Transmission Control Protocol，传输控制协议） 是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“握手”才能建立起来。</li><li>UDP（User Data Protocol，用户数据报协议） 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li><li>tcp协议与udp协议比较：</li></ul><table><thead><tr><th>tcp协议</th><th>udp协议</th></tr></thead><tbody><tr><td>传输控制协议，面向连接</td><td>用户数据报协议，非面向连接</td></tr><tr><td>通信过程全程保持连接</td><td>通信过程不需要全程连接</td></tr><tr><td>保证了数据传输的可靠性和有序性</td><td>不保证数据传输的可靠性和有序性</td></tr><tr><td>全双工的字节流的通信方式</td><td>全双工的数据报的通信方式</td></tr><tr><td>服务器的资源消耗多，压力大，效率低</td><td>服务器资源消耗少，压力小，效率高</td></tr></tbody></table><h3 id="2-基于tcp协议的编程模型"><a href="#2-基于tcp协议的编程模型" class="headerlink" title="2. 基于tcp协议的编程模型"></a>2. 基于tcp协议的编程模型</h3><h4 id="2-1-编程模型"><a href="#2-1-编程模型" class="headerlink" title="2.1 编程模型"></a>2.1 编程模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">服务器端                         客户端</span><br><span class="line"></span><br><span class="line">创建监听服务</span><br><span class="line">等待连接    &lt;----建立连接------  连接服务器           </span><br><span class="line">进行通讯    &lt;----进行通讯-----&gt;  进行通讯</span><br><span class="line">关闭连接                        关闭连接</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>服务器：<ol><li>创建ServerSocket类型的对象并提供端口号；</li><li>等待客户端的连接请求，调用accept方法；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li><li>客户端：<ol><li>创建Socket类型的对象并提供服务器的通信地址和端口号；</li><li>使用输入输出流进行通信；</li><li>关闭Socket；</li></ol></li></ul><h4 id="2-2-ServerSocket类和Socket类"><a href="#2-2-ServerSocket类和Socket类" class="headerlink" title="2.2 ServerSocket类和Socket类"></a>2.2 ServerSocket类和Socket类</h4><ul><li>java.net.ServerSocket类主要用于描述服务器套接字信息。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>根据参数指定的端口号来构造对象</td></tr><tr><td>Socket accept()</td><td>监听并接收到此套接字的连接请求</td></tr><tr><td>void close()</td><td>用于关闭套接字</td></tr></tbody></table><ul><li>java.net.Socket类主要用于描述客户端套接字，是两台机器间通信的端点。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>根据指定主机名和端口号来构造对象</td></tr><tr><td>InputStream getInputStream()</td><td>用于获取当前套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>用于获取当前套接字的输出流</td></tr><tr><td>void close()</td><td>用于关闭套接字</td></tr></tbody></table><h3 id="3-客户端与服务端通信演示："><a href="#3-客户端与服务端通信演示：" class="headerlink" title="3.客户端与服务端通信演示："></a>3.客户端与服务端通信演示：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Socket s;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ServerThread</span><span class="params">(Socket s)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 3.使用输入输出流进行通信</span></span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">      <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(s.getOutputStream());</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 实现服务器接收到字符串内容后打印出来</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        <span class="comment">//System.out.println(&quot;服务器接收到的数据是：&quot; + str);</span></span><br><span class="line">        <span class="comment">// 当服务器接收到&quot;bye&quot;后，则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(str)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;客户端&quot;</span> + s.getInetAddress() + <span class="string">&quot;已下线！&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端&quot;</span> + s.getInetAddress() </span><br><span class="line">          + <span class="string">&quot;发来的消息是：&quot;</span> + str);  </span><br><span class="line">        <span class="comment">// 当服务器接收到客户端发来的消息后，向客户端回发消息&quot;I received!&quot;</span></span><br><span class="line">        ps.println(<span class="string">&quot;I received!&quot;</span>);</span><br><span class="line">        <span class="comment">//System.out.println(&quot;服务器发送数据成功！&quot;);</span></span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 4.关闭Socket</span></span><br><span class="line">      ps.close();</span><br><span class="line">      br.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerStringTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建ServerSocket类型的对象并提供端口号</span></span><br><span class="line">      <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">      <span class="comment">// 2.等待客户端的连接请求，调用accept方法</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;等待客户端的连接请求...&quot;</span>);</span><br><span class="line">        <span class="comment">// 当没有客户端连接时，阻塞在accept方法的调用这里</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 获取连接成功的客户端通信地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端&quot;</span> + s.getInetAddress() + <span class="string">&quot;连接成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 当有客户端连接成功后，则启动一个新的线程为之服务</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerThread</span>(s).start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//ss.close();</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStringTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 1.创建Socket类型的对象并提供服务器的通信地址和端口号</span></span><br><span class="line">      <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;XDL-20170621QCO&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;连接服务器成功！&quot;</span>);</span><br><span class="line">      <span class="comment">// 2.使用输入输出流进行通信</span></span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">      <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(s.getOutputStream());</span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 希望客户端连接服务器成功后睡眠10秒再发送数据，测试服务器是否阻塞</span></span><br><span class="line">        <span class="comment">//Thread.sleep(10000);</span></span><br><span class="line">        <span class="comment">// 练习：实现客户端向服务器发送的内容由用户从键盘输入</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要发送的内容：&quot;</span>);</span><br><span class="line">        <span class="comment">//String msg = sc.next(); // 读取字符串内容时，遇到空格停止</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        <span class="comment">// 实现客户端向服务器发送字符串内容&quot;hello&quot;</span></span><br><span class="line">        <span class="comment">//ps.println(&quot;hello&quot;);</span></span><br><span class="line">        ps.println(msg);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端发送数据成功！&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断客户端发送的内容是否为&quot;bye&quot;，若是则聊天结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(msg)) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;聊天结束！&quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现服务器回发消息的接收</span></span><br><span class="line">        <span class="comment">// 当客户端没有发送数据时，服务器会在这里阻塞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端接收到的数据是：&quot;</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 3.关闭Socket</span></span><br><span class="line">      br.close();</span><br><span class="line">      sc.close();</span><br><span class="line">      ps.close();</span><br><span class="line">      s.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-基于udp协议的编程模型"><a href="#4-基于udp协议的编程模型" class="headerlink" title="4. 基于udp协议的编程模型"></a>4. 基于udp协议的编程模型</h3><h4 id="4-1-编程模型"><a href="#4-1-编程模型" class="headerlink" title="4.1 编程模型"></a>4.1 编程模型</h4><ul><li>主机A(接收方):<ol><li>创建DatagramSocket类型的对象，并提供端口号；</li><li>创建DatagramPacket类型的对象，用于接收发来的数据；</li><li>从Socket中接收数据，调用**receive()**方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li><li>主机B(发送方)<ol><li>创建DatagramSocket类型的对象；</li><li>创建DatagramPacket类型的对象，并提供接收方的IP地址和端口号；</li><li>通过Socket发送数据，调用**send()**方法；</li><li>关闭Socket并释放有关的资源；</li></ol></li></ul><h4 id="4-2-DatagramSocket类"><a href="#4-2-DatagramSocket类" class="headerlink" title="4.2 DatagramSocket类"></a>4.2 DatagramSocket类</h4><ul><li>java.net.DatagramSocket类用于描述发送或接受数据报的套接字(邮局点);</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>无参的方式构造对象。</td></tr><tr><td>DatagramSocket(int port)</td><td>根据参数指定的端口号来构造对象。</td></tr><tr><td>void receive(DatagramPacket p)</td><td>用于接收数据并存放到参数指定的变量中。</td></tr><tr><td>void send(DatagramPacket p)</td><td>用于将参数指定的数据发送出去。</td></tr><tr><td>void close()</td><td></td></tr></tbody></table><h4 id="4-3-DatagramPacket类"><a href="#4-3-DatagramPacket类" class="headerlink" title="4.3 DatagramPacket类"></a>4.3 DatagramPacket类</h4><ul><li>java.net.DatagramPacket类用于描述数据报信息(信件)；</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>用于接收数据包并记录到参数变量中；</td></tr><tr><td>DatagramPacket(byte[] buf, int length, InetAddress address, int port)</td><td>用于将参数指定的数据发送到参数指定的位置</td></tr><tr><td>InetAddress getAddress()</td><td>用于获取发送方或接收方的通信地址信息。</td></tr><tr><td>int getPort()</td><td>用于获取发送方或接收方的端口信息。</td></tr><tr><td>int getLength()</td><td>用于获取发送或接收数据的长度。</td></tr></tbody></table><h4 id="4-4-InetAddress类"><a href="#4-4-InetAddress类" class="headerlink" title="4.4 InetAddress类"></a>4.4 InetAddress类</h4><ul><li>java.net.InetAddress类用于描述互联网协议地址。</li></ul><table><thead><tr><th>常用方法</th><th></th></tr></thead><tbody><tr><td>static InetAddress getLocalHost()</td><td>用于获取本地主机的通信地址信息。</td></tr><tr><td>static InetAddress getByName(String host)</td><td>根据参数指定的主机名来获取通信地址。</td></tr><tr><td>String getHostName()</td><td>用于获取通信地址中的主机名信息。</td></tr><tr><td>String getHostAddress()</td><td>用于获取通信地址中的IP地址信息。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」反射机制</title>
      <link href="/2017/05/18/java-reflection.html"/>
      <url>/2017/05/18/java-reflection.html</url>
      
        <content type="html"><![CDATA[<p>反射(Reflection)是Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。<br>多数情况下反射是为了提高程序的灵活性，运行时动态加载需要加载的对象。</p><span id="more"></span><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><p>反射（reflect）就是把java类中的各种成分映射成一个个的Java对象；<br>类是用来描述一组对象，反射机制可以理解为是用来描述一组类</p><p>通俗来讲，反射机制就是用于动态创建对象并且动态调用方法的机制；目前主流的框架底层都采用反射机制实现的。</p><h4 id="1-1-相关类及描述"><a href="#1-1-相关类及描述" class="headerlink" title="1.1 相关类及描述"></a>1.1 相关类及描述</h4><ul><li>Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</li><li>Package：用来描述类所属的包</li><li>Field：用来描述类中的属性</li><li>Method：用来描述类中的方法</li><li>Constructor：用来描述类中的构造方法</li><li>Annotation：用来描述类中的注解</li></ul><h3 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h3><p>java.lang.Class：用来描述类和接口；该类没有公共构造方法，由虚拟机和类加载器自动构造完成</p><h4 id="2-1-获取Class类型对象的三种方式"><a href="#2-1-获取Class类型对象的三种方式" class="headerlink" title="2.1 获取Class类型对象的三种方式"></a>2.1 获取Class类型对象的三种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;包名.类名&quot;</span>);<span class="comment">//用的最多，但可能抛出ClassNotFoundException异常</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> 类名.class;<span class="comment">//任何类都有一个隐含的静态成员变量class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> 对象.getClass();<span class="comment">//Object类中的方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> 包装类.TYPE;<span class="comment">//获取对应基本数据类型的class对象</span></span><br></pre></td></tr></table></figure><h4 id="2-2-常用方法"><a href="#2-2-常用方法" class="headerlink" title="2.2 常用方法"></a>2.2 常用方法</h4><ul><li>static Class&lt;?&gt; forName(String className)<ul><li>用于获取参数指定对应的Class对象并返回</li></ul></li><li>T newInstance()<ul><li>默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li></ul></li><li>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)<ul><li>用于获取此Class对象所表示类型中参数指定的公共构造方法。</li></ul></li><li>Constructor&lt;?&gt;[] getConstructors()<ul><li>用于获取此Class对象所表示类型中所有的公共构造方法</li></ul></li><li>Field getDeclaredField(String name)<ul><li>用于获取此Class对象所表示类中参数指定的单个成员变量信息</li></ul></li><li>Field[] fs &#x3D; getDeclaredFields()<ul><li>用于获取此Class对象所表示类中所有成员变量信息</li></ul></li><li>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)<ul><li>用于获取该Class对象所表示类型中名字为name参数为parameterTypes的指定公共成员方法</li></ul></li><li>Method[] getMethods()<ul><li>用于获取该Class对象表示类中所有公共成员方法。</li></ul></li><li>获取私有相关方法<ul><li>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)；获取该类对象表示的类或接口的指定构造函数(包括私有)</li><li>getDeclaredConstructors()；获取该类对象所表示的类声明的所有构造函数(包括私有)</li><li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 获取一个方法(自己类 公有 私有)</li><li>getDeclaredMethods(); 获取全部的方法(自己类 公有 私有)</li></ul></li></ul><h4 id="2-3-其他方法"><a href="#2-3-其他方法" class="headerlink" title="2.3 其他方法"></a>2.3 其他方法</h4><ol><li>int result &#x3D; getModifiers(); 获取类的修饰符(权限+特征)<ul><li>每一个修饰符 用一个整数来进行表示：0–默认不写，1–public，2–private，4–protected，-static， 16–final，32–synchronized，64volatile，128–transient，256–native，512–interface，1024–abstract</li></ul></li><li>String name &#x3D; getName(); 获取类的全名(包名.类名)</li><li>String name &#x3D; getSimpleName(); 获取类简单名(只有类名 缺少包)</li><li>Package p &#x3D; getPackage(); 获取当前类所属的包<ul><li>p.getName(); 获取包名(Package类中的方法)</li></ul></li><li>Class sclazz &#x3D; getSuperClass(); 获取超类(父类)对应Class</li><li>Class[] classes &#x3D; getInterface(); 获取当前类父亲接口</li><li>Class[] classes &#x3D; getClasses(); 获取类中的内部类</li><li>Object obj &#x3D; <strong>newInstance()</strong>; 默认调用无参数构造方法创建对象，若类中不存在无参数构造方法抛出异常NoSuchMethodException</li><li>Field f &#x3D; getField(“属性名”); 获取类中的属性(公有的 自己类+父类)</li><li>Field[] fs &#x3D; getFields(); 获取类中的全部属性(公有的 自己类+父类)</li><li>getDeclaredField(“属性”); 获取当前类中的属性(公有+私有 自己类)</li><li>Field[] fs &#x3D; getDeclaredFields(); 获取当前类中全部的属性(公有+私有 自己类)</li></ol><h3 id="3-Constructor类"><a href="#3-Constructor类" class="headerlink" title="3. Constructor类"></a>3. Constructor类</h3><p>java.lang.reflect.Constructor类主要用于描述获取到的构造方法信息</p><h4 id="3-1-Constructor类中的常用方法"><a href="#3-1-Constructor类中的常用方法" class="headerlink" title="3.1 Constructor类中的常用方法"></a>3.1 Constructor类中的常用方法</h4><ul><li>T newInstance(Object… initargs)<ul><li>使用此Constructor对象描述的构造方法来构造Class对象代表类型的新实例；该方法的参数用于给新实例中的成员变量进行初始化操作。</li></ul></li></ul><h4 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2 其他方法"></a>3.2 其他方法</h4><ul><li>con.getModifiers();</li><li>con.getName();</li><li>con.getParameterTypes();</li><li>con.getExceptionTypes();</li><li>如何操作构造方法<ul><li>执行一次,创建对象</li><li>Object &#x3D; newInstance(执行构造方法时的所有参数);</li><li>con.setAccessible(true);</li></ul></li></ul><h3 id="4-Field类"><a href="#4-Field类" class="headerlink" title="4. Field类"></a>4. Field类</h3><p>java.lang.reflect.Field类主要用于描述获取到的单个成员变量信息。</p><h4 id="4-1-Field类中的常用方法"><a href="#4-1-Field类中的常用方法" class="headerlink" title="4.1 Field类中的常用方法"></a>4.1 Field类中的常用方法</h4><ul><li>Object get(Object obj)<ul><li>调用该方法的意义就是获取参数对象obj中此Field对象所表示成员变量的数值。</li></ul></li><li>Object set(Object obj, Object value)<ul><li>将参数对象obj中此Field对象表示成员变量的数值修改为参数value的数值。</li></ul></li><li>void setAccessible(boolean flag)<ul><li>当实参传递true时，则反射的对象在使用时应该取消java语言访问检查</li></ul></li></ul><h4 id="4-2-其他方法"><a href="#4-2-其他方法" class="headerlink" title="4.2 其他方法"></a>4.2 其他方法</h4><ol><li>int &#x3D; getModifiers(); 获取属性修饰符(权限+特征)</li><li>Class &#x3D; getType(); 获取属性的类型对应的那个class</li><li>String &#x3D; getName(); 获取属性的名字</li><li>操作属性: set(对象,值); Object &#x3D; get(对象);<ul><li>如果是私有属性不能直接操作的，需设置一个使用权setAccessable(true);准入</li></ul></li></ol><h3 id="5-Method类"><a href="#5-Method类" class="headerlink" title="5. Method类"></a>5. Method类</h3><p>java.lang.reflect.Method类主要用于描述获取到的单个成员方法信息。</p><h4 id="5-1-Method类中的常用方法"><a href="#5-1-Method类中的常用方法" class="headerlink" title="5.1 Method类中的常用方法"></a>5.1 Method类中的常用方法</h4><ul><li>Object invoke(Object obj, Object… args)<ul><li>使用对象obj来调用此Method对象所表示的成员方法，实参传递args。</li></ul></li></ul><h4 id="5-2-其他方法"><a href="#5-2-其他方法" class="headerlink" title="5.2 其他方法"></a>5.2 其他方法</h4><ul><li>int mm &#x3D; m.getModifiers(); 获取方法的修饰符(权限+特征)</li><li>Class mrt &#x3D; m.getReturnType(); 获取返回值数据类型</li><li>String mn &#x3D; m.getName(); 获取方法的名字</li><li>Class[] mpts &#x3D; m.getParameterTypes(); 获取方法参数列表的类型</li><li>Class[] mets &#x3D; m.getExceptionTypes(); 获取方法抛出异常的类型</li><li>如何操作方法</li><li>调用方法   让他执行一次</li><li>Object result &#x3D; invoke(对象,执行方法需要传递的所有参数…);</li><li>若方法是私有的方法  不允许操作</li><li>可以设置setAccessable(true)   设置方法使用权  准入</li></ul><h3 id="6-原始方式与反射方式构造对象实例"><a href="#6-原始方式与反射方式构造对象实例" class="headerlink" title="6. 原始方式与反射方式构造对象实例"></a>6. 原始方式与反射方式构造对象实例</h3><ol><li>使用原始方式来构造对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//1.采用无参的方式构造Person对象并打印</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p); <span class="comment">//null 0</span></span><br><span class="line">  <span class="comment">//2.使用有参方式来构造Person对象</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangfei&quot;</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(p2); <span class="comment">//zhangfei 30</span></span><br><span class="line">  <span class="comment">//3.修改与获取属性(成员变量)，调用get,set方法</span></span><br><span class="line">p2.setName(<span class="string">&quot;guanyu&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改后的姓名是：&quot;</span> + p2.getName()); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用反射机制来构造对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//1.使用获取到的Class对象来构造Person对象并打印</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;myproject.Person&quot;</span>);<span class="comment">//不可省略包名</span></span><br><span class="line">System.out.println(c1.newInstance());<span class="comment">//null 0</span></span><br><span class="line">    <span class="comment">//2.使用有参方式来构造对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;myproject.Person&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">ct2</span> <span class="operator">=</span> c2.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ct2.newInstance(<span class="string">&quot;zhangfei&quot;</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(obj);<span class="comment">//zhangfei 30</span></span><br><span class="line">    <span class="comment">//3.修改与获取属性(成员变量)</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">f2</span> <span class="operator">=</span> c2.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">f2.setAccessible(<span class="literal">true</span>);<span class="comment">//暴力反射，设置使用权</span></span><br><span class="line">f2.set(obj, <span class="string">&quot;guanyu&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改后的姓名是：&quot;</span> + f2.get(obj)); <span class="comment">//guanyu</span></span><br><span class="line">    <span class="comment">//4.获取成员方法getName，使用获取到的成员方法来获取姓名并打印出来</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> c2.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;获取到的姓名是：&quot;</span> + m1.invoke(obj)); <span class="comment">//zhangfei</span></span><br><span class="line">    <span class="comment">//5.成员方法setName，调用getMethod方法来修改姓名并打印出来</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> c2.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> m2.invoke(obj, <span class="string">&quot;guanyu&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;方法调用的返回值是：&quot;</span> + res); <span class="comment">//null</span></span><br><span class="line">System.out.println(<span class="string">&quot;修改后的姓名是：&quot;</span> + m1.invoke(obj)); <span class="comment">//guanyu</span></span><br></pre></td></tr></table></figure><h3 id="7-注解-Annotation"><a href="#7-注解-Annotation" class="headerlink" title="7. 注解(Annotation)"></a>7. 注解(Annotation)</h3><h4 id="7-1-注解相关概念"><a href="#7-1-注解相关概念" class="headerlink" title="7.1 注解相关概念"></a>7.1 注解相关概念</h4><ul><li>注释<ul><li>单行注释：<code>//</code></li><li>多行注释：<code>/*   */</code></li><li>文档注释：<code>/**   */</code></li></ul></li><li>注解的写法<ul><li><code>@XXX [(一些信息)]</code></li></ul></li><li>注解位置<ul><li>类的上面，属性上面，方法上面，构造方法上面，参数前面</li></ul></li><li>注解的作用<ol><li>用来充当注释的作用(仅仅是一个文字的说明)，@Deprecated</li><li>用来做代码的检测(验证)，@Override</li><li>*可以携带一些信息(内容)，文件.properties&#x2F;.xml，注解</li></ol></li><li>常用的注解<ul><li>@Deprecated：用来说明方法是废弃的</li><li>@Override：用来做代码检测   检测此方法是否是一个重写</li><li>@SuppressWarnings(String[])：{“”}，如果数组内的元素只有一个长度，可以省略{}<ul><li>unused：变量定义后未被使用</li><li>serial：类实现了序列化接口  不添加序列化ID号</li><li>rawtypes：集合没有定义泛型</li><li>deprecation：方法以废弃    </li><li>*unchecked：出现了泛型的问题  可以不检测</li><li>all：包含了以上所有(不推荐)</li></ul></li></ul></li><li>注解中可以携带信息，可以不携带；信息不能随意写，信息的类型只能是如下的类型：<ol><li>基本数据类型</li><li>String类型</li><li>枚举类型enum</li><li>注解类型@</li><li>数组类型[]，数组的内部需要是如上的四种类型</li></ol></li><li>注解的分类<ol><li>按运行机制分：源码注解，编译时注解，运行时注解</li><li>按照来源分：来自JDK的注解，来自第三方的注解，自定义注解</li></ol></li></ul><h4 id="7-2-自定义注解类型的语法要求："><a href="#7-2-自定义注解类型的语法要求：" class="headerlink" title="7.2 自定义注解类型的语法要求："></a>7.2 自定义注解类型的语法要求：</h4><ol><li>使用@interface关键字定义注解</li><li>成员以<strong>无参无异常</strong>方式声明</li><li>可以用default为成员指定一个默认值</li><li>成员类型是受限的，合法类型包括原始类型及String,Class,Annotation,Enumeration</li><li>如果注解只有一个成员，则成员名必须取名<strong>value()</strong>,在使用时可以忽略成员名和赋值号(&#x3D;)</li><li>注解类可以没有成员，没有成员的注解称为标识注解</li><li>需要元注解来描述说明<ul><li>@Target：当前注解的放置(CONSTRUCTOR，FIELD，LOCAL_VARIABLE，METHOD，PACKAGE，PARAMETER，TYPE)</li><li>@Retention：当前注解的生命周期作用域(SOURCE，CLASS，RUNTIME)，源代码文件(SOURCE)—&gt;编译—&gt;字节码文件(CLASS)—&gt;加载—&gt;内存执行(RUNTIME)</li><li>@Inherited：允许子类继承</li><li>@Document：当前注解是否能被文档(javadoc)所记录</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description&#123;</span><br><span class="line">    String <span class="title function_">desc</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">author</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-使用自定义注解："><a href="#7-3-使用自定义注解：" class="headerlink" title="7.3 使用自定义注解："></a>7.3 使用自定义注解：</h4><ul><li>@&lt;注解名&gt;(&lt;成员名1&gt;&#x3D;&lt;成员值1&gt;,&lt;成员名2&gt;&#x3D;&lt;成员值2&gt;,…)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description(desc=&quot;I am eyeColor&quot;, author=&quot;Chao&quot;, age=18)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">eyeColor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果自定义注解只有一个value成员，在使用的时候就可以省略方法名，如果方法是两个以上，每一个方法必须写名字</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Description(&quot;I am class annotation&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">implements</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Description(&quot;I am method annotation&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-解析注解"><a href="#7-4-解析注解" class="headerlink" title="7.4 解析注解"></a>7.4 解析注解</h4><p>通过反射获取类、函数或成员上的运行时注解信息，从而实现动态控制程序运行的逻辑。</p><ol><li>使用类加载器加载类<ul><li><code>Class c=Class.forName（&quot;com.ann.test.Child&quot;)</code></li></ul></li><li>找到类上面的注解<ul><li><code>isAnnotationPresent（类类型）</code>：Class对象的方法，判断当前类类型是否存在某个类类型的注解，返回类型为boolean。</li></ul></li><li>拿到注解实例，需要强制类型转换。<ul><li><code>Description d=（Description）c.getAnnotation(Description.class);</code></li></ul></li><li>找到方法上的注解，首先，遍历所有方法，通过方法对象的isAnnotation查看是否有自定义注解。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParseAnn</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[])</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//1. 使用类加载器加载类</span></span><br><span class="line">      Class c=Class.forName（<span class="string">&quot;com.ann.test.Child&quot;</span>)</span><br><span class="line">      <span class="comment">//2. 找到类上面的注解</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> c.isAnnotationPresent(Description.class);</span><br><span class="line">      <span class="keyword">if</span>(isExist)&#123;</span><br><span class="line">        <span class="comment">//3. 拿到注解实例</span></span><br><span class="line">        Description d=（Description）c.getAnnotation(Description.class);</span><br><span class="line">        System.out.println(d.value());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//4.找到方法上的注解</span></span><br><span class="line">      Method[] ms = c.getMethods();</span><br><span class="line">      <span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMExist</span> <span class="operator">=</span> m.isAnnotationPresent(Description.class);</span><br><span class="line">        <span class="keyword">if</span>(isMExist)&#123;</span><br><span class="line">          Description md=（Description）c.getAnnotation(Description.class);</span><br><span class="line">          System.out.println(md.value());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>另一种解析方法上的注解:<ul><li>获取这个方法的所有注解，<code>Annotation [] as=m.getAnnotations();</code>然后遍历该注解，如果遍历的注解是Description类型，则把遍历的注解强转为Description类型，并进行输出value()信息。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Method m:ms)&#123;</span><br><span class="line">  Annotation [] as=m.getAnnotations();</span><br><span class="line">  <span class="keyword">for</span>(Annotation a:as)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Description)&#123;</span><br><span class="line">      <span class="type">Description</span> <span class="variable">md</span> <span class="operator">=</span> (Description)a;</span><br><span class="line">      System.out.println(md.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Inherited:当自定义注解上使用了该注解，如果在父类上标识该注解，解析一个子类，子类也可以获取该注解的信息。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」多线程</title>
      <link href="/2017/05/12/java-thread.html"/>
      <url>/2017/05/12/java-thread.html</url>
      
        <content type="html"><![CDATA[<p>多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。<br>程序的执行其实都是在抢 CPU 的资源，CPU 的执行权。<br>多个进程是在抢这个资源，而其中的某一个进程如果执行路径(线程)比较多，就会有更高的几率抢到 CPU 的执行权。</p><span id="more"></span><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>程序：数据结构 + 算法，主要指存放在硬盘上的可执行文件。</li><li>进程：主要指运行在内存中的程序；每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个<strong>进程包含 n 个线程</strong>；(进程是系统进行资源分配和调度的一个独立单位)。</li><li>线程：线程是进程的一个实体，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小；(线程是 cpu 调度和分派的最小单位)。</li><li>多进程是指操作系统能同时运行多个任务（程序）。</li><li>多线程是指在同一程序(一个进程)中有多个顺序流在执行。</li><li>并行与并发：<ul><li>并行：多个 cpu 实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过 cpu 调度算法，让用户看上去同时执行，实际上从 cpu 操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用 TPS 或者 QPS 来反应这个系统的处理能力。</li></ul></li><li>线程和进程一样分为五个阶段：<strong>创建</strong>、<strong>就绪状态</strong>、<strong>执行状态</strong>、<strong>等待&#x2F;挂起&#x2F;阻塞</strong>、<strong>终止&#x2F;异常&#x2F;消亡</strong>。</li></ul><h3 id="2-实现线程的过程"><a href="#2-实现线程的过程" class="headerlink" title="2. 实现线程的过程"></a>2. 实现线程的过程</h3><p>java.lang.Thread 类主要用于描述线程，Java 虚拟机允许应用程序并发地运行多个执行线程。</p><ul><li>自定义类继承 Thread 类并重写 run 方法，然后创建该类的实例调用 start 方法。</li><li>自定义类实现 Runnable 接口并重写 run 方法，然后创建该类的对象作为实参去构造 Thread 类型的对象，最后使用 Thread 类对象调用 start 方法。</li></ul><h4 id="2-1-实现方式一：继承-Thread-类"><a href="#2-1-实现方式一：继承-Thread-类" class="headerlink" title="2.1 实现方式一：继承 Thread 类"></a>2.1 实现方式一：继承 Thread 类</h4><ol><li>自己描述一个类</li><li>继承父类 Thread</li><li>重写 run 方法</li><li>new 一个线程对象，调用 start()方法，让线程进入就绪状态(需要注意的是 start 方法是 Thread 类中的)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里编写该线程的执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">mt.start();</span><br></pre></td></tr></table></figure><h4 id="2-2-实现方式二：实现-Runnable-接口"><a href="#2-2-实现方式二：实现-Runnable-接口" class="headerlink" title="2.2 实现方式二：实现 Runnable 接口"></a>2.2 实现方式二：实现 Runnable 接口</h4><ol><li>自己描述一个类</li><li>实现一个父接口 Runnable</li><li>重写 run 方法</li><li>new 一个线程对象，new 一个 Thread 并传入线程对象，调用 start()方法，让线程进入就绪状态</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//这里编写该线程的执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt);</span><br><span class="line">td.start();</span><br></pre></td></tr></table></figure><h4 id="2-3-两种方式优缺点："><a href="#2-3-两种方式优缺点：" class="headerlink" title="2.3 两种方式优缺点："></a>2.3 两种方式优缺点：</h4><ul><li>使用继承 Thread 方式代码简单，但 Java 语言只支持单继承，若该类继承 Thread 类后则无法继承其他类</li><li>使用实现 Runnable 的方式代码复杂，但不影响该类继承其他类，并且支持多实现，适合多个相同程序代码的线程去处理同一个资源，增加程序健壮性，代码可以被多个线程共享，代码和数据独立。</li></ul><h3 id="3-线程常用方法"><a href="#3-线程常用方法" class="headerlink" title="3. 线程常用方法"></a>3. 线程常用方法</h3><p><img src="/2017/05/12/java-thread/thread.jpg"></p><h4 id="3-1-相关方法的解析："><a href="#3-1-相关方法的解析：" class="headerlink" title="3.1 相关方法的解析："></a>3.1 相关方法的解析：</h4><ul><li>Thread()：使用无参方式构造对象</li><li>Thread(String name)：根据参数指定的名称来构造对象。</li><li>Thread(Runnable target)：根据参数指定的 Runnable 引用来构造对象。</li><li>Thread(Runnable target, String name)：根据参数指定的 Runnable 引用和名称构造对象。</li><li>void run()：若使用 Runnable 对象作为参数构造的对象来调用该方法，则最终调用 Runnable 对象中的 run 方法，否则该方法啥也不做。</li><li>void <strong>start()<strong>：用于</strong>启动线程</strong>，除了主方法线程外新启动一个线程同时执行，Java 虚拟机会自动调用该线程的 run 方法。</li></ul><ul><li>int getPriority()：用于获取线程的优先级，优先级 1-10</li><li>void setPriority(int)：更改线程的优先级</li></ul><h4 id="3-2-多线程原理分析"><a href="#3-2-多线程原理分析" class="headerlink" title="3.2 多线程原理分析"></a>3.2 多线程原理分析</h4><ol><li>执行 main 方法的线程叫做主线程，而执行 run 方法的线程叫做子线程。</li><li>对于 start 方法之前的代码来说，由主线程执行一次，当 start 方法调用成功之后，线程的个数由 1 个变成了 2 个，主线程继续向下执行，而新启动的线程去执行 run 方法的代码，两个线程各自独立运行。</li><li>当 run 方法执行完毕后，则子线程结束；当 main 方法执行完毕后，则主线程结束。</li><li>两个线程执行的先后次序没有明确的规定，由系统的调度算法决定。</li></ol><h4 id="3-3-线程的编号和名称"><a href="#3-3-线程的编号和名称" class="headerlink" title="3.3 线程的编号和名称"></a>3.3 线程的编号和名称</h4><ul><li>long getId()：用于获取调用对象所表示线程的编号</li><li>String getName()：用于获取调用对象所表示线程的名称</li><li>void setName()：用于设置线程的名称为参数指定的数值</li><li>static Thread currentThread()：获取当前正在执行线程的引用</li></ul><h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h3><ul><li>为了避免重复的创建线程，线程池的出现可以<strong>让线程进行复用</strong>。通俗点讲，当有工作来，就会向线程池拿一个线程，当工作完成后，并不是直接关闭线程，而是将这个线程归还给线程池供其他任务使用。</li><li>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，它就在内部找有无空闲线程，再把任务交给内部某个空闲线程。</li><li>一个线程同时只能执行一个任务，但可以同时向一个线程池提交多个任务<ul><li>接口：Executor,CompletionService,ExecutorService，ScheduledExecutorService</li><li>抽象类：AbstractExecutorService</li><li>实现类：ExecutorCompletionService，ThreadPoolExecutor，ScheduledThreadPoolExecutor</li></ul></li><li>创建线程的第三种方式是实现 Callable 接口，主要用于线程池</li></ul><h3 id="5-线程的主要状态"><a href="#5-线程的主要状态" class="headerlink" title="5. 线程的主要状态"></a>5. 线程的主要状态</h3><p><img src="/2017/05/12/java-thread/threadLife.jpg"></p><ol><li>新建状态：使用 new 关键字创建线程后进入状态，此时线程还没有开始执行</li><li>就绪状态：调用 start()进入的状态，此时线程还是没有开始执行</li><li>运行状态：使用线程调度器调用该线程后进入的状态(获得 CPU 执行权)，此时线程开始执行，当线程的时间片执行完毕后若没有完成就回到就绪状态，若任务完成进入消亡状态</li><li>消亡状态：当线程的任务执行完成之后进入的状态，此时线程已经终止</li><li>阻塞状态：当线程执行过程中发生了阻塞事件进入的状态，阻塞解除后再回到就绪状态</li></ol><h4 id="5-1-线程的休眠"><a href="#5-1-线程的休眠" class="headerlink" title="5.1 线程的休眠"></a>5.1 线程的休眠</h4><ul><li><strong>终止线程</strong>：通常使用退出标识，使线程正常退出，也就是当 run() 方法完成后线程终止。</li><li>static void **yield()**：当线程让出处理器(离开 Running 状态)，使用当前线程进入 Runnable 状态等待。</li><li>static void **sleep(times)**：使当前线程从 Running 放弃处理器进入 Block 状态，休眠 times 毫秒，再返回到 Runnable 如果其他线程打断当前线程的 Block(sleep)，就会发生 InterruptException。</li></ul><h4 id="5-1-线程的等待"><a href="#5-1-线程的等待" class="headerlink" title="5.1 线程的等待"></a>5.1 线程的等待</h4><ul><li>void **join()**：等待该线程终止，让多个线程同步执行，变成单个线程</li><li>void **join(long millis)**：表示等待参数指定的毫秒数</li><li><strong>对象.wait()</strong> 和 **对象.notify()&#x2F;notifyAll()**可以让线程的状态来回切换</li><li>sleep()和 wait()的区别：</li></ul><table><thead><tr><th>sleep()和 wait()的区别</th><th>sleep()</th><th>wait()</th></tr></thead><tbody><tr><td>1.类</td><td>Thread 类</td><td>Object 类</td></tr><tr><td>2.调用</td><td>静态 类名.</td><td>对象.</td></tr><tr><td>3.理解</td><td>调用位置的线程等待</td><td>对象调用，访问对象的其他线程等待</td></tr><tr><td>4.唤醒</td><td>不需要唤醒</td><td>需要其他对象调用 notify 唤醒</td></tr><tr><td>5.锁</td><td>不会释放锁</td><td>等待后会释放锁</td></tr></tbody></table><h4 id="5-2-守护线程"><a href="#5-2-守护线程" class="headerlink" title="5.2 守护线程"></a>5.2 守护线程</h4><ul><li>boolean **isDeamon()**：用于判断是否为守护线程</li><li>void **setDeamon(boolean on)**：用于设置线程为守护线程</li><li>Java 线程有两类：<ul><li>用户线程：运行在前台，执行具体任务；程序的主线程、连接网络的子线程等都是用户线程</li><li>守护线程：运行在后台，为其他前台线程服务</li></ul></li><li>守护线程特点：<ul><li><strong>一旦所有线程都结束运行，守护线程会随 JVM 一起结束工作</strong></li></ul></li><li>守护线程应用：<ul><li>数据库连接池中检测的线路，JVM 虚拟机启动后的监测线程；最常见的是垃圾回收线程。</li></ul></li><li>设置守护线程：<ul><li>可以通过调用 Thread 类的 setDeamon(true)方法来设置当前的线程为守护线程</li></ul></li></ul><h3 id="6-线程的同步机制"><a href="#6-线程的同步机制" class="headerlink" title="6. 线程的同步机制"></a>6. 线程的同步机制</h3><ul><li><p>条件争用：当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏(corrupted)，这种现象称为争用条件。</p></li><li><p>当多个线程同时访问同一种共享资源时，可能会造成数据的覆盖等不一致性问题，此时就需要对多个线程之间进行通信和协调，该机制就叫做<strong>线程的同步机制</strong>。</p></li><li><p>Java 提供了一种<strong>内置的锁机制</strong>来支持<strong>原子性</strong>，使用<strong>synchronized</strong>关键字来保证线程执行操作的原子性，叫做<strong>对象&#x2F;同步锁机制</strong>。</p></li><li><p>特征修饰符 synchronized：表示同步，一个时间点只有一个线程访问</p></li><li><p>线程安全锁：两种形式是（锁定的永远是对象）</p><ol><li>使用同步代码块的方式，将 synchronized 关键字放在方法体内部</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">    <span class="comment">//需同步执行(锁定)的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用同步方法的方式处理，直接使用 synchronized 关键字修饰整个方法，锁定的是调用方法的那个对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 synchronized 保证线程同步时应当注意：</p><ol><li>多个需要同步的线程在访问该同步块时，看到的应该时同一个锁对象引用</li><li>在使用同步块时应当尽量减少同步范围以提高并发的执行效率</li></ol></li></ul><blockquote><ol><li>无论 synchronized 关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li><li>每个对象只有一个锁（lock）与之相关联。</li><li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li></ol></blockquote><h3 id="7-线程的死锁"><a href="#7-线程的死锁" class="headerlink" title="7. 线程的死锁"></a>7. 线程的死锁</h3><p>Java 线程死锁是一个经典的多线程问题，因为不同的线程都在等待那些根本不可能被释放的锁，从而导致所有的工作都无法完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**当两个线程或多个线程之间相互锁定时就形成了死锁**/</span></span><br><span class="line"><span class="comment">//线程一：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(a) &#123; <span class="comment">//表示:持有对象锁a,等待对象锁b</span></span><br><span class="line">        <span class="keyword">synchronized</span>(b) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程二：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(b) &#123; <span class="comment">//表示:持有对象锁b,等待对象锁a</span></span><br><span class="line">        <span class="keyword">synchronized</span>(a) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：在以后的开发中尽量不要使用同步代码块的嵌套结构。</span></span><br></pre></td></tr></table></figure><ul><li>产生死锁的必要条件：a.互斥条件、b.不可抢占条件、c.占有且申请条件、d.循环等待条件。</li><li>隐性死锁：隐性死锁由于不规范的编程方式引起，但不一定每次测试运行时都会出现程序死锁的情形。由于这个原因，一些隐性死锁可能要到应用正式发布之后才会被发现，因此它的危害性比普通死锁更大。</li><li>两种导致隐性死锁的情况：加锁次序和占有并等待。<ul><li>加锁次序：当多个并发的线程分别试图同时占有两个锁时，会出现加锁次序冲突的情形。如果一个线程占有了另一个线程必需的锁，就有可能出现死锁。</li><li>占有并等待：如果一个线程获得了一个锁之后还要等待来自另一个线程的通知，可能出现另一种隐性死锁。</li></ul></li></ul><h4 id="7-1-死锁的避免"><a href="#7-1-死锁的避免" class="headerlink" title="7.1 死锁的避免"></a>7.1 死锁的避免</h4><ul><li>避免死锁的原则：顺序上锁，反向解锁，不要回头</li><li>静态策略：使产生死锁的四个必要条件不能同时具备，从而对进程申请资源的活动加以限制，以保证死锁不会发生。</li><li>动态策略：不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。具体策略有：<strong>安全序列</strong>和<strong>银行家算法</strong>。</li></ul><h3 id="8-内存可见性"><a href="#8-内存可见性" class="headerlink" title="8.内存可见性"></a>8.内存可见性</h3><h4 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1 基本概念"></a>8.1 基本概念</h4><ul><li>可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到</li><li>共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量</li><li>Java 内存模型(JMM)：<ul><li>Java Memory Model 描述了 Java 程序中各种变量(线程共享变量)的访问规则，以及在 JVM 中将变量存储到内存中和从内存中读取变量这样的底层细节。</li><li>所有的变量都存储在主内存中</li><li>每个线程都有自己的独立的工作内存，里面保存该线程使用到的变量的副本(来自主内存的拷贝)</li></ul></li><li>Java 内存模型规定：<ul><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写。</li><li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</li></ul></li><li>要实现共享变量的可见性，必须保证两点：<ul><li>线程修改后的共享变量值能够及时从工作内存中刷新到主内存中</li><li>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中。</li></ul></li><li>Java<strong>语言层面</strong>支持的可见性实现方式：Synchronized，volatile</li></ul><h4 id="8-2-Synchronized-实现可见性"><a href="#8-2-Synchronized-实现可见性" class="headerlink" title="8.2 Synchronized 实现可见性"></a>8.2 Synchronized 实现可见性</h4><ul><li>Synchronized 能够实现：原子性(同步)、可见性</li><li>JMM 关于 synchronized 的两条规定：<ul><li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li><li>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li></ul></li><li>线程执行互斥代码的过程：<ol><li>获得互斥锁</li><li>清空工作内存</li><li>从主内存拷贝变量的最新副本到工作内存</li><li>执行代码</li><li>将更改后的共享变量的值刷新到主内存</li><li>释放互斥锁</li></ol></li><li>重排序：代码的书写顺序与实际的执行顺序不同，指令重排序是编译器或处理器为了性能而做的优化<ol><li>编译器优化重排序（编译器处理）</li><li>指令级并行重排序（处理器优化）</li><li>内存系统的重排序（处理器读写缓存的优化）</li></ol></li><li>as-is-serial:无论如何重排序，程序执行的结果应该与代码的顺序执行结果一致</li><li>单线程中重排序不会带来内存可见性问题</li><li>多线程中程序交错执行时，重排序可能造成内存可见性问题</li></ul><table><thead><tr><th>不可见的原因</th><th>syschronized 解决方案</th></tr></thead><tbody><tr><td>1.线程的交叉执行</td><td>原子性</td></tr><tr><td>2.重排序结合线程交叉执行</td><td>原子性</td></tr><tr><td>3.共享变量未及时更新</td><td>可见性</td></tr></tbody></table><h4 id="8-3-volatile-实现可见性"><a href="#8-3-volatile-实现可见性" class="headerlink" title="8.3 volatile 实现可见性"></a>8.3 volatile 实现可见性</h4><ul><li>深入来说：通过加入内存屏障和禁止重排序优化来实现的。<ul><li>对 volatile 变量执行写操作时，会在写操作后加入一条 store 屏蔽指令</li><li>对 volatile 变量执行读操作时，会在读操作前加入一条 load 屏蔽指令</li></ul></li><li>通俗地讲：volatile 变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。</li><li>线程<strong>写</strong>volatile 变量的过程：<ol><li>改变线程工作内存中 volatile 变量副本的值</li><li>将改变后的副本的值从工作内存刷新到主内存</li></ol></li><li>线程<strong>读</strong>volatile 变量的过程：<ol><li>从主内存中读取 volatile 变量的最新值到线程的工作内存中</li><li>从工作内存中读取 volatile 变量的副本</li></ol></li><li>volatile 不能保证 volatile 变量复合操作的原子性</li><li>volatile 适用场景：<ol><li>对变量的写操作不依赖其当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol></li></ul><h4 id="8-4-Synchronized-和-volatile-比较"><a href="#8-4-Synchronized-和-volatile-比较" class="headerlink" title="8.4 Synchronized 和 volatile 比较"></a>8.4 Synchronized 和 volatile 比较</h4><ul><li>volatile 不需要加锁，比 synchronized 更轻量级，不会阻塞线程；</li><li>从内存可见性角度讲，volatile 读相当于加锁，volatile 写相当于解锁</li><li>synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性</li><li>volatile 没有 synchronized 使用广泛。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」IO机制</title>
      <link href="/2017/05/05/java-io.html"/>
      <url>/2017/05/05/java-io.html</url>
      
        <content type="html"><![CDATA[<p>输入输出（I&#x2F;O）是指程序与外部设备或其他计算机进行交互的操作。几乎所有的程序都具有输入与输出操作，Java把这些输入与输出操作用流来实现，通过统一的接口来表示，从而使程序设计更为简单。</p><span id="more"></span><h3 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h3><ul><li>File与真实硬盘中的文件或文件夹  不是一个东西<ul><li>File是在内存中的一个对象&lt;—映射—&gt;硬盘上的文件或文件夹</li></ul></li><li>java.io.File类用于文件或目录信息(名称、大小等)的抽象表示方式，不能对文件内容进行访问。</li><li>File类中的常用的方法<ul><li>canRead()，canWrite()，isHidden()，isFile()，isDirectory()</li><li>length()，获取文件中字节的个数</li><li>lastModified()，获取文件最后的修改时间—&gt;毫秒值</li><li>*String path &#x3D; getAbsolutePath()，获取文件的绝对路径   D:&#x2F;&#x2F;test&#x2F;&#x2F;Test.txt<ul><li>绝对路径&lt;—-&gt;相对路径</li><li>绝对路径可以通过完整的字符串，定位盘符，文件夹，文件</li><li>相对路径没有盘符的写法，当前工程(项目)所在的位置找寻</li></ul></li><li>String name &#x3D; getName()，获取文件的名字    Test.txt</li><li>*boolean &#x3D; **createNewFile()**，创建新的文件</li><li>*boolean &#x3D; <strong>mkdir</strong> ，创建新的文件夹  外层没有 不能创建</li><li>*boolean &#x3D; <strong>mkdirs</strong>，创建新的文件夹  外层没有 可以自动创建</li><li>String pname &#x3D; getParent()，获取当前file的父亲file名字</li><li>*File file &#x3D; getParentFile()，获取当前file的父亲file对象</li><li>String[] names &#x3D; list()，获取当前file的所有儿子名字</li><li>*File[] files &#x3D; listFiles()，获取当前file的所有儿子对象</li><li>*boolean &#x3D; delete()，删除文件或空的文件夹  不能删除带元素的文件夹</li></ul></li><li>文件夹的路径(找父目录)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找当前file的所有父目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\bbb\\inner\\InnerTest.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">pfile</span> <span class="operator">=</span> file.getParentFile();</span><br><span class="line"><span class="keyword">while</span>(pfile!=<span class="literal">null</span>)&#123;</span><br><span class="line">    System.out.println(pfile.getAbsolutePath());</span><br><span class="line">    pfile = pfile.getParentFile();<span class="comment">//再找一遍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件夹的遍历—-需要一个递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法  用来展示(遍历)文件夹,参数--&gt;file(代表文件或文件夹)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showFile</span><span class="params">(File file)</span>&#123;</span><br><span class="line">    <span class="comment">//获取file的子元素</span></span><br><span class="line">    <span class="comment">//files==null是个文件</span></span><br><span class="line">    <span class="comment">//files!=null是个文件夹</span></span><br><span class="line">    <span class="comment">//files.length!=0是一个带元素的文件夹</span></span><br><span class="line">    File[] files = file.listFiles();<span class="comment">//test文件夹所有子元素</span></span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="literal">null</span> &amp;&amp; files.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">            <span class="built_in">this</span>.showFile(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//做自己的显示(file是文件或file是一个空的文件夹)</span></span><br><span class="line">    System.out.println(file.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件夹的删除—-需要一个递归</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法 删除文件夹,参数 file</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteFile</span><span class="params">(File file)</span>&#123;</span><br><span class="line">    <span class="comment">//判断file不是空文件夹</span></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">if</span>(files!=<span class="literal">null</span> &amp;&amp; files.length!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(File f:files)&#123;</span><br><span class="line">            <span class="built_in">this</span>.deleteFile(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除file (file是个文件或file是一个空文件夹)</span></span><br><span class="line">    file.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-IO流"><a href="#2-IO流" class="headerlink" title="2. IO流"></a>2. IO流</h3><ul><li>流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 </li><li>流的分类:<ul><li>根据处理数据类型的不同分为：字符流和字节流</li><li>根据数据流向不同分为：输入流in(读取)和输出流out(写入)</li><li>操作的目标来区分:<ul><li>文件流，数组流，字符串流，数据流，对象流，网络流…</li></ul></li></ul></li><li>IO流的框架结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">|——IO流</span><br><span class="line">    |————字节流</span><br><span class="line">        |————InputStream</span><br><span class="line">            |————FileInputStream</span><br><span class="line">            |————DataInputStream</span><br><span class="line">            |————ObjectInputStream</span><br><span class="line">        |————OutputStream</span><br><span class="line">            |————FileOutputStream</span><br><span class="line">            |————DataOutputStream</span><br><span class="line">            |————ObjectOutputStream</span><br><span class="line">            |————PrintStream</span><br><span class="line">    |————字符流</span><br><span class="line">        |————Reader</span><br><span class="line">            |————BufferedReader</span><br><span class="line">            |————InputStreamReader</span><br><span class="line">        |————Writer</span><br><span class="line">            |————BufferedWriter</span><br><span class="line">            |————OutputStreamWriter</span><br></pre></td></tr></table></figure><h3 id="3-文件流"><a href="#3-文件流" class="headerlink" title="3. 文件流"></a>3. 文件流</h3><p>读取文件中的信息in，将信息写入文件中out；文件流按照读取或写入的单位(字节数)大小来区分</p><ul><li>字节型文件流(1字节)：FileInputStream&#x2F;FileOutputStream</li><li>字符型文件流(2字节–1字符)：FileReader&#x2F;FileWriter</li><li>字节流和字符流的区别：<ul><li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li><li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li></ul></li><li>结论：只要是处理<strong>纯文本</strong>数据，就优先考虑使用<strong>字符流</strong>。 除此之外都使用<strong>字节流</strong>。</li><li>输入流和输出流<ul><li>对输入流只能进行<strong>读</strong>操作，对输出流只能进行<strong>写</strong>操作。</li></ul></li></ul><h3 id="4-字节型文件流"><a href="#4-字节型文件流" class="headerlink" title="4. 字节型文件流"></a>4. 字节型文件流</h3><h4 id="4-1-字节型文件输入流FileInputStream-读"><a href="#4-1-字节型文件输入流FileInputStream-读" class="headerlink" title="4.1 字节型文件输入流FileInputStream(读)"></a>4.1 字节型文件输入流FileInputStream(读)</h4><ul><li>FileInputStream类在java.io包，继承自InputStream类(字节型输入流的父类)。</li><li>创建对象<ul><li>调用一个带File类型的构造方法</li><li>调用一个带String类型的构造方法</li></ul></li><li>常用方法<ul><li>int code &#x3D; read();    每次从流管道中读取一个字节，返回字节的code码</li><li>*int count &#x3D; read(byte[] )  每次从流管道中读取若干个字节，存入数组内  返回有效元素个数</li><li>int count &#x3D; available();   返回流管道中还有多少缓存的字节数</li><li>skip(long n);跳过几个字节  读取<ul><li>多线程—&gt;利用几个线程同时读取文件</li></ul></li><li>*close()    将流管道关闭—必须要做,最好放在finally里<ul><li>注意代码的健壮性，判断严谨（eg:非空判断）</li></ul></li></ul></li></ul><h4 id="4-2-字节型文件输出流FileOutputStream-写"><a href="#4-2-字节型文件输出流FileOutputStream-写" class="headerlink" title="4.2 字节型文件输出流FileOutputStream(写)"></a>4.2 字节型文件输出流FileOutputStream(写)</h4><ul><li>FileOutputStream类在java.io包，继承自OutputStream类(所有字节型输出流的父类)。</li><li>创建对象<ul><li>调用一个带File参数，还有File boolean重载</li><li>调用一个带String参数，还有String boolean重载</li><li>eg: new FileOutputStream(“D:&#x2F;&#x2F;test&#x2F;&#x2F;bbb.txt”, true)&#x2F;&#x2F;第二个参控制每次写入追加还是重载</li></ul></li><li>常用方法<ul><li>write(int code);  将给定code对应的字符写入文件   ‘&#x3D;’</li><li>write(byte[]);  将数组中的全部字节写入文件   getByte()</li><li>write(byte[] b, int off, int len);</li><li>flush();    将管道内的字节推入(刷新)文件</li><li>close();    注意在finally中关闭</li></ul></li></ul><blockquote><ul><li>创建的是文件输入流，若文件路径有问题，则抛出异常  FileNotFoundException</li><li>创建的是文件输出流，若文件路径有问题，则直接帮我们创建一个新的文件</li></ul></blockquote><ul><li>设计一个文件复制的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File file, String path)</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建输入流读取信息</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">//创建一个新的File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path +<span class="string">&quot;\\&quot;</span>+ file.getName());<span class="comment">//&quot;E:\\test\\test.txt&quot;</span></span><br><span class="line">        <span class="comment">//创建一个输出流</span></span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(newFile);</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//通常1kb-8kb之间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> fis.read(b);</span><br><span class="line">        <span class="keyword">while</span>(count != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(b, <span class="number">0</span>, count);<span class="comment">//将读取到的有效字节写入</span></span><br><span class="line">            fos.flush();</span><br><span class="line">            count = fis.read(b);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;复制完毕！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fis!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; fis.close(); &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;fos.close();&#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-字符型文件流"><a href="#5-字符型文件流" class="headerlink" title="5. 字符型文件流"></a>5. 字符型文件流</h3><p>FileReader&#x2F;FileWriter：只能操作纯文本的文件 .txt &#x2F; .properties</p><h4 id="5-1-字符型文件输入流FileReader-读"><a href="#5-1-字符型文件输入流FileReader-读" class="headerlink" title="5.1 字符型文件输入流FileReader(读)"></a>5.1 字符型文件输入流FileReader(读)</h4><ul><li>FileReader类在java.io包，继承自InputStreamReader，Reader</li><li>创建对象<ul><li>调用一个带File类型的构造方法</li><li>调用一个带String类型的构造方法</li></ul></li><li>常用方法<ul><li>read()</li><li>read(char[])</li><li>close()</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F://test//Test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">    <span class="comment">// int code = fr.read();</span></span><br><span class="line">    <span class="comment">// System.out.println(code);</span></span><br><span class="line">    <span class="type">char</span>[] c = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> fr.read(c);</span><br><span class="line">    <span class="keyword">while</span>(count!=-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(c, <span class="number">0</span>, count));</span><br><span class="line">        count = fr.read(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-字符型文件输出流FileWriter-写"><a href="#5-2-字符型文件输出流FileWriter-写" class="headerlink" title="5.2 字符型文件输出流FileWriter(写)"></a>5.2 字符型文件输出流FileWriter(写)</h4><ul><li>FileWriter类在java.io包，继承自OutputStreamWriter，Writer</li><li>构造方法<ul><li>带file参数，带file,boolean参数</li><li>带String参数，带String,boolean参数</li></ul></li><li>常用方法<ul><li>write(int)</li><li>write(char[])</li><li>write(string)</li><li>flush()，close()</li></ul></li></ul><h3 id="6-缓冲流"><a href="#6-缓冲流" class="headerlink" title="6. *缓冲流"></a>6. *缓冲流</h3><ul><li>缓冲流,也叫高效流，是对4个基本的File…流的增强，所以也是4个流，按照数据类型分类：<ul><li>字节缓冲流：BufferedInputStream，BufferedOutputStream </li><li>字符缓冲流：BufferedReader，BufferedWriter</li></ul></li><li>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li><li>缓冲流读写方法与基本的流是一致</li></ul><h4 id="6-1-字节缓冲流"><a href="#6-1-字节缓冲流" class="headerlink" title="6.1 字节缓冲流"></a>6.1 字节缓冲流</h4><ul><li>BufferedInputStream，BufferedOutputStream</li><li>构造方法<ul><li>public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。 </li><li>public BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="6-2-字符缓冲流"><a href="#6-2-字符缓冲流" class="headerlink" title="6.2 字符缓冲流"></a>6.2 字符缓冲流</h4><ul><li>BufferedReader，BufferedWriter</li><li>构造方法<ul><li>public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。 </li><li>public BufferedWriter(Writer out)： 创建一个新的缓冲输出流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</li><li>特有方法: <ul><li>BufferedReader：public String readLine(): 读一行文字。 </li><li>BufferedWriter：public void newLine(): 写一行行分隔符,由系统属性定义符号。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个方法，用来用户登录认证</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;F://test//User.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//User.txt每行存储格式：张三-123</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> br.readLine();<span class="comment">//user表示一行记录，记录账号密码</span></span><br><span class="line">        <span class="keyword">while</span>(user!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//将user信息拆分，分别与参数比较</span></span><br><span class="line">            String[] value = user.split(<span class="string">&quot;-&quot;</span>);<span class="comment">//value[0]账号，value[1]密码</span></span><br><span class="line">            System.out.println(value[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(value[<span class="number">0</span>].equals(username)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(value[<span class="number">1</span>].equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            user = br.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;账号或密码错误！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>readLine方法演示:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;F://test//User.txt&quot;, true));</span><br><span class="line">    bw.newLine();</span><br><span class="line">    bw.write(&quot;java-888&quot;);</span><br><span class="line">    bw.flush();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-转换流"><a href="#7-转换流" class="headerlink" title="7. 转换流"></a>7. 转换流</h3><h4 id="7-1-字符编码"><a href="#7-1-字符编码" class="headerlink" title="7.1 字符编码"></a>7.1 字符编码</h4><ul><li>字符编码Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。</li><li>字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</li><li>常见字符集:<ul><li>ASCII字符集 ：<ul><li>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）</li></ul></li><li>ISO-8859-1字符集：<ul><li>拉丁码表，别名Latin-1，用于显示欧洲使用的语言；ISO-8859-1使用单字节编码，兼容ASCII编码。</li></ul></li><li>GBxxx字符集：<ul><li>GB就是国标的意思，是为了显示中文而设计的一套字符集。</li><li>GB2312（简体中文码表），GBK（最常用的中文码表），GB18030（最新的中文码表）</li></ul></li><li>Unicode字符集 ：<ul><li>Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。</li><li>UTF-8、UTF-16和UTF-32；最为常用的UTF-8编码。</li></ul></li></ul></li><li>编码引出的问题<ul><li>在IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。</li></ul></li></ul><h4 id="7-2-InputStreamReader类"><a href="#7-2-InputStreamReader类" class="headerlink" title="7.2 InputStreamReader类"></a>7.2 InputStreamReader类</h4><p>转换流java.io.InputStreamReader，是Reader的子类，是从<strong>字节流到字符流</strong>的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><ul><li>构造方法<ul><li>InputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。 </li><li>InputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>指定编码读取:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderDemo2</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 定义文件路径,文件为gbk编码</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\file_gbk.txt&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">       <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileName));</span><br><span class="line">    <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">       <span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FileName) , <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="comment">// 定义变量,保存字符</span></span><br><span class="line">       <span class="type">int</span> read;</span><br><span class="line">    <span class="comment">// 使用默认编码字符流读取,乱码</span></span><br><span class="line">       <span class="keyword">while</span> ((read = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print((<span class="type">char</span>)read); <span class="comment">// ��Һ�</span></span><br><span class="line">      &#125;</span><br><span class="line">       isr.close();</span><br><span class="line">    <span class="comment">// 使用指定编码字符流读取,正常解析</span></span><br><span class="line">       <span class="keyword">while</span> ((read = isr2.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">           System.out.print((<span class="type">char</span>)read);<span class="comment">// 大家好</span></span><br><span class="line">      &#125;</span><br><span class="line">       isr2.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-OutputStreamWriter类"><a href="#7-3-OutputStreamWriter类" class="headerlink" title="7.3 OutputStreamWriter类"></a>7.3 OutputStreamWriter类</h4><p>转换流java.io.OutputStreamWriter ，是Writer的子类，是从<strong>字符流到字节流</strong>的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</p><ul><li>构造方法<ul><li>OutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。 </li><li>OutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>指定编码写出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 定义文件路径</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">FileName</span> <span class="operator">=</span> <span class="string">&quot;E:\\out.txt&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,默认UTF8编码</span></span><br><span class="line">       <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName));</span><br><span class="line">       <span class="comment">// 写出数据</span></span><br><span class="line">    osw.write(<span class="string">&quot;你好&quot;</span>); <span class="comment">// 保存为6个字节</span></span><br><span class="line">       osw.close();</span><br><span class="line"><span class="comment">// 定义文件路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">FileName2</span> <span class="operator">=</span> <span class="string">&quot;E:\\out2.txt&quot;</span>;</span><br><span class="line">    <span class="comment">// 创建流对象,指定GBK编码</span></span><br><span class="line">       <span class="type">OutputStreamWriter</span> <span class="variable">osw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(FileName2),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">       <span class="comment">// 写出数据</span></span><br><span class="line">    osw2.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">// 保存为4个字节</span></span><br><span class="line">       osw2.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-对象流"><a href="#8-对象流" class="headerlink" title="8. 对象流"></a>8. 对象流</h3><ul><li>对象序列化和反序列化<ul><li>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。 </li><li>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象</li><li>简单来讲<ul><li>对象的序列化指的是：将一个完整的对象 拆分成字节碎片 记录在文件中</li><li>对象的反序列化指的是：将文件中记录的对象随便 反过来组合成一个完整的对象</li><li>如果想要将对象序列化到文件中：需要让对象实现Serializable接口，是一个示意性接口；<br>  如果想要将对象反序列化：需要给对象提供一个序列化的版本号，<code>private long serialVersionUID = 任意L</code>;</li></ul></li></ul></li></ul><h3 id="8-1-ObjectOutputStream类"><a href="#8-1-ObjectOutputStream类" class="headerlink" title="8.1 ObjectOutputStream类"></a>8.1 ObjectOutputStream类</h3><ul><li>java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</li><li>构造方法<ul><li>public ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br></pre></td></tr></table></figure><ul><li>序列化操作<ol><li>一个对象要想序列化，必须满足两个条件:<ul><li>该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。</li></ul></li><li>写出对象方法<ul><li>public final void writeObject (Object obj) : 将指定的对象写出。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//满足两个条件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="keyword">public</span> String address;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">transient</span> <span class="type">int</span> age; <span class="comment">// transient瞬态修饰成员,不会被序列化</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Address check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写出对象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>   &#123;</span><br><span class="line">  <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">  e.name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">  e.address = <span class="string">&quot;beiqinglu&quot;</span>;</span><br><span class="line">  e.age = <span class="number">20</span>; </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建序列化流对象</span></span><br><span class="line">         <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>));</span><br><span class="line">      <span class="comment">// 写出对象</span></span><br><span class="line">      out.writeObject(e);</span><br><span class="line">      <span class="comment">// 释放资源</span></span><br><span class="line">      out.close();</span><br><span class="line">      fileOut.close();</span><br><span class="line">      System.out.println(<span class="string">&quot;Serialized data is saved&quot;</span>); <span class="comment">// 姓名，地址被序列化，年龄没有被序列化。</span></span><br><span class="line">      &#125; <span class="keyword">catch</span>(IOException i)   &#123;</span><br><span class="line">           i.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//Serialized data is saved</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><h4 id="8-2-ObjectInputStream类"><a href="#8-2-ObjectInputStream类" class="headerlink" title="8.2 ObjectInputStream类"></a>8.2 ObjectInputStream类</h4><ul><li>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </li><li>构造方法<ul><li>public ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。</li></ul></li><li>反序列化操作1<ul><li>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法。</li><li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。</li><li>public final Object readObject () : 读取一个对象。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeserializeDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>   &#123;</span><br><span class="line">       <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建反序列化流</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">            <span class="comment">// 读取一个对象</span></span><br><span class="line">            e = (Employee) in.readObject();</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException i) &#123;</span><br><span class="line">            <span class="comment">// 捕获其他异常</span></span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">catch</span>(ClassNotFoundException c) &#123;</span><br><span class="line">      <span class="comment">// 捕获类找不到异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Employee class not found&quot;</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">// 无异常,直接打印输出</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Name: &quot;</span> + e.name);<span class="comment">// zhangsan</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Address: &quot;</span> + e.address); <span class="comment">// beiqinglu</span></span><br><span class="line">       System.out.println(<span class="string">&quot;age: &quot;</span> + e.age); <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>反序列化操作2<ul><li>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：<ul><li>该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li><li>该类包含未知数据类型 </li><li>该类没有可访问的无参数构造方法</li></ul></li><li>Serializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 加入序列版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">    <span class="comment">// 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> eid; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addressCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Address check : &quot;</span> + name + <span class="string">&quot; -- &quot;</span> + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-打印流-PrintStream类"><a href="#9-打印流-PrintStream类" class="headerlink" title="9. 打印流(PrintStream类)"></a>9. 打印流(PrintStream类)</h3><ul><li>平时我们在控制台打印输出，是调用print方法和println方法完成的，这两个方法都来自于java.io.PrintStream类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</li><li>构造方法<ul><li><code>public PrintStream(String fileName);</code>  使用指定的文件名创建一个新的打印流。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>)；</span><br></pre></td></tr></table></figure><ul><li>改变打印流向<ul><li>System.out就是PrintStream类型的，只不过它的流向是系统规定的，打印在控制台上。不过，我们可以改变它的流向。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">        <span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        <span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">        System.out.println(<span class="number">97</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Properties类的使用"><a href="#10-Properties类的使用" class="headerlink" title="10. Properties类的使用"></a>10. Properties类的使用</h3><ul><li>Java.util.Properties，主要用于读取Java的配置文件。</li><li>Properties类继承自Hashtable</li><li>配置文件：在Java中，其配置文件常为.properties文件，格式为文本文件，文件的内容的格式是“键&#x3D;值”的格式，文本注释信息可以用”#”来注释。</li><li>Properties类的主要方法：<ol><li>getProperty ( String key)，用指定的键在此属性列表中搜索属性。也就是通过参数 key ，得到 key 所对应的 value。</li><li>load ( InputStream inStream)，从输入流中读取属性列表（键和元素对）。通过对指定的文件（比如说上面的 test.properties 文件）进行装载来获取该文件中的所有键 - 值对。以供 getProperty ( String key) 来搜索。</li><li>setProperty ( String key, String value) ，调用 Hashtable 的方法 put 。他通过调用基类的put方法来设置 键 - 值对。</li><li>store ( OutputStream out, String comments)，以适合使用 load 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。与 load 方法相反，该方法将键 - 值对写入到指定的文件中去。</li><li>clear ()，清除所有装载的 键 - 值对。该方法在基类中提供。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」异常处理机制</title>
      <link href="/2017/04/25/java-exception.html"/>
      <url>/2017/04/25/java-exception.html</url>
      
        <content type="html"><![CDATA[<p>Java语言提供了完善的异常处理机制。正确运用这套机制，有助于提高程序的健壮性。</p><span id="more"></span><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>异常用于在Java语言中描述运行阶段发生的错误。</li><li>在Java中有一个定义好的规则Throwable（可以抛出的）</li><li>java.lang.Throwable类是所有错误(Error)和异常(Exception)的超类。<ul><li>Error类主要用于描述比较严重无法编码解决的错误，如：JVM内存资源耗尽等。</li><li>Exception类主要用于描述比较轻微可以编码解决的错误，如：文件损坏、非法输入等。</li></ul></li><li>java.lang.Exception类是所有异常的超类，主要分为两大类：<ul><li>RuntimeException - 运行时异常，也叫非检测性异常</li><li>IOException和其他异常 - 其他异常也叫做检测性异常</li></ul></li></ul><blockquote><p>注意：当程序运行过程中发生异常而又没有手动处理时，则由java虚拟机采用默认方式处理，即打印异常名称、原因、发生位置并终止程序。在开发中尽量使用条件判断避免异常的发生。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Throwable类</span><br><span class="line">    |————Exception类</span><br><span class="line">        |————RuntimeException异常</span><br><span class="line">            |————ArithmeticException类</span><br><span class="line">            |————ArrayIndexOutOfBoundsException类</span><br><span class="line">            |————NullPointerException类</span><br><span class="line">            |————ClassCastException类</span><br><span class="line">            |————NumberFormatException类</span><br><span class="line">        |————IOException和其他异常</span><br><span class="line">    |————Error类</span><br></pre></td></tr></table></figure><h3 id="2-异常的分支结构"><a href="#2-异常的分支结构" class="headerlink" title="2. 异常的分支结构"></a>2. 异常的分支结构</h3><h4 id="2-1-运行时异常（非检查异常）"><a href="#2-1-运行时异常（非检查异常）" class="headerlink" title="2.1 运行时异常（非检查异常）"></a>2.1 运行时异常（非检查异常）</h4><ol><li>Error和RuntimeException都算作运行时异常</li><li>javac编译的时候，不会提示和发现的，</li><li>在程序编写时不要求必须做处理，如果我们愿意可以添加处理手段(try throws)</li><li>要求大家出现这样异常的时候 知道怎么产生及如何修改<ul><li>InputMisMatchException 输入不匹配<ul><li>int value &#x3D; input.nextInt();&#x2F;&#x2F;   abc</li></ul></li><li>*NumberFormatException 数字格式化<ul><li>int value &#x3D; Integer.parseInt(“123.45”);</li></ul></li><li>NegativeArraySizeException 数组长度负数<ul><li>int[] array &#x3D; new int[-2];</li></ul></li><li>*ArrayIndexOutOfBoundsException 数组索引越界<ul><li>int[] array &#x3D; {1,2,3};</li><li>array[5];</li></ul></li><li>*5NullPointerException 空指针异常<ul><li>int[][] array &#x3D; new int[3][];</li><li>array[0][0] &#x3D;10;</li><li>Person p &#x3D; null;</li><li>p.getName();</li></ul></li><li>ArithmeticException 数字异常<ul><li>10&#x2F;0    整数不允许除以0    Infinity小数除以0会产生无穷</li></ul></li><li>*ClassCastException 造型异常<ul><li>Person p &#x3D; new Teacher();</li><li>Student s &#x3D; (Student)p;</li></ul></li><li>*StringIndexOutOfBoundsException 字符串越界<ul><li>String str &#x3D; “abc”;</li><li>str.charAt(5);</li></ul></li><li>*IndexOutOfBoundsException 集合越界<ul><li>List家族</li><li>ArrayList  list &#x3D; new ArrayList();</li><li>list.add(); list.add(); list.add();</li><li>list.get(5);</li></ul></li><li>IllegalArgumentException 非法参数异常<ul><li>ArrayList  list &#x3D; new ArrayList(-1);</li></ul></li></ul></li></ol><h4 id="2-2-编译时异常-检查异常"><a href="#2-2-编译时异常-检查异常" class="headerlink" title="2.2 编译时异常(检查异常)"></a>2.2 编译时异常(检查异常)</h4><ul><li>除了Error和RuntimeException以外其他的异常</li><li>javac编译的时候，强制要求我们必须为这样的异常做处理(try或throws)</li><li>因为这样的异常在程序运行过程中极有可能产生问题的</li><li>异常产生后后续的所有执行就停止</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//eg: InterruptException</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-添加处理异常的手段"><a href="#3-添加处理异常的手段" class="headerlink" title="3. 添加处理异常的手段"></a>3. 添加处理异常的手段</h3><ul><li>处理异常不是 异常消失了</li><li>处理异常指的是：处理掉异常之后，后续的代码不会因为此异常而终止执行</li><li>两种手段：<ul><li>异常的捕获：try{}catch(){}[ finally{} ]</li><li>throws抛出</li></ul></li><li>final，finally，finalize区别<ul><li>final：特征修饰符，修饰变量，属性，方法，类<ul><li>修饰变量：基本类型:值不能改变；引用类型:地址不能改变(如果变量没有初值,给一次机会赋值)</li><li>修饰属性：特点与修饰变量类似(要求必须给属性赋初始值,否则编译报错)</li><li>修饰方法：不能被子类重写</li><li>修饰类：不能被其他的子类继承</li></ul></li><li>finally：处理异常手段的一部分<ul><li>try{}catch(){}后面的一个部分</li><li>这个部分可有可无，如果有只能含有一份，且必须执行</li></ul></li><li>finalize：是Object类中的一个protected方法<ul><li>对象没有任何引用指向的时候 – 会被GC回收</li><li>当对象回收的时候 默认调用finalize方法</li><li>若想要看到对象回收的效果，可以重写 public void finalize(){}</li></ul></li></ul></li></ul><h3 id="4-异常的捕获"><a href="#4-异常的捕获" class="headerlink" title="4. 异常的捕获"></a>4. 异常的捕获</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 引用变量)&#123;</span><br><span class="line">    针对该异常的处理代码;</span><br><span class="line">&#125;<span class="keyword">catch</span> ...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论是否发生异常都要执行的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理异常放在方法内部 可能会出现的小问题<ul><li>如果在方法内部含有返回值，不管返回值return关键字在哪里，finally一定会执行完毕，返回值的具体结果得看情况。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String test() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //...可能产生异常的的代码</span><br><span class="line">        return &quot;值1&quot;;//事先约定好 返回值</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();//打印输出异常的名字</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        System.out.println(&quot;finally块执行啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot;值2&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述执行结果：若try中代码块产生异常return返回 <strong>值2</strong>，若try中无异常则return返回 <strong>值1</strong>，无论return在哪finally都会执行。</li></ul><blockquote><p>异常捕获的注意事项：</p><ul><li>当需要多分catch分子时，切记小类型应该放在大类型的前面；</li><li>懒人写法：catch(Exception e){…}</li><li>finally通常用于善后处理，如：关闭已经打开的文件等。</li></ul></blockquote><h3 id="5-异常的抛出"><a href="#5-异常的抛出" class="headerlink" title="5. 异常的抛出"></a>5. 异常的抛出</h3><ul><li>当程序中发生异常又不方便直接处理时，可以将异常转移给方法调用者进行处理，这个过程叫做异常的抛出。</li><li>语法格式：访问权限 返回值类型 方法名(形参列表) throws 异常类型1,异常类型2,…{} ，<br><br>如：<code>public void show() throw Exception &#123;&#125;</code></li><li>重写方法的抛出规则：<ul><li>不抛出异常</li><li>抛出父类异常中的子类异常</li><li>抛出和父类一样的异常</li><li>不能抛出同级不一样的异常</li><li>不能抛出更大的异常</li></ul></li></ul><h3 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6. 自定义异常"></a>6. 自定义异常</h3><ul><li>可以根据需要自定义异常类。</li><li>自定义异常的方式：<ul><li>继承Exception或者异常的子类。</li><li>提供两个构造，无参构造和String做参数的构造。</li></ul></li><li>异常的手段<ul><li>如果继承是RuntimeException—-&gt;运行时异常(不需要必须添加处理手段)</li><li>如果继承是Exception—–&gt;编译时异常(必须添加处理手段)</li></ul></li><li>类中可以写带String参数的构造方法，可以做细致的说明</li><li>通过throw关键字，new一个异常的对象</li><li>主动产生异常：<code>throw new 异常类型();</code></li></ul><h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><ul><li>1.在开发中尽量使用条件判断避免异常的发生;</li><li>2.若实在避免不了，则进行异常捕获；</li><li>3.若实在捕获不了，则进行异常抛出；</li><li>4.若需要使用针对性异常，则自定义异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」集合框架</title>
      <link href="/2017/04/17/java-collection.html"/>
      <url>/2017/04/17/java-collection.html</url>
      
        <content type="html"><![CDATA[<p>为了方便对多个对象的操作，对对象进行存储，集合就是存储对象最常用的一种方式。</p><span id="more"></span><h3 id="1-Collection集合"><a href="#1-Collection集合" class="headerlink" title="1. Collection集合"></a>1. Collection集合</h3><ul><li>Collection集合框架，字面意思容器；与数组类似，集合的长度存储之后还能改变，集合框架中包含了一系列不同数据结构的实现类。</li></ul><blockquote><p>数组与集合的比较</p><ul><li>数组的特点：<ol><li>数组本质上就是一段连续的存储单元，用于存放多个类型相同的数据类容；</li><li>支持下标访问，实现随机访问非常方便；</li><li>增删操作不方便，可能会移动大量元素；</li><li>数组一旦声明长度固定无法更改；</li><li>数组支持基本数据类型，也支持引用数据类型；</li></ol></li><li>集合的特点：<ol><li>集合的存储单元可以不连续，数据类容可以不相同；</li><li>集合部分支持下标访问，部分不支持；</li><li>集合中增删元素可以不移动大量元素；</li><li>集合大小可以随时动态调整；</li><li>集合中的元素必须是引用数据类型（基本数据类型可用包装类）；</li></ol></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-Collection接口</span><br><span class="line">    |————List接口</span><br><span class="line">        |————ArrayList类</span><br><span class="line">        |————LinkedList类</span><br><span class="line">        |————Stack类</span><br><span class="line">        |————Vector类</span><br><span class="line">    |————Queue接口</span><br><span class="line">        |————LinkedList类</span><br><span class="line">    |————Set接口</span><br><span class="line">        |————HashSet类</span><br><span class="line">        |————TreeSet类</span><br><span class="line">-Map接口</span><br><span class="line">    |————HashMap类</span><br><span class="line">    |————TreeMap类</span><br></pre></td></tr></table></figure><blockquote><ul><li>Collection存储的都是value,其中List有序可重复，Set无序无重复</li><li>Map存储的是以key-value形式,key无序无重复 value无序可重复</li><li>序 : 顺序–添加进去的元素，取得元素的顺序一致；注意指的不是集合自己的顺序</li></ul></blockquote><table><thead><tr><th>Collection集合的常用方法</th><th></th></tr></thead><tbody><tr><td>boolean add(E e);</td><td>向集合中添加对象</td></tr><tr><td>boolean contains(Object o);</td><td>判断是否包含指定对象</td></tr><tr><td>boolean remove(Object o);</td><td>从集合中删除对象</td></tr><tr><td>void clear();</td><td>清空集合</td></tr><tr><td>int size();</td><td>返回包含对象的个数</td></tr><tr><td>boolean isEmpty();</td><td>判断是否为空</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//多态</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> c2.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;one&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> c2.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(<span class="string">&quot;c2 = &quot;</span> + c2); <span class="comment">//[one, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> c2.contains(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));<span class="comment">//true</span></span><br><span class="line"><span class="comment">//contains方法工作原理：(o==null ? e==null : o.equals(e));</span></span><br></pre></td></tr></table></figure><h3 id="2-List集合"><a href="#2-List集合" class="headerlink" title="2. List集合"></a>2. List集合</h3><ul><li>java.util.List集合是Collection集合的子集合。</li><li>List集合中元素有先后放入次序并且元素可以重复；实现类有：ArrayList类、LinkedList类、Stack类以及Vector类。<ul><li>ArrayList类的底层使用<strong>数组</strong>进行数据管理，访问元素方便，增删不方便。</li><li>LinkedList类的底层使用<strong>链表</strong>进行数据管理，访问不方便，增删方便。</li><li>Stark类的底层使用数组进行数据管理，该类主要描述具有<strong>后进先出</strong>的特征的数据结构，叫做<strong>栈</strong>。</li><li>Vector类的底层使用数组进行数据管理，与ArrayList类似，与之比线程安全的类，因此效率低。</li></ul></li><li>List类除了继承Collection定义的方法外，还根据线性表的数据结构定义了一系列方法，其中最常用的是基于下标的get()，set()方法。</li></ul><table><thead><tr><th>List类常用方法</th><th></th></tr></thead><tbody><tr><td>void add(int index, E element)</td><td>向集合指定位置添加元素</td></tr><tr><td>boolean addAll(int index, Collection&lt;?extends E&gt; c)</td><td>向集合中添加所有元素</td></tr><tr><td>E get(int index)</td><td>从集合中获取指定位置的元素</td></tr><tr><td>E set(int index, E element)</td><td>修改指定位置的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定位置的元素</td></tr><tr><td>int indexOf(Object o)</td><td>在集合中检索某个对象，判断逻辑(o&#x3D;&#x3D;null?get(i)&#x3D;&#x3D;null:o.equals(get(i)))</td></tr><tr><td><T> T[] toArray(T[] a)</td><td>将集合中的对象序列化以对象数组的形式返回。</td></tr><tr><td>List<E> subList(int fromIndex, int toIndex)</td><td>获取List从fromIndex(包括)和 toIndex(不包括)之间的部分视图</td></tr></tbody></table><h3 id="3-泛型机制"><a href="#3-泛型机制" class="headerlink" title="3. 泛型机制"></a>3. 泛型机制</h3><ul><li>集合可以存放不同的对象，本质上都看作Object类型放入，此时从集合中取出也是Object类型，为了表达该元素真实类型需要强制类型转换，而强制类型转换可能发生类型转换异常。</li><li>从jdk1.5开始推出泛型机制，在集合名称后面使用&lt;数据类型&gt;的方式明确要求该集合中可以存放的数据类型。如：<code>List&lt;String&gt; lt = new LinkedList&lt;String&gt;();</code>。</li><li>从jdk1.7开始可省略后面&lt;&gt;的数据类型，叫做<code>菱形特性</code>，如：<code>List&lt;String&gt; lt = new ArrayList&lt;&gt;();</code>。</li><li>泛型本质就是参数化类型，让数据类型作为参数传递，<code>public interface List&lt;E&gt;&#123;&#125;</code>其中<code>E</code>是占位形参，由于实参可以支持各种广泛的类型，因此得名<code>泛型</code>。</li><li>泛型可以用在哪里：<ol><li>泛型类：类定义的时候描述某种数据类型，集合的使用就是这样</li><li>泛型接口：与泛型类的使用基本一致，子类实现接口时必须添加泛型</li><li>泛型方法：方法调用时传参数，方法的泛型与类无关，带有泛型的方法可以不放在带有泛型的类中</li><li>方法参数泛型限制，高级泛型，规范边界，extends，super</li></ol></li></ul><h3 id="4-Queue集合"><a href="#4-Queue集合" class="headerlink" title="4. Queue集合"></a>4. Queue集合</h3><ul><li>java.util.Queue集合是Collection集合的子集合。</li><li>Queue集合主要描述具有<strong>先进先出</strong>特性的数据结构，叫做<strong>队列</strong>(FIFO:First Input First Output)。</li><li>Queue集合主要实现类是<code>LinkedList类</code>，因为该类在增删方面有一定优势。</li></ul><table><thead><tr><th>Queue接口中主要方法</th><th></th></tr></thead><tbody><tr><td>boolean offer(E e)</td><td>将一个对象添加至队尾，若添加成功则返回true</td></tr><tr><td>E poll()</td><td>从队首删除并返回一个元素</td></tr><tr><td>E peek()</td><td>返回队首的元素（但并不删除）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; q1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//将数据11、22、33、44、55依次入队</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    q1.offer(i*<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-ArrayList类"><a href="#5-ArrayList类" class="headerlink" title="5. *ArrayList类"></a>5. *ArrayList类</h3><ol><li>底层是利用(动态)数组形式实现，jdk1.5，所属的包 java.util</li><li>ArrayList特点适合遍历轮询，不适合插入删除</li><li>如何构建一个ArrayList对象<ul><li>无参数构造方法，带默认容量构造方法，带collection参数的构造方法</li></ul></li><li>ArrayList中常用的方法<ul><li>增删改查：add(E e)，remove(index)，set(index value)，get(index)，size()</li></ul></li><li>类中其他常用的方法<ul><li>addAll并集，removeAll差集，ratainAll交集;</li><li>indexOf()，lastIndexOf()，contains()，List&#x3D;subList();</li><li>isEmpty()，clear()，ensureCapacity()，iterator();迭代器</li><li>toArray(T[] x)，trimToSize();</li></ul></li></ol><h3 id="6-Vector类"><a href="#6-Vector类" class="headerlink" title="6. Vector类"></a>6. Vector类</h3><ol><li>是ArrayList集合的早期版本，所属的包 java.util<ul><li>Vector底层也是利用(动态)数组的形式存储</li><li>Vector是线程同步的(synchronized)，安全性高，效率较低</li></ul></li><li>扩容方式与ArrayList不同<ul><li>默认是扩容2倍，可以通过构造方法创建对象时修改这一机制</li></ul></li><li>构造方法和常用方法与ArrayList类似</li></ol><h3 id="7-Stack类"><a href="#7-Stack类" class="headerlink" title="7. Stack类"></a>7. Stack类</h3><ol><li>Stack类，栈，java.util包</li><li>构造方法只有一个无参数</li><li>除了继承自Vacton类的方法外还有特殊的方法<ul><li>push(E e)将某一个元素压入栈顶(add())</li><li>E &#x3D; pop()将某一个元素从栈顶取出并删掉(E &#x3D; remove())</li><li>E &#x3D; peek()查看栈顶的一个元素 不删除(get())</li><li>boolean &#x3D; empty()判断栈内元素是否为空(isEmpty())</li><li>int &#x3D; search()查找给定的元素在占中的位置(indexOf())</li></ul></li><li>应用场景<ul><li>中国象棋，悔棋</li><li>栈中存储每一次操作的步骤</li><li>撤销功能</li></ul></li></ol><h3 id="8-LinkedList类"><a href="#8-LinkedList类" class="headerlink" title="8. *LinkedList类"></a>8. *LinkedList类</h3><ol><li>LinkedList类，java.util包</li><li>底层使用<strong>双向链表</strong>的数据结构形式来存储<ul><li>适合于插入或删除  不适合遍历轮询</li></ul></li><li>构建对象<ul><li>无参数构造方法，带参数的构造方法(collection)</li></ul></li><li>常用的方法<ul><li>增删改查：add()，remove()，set()，get()，size()，offer，poll，peek</li><li>手册中提供的其他常用方法：addAll，addFist，addLast()，clear()，contains()，element()，getFirst()，getLast()，indexOf()，lastIndex()</li></ul></li><li>插入删除的特性是否像想的那样<ul><li>对比ArrayList  Linked</li></ul></li></ol><h3 id="9-Set集合"><a href="#9-Set集合" class="headerlink" title="9. Set集合"></a>9. Set集合</h3><ul><li>java.util.Set集合是Collection集合的子集合。</li><li>Set集合没有先后放入次序，并且不允许有重复关系，实现类有<code>HashSet类</code>和<code>TreeSet</code>类。</li><li>其中<code>HashSet类</code>底层是采用哈希表进行数据管理的。</li><li>其中<code>TreeSet类</code>的底层是采用二叉树进行数据管理的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法和Collection集合基本一样</span></span><br><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">set1.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;s1=&quot;</span>+s1);</span><br></pre></td></tr></table></figure><ul><li>set集合的无重复特性<ul><li>HashSet，无重复原则有两个方法同时起作用<ul><li>equals    hashCode</li><li>默认比较的是两个对象的地址  若第二个对象地址与之前的一致  不再存入</li><li>如果想要改变其比较的规则  可以重写上述两个方法</li></ul></li><li>TreeSet，无重复原则有一个方法起作用<ul><li>compareTo</li><li>上述这个方法不是每一个对象都有的</li><li>若想要将某一个对象存入TreeSet集合中，需要让对象所属的类实现接口Comparable</li><li>实现接口后将compareTo方法重写，返回值int，负数靠前排布，整数排列靠后</li></ul></li></ul></li></ul><h4 id="9-1-Set集合的遍历"><a href="#9-1-Set集合的遍历" class="headerlink" title="9.1 Set集合的遍历"></a>9.1 Set集合的遍历</h4><ul><li>所有Collection的实现类都实现了其iterator方法，该方法返回Iterator接口类型对象，用于实现对集合元素的迭代遍历。</li></ul><table><thead><tr><th>迭代器<code>Iterator&lt;E&gt; iterator()</code>，主要方法有</th><th></th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>判断集合中是否有可以迭代&#x2F;访问的元素</td></tr><tr><td>E next()</td><td>用于取出一个元素并指向下一个元素</td></tr><tr><td>void remove()</td><td>用于删除访问到的最后一个元素</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = set1.iterator();<span class="comment">//获取当前集合的迭代器对象</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;<span class="comment">//判断是否有可以访问的元素</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> it.next();<span class="comment">//取出一个并指向下一个</span></span><br><span class="line">    System.out.println( temp );</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;two&quot;</span>.equals(temp))&#123;</span><br><span class="line">        it.remove();<span class="comment">//删除set1中该元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>增强for循环(for each结构)</li><li>语法格式：<code>for(元素类型 变量名:集合/数组)&#123; 循环体; &#125;</code>。</li><li>执行流程：不断从集合&#x2F;数组中取出一个元素赋值给变量名后执行循环体，直到取出所有元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="keyword">for</span>(String ts : s1) &#123;</span><br><span class="line">    System.out.println(ts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ti : arr) &#123;</span><br><span class="line">    System.out.println(ti);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-HashSet类"><a href="#10-HashSet类" class="headerlink" title="10. HashSet类"></a>10. HashSet类</h3><ol><li>HashSet集合底层采用HashMap（数组+链表–&gt;散列表），java.util包。</li><li>它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用null元素。 </li><li>创建对象：无参数，有参数</li><li>集合容器的基本使用<ul><li>增删改查：boolean &#x3D; add(value)，addAll(collection c)，retainAll，removeAll，boolean &#x3D; remove(Object)</li><li>没有修改方法</li><li>iterator()  获取一个迭代器对象</li><li>size()</li></ul></li><li>无重复的原则<ul><li>在HashSet中，元素都存到HashMap键值对的Key上面，而Value时有一个统一的值private static final Object PRESENT &#x3D; new Object();，(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final。)</li></ul></li></ol><h3 id="11-TreeSet类"><a href="#11-TreeSet类" class="headerlink" title="11. TreeSet类"></a>11. TreeSet类</h3><ol><li><p>TreeSet类，无序无重复，java.util包。(底层TreeMap 二叉树 利用Node(left item right))</p></li><li><p>创建对象： 无参数构造方法 ，带Collection构造方法</p></li><li><p>基本常用方法：add(E e)，iterator()，remove(E e)，没有修改，size()</p></li><li><p>二叉树主要指每个节点最多只有两个子节点的树形结构。</p></li><li><p>满足以下三个特征的二叉树叫做<strong>有序二叉树</strong>：</p><ul><li>左子树中的任意节点元素都小于根节点元素；</li><li>右子树中的任意节点元素都大于根节点元素；</li><li>左子树和右子树内部也遵守上述规则；</li></ul></li><li><p>无序无重复：treeSet集合本身有顺序，我们指的无序存入的和取出来的不一致。</p></li><li><p>元素放入TreeSet集合过程：<br>由于TreeSet集合底层采用<strong>有序二叉树</strong>进行数据的管理，当有新元素插入到TreeSet集合时，需要使用新元素与集合中已有的元素依次比较来确定存放合理位置，而比较元素大小规则有两种方式：</p><ol><li>使用元素的<strong>自然排序</strong>规则进行比较并排序，让元素类型实现java.lang.Comparable接口；</li><li>使用<strong>比较器规则</strong>进行比较并排序，构造TreeSet集合时传入java.util.Comparable接口；</li></ol></li></ol><blockquote><p>注意：<br>    1. 自然排序的规则比较单一，而比较强的规则比较多元化，而且比较器优先于自然排序；<br>    2. 可以使用Collections工具类对集合中的元素进行操作；</p></blockquote><h3 id="12-Map集合"><a href="#12-Map集合" class="headerlink" title="12. Map集合"></a>12. Map集合</h3><ul><li>java.util.Map&lt;K, V&gt;集合存取元素的基本单位是：单对元素（键值对key-value）。</li><li>Map：映射，通过某一个key可以直接定位到一个value值</li><li>key无序无重复   value无序可重复<ul><li>key无序还是一样，指的是存入顺序与取得顺序不一致，key无重复当然指的是，元素不能一致</li></ul></li><li>主要有两个实现类：<code>HashMap类</code>和<code>TreeMap类</code>。</li><li>Map基本使用：HashMap，TreeMap，Properties</li><li>Map集合常用方法：<ul><li>增改：put(key,value)，删：remove(key)，查：get(key),containsKey(key),containsValue(value)</li></ul></li><li>Map集合的遍历方式：a.迭代Key，b.迭代Entry</li><li>Map集合的性能调优：<ul><li>加载因子较小时散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡的结果，在常见散列表时指定合理容量，减少rehash提高性能。（Capacity:容量，Initial capacity:初始容量，Size:数据大小，Load factor:加载因子(size&#x2F;capacity),默认0.75）</li></ul></li></ul><h3 id="13-HashMap类"><a href="#13-HashMap类" class="headerlink" title="13. HashMap类"></a>13. HashMap类</h3><ol><li>包:java.util，底层散列表的形式（数组+链表）</li><li>构造方法创建对象   无参数  带默认容量的  带map参数的构造方法</li><li>特点:(数组+链表)底层散列表形式存储，key无序无重复,value无序可重复<ul><li>找寻某一个唯一元素的时候建议使用map，更适合于查找唯一元素，Map$Entry</li></ul></li><li>基本方法：<ul><li>增 put(key,value)，存放一组映射关系key-value<ol><li>key存储的顺序与取得顺序不同</li><li>不同的key可以存储相同的value</li><li>key若有相同的 则将 原有的value覆盖而不是拒绝存入(跟set刚好相反)</li></ol></li><li>删 E &#x3D; remove(key);</li><li>改 replace(key,newValue)，put(key,value2)</li><li>查 E &#x3D; get(key)；</li><li>Set<Key> &#x3D; keySet()获取全部的key</li><li>Set<Entry> &#x3D; entrySet();</li><li>size();</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Entry&lt;Integer,String&gt;&gt; entrys = map.entrySet();<span class="comment">//获取集合中全部的entry对象</span></span><br><span class="line">Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = entrys.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Entry&lt;Integer,String&gt; entry = it.next();<span class="comment">//entry  key value</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;--&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>除了上述几个常用的方法外  其他API中提供的方法<ul><li>clear，containsKey(key)，containsValue(value)</li><li>getOrDefault(key,defaultValue);如果key存在就返回对应的value 若没有找到则返回默认值</li><li>isEmpty()</li><li>putAll(map)</li><li>putIfAbsent(key,value);&#x2F;&#x2F;如果key不存在才向集合内添加  如果key存在就不添加啦</li></ul></li><li>map集合在什么情形下用?<ol><li>想要存储一组元素<ul><li>数组  or  集合，如果存储的元素以后长度不变 用数组，如果长度以后不确定 用集合</li></ul></li><li>如果发现长度以后不确定—&gt;集合</li></ol></li></ol><table><thead><tr><th align="center">list</th><th align="center">Set</th><th align="center">Map</th></tr></thead><tbody><tr><td align="center">List家族有序的</td><td align="center">Set家族无重复</td><td align="center">Map家族k-v</td></tr><tr><td align="center">存储有顺序用这个</td><td align="center">存储元素希望自动去掉重复元素用这个</td><td align="center">通过唯一的k快速找寻v用这个</td></tr><tr><td align="center">ArrayList:更适合遍历轮询</td><td align="center">HashSet:性能更高</td><td align="center">HashMap:性能更高</td></tr><tr><td align="center">LinkedList:更适合插入和删除</td><td align="center">TreeSet:希望存进去的元素自动去重复,同时还能自动排序</td><td align="center">Tree:希望存进去的元素key自动排序</td></tr><tr><td align="center">Stack:LIFO</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h3 id="14-TreeMap类"><a href="#14-TreeMap类" class="headerlink" title="14. TreeMap类"></a>14. TreeMap类</h3><ol><li>java.util包</li><li>构造方法：无参数，带map参数</li><li>常用方法：put， get，remove，replace，size</li><li>底层数据结构的存储：红黑二叉树（层级多余2层可能会左旋或右旋）</li><li>自然有序，按照Unicode编码自然有序<ul><li>ap集合中的key需要可比较的   key的对象需要实现Comparable接口</li></ul></li></ol><h3 id="15-Lambda表达式"><a href="#15-Lambda表达式" class="headerlink" title="15. Lambda表达式"></a>15. Lambda表达式</h3><ul><li>java8支持的新的语法格式，Lambda允许<code>把函数作为一个方法的参数</code>(函数作为参数传递进方法中)，使用lambda表达式可以<code>使代码变得更加简洁紧凑</code>。</li><li>函数式编程：一种抽象程度很高的编程范式。函数也可以跟变量、对象一样使用，可以作为参数，也可以作为返回值，大大简化了代码的开发。</li><li>lambda表达式语法由<strong>参数列表</strong>、<strong>箭头函数<code>-&gt;</code><strong>和</strong>函数体</strong>组成，函数体即可以是一个表达式，也可以是一个语句块。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int a, int b) -&gt; a+b</span><br><span class="line">() -&gt; 42</span><br><span class="line">(String s) -&gt; &#123;System.out.println(s);&#125;</span><br></pre></td></tr></table></figure><ul><li>函数式接口：指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式大都会被匹配到这个抽象方法。</li><li>jdk1.8提供了一个@FunctionalInterface注解来定义函数式接口，如果我们定义的接口不符合函数式的规范便会报错。</li></ul><h4 id="15-1-Lambda表达式-方法引用"><a href="#15-1-Lambda表达式-方法引用" class="headerlink" title="15.1 Lambda表达式-方法引用"></a>15.1 Lambda表达式-方法引用</h4><ul><li>方法引用：只需要使用方法的名字，而具体调用交给函数式接口，需要和Lambda表达式配合使用。</li><li>方法引用和lambda表达式拥有相同的特性，我们并不需要为方法引用提供方法体，我们可以直接通过方法名称引用已有的方法。</li></ul><h3 id="16-Stream-API"><a href="#16-Stream-API" class="headerlink" title="16. Stream API"></a>16. Stream API</h3><ul><li><p>Stream(流)借助lambda表达式来进行集合数据处理,分为中间操作和最终操作两种；最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样就可以将多个操作依次串起。</p></li><li><p>虽然大部分情况下stream是容器调用Collection.stream()方法得到的，但stream和collections有以下不同：</p><ul><li><strong>无存储</strong>。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I&#x2F;O channel等。</li><li><strong>为函数式编程而生</strong>。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。</li><li><strong>惰式执行</strong>。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li><strong>可消费性</strong>。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul></li><li><p>对stream的操作分为为两类，中间操作和结束操作，二者特点是：</p><ul><li><strong>中间操作</strong>总是会惰式执行，调用中间操作只会生成一个标记了该操作的新stream，仅此而已。</li><li><strong>结束操作</strong>会触发实际计算，计算发生时会把所有中间操作积攒的操作以pipeline的方式执行，这样可以减少迭代次数。计算完成之后stream就会失效。</li></ul></li></ul><h4 id="16-1-stream方法使用"><a href="#16-1-stream方法使用" class="headerlink" title="16.1 stream方法使用"></a>16.1 stream方法使用</h4><ul><li>stream跟<strong>函数接口</strong>关系非常紧密，没有函数接口stream就无法工作（通常函数接口出现的地方都可以使用Lambda表达式，所以不必记忆函数接口的名字)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找出最长的单词</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;love&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;too&quot;</span>);</span><br><span class="line">Optional&lt;String&gt; longest = stream.reduce((s1, s2) -&gt; s1.length()&gt;=s2.length() ? s1 : s2);</span><br><span class="line"><span class="comment">//Optional&lt;String&gt; longest = stream.max((s1, s2) -&gt; s1.length()-s2.length());</span></span><br><span class="line">System.out.println(longest.get());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」核心工具类</title>
      <link href="/2017/04/12/java-api.html"/>
      <url>/2017/04/12/java-api.html</url>
      
        <content type="html"><![CDATA[<p>API (Application Programming Interface) 应用程序编程接口，Java中的API，就是JDK提供的各种功能的Java类。</p><span id="more"></span><h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ul><li>java.lang包：是Java最核心的包，JVM(Java虚拟机)启动时自动加载lang包的所有类和接口，无需import。如：System类、String类、Object类、Class类…</li><li>java.util包：是Java工具包，包括很多工具类和集合。如：Scanner类、Random类…</li><li>java.io包：是输入输出包，包括读写各种设备。</li><li>java.net包：是网络编程的包，包括各种网络编程。</li><li>java.sql包：是操作数据库的所有类和接口。</li></ul><h3 id="1-Object类与其常用方法"><a href="#1-Object类与其常用方法" class="headerlink" title="1. Object类与其常用方法"></a>1. Object类与其常用方法</h3><h4 id="1-1-Object类"><a href="#1-1-Object类" class="headerlink" title="1.1 Object类"></a>1.1 Object类</h4><ul><li>java.lang.Object类在Java类继承结构中位于顶端(根类)，任何类都是该类的直接或间接子类。</li><li>Object定义了“对象”的基本行为，被子类默认继承。</li></ul><h4 id="1-2-equals-和-hashCode"><a href="#1-2-equals-和-hashCode" class="headerlink" title="1.2 equals() 和 hashCode()"></a>1.2 equals() 和 hashCode()</h4><ul><li>boolean equals()方法用于非空对象的“相等”逻辑，默认比较两个对象的地址，返回布尔值。</li><li>equals()方法要求：自反性&#x2F;对称性&#x2F;传递性&#x2F;一致性&#x2F;非空性。</li><li>Java类可以根据需要重写继承自Object的equals()方法。</li></ul><blockquote><p>注意：当equals()方法被重写时，必须重写hashCode方法，以维护hashCode方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</p></blockquote><ul><li><p>int hashCode():返回对象的哈希码值，对应一个内存。</p></li><li><p>hashCode规范要求：</p><ul><li>一致性，同一对象，若没有改变属性值，多次调用其hashCode应该时一致的</li><li>如果两个对象判定相等，它们的hashCode应该时同一个值</li><li>如果两个对象不相等，它们的hashCode可以相同，但最好不相同而可以提高哈希表的性能。</li></ul></li><li><p>hashCode()方法和equals()方法的判断条件必须保持一致，如果重写一个，另一个也必须重写。</p></li></ul><h4 id="1-3-toString"><a href="#1-3-toString" class="headerlink" title="1.3 toString()"></a>1.3 toString()</h4><ul><li>String toString()：用于获取调用对象的字符串形式，返回”包名.类名@hashCode值的16进制”。</li><li>Java类可以根据需要重写toString方法返回更有意义的信息。</li><li>Java在使用System.out.println()打印对象时或者<code>+</code>连接字符串时，默认调用toString()方法。</li></ul><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2. 包装类"></a>2. 包装类</h3><h4 id="2-1-包装类"><a href="#2-1-包装类" class="headerlink" title="2.1 包装类"></a>2.1 包装类</h4><ul><li>由于某些特殊场合(集合)中要求所有数据内容都必须是对象，而对于基本数据类型的变量来说不满足该要求，为了使得该变量也能够使用就需要对变量打包处理变成对象，此时就需要借助包装类。</li><li>Java语言8种基本类型分别对应了8中“包装类”，每一种包装类都封装了一个对应的基本类型成员变量，还提供了一些针对该数据类型的实用方法。</li></ul><table><thead><tr><th>基本类型</th><th>对应包装类</th></tr></thead><tbody><tr><td>byte</td><td>java.lang.Byte</td></tr><tr><td>short</td><td>java.lang.Short</td></tr><tr><td>int</td><td>java.lang.Integer</td></tr><tr><td>long</td><td>java.lang.Long</td></tr><tr><td>float</td><td>java.lang.Float</td></tr><tr><td>double</td><td>java.lang.Double</td></tr><tr><td>boolean</td><td>java.lang.Boolean</td></tr><tr><td>char</td><td>java.lang.Character</td></tr></tbody></table><ol><li>八个包装类都在同一个包下（java.lang包），不需要import导包直接使用</li><li>八个包装类中有六个是与数字相关，都默认继承父类Number</li><li>八个包装类都实现了Serializable, Comparable</li><li>八个包装类都有带自己对应类型参数的构造方法，其中有七个(除了Character)还有构造方法重载，带String类型</li><li>八个包装类都提供了各自对应的拆包方法，如intValue,floatValue,将包装类对象拆成基本类型</li></ol><h4 id="2-2-Integer类"><a href="#2-2-Integer类" class="headerlink" title="2.2 Integer类"></a>2.2 Integer类</h4><ul><li>java.lang.Integer类是int类型的包装类，该类型对象中包含一个int类型的成员变量。该类由final关键字修饰表示不能被继承。</li><li>Integer类重写了**equals()**方法（重写后比较的是数值）、hashCode()以及toString()方法。</li></ul><table><thead><tr><th>Integer类的常用方法</th><th></th></tr></thead><tbody><tr><td>Integer(int i)</td><td>根据参数指定整数来构造对象</td></tr><tr><td>Integer(String s)</td><td>根据参数指定的字符串来构造对象</td></tr><tr><td>int intValue()</td><td>获取调用对象中整数值并返回</td></tr><tr><td>static Integer valueOf(int i)</td><td>根据参数指定整数值得到Integer类型对象</td></tr><tr><td>static int parseInt(String s)</td><td>将字符串类型转换为int类型并返回</td></tr></tbody></table><h4 id="2-3-装箱和拆箱"><a href="#2-3-装箱和拆箱" class="headerlink" title="2.3 装箱和拆箱"></a>2.3 装箱和拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it</span> <span class="operator">=</span> Integer.valueOf(i); <span class="comment">//实现了int类型到Integer类型的转换，这个过程叫做装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ia</span> <span class="operator">=</span> it.intValue();<span class="comment">//实现了Integer类型到int类型的转换，这个过程叫做拆箱</span></span><br><span class="line"><span class="comment">//jdk5增加了自动拆箱和装箱功能（编译器预处理）:</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ia</span> <span class="operator">=</span> i;<span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><ul><li>笔试考点：<blockquote><ul><li>在Integer类部提供了自动装箱池技术，将**-128~127间的整数已经装箱完毕**，当使用该范围整数时直接取池中的对象即可，从而提高效率。</li><li>Integer类加载的时候，自己有一个静态的空间立即加载Integer类型的数组，存储256个Integer对象（-128 ~ 127），当使用该范围整数时，直接取静态区中找对应的对象；如果我们用的对象范围会帮我们创建一个新的Integer对象。</li></ul></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">it1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">128</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">128</span>);</span><br><span class="line">System.out.println(it1.equals(it2));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it1 == it2);<span class="comment">//比较地址 false</span></span><br><span class="line">System.out.println(it3.equals(it4));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it3 == it4);<span class="comment">//比较地址 false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">it5</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it6</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">it8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(it5.equals(it6));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it5 == it6);<span class="comment">//比较地址 true, 自动装箱池范围-128~127。</span></span><br><span class="line">System.out.println(it7.equals(it8));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(it7 == it8);<span class="comment">//比较地址 false</span></span><br></pre></td></tr></table></figure><h3 id="3-数学处理类"><a href="#3-数学处理类" class="headerlink" title="3. 数学处理类"></a>3. 数学处理类</h3><ul><li>java.lang.Math构造方法是私有的，我们不能直接调用创建对象；由于Math中提供的属性及方法都是static  不需要创建对象。</li></ul><table><thead><tr><th>常用的方法</th><th>返回值类型</th><th></th></tr></thead><tbody><tr><td>Math.abs()</td><td></td><td>返回给定数字的绝对值(参数 int long float double)</td></tr><tr><td>Math.ceil()</td><td>double</td><td>向上取整</td></tr><tr><td>Math.floor()</td><td>double</td><td>向下取整</td></tr><tr><td>Math.rint()</td><td>double</td><td>临近的整数 如果两边距离一样 则返回偶数</td></tr><tr><td>Math.round()</td><td>int</td><td>四舍五入的整数</td></tr><tr><td>Math.max(a,b)&#x2F;min(a,b)</td><td></td><td>(参数int  long  float  double)</td></tr><tr><td>Math.pow(a,b)</td><td>double</td><td>a的b次方  (参数double 返回值double)</td></tr><tr><td>Math.sqrt(double a)</td><td></td><td>获取给定参数的平方根</td></tr><tr><td>Math.random()</td><td>double</td><td>随机产生一个[0.0–1.0)</td></tr></tbody></table><ul><li>0-9之间的随机整数：int value &#x3D; (int)**(Math.random()<em>10</em>*);</li><li>Math.random()计算小数的时候精确程度可能有些损失</li></ul><h4 id="3-1-Random类"><a href="#3-1-Random类" class="headerlink" title="3.1 Random类"></a>3.1 Random类</h4><ul><li>java.util.Random，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li></ul><table><thead><tr><th>常用的方法</th><th>Random r &#x3D; new Random();</th></tr></thead><tbody><tr><td>r.nextInt();</td><td>随机产生 int取值范围的整数 有正有负(<code>-2^31</code>~<code>2^31-1</code>即<code>正负21亿</code>之间)</td></tr><tr><td>r.nextInt(int bound);</td><td>随机产生一个[0–bound)整数；注意bound必须为正数，否则会出现如下的运行时异常：IllegalArgumentException</td></tr><tr><td>r.nextFloat()</td><td>随机产生一个 [0.0—1.0)</td></tr><tr><td>r.nextBoolean()</td><td>随机产生一个boolean值   true  false</td></tr></tbody></table><h4 id="3-2-UUID类"><a href="#3-2-UUID类" class="headerlink" title="3.2 UUID类"></a>3.2 UUID类</h4><ul><li>java.util.UUID，在java.util包中的类，需要import导入，没有任何继承关系  默认继承Object类</li><li>只有有参构造方法，我们通常不会创建对象</li><li>UUID uuid &#x3D; UUID.randomUUID();&#x2F;&#x2F;通常用于数据库表格主键 primary key</li><li>产生一个32位的随机元素 每一个位置是一个16进制的数字</li></ul><h4 id="3-3-BigDecimal"><a href="#3-3-BigDecimal" class="headerlink" title="3.3 BigDecimal"></a>3.3 BigDecimal</h4><ul><li>java.math.BigDecimal类处理大浮点数，需要import导入，继承自Number</li><li>Java浮点数据类型(float和double)在运算时会有舍入误差，如果希望得到精确运算结果，可以使用java.math.BigDecimal类。</li><li>提供的构造方法全部都是带参数的<ul><li>通常利用带String参数的构造方法创建这个类的对象：BigDecimal  bi &#x3D; new BigDecimal(“1.23”);</li></ul></li></ul><table><thead><tr><th>BigDecimal类的常用方法</th><th></th></tr></thead><tbody><tr><td>BigDecimal(String val)</td><td>根据参数指定的字符串来构造对象</td></tr><tr><td>BigDecimal    setScale(int newScale, RoundingMode roundingMode)</td><td>两个参数前面是保留小数点之后的位数，后面参数是设置的模式(向上取整或向下等)</td></tr><tr><td>BigDecimal <strong>add</strong>(BigDecimal augend)</td><td>用于实现<strong>加法</strong>运算</td></tr><tr><td>BigDecimal <strong>subtract</strong>(BigDecimal subtrahend)</td><td>用于实现<strong>减法</strong>运算</td></tr><tr><td>BigDecimal <strong>multiply</strong>(BigDecimal multiplicand)</td><td>用于实现<strong>乘法</strong>运算</td></tr><tr><td>BigDecimal <strong>divide</strong>(BigDecimal divisor)</td><td>用于实现<strong>除法</strong>运算，也可传入更多参数设置保留小数点位数和取值模式</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">d4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;2.9&quot;</span>);</span><br><span class="line">System.out.println(d3.add(d4));<span class="comment">//加：5.9</span></span><br><span class="line">System.out.println(d3.subtract(d4));<span class="comment">//减：0.1</span></span><br><span class="line">System.out.println(d3.multiply(d4));<span class="comment">//乘：8.70</span></span><br><span class="line">System.out.println(d3.divide(d4, <span class="number">8</span>, BigDecimal.ROUND_HALF_UP));<span class="comment">//除：1.03448276</span></span><br></pre></td></tr></table></figure><p>对于divide方法，通常需要制定<strong>精度和舍入模式</strong>，否则当遇到无限小数时，除法会一直进行下去直至抛出异常。</p><h4 id="3-4-BigInteger"><a href="#3-4-BigInteger" class="headerlink" title="3.4 BigInteger"></a>3.4 BigInteger</h4><ul><li>java.math.BigInteger类处理大整数，需要import导入，继承自Number</li><li>java提供的整数类型(int\long)的存储范围有限，当需要进行很大整数运算时可以使用java.math.BigInteger类，理论上其储值范围只受内存容量限制。 </li><li>如何创建对象，提供的构造方法全部都是带参数的<ul><li>通常利用带String参数的构造方法创建这个类的对象：BigInteger  bi &#x3D; new BigInteger(“123”);</li></ul></li><li>和BigDecimal类似，BigInteger也提供add()、substract()、multiply()、divide()等方法。</li></ul><h4 id="3-5-DecimalFormat类"><a href="#3-5-DecimalFormat类" class="headerlink" title="3.5 DecimalFormat类"></a>3.5 DecimalFormat类</h4><ul><li>所属的包 java.text，import导入才能使用</li><li>通过带String参数的构造方法创建一个格式化对象(0:未满会补齐，#：未满不补）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//调用format方法将一个小数格式化成一个字符串</span></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000.000&quot;</span>);</span><br><span class="line">System.out.println(df.format(<span class="number">12.45</span>)); <span class="comment">//012.450</span></span><br><span class="line">System.out.println(df.format(<span class="number">12345.6789</span>)); <span class="comment">//12345.679</span></span><br><span class="line"></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###.###&quot;</span>);</span><br><span class="line">System.out.println(df2.format(<span class="number">12.45</span>)); <span class="comment">//12.45</span></span><br><span class="line">System.out.println(df2.format(<span class="number">12345.6789</span>)); <span class="comment">//12345.679</span></span><br><span class="line"></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000.###&quot;</span>);</span><br><span class="line">System.out.println(df3.format(<span class="number">12.45</span>)); <span class="comment">//012.45</span></span><br><span class="line">System.out.println(df3.format(<span class="number">12345.6789</span>)); <span class="comment">//12345.679    </span></span><br></pre></td></tr></table></figure><h3 id="4-Scanner类和System类"><a href="#4-Scanner类和System类" class="headerlink" title="4. Scanner类和System类"></a>4. Scanner类和System类</h3><h4 id="4-1-Scanner类"><a href="#4-1-Scanner类" class="headerlink" title="4.1 Scanner类"></a>4.1 Scanner类</h4><ol><li>所属的包java.util包  需要import导包</li><li>通过一个带输入流的构造方法创建对象</li><li>常用方法    nextInt()  nextFloat()   next()   nextLine()</li></ol><h4 id="4-1-System类"><a href="#4-1-System类" class="headerlink" title="4.1 System类"></a>4.1 System类</h4><ol><li>所属的包java.lang包 不需要导入</li><li>不需要创建对象  通过类名就可以访问</li><li>有三个属性及若干的方法<ul><li>三个属性out   in   err</li><li>方法：gc()  exit(0);  currentTimeMillis()获取系统当前时间毫秒;</li></ul></li></ol><h3 id="5-日期类"><a href="#5-日期类" class="headerlink" title="5. 日期类"></a>5. 日期类</h3><h4 id="5-1-Date类"><a href="#5-1-Date类" class="headerlink" title="5.1 Date类"></a>5.1 Date类</h4><ul><li>java.util.Date类表示特定的瞬间，精确到毫秒。</li><li>通常使用无参数的构造方法，或者带long构造方法</li><li>Date类中常用的方法<ul><li>before();  after();</li><li>setTime()  getTime();—–&gt;long</li><li>compareTo();   &#x2F;&#x2F;-1  1  0</li></ul></li><li>Date类大多数用于进行时间分量计算的方法已经被Calender取代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//当前日期信息</span></span><br><span class="line">    <span class="comment">//Date类重写了toString方法，输出格式如：Sun Jan 06 11:52:55 CST 2019</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> date.getTime();<span class="comment">//1970年1月1日距今毫秒数。</span></span><br><span class="line">date.setTime(time + <span class="number">24</span>\*<span class="number">60</span>\*<span class="number">60</span>\*<span class="number">1000</span>);<span class="comment">//通过毫秒数设置时间</span></span><br></pre></td></tr></table></figure><h4 id="5-2-SimpleDateFormat类"><a href="#5-2-SimpleDateFormat类" class="headerlink" title="5.2 SimpleDateFormat类"></a>5.2 SimpleDateFormat类</h4><ul><li>java.text.SimpleDateFormat类主要用于实现日期和文本类型之间的转换。是DateFormat(抽象类)的子类</li><li>其构造方法 SimpleDateFormat(String pattern)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">dateStr</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line"><span class="comment">// format用于将日期按指定格式转换为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2013-01-06&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> sdf2.parse(str);<span class="comment">//如果字符串格式不匹配将抛出异常</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>常用格式字符串</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>y</td><td>年</td><td>yyyy年——2013年；yy——13年</td></tr><tr><td>M</td><td>月</td><td>MM月——01月；M月——1月</td></tr><tr><td>d</td><td>日</td><td>dd日——01日；d日——1日</td></tr><tr><td>H</td><td>小时(24)</td><td>HH:mm:ss—12:46:33</td></tr><tr><td>h</td><td>小时(12)</td><td>hh(a):mm:ss—12(下午):47:48</td></tr><tr><td>m</td><td>分钟</td><td>–</td></tr><tr><td>s</td><td>秒</td><td>–</td></tr></tbody></table><h4 id="5-3-Calendar类"><a href="#5-3-Calendar类" class="headerlink" title="5.3 Calendar类"></a>5.3 Calendar类</h4><ul><li>java.util.Calendar类是一个抽象类,主要用于取代Date类中过时的方法来描述年月日时分秒信息。</li><li>有构造方法，用protected修饰的，通常访问不到，通常会调用默认的getInstance();</li><li>通常使用Calendar的静态方法getInstance获得Calendar对象；getInstance方法将根据系统地域信息返回不同的Calendar类的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">c1.set(<span class="number">2008</span>,<span class="number">9</span>-<span class="number">1</span>,<span class="number">20</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">System.out.println(c1.getTime());</span><br></pre></td></tr></table></figure><ul><li><p>常用方法</p><ul><li>after()  before()</li><li>setTime()  getTime()—-&gt;Date</li><li>getTimeInMillis()—-time</li><li>getTimeZone()—TimeZone</li><li>Calendar里面包含一个date属性  可以操作date的某一个局部信息</li><li>set   get<ul><li>calendar.set(Calendar.YEAR,2015);</li></ul><p>  *int year &#x3D; calendar.get(Calendar.YEAR);</p></li></ul></li><li><p>TimeZone</p><ol><li>java.util包</li><li>可以通过calendar对象.getTimeZone()获取 或 TimeZone.getDefault();</li><li>常用方法<ul><li>tz.getID()       —-&gt;    Asia&#x2F;Shanghai</li><li>tz.getDisplayName()    —-&gt;  中国标准时间</li></ul></li></ol></li></ul><h3 id="6-String类"><a href="#6-String类" class="headerlink" title="6. String类"></a>6. String类</h3><h4 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h4><ul><li>String类 —&gt; 引用类型  —&gt; java.lang包</li><li>没有任何继承关系，实现三个接口Serializable, CharSequence, Comparable<String></li><li>java.lang.String类用于描述字符串数据，java程序中所有的字符串字面值都可以使用String类的实例(对象)加以描述，如”abc”等，任何一个字符对应2字节定长编码。</li><li>String类由final关键字修饰表示该类不能被继承，该类描述的字符串内容是常量，一旦创建无法更改，因此可以被共享。对字符串重新赋值不是改变其内容，而是改变引用的指向。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何构建对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//直接将字符串常量赋值给str   (字符串常量池)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//无参数构造方法创建空的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//带string参数的构造方法创建对象</span></span><br><span class="line"><span class="type">byte</span>[] bArr = &#123;<span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;;<span class="comment">//a:97，b:98，c:99，d:100</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bArr);<span class="comment">//将数组中的每一个元素转化成对应的char 组合成String</span></span><br><span class="line"><span class="type">char</span>[] cArr = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cArr);<span class="comment">//将数组中的每一个char元素拼接成最终的String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> String(<span class="type">char</span>[], index, count);<span class="comment">//使用char数组中下标从index位置开始的count个字符来构造对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str7</span> <span class="operator">=</span> String(<span class="type">byte</span>[], index, length);<span class="comment">//使用byte数组下标从index位置开始length个字节来构造对象</span></span><br></pre></td></tr></table></figure><h4 id="6-2-字符串常量池"><a href="#6-2-字符串常量池" class="headerlink" title="6.2 字符串常量池"></a>6.2 字符串常量池</h4><ul><li>由于String类型对象描述的字符串内容是个常量，若多个相同的内容单独存储会造成时间和空间的浪费。</li><li>出于性能考虑，Java虚拟机(JVM)将<strong>字符串字面量对象</strong>缓存在常量池中；对于重复出现的字符串直接量，JVM会首先在缓存池中查找，如果存在即返回该对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//比较地址 true，不会重新创建</span></span><br><span class="line">System.out.println(str1.equals(str3));<span class="comment">//比较内容 true</span></span><br><span class="line">System.out.println(str1==str3);<span class="comment">//比较地址 false，使用new会重新创建新的String对象</span></span><br><span class="line">    <span class="comment">//1.下面的代码中创建了几个对象并分别存放在什么位置？</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>; <span class="comment">//1个对象，常量池。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;world&quot;</span>); <span class="comment">//2个对象，1个在常量池，1个new后在堆区(内容为常量池里的副本)</span></span><br></pre></td></tr></table></figure><h4 id="6-3-String类常用方法"><a href="#6-3-String类常用方法" class="headerlink" title="6.3 String类常用方法"></a>6.3 String类常用方法</h4><ol><li>第一梯队(重写): equals  hashCode  compareTo  toString</li><li>第二梯队(常用):charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，split()，replace()，length()，concat()，contains()， trim()，getBytes()， toCharArray()，matches()。</li><li>第三梯队(一般):toUpperCase()，toLowerCase()，startsWith()，endsWith()，isEmpty()。</li></ol><ul><li>重写了equals(obj)，hashCode()，toString()方法，compareTo(str)方法实现自Comparable接口<ol><li>boolean &#x3D; equals(Object obj);<ul><li>继承自Object类中的方法，重写后改变了规则，比较字符串中的字面值（&#x3D;&#x3D;与equals()区别）;</li></ul></li><li>int &#x3D; hashCode();<ul><li>继承自Object类中的方法，重写了：31*h+和…</li></ul></li><li>int &#x3D; compareTo();<ul><li>实现自Comparable接口，实现方法：结果按照字典排布(unicode编码)顺序，按照两个字符串的长度较小的那个(次数)来进行循环，若每次的字符不一致 则直接返回code之差，若比较之后都一致  则直接返回长度之差</li></ul></li><li>String &#x3D; toString()<ul><li>Object类中返回类名@hashCode(16进制形式)</li><li>String类重写后返回的是String对象的字面值</li></ul></li></ol></li></ul><blockquote><p>忽略大小写比较：equalsIgnoreCase(), compareToIgnoreCase();</p></blockquote><table><thead><tr><th>String类的成员方法</th><th></th></tr></thead><tbody><tr><td>char charAt(int index)</td><td>返回字符串指定位置</td></tr><tr><td>int codePointAt(int index)</td><td>“abc”0–&gt;97，返回给定index对应位置的那个char所对应的code码</td></tr><tr><td>String concat(String)</td><td>将给定的字符串拼接在当前字符串之后</td></tr><tr><td>int length()</td><td>返回字符串序列的长度</td></tr></tbody></table><blockquote><p>注意：区别数组的length是属性，String的length()是方法，集合是size()方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;下标为0的字符是：&quot;</span>+str6.charAt(<span class="number">0</span>));<span class="comment">// h</span></span><br><span class="line">System.out.println(<span class="string">&quot;字符串长度是：&quot;</span>+str6.length());<span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串&quot;12345&quot;转换为整数类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">//方式一：Integer类中的pareseInt方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ia</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">System.out.println(<span class="string">&quot;转换出来结果是：&quot;</span>+ ia);<span class="comment">//123456</span></span><br><span class="line">    <span class="comment">//方式二：利用ASCII数值进行转换&#x27;1&#x27;-&#x27;0&#x27;=1，&#x27;2&#x27;-&#x27;0&#x27;=2，...</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++)&#123;</span><br><span class="line">    res = res*<span class="number">10</span> + (str.charAt(i)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;转换出来结果是：&quot;</span>+ res);<span class="comment">//123456</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>String类的常用基本方法</th><th></th></tr></thead><tbody><tr><td>boolean contains(CharSequence s)</td><td>判断当前字符串是否包含参数指定的内容</td></tr><tr><td>String toLowerCase()</td><td>返回小写形式</td></tr><tr><td>String toUpperCase()</td><td>返回大写形式</td></tr><tr><td>String trim()</td><td>返回去掉前后空格的字符串</td></tr><tr><td>boolean startsWith(String prefix)</td><td>判断是否以参数字符开头</td></tr><tr><td>boolean endsWith(String suffix)</td><td>判断是否以参数字符结尾</td></tr><tr><td>boolean equals(Object anObject)</td><td>比较字符串内容是否相等，String类已重写</td></tr><tr><td>boolean equalsIgnoreCase(String anotherString)</td><td>同上，并且忽略大小写</td></tr><tr><td>int indexOf(String str)</td><td>返回第一次出现str位置，找不到返回-1</td></tr><tr><td>int indexOf(String str, int fromIndex)</td><td>同上，从fromIndex开始检索</td></tr><tr><td>String substring(int beginIndex, int endIndex)</td><td>截取字符串，beginIndex开始，endIndex结束</td></tr><tr><td>String substring(int beginIndex)</td><td>截取字符串，beginIndex开始到结尾</td></tr></tbody></table><h4 id="6-4-正则相关方法"><a href="#6-4-正则相关方法" class="headerlink" title="6.4 正则相关方法"></a>6.4 正则相关方法</h4><ul><li>正则表达式本质就是一个字符串，用于对用户输入数据的格式进行验证。</li></ul><table><thead><tr><th>正则相关方法</th><th></th></tr></thead><tbody><tr><td>boolean matches(String regex)</td><td>用于判断是否匹配正则表达式规则。</td></tr><tr><td>String[] split(String regx)</td><td>以正则为分割符，将字符串拆分成字符串数组</td></tr><tr><td>String replaceAll(String regex, String replacement)</td><td>正则替换</td></tr></tbody></table><h3 id="7-StringBuilder类-x2F-StringBuffer类"><a href="#7-StringBuilder类-x2F-StringBuffer类" class="headerlink" title="7. StringBuilder类&#x2F;StringBuffer类"></a>7. StringBuilder类&#x2F;StringBuffer类</h3><h4 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h4><ol><li>java.lang.StringBuilder类和java.lang.StringBuffer类描述的字符串内容是个可以改变的字符串序列。</li><li>StringBuffer和StringBuilder继承AbstractStringBuilder间接继承 Object，实现接口Serializable,CharSequence,Appendable<ul><li>StringBuffer&#x2F;StringBuilder没有compareTo方法</li><li>StringBuffer&#x2F;StringBuilder含有一个String没有的方法 append();拼接</li></ul></li></ol><h4 id="7-2-特性"><a href="#7-2-特性" class="headerlink" title="7.2 特性"></a>7.2 特性</h4><p>可变字符串，char[] value;  动态扩容</p><h4 id="7-3-对象的构建"><a href="#7-3-对象的构建" class="headerlink" title="7.3 对象的构建"></a>7.3 对象的构建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//无参数构造方法  构建一个默认长度16个空间的对象  char[]</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//利用给定的参数 构建一个自定义长度空间的对象 char[]</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//利用带String参数的构造方法  默认数组长度字符串长度+16个</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="7-4-StringBuilder中常用的方法"><a href="#7-4-StringBuilder中常用的方法" class="headerlink" title="7.4 StringBuilder中常用的方法"></a>7.4 StringBuilder中常用的方法</h4><ul><li>最主要的方法 <strong>append()</strong> 频繁的拼接字符串的时候使用此方法 提高性能</li><li>ensureCapacity(int minimumCapacity)  确保底层数组容量够用</li><li>capacity();&#x2F;&#x2F;字符串底层char[]的容量</li><li>length();&#x2F;&#x2F;字符串有效元素个数(长度)</li><li>setLength();&#x2F;&#x2F;设置字符串的有效元素个数</li><li>char &#x3D; charAt(int index);</li><li>int &#x3D; codePointAt(int index);</li><li>String &#x3D; substring(int start [,int end]);&#x2F;&#x2F;注意需要接受返回值 看见截取出来的新字符串效果</li><li>StringBuilder &#x3D; delete(int start [,int end]);&#x2F;&#x2F;StringBuilder类中独有的方法String类没有，将start到end之间的字符串删掉  不用接受返回值就看到效果啦</li><li>StringBuilder &#x3D; deleteCharAt(int index);&#x2F;&#x2F;String类中没有的方法，将给定index位置的某一个字符删除掉啦</li><li>int &#x3D; indexOf(String str [,int fromIndex]);</li><li>int &#x3D; lastIndexOf(String str [,int fromIndex]);&#x2F;&#x2F;找寻给定的str在字符串中第一次出现的索引位置  带重载 则从某一个位置开始找</li><li>insert(int index,value);&#x2F;&#x2F;将给定的value插入在index位置之上</li><li>replace(int start,int end,String str);&#x2F;&#x2F;将start和end之间的部分替换成str, builder.replace(2,5,”zzt”);</li><li>setCharAt(int index,char value);&#x2F;&#x2F;将index位置的字符改成给定的value</li><li>toString();&#x2F;&#x2F;将StringBuilder对象 构建成一个string对象 返回</li><li>trimToSize();&#x2F;&#x2F;将数组中无用的容量去掉  变成length长度的数组</li></ul><h4 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h4><ol><li>StringBuilder类不一定需要，是为了避免String频繁拼接修改字符串信息的时候才用的，底层数组是可变的，提高了性能；</li><li>常用方法<ul><li>与String类不同的独有方法：append()，insert()，delete()，deleteCharAt()，reverse()；</li><li>与String类相同的方法：length()，charAt()，codePointAt()，indexOf()，lastIndexOf()，substring()，replace()；名字相同 用法不一致</li><li>不是很常用的方法：ensureCapacity()，capacity()，setLength()，trimToSize()，setCharAt();</li></ul></li><li>String家族笔试中经常容易考察的知识点</li><li>String所属的包 继承关系 实现接口<ul><li>java.lang 继承Object 接口Serializable,CharSequence,Comparable</li></ul></li><li>String构建方式<ul><li>常量  构造方法</li></ul></li><li>String对象内存结构<ul><li>字符串常量区  new堆内存对象</li><li>&#x3D;&#x3D;  equals()区别</li><li>“a”+”b”+”c”</li></ul></li><li>String不可变特性<ul><li>长度及内容</li></ul></li><li>String中的常用方法<ul><li>concat();  toUpperCase();</li></ul></li><li>String和StringBuilder区别   |   String和StringBuffer区别<ul><li>String不可变字符串<ul><li>JDK1.0</li><li>有一个接口Comparable</li><li>不可变体现在长度及内容</li><li>有一些方法StringBuilder没有 concat  compareTo  toUpperCase</li></ul></li><li>StringBuilder可变字符串<ul><li>JDK1.5</li><li>有一个接口Appendable</li><li>可变字符串  没有final修饰  底层可以进行数组扩容</li><li>有一些方法String没有  append() insert() delete() reverse()</li></ul></li></ul></li><li>StringBuffer和StringBuilder的不同<ul><li>它们方法基本相同</li><li>StringBuffer早期版本1.0，早期版本，线程同步，安全性比较高，执行效率相对较低</li><li>StringBuilder后来的版本1.5，后期版本，线程非同步，安全性比较低，执行效率相对较高</li></ul></li></ol><h3 id="8-Optional类"><a href="#8-Optional类" class="headerlink" title="8. Optional类"></a>8. Optional类</h3><ul><li>可能包含或不包含非空值的容器对象。 如果一个值存在， isPresent()将返回true和get()将返回值。</li><li>获取字符串长度：<ol><li>方式1：if(null&#x3D;&#x3D;str){return 0;}else{return str.length();}</li><li>方式2：return Optional.ofNullable(str).map(String::length).orElse(0);</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取两个字符串长度和</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">str1Length</span> <span class="operator">=</span> Optional.ofNullable(str1).map(String::length).orElse(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">str2Length</span> <span class="operator">=</span> Optional.ofNullable(str2).map(String::length).orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(str1Length + str2Length);<span class="comment">//8，8+0</span></span><br><span class="line"><span class="comment">//步骤分解:</span></span><br><span class="line"><span class="comment">//构建Optional对象</span></span><br><span class="line">Optional&lt;String&gt; op1 = Optional.ofNullable(str1);</span><br><span class="line"><span class="comment">//将str1的长度的结果构建成Optional对象</span></span><br><span class="line">Optional&lt;Integer&gt; op2 = op1.map(String::length);</span><br><span class="line"><span class="comment">//如果长度不为空，则获取长度值，否则返回默认值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> op2.orElse(<span class="number">0</span>);</span><br><span class="line">System.out.println(len);<span class="comment">//8</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」面向对象</title>
      <link href="/2017/04/10/java-object.html"/>
      <url>/2017/04/10/java-object.html</url>
      
        <content type="html"><![CDATA[<p>面向对象是相对于面向过程而言，过程其实就是函数，对象是将函数和属性进行了封装。<br><code>Java</code>中的面向对象（<code>Object Oriented</code>）是一种新兴的程序设计方法，或者是一种新的程序设计规范(<code>paradigm</code>)，其基本思想是使用对象、类、继承、封装、多态等基本概念来进行程序设计。</p><span id="more"></span><h3 id="1-类与对象"><a href="#1-类与对象" class="headerlink" title="1. 类与对象"></a>1. 类与对象</h3><h4 id="1-1-类的定义"><a href="#1-1-类的定义" class="headerlink" title="1.1 类的定义"></a>1.1 类的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;类体&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类名由多个单词组成时，要求每个单词首字母大写</p></blockquote><h4 id="1-2-成员变量的定义"><a href="#1-2-成员变量的定义" class="headerlink" title="1.2 成员变量的定义"></a>1.2 成员变量的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123; 数据类型 成员变量名=初始值; ... &#125;</span><br></pre></td></tr></table></figure><blockquote><p>成员变量名由多个单词组成时，要求第二个起每个单词首字母大写</p></blockquote><h4 id="1-3-对象的创建"><a href="#1-3-对象的创建" class="headerlink" title="1.3 对象的创建"></a>1.3 对象的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><blockquote><p>当一个类定义完毕后使用new关键字创建&#x2F;构造该类的对象的过程叫做类的实例化。</p></blockquote><h4 id="1-4-引用"><a href="#1-4-引用" class="headerlink" title="1.4 引用"></a>1.4 引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名 引用变量名;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(); <span class="comment">//声明person类型的引用p指向Person类型对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">引用变量名.成员变量名;</span><br><span class="line">p.name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>在JAVA中，使用引用数据类型声明的变量叫做引用变量，简称‘引用’。</li><li>使用引用可以记录对象在堆区中存放的内存地址信息，便于下次访问。</li></ul></blockquote><ul><li>除八种基本类型之外，用类名（接口，数组）声明的变量称为引用类型变量，引用类型变量存的某个对象的地址信息，引用的功能在于访问对象。</li></ul><h4 id="1-5-成员方法"><a href="#1-5-成员方法" class="headerlink" title="1.5 成员方法"></a>1.5 成员方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123;</span><br><span class="line">    返回值类型 成员方法名(形参列表)&#123;方法体;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型：可以是基本数据类型，也可以是引用，当方法不需要返回数据用void</li><li>形参列表：数据类型 形参1, 数据类型 形参2, …</li></ul><h3 id="2-构造方法和方法重载"><a href="#2-构造方法和方法重载" class="headerlink" title="2. 构造方法和方法重载"></a>2. 构造方法和方法重载</h3><h4 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &#123; 构造方法名(形参列表)&#123;构造方法体;&#125; &#125;</span><br></pre></td></tr></table></figure><ul><li>构造方法名与类名相同且没有返回值</li><li>当使用new关键字构造对象时，会自动调用构造方法，实现成员变量的初始化工作。</li></ul><h4 id="2-2-默认构造方法"><a href="#2-2-默认构造方法" class="headerlink" title="2.2 默认构造方法"></a>2.2 默认构造方法</h4><ul><li>当一个类中没有没有自定义任何构造方法时，编译器会提供一个无参的空构造方法，叫做默认&#x2F;缺省构造方法。</li><li>若类中出现自定义构造方法，则编译器不再提供构造方法。</li></ul><h4 id="2-3-方法重载（overload）"><a href="#2-3-方法重载（overload）" class="headerlink" title="2.3 方法重载（overload）"></a>2.3 方法重载（overload）</h4><p>在Java中，方法名相同，参数列表不同的方法构成重载关系。</p><ul><li>体现形式：参数个数，参数顺序，参数类型。（与形参变量名和返回值无关，但最好返回值类型相同）</li><li>实际意义：调用者只需要记住一个方法名就可以不同的版本，从而实现不同的效果。</li></ul><h4 id="2-4-this关键字"><a href="#2-4-this关键字" class="headerlink" title="2.4  this关键字"></a>2.4  this关键字</h4><p>在构造方法中出现this时,this代表当前正在构造的对象；在成员方法中出现this,this代表当前正在调用的对象。</p><ul><li>使用方式：<ol><li>当形参变量和成员变量同名时，在方法体中优先使用形参变量，若希望使用成员变量，则需要加上this，即this.变量名</li><li>在构造方法的的第一行，可以调用本类中的其他构造方法。</li></ol></li></ul><h4 id="2-5-封装"><a href="#2-5-封装" class="headerlink" title="2.5 封装"></a>2.5 封装</h4><p>面向对象的三大特征：封装，继承，多态。</p><ul><li>封装基本概念：封装就是对成员变量的数值进行密封包装处理以及合理性判断</li><li>封装基本流程：<ol><li>私有化成员变量(private)</li><li>提供公有的get、set方法，并在set方法体中进行合理性判断</li><li>在构方法中调用set方法进行合理值的判断</li></ol></li></ul><h4 id="2-6-static关键字"><a href="#2-6-static关键字" class="headerlink" title="2.6 static关键字"></a>2.6 static关键字</h4><p>基本概念：通常情况下成员变量隶属于对象层级，也就是每创建一个对象就会申请一块独立的内存空间来存储就会造成内存空间的浪费。</p><blockquote><p>为了解决上诉问题，Java中使用static关键字修饰该成员变量表达静态的含义，此时成员变量提升到类层级，所有对象共享，随着类的加载准备就绪，与对象创建再无关。</p></blockquote><ul><li>static可以修饰：修饰属性 修饰方法 修饰块 修饰类(内部类)</li><li>特点<ul><li>静态元素在类加载时就初始化，此时还没创建对象，可以通过类名直接访问</li><li>静态元素存储在静态元素区，每个类有一个自己的区域，与别的类不冲突</li><li>静态元素只加载一次，全部类对象及类本身共享</li><li>静态元素区Carbage Collection无法管理，可以粗暴理解为常驻内存</li><li>非静态成员和静态成员都可以访问静态成员</li><li>静态成员不可以访问非静态成员</li><li>静态元素中不可出现this或super关键字，静态元素属于类的</li></ul></li></ul><h3 id="3-方法的传递和递归"><a href="#3-方法的传递和递归" class="headerlink" title="3. 方法的传递和递归"></a>3. 方法的传递和递归</h3><h4 id="3-1-传参"><a href="#3-1-传参" class="headerlink" title="3.1 传参"></a>3.1 传参</h4><ul><li>基本数据类型变量作为参数传递时，型参数值改变不会影响实参变量的数值。</li><li>引用类型变量作为参数传递时，形参指向内容的改变会影响实参变量指向的内容。</li><li>引用数据类型变量作为参数传递时，形参改变指向后再改变指向内容不会影响实参指向的内容。</li></ul><h4 id="3-2-递归的调用"><a href="#3-2-递归的调用" class="headerlink" title="3.2 递归的调用"></a>3.2 递归的调用</h4><ul><li>递归是指方法体内部调用自身</li><li>必须有递归的规律和退出条件</li><li>使用递归必须使得问题简单化而不是复杂化</li><li>若递归影响到程序的执行性能时，则用递推取代之</li></ul><h3 id="4-单例设计模式"><a href="#4-单例设计模式" class="headerlink" title="4. 单例设计模式"></a>4. 单例设计模式</h3><p>基本概念：当一个类有且只能对外提供一个对象时，这样的类就叫作单例类，而设计单例类的思想和模式，叫做单例设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编程实现Singleton类的封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">sin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();<span class="comment">//2.提供本类的引用指向本类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125; <span class="comment">//1.私有化构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;<span class="comment">//3.提供公有的get方法将上述成员变量的数值返回出去</span></span><br><span class="line">        <span class="keyword">return</span> sin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现流程：<ol><li>私有化构造方法（private）</li><li>提供本类类型的引用指向本类类型对象（private static）</li><li>提供公有的get方法将上述对象return出去（public static）</li><li>实现方式：饿汉式和懒汉式，开发中推荐饿汉式。</li></ol></li></ul><h3 id="5-继承（extends）"><a href="#5-继承（extends）" class="headerlink" title="5. 继承（extends）"></a>5. 继承（extends）</h3><ul><li>继承就是子类复用父类的代码，关键字extends表示类和类的继承关系</li><li>使用继承可以提高代码复用性、扩展性、以及可维护性。<ol><li>子类不能继承父类的构造方法和私有方法，私有成员变量可以继承但不能直接使用。</li><li>无论使用何种方式构造方式构造子类的对象都会自动调用父类的无参构造方法来初始化从父类中继承下来的成员变量，相当于在构造方法的第一行增加super()的效果。</li><li>使用继承必须满足逻辑关系：子类 is a 父类，不能滥用继承。</li><li>在Java中只能支持单继承，也就是一个一个子类只能有一个父类，但一个父类可以有多个子类。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cricle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    Cricle()&#123;&#125;   <span class="comment">//编译器会加入无参的调用 super()。</span></span><br><span class="line">    Cricle(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> r)&#123;</span><br><span class="line">        <span class="built_in">super</span>(x, y);  <span class="comment">//通过super关键字调用父类的构造方法。</span></span><br><span class="line">        setR(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setR</span><span class="params">(<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-方法的重写（Override）"><a href="#6-方法的重写（Override）" class="headerlink" title="6. 方法的重写（Override）"></a>6. 方法的重写（Override）</h3><p>概念：从父类继承下来的方法不满足子类的需求时，就需要子类中重新写一个和父类一样的方法，覆盖从父类中继承下来的版本，该方法就叫方法的重写。<br><br>原则：</p><ol><li>要求方法名相同，参数列表相同，返回值类型相同；jdk1.5开始返回子类类型。</li><li>要求访问权限不能变小，可以相同或变大</li><li>重写的方法不能抛出更大的异常</li></ol><h3 id="7-访问控制"><a href="#7-访问控制" class="headerlink" title="7. 访问控制"></a>7. 访问控制</h3><ul><li>public修饰的内容可以在任意位置使用，private修饰的内容只能在本类中使用，</li><li>通常情况下，成员变量都使用private修饰，成员方法都使用pubic修饰</li></ul><table><thead><tr><th>访问控制符</th><th align="center">访问权限</th><th align="right">本类内部</th><th align="right">本类中的包</th><th align="right">子类</th><th align="right">其他包</th></tr></thead><tbody><tr><td>public</td><td align="center">共有的</td><td align="right">Y</td><td align="right">Y</td><td align="right">Y</td><td align="right">Y</td></tr><tr><td>protected</td><td align="center">保护的</td><td align="right">Y</td><td align="right">Y</td><td align="right">Y</td><td align="right">N</td></tr><tr><td>不写</td><td align="center">默认的</td><td align="right">Y</td><td align="right">Y</td><td align="right">N</td><td align="right">N</td></tr><tr><td>private</td><td align="center">私有的</td><td align="right">Y</td><td align="right">N</td><td align="right">N</td><td align="right">N</td></tr></tbody></table><h3 id="8-包（Package）"><a href="#8-包（Package）" class="headerlink" title="8. 包（Package）"></a>8. 包（Package）</h3><p>为了解决命名冲突问题，便于文件的管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名；</span><br><span class="line"><span class="keyword">package</span> 包名<span class="number">1.</span>包名<span class="number">2.</span>包名<span class="number">3.</span>..包名n;</span><br><span class="line"><span class="comment">/* 指定包名时应按照一定的规范，eg: 公司域名反写.项目名称.模块名称.类名 */</span></span><br><span class="line">org.apache.commons.lang.StringUtil;</span><br></pre></td></tr></table></figure><h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9. final关键字"></a>9. final关键字</h3><ol><li>final关键字修饰<strong>类</strong>体现该类<strong>不能被继承</strong>（防止滥用继承）。</li><li>final关键字修饰<strong>方法</strong>体现在该方法<strong>不能被重新，但可以被继承</strong>（防止不经意间造成的方法重写）。</li><li>final关键字修饰<strong>成员变量</strong>体现在改成员变量<strong>必须初始化且不能更改</strong>（防止不经意间造成的数据更改）。</li></ol><blockquote><p>扩展：在开发中很少单独使用static或者final单独修饰成员变量，而是使用**<code>public static final</code>**共同修饰成员变量来表达常量的含义，而常量的命名规范是：所有字母大写，不同单词之间下划线连接。</p></blockquote><h3 id="10-对象的创建过程"><a href="#10-对象的创建过程" class="headerlink" title="10. 对象的创建过程"></a>10. 对象的创建过程</h3><ul><li>单个对象的创建过程<ol><li>main方法是程序的入口，若创建对象时没有指定初始值则采用默认初始化方式处理；</li><li>若声明成员变量时进行了显示初始化操作，则最终采用显示初始化的初始值处理；</li><li>执行构造块中的代码可以对成员变量进行赋值；</li><li>执行构造方法体中的代码可以对成员变量进行再次赋值；</li><li>此时对象构造完毕，继续向下执行后续的代码；</li></ol></li><li>子类对象的创建过程<ol><li>main方法是程序的入口，先加载父类的的代码再加载子类的代码；</li><li>先执行父类静态代码块，再执行子类的静态代码块；</li><li>先执行父类的构造块，再执行父类的构造方法体，此时包含的父类对象构造完毕；</li><li>先执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕，继续向下执行后续代码。</li></ol></li></ul><h3 id="11-多态"><a href="#11-多态" class="headerlink" title="11. 多态"></a>11. 多态</h3><ol><li>语法：父类的引用指向子类的对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类类型 引用变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line"><span class="type">Person</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">pw.show();<span class="comment">//再编译阶段调用Person的show()方法，在运行阶段调用Worker的show()方法。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>多态的效果：<ol><li>父类的引用<strong>可以</strong>直接调用<strong>父类独有</strong>的方法。</li><li>父类的引用<strong>不可以</strong>直接调用<strong>子类独有</strong>的方法。</li><li>对于父类子类都有的<strong>非静态方法</strong>来说，编译阶段调用父类的，运行阶段调用子类重写后的。</li><li>对于父类子类都有的<strong>静态方法</strong>来说，只调用父类的。</li></ol></li><li>多态的实际意义：屏蔽不同子类的差异性实现通用的编程，从而带来不同的结果。</li><li>多态的表现形式<ol><li>多态的前提要有继承的关系</li><li>使用父类引用指向子类对象 Person p &#x3D; new Teacher();&#x2F;&#x2F;向上转型</li><li>该引用只能调用父类中定义的属性&#x2F;方法</li><li>执行结果，如果调用属性:执行父类的，如果调用方法:看子类是否重写</li><li>若想要调用子类独有的成员，将身份还原回去(向下转型&#x2F;造型)，若需要转换的类型与真实对象类型不匹配，会产生一个运行时异常ClassCastException</li></ol></li><li>引用数据类型之间的转换<ul><li>转换必须发生在父子类之间，否则编译报错。</li><li>自动类型转换：小到大，子类型向父类型的转换，eg:<code>Person pw = new Worker();</code>。</li><li>强制类型转换：大到小，父类型向子类型转换，eg:<code>((Worker) pw).getSalary();//将父类引用强制转换子类型调用子类方法</code>。</li></ul></li><li>为了避免类型转换异常，对象进行强制类型转换时应该用instanceof判断引用变量真正指向的对象是否是要转换的目标类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*语法格式：*/</span> 对象 <span class="keyword">instanceof</span> 类型  <span class="comment">//返回布尔值</span></span><br><span class="line"><span class="keyword">if</span>(pw <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">t</span> <span class="operator">=</span> (Teacher) pw;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;转换会有异常&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>多态的使用场合：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过方法的参数传递形成多态。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(Shape s)</span>&#123;&#125;</span><br><span class="line">TestShape.draw(<span class="keyword">new</span> <span class="title class_">Rect</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在方法体中直接使用多态的语法格式。</span></span><br><span class="line"><span class="type">TestAbstrat</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubTestAbstract</span>();</span><br><span class="line">ta.show();</span><br></pre></td></tr></table></figure><h3 id="12-抽象类"><a href="#12-抽象类" class="headerlink" title="12. 抽象类"></a>12. 抽象类</h3><ol><li>基本概念<ul><li>用<strong>abstract</strong>关键字修饰的类称为抽象类。</li><li>抽象类不能实例化，抽象类的意义在于被继承。</li><li>抽象类为其子类“抽象”出了公共部分，通常也定义了子类所必须具体实现的抽象方法。</li><li>抽象方法：指不能具体实现的方法，没有方法体并使用abstract修饰。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span>&#123; <span class="comment">//一个类若定义了抽象方法，则必须以abstract关键字声明为抽象类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;<span class="comment">//用abstract修饰的方法，称之为抽象方法，没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>注意：<ol><li>抽象类中可以有成员变量，成员方法，以及构造方法。</li><li>抽象类中可以没有抽象方法，也可以有抽象方法。</li><li>具有抽象方法的类必须是抽象类，因此其真正意义的抽象类应该是有抽象方法，并且使用abstract修饰。</li><li>子类必须实现抽象方法（不同子类可能有不同实现），否则改子类也变抽象。</li><li>抽象类对子类具有强制性和规范性，因此叫做模板设计模式。</li><li>推荐使用多态的语法格式实现抽象类，若需要更换子类时，该方法中只需要将new关键字后面的类型名称修改而其他位置无需改变就可以立即生效，从而提高了代码的维护性和扩展性。</li></ol></li></ol><blockquote><p>多态实现抽象类的缺点：若希望调用子类独有的方法时，则需要强制类型转换。</p></blockquote><h3 id="13-接口"><a href="#13-接口" class="headerlink" title="13. 接口"></a>13. 接口</h3><ol><li>基本概念：接口可以看成是特殊的抽象类。即只包含抽象方法的抽象类。通过<strong>interface</strong>关键字定义。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span> &#123; <span class="comment">//-通过interface关键字定义接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> SEF_SPEED=<span class="number">100</span>;<span class="comment">//-接口中不能定义成员变量，只能定义常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;<span class="comment">//-接口中只可以定义没有实现的方法（可以省略public abstract）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>一个类可以通过<strong>implements</strong>关键字实现接口，一个类可以实现多个接口，并且该类需要实现这些接口中定义的所有方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">American</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>,... &#123; <span class="comment">//与继承不同，可以实现多个接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//该类需要实现接口中定义的所有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;run...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runner</span> <span class="variable">ra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">American</span>();<span class="comment">//接口作为一种类型声明，并且声明的变量可以引用实现类的对象</span></span><br><span class="line">        ra.run();<span class="comment">//通过该变量可以调用该接口定义的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>一个接口可以通过extends关键字继承另一个接口，子接口继承了父接口所有的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Hunter</span> <span class="keyword">extends</span> <span class="title class_">Runner</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>类与接口的关系<ul><li>类和类使用<code>extends</code>继承，仅支持<strong>单继承</strong>。</li><li>接口和接口使用<code>extends</code>继承，支持多继承。</li><li>类使用<code>implements</code>实现接口，支持<strong>多实现</strong>。</li></ul></li><li>抽象类与接口的关系（笔试题）<ol><li>定义抽象类:<code>abstract class</code>，而定义接口:<code>interface</code>；</li><li>类继承抽象类:<code>extends</code>单继承，而类实现接口:<code>implements</code>多实现；</li><li>抽象类可以<code>有</code>构造方法，而接口<code>不能有</code>构造方法；</li><li>抽象类可以有<code>成员变量</code>，而接口只能有<code>常量</code>；</li><li>抽象类可以有<code>成员方法</code>，而接口只能有<code>抽象方法</code>；</li><li>抽象类中增加方法子类可以<code>不用重写</code>，而接口中增加方法子类<code>必须重写</code>；</li><li>从jdk1.8开始允许接口中有非抽象方法，但需要<code>default</code>关键字修饰。</li></ol></li></ol><h3 id="14-内部类"><a href="#14-内部类" class="headerlink" title="14. 内部类"></a>14. 内部类</h3><ul><li>内部类指的是在Java中可以将一个类定义在另一个类定义在另一个类的内部</li><li>内部类定义在 类的内部 ，与类成员层次一致</li><li>内部类定义在 方法&#x2F;块内部（与类成员相差一个层次，方法的局部变量一个层次）<ul><li>成员内部类：将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li><li>局部内部类：将一个类定义在方法&#x2F;块里面，作为成员的内部结构，与临时的局部变量一个层次</li><li>匿名内部类：成员匿名内部类，局部匿名内部类</li><li>静态内部类：成员静态内部类</li></ul></li></ul><h4 id="14-1-成员内部类"><a href="#14-1-成员内部类" class="headerlink" title="14.1 *成员内部类"></a>14.1 *成员内部类</h4><ul><li>将一个类直接定义在类的里面，作为成员，与属性或方法层次一致</li><li>成员内部类可以与正常类一样 使用不同的修饰符来修饰</li><li>好处1.省略了一个.java文件  好处2.成员内部类中可以访问外部类的所有成员 包括私有的</li><li>若想要在内部类中通过对象.调用外部类成员   外部类.this.外部类成员;</li><li>内部类存在后 源代码进行编译 产生一个字节码  Demo$InnerDemo.class</li></ul><h4 id="14-2-局部内部类"><a href="#14-2-局部内部类" class="headerlink" title="14.2 局部内部类"></a>14.2 局部内部类</h4><ul><li>将一个类定义在方法&#x2F;块里面，作为成员的内部结构，与临时的局部变量一个层次</li><li>局部内部类像是一个局部的变量一样，不能用public protected private及static</li><li>只能用abstract或final</li><li>局部内部类命名规则Demo$1InnerTestMethod   Demo$2InnerTestMethod</li><li>局部内部类使用的变量只能是final修饰</li></ul><h4 id="14-3-匿名内部类"><a href="#14-3-匿名内部类" class="headerlink" title="14.3 *匿名内部类"></a>14.3 *匿名内部类</h4><p>将类直接定义在类中 或者类成员中     成员匿名内部类   局部匿名内部类<br><br>匿名内部类没有类的所有结构(名字 修饰符) 只有类体<br><br>通常会在抽象类或接口创建的后面使用，当然具体的类也可以有匿名子类<br><br>匿名类内部没有构造方法，也不能用任何修饰符来修饰</p><ul><li>当接口类型的引用作为方法的形参时，实参的传递方式有两种：<ol><li>自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递。</li><li>直接使用匿名内部类的语法格式得到接口类型的引用，再作为实参传递。</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-方式1：自定义类实现接口并重写抽象方法，然后创建该类的对象作为实参传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubA</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里自定义类实现接口并重写抽象方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ATest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span> &#123;</span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ATest.test(new A());//报错，A是接口，不能new对象</span></span><br><span class="line">        <span class="comment">//-方式1：接口实现类的对象作为实参传递</span></span><br><span class="line">        ATest.test(<span class="keyword">new</span> <span class="title class_">ASub</span>());<span class="comment">//接口类型引用指向实现类的对象，形成了多态。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//-方式2：匿名内部类</span></span><br><span class="line">        <span class="comment">// 接口/父类类型 引用变量名 = new 接口/父类类型() &#123;方法的重写&#125;;</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是匿名内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ATest.test(ta);<span class="comment">//得到接口类型的引用，再作为实参传递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>匿名内部类定义：如果在一段程序需要创建一个类的对象（通常这个类需要实现某个接口或继承某个类），而且对象创建后这个类的价值就不存在了，这个类不必命名，称之为匿名内部类。</li><li>语法格式：<code>接口/父类类型 引用变量名 = new 接口/父类类型() &#123;匿名类类体，这里重写方法&#125;;</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SuperType</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperType</span>(...)&#123; ... &#125;;</span><br></pre></td></tr></table></figure><h4 id="14-4-静态内部类"><a href="#14-4-静态内部类" class="headerlink" title="14.4 静态内部类"></a>14.4 静态内部类</h4><ul><li>成员静态内部类</li><li>不需要外部类对象，通过正常的方式直接创建内部类</li><li>静态元素不能访问非静态成员(自己类和外部类)</li></ul><h3 id="15-回调模式"><a href="#15-回调模式" class="headerlink" title="15. 回调模式"></a>15. 回调模式</h3><p>回调模式是指：如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口的对象；而该方法在运行时会调用到参数对象中所实现的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Action</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//repeat方法需要一个Action接口类型参数，让其doSth方法重复执行n次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">int</span> n, Action ac)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123; ac.doSth();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此处的语义可解释为：通过接口回调传递了一个方法给repeat,让repeat将其执行5次。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    repeat(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">Action</span>()&#123;<span class="comment">//通过匿名内部类传递参数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSth</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-抽象方法的笔试考点"><a href="#16-抽象方法的笔试考点" class="headerlink" title="16. 抽象方法的笔试考点"></a>16. 抽象方法的笔试考点</h3><ul><li><code>abstract</code>与哪些关键字不能共存：<ol><li><code>final</code>关键字；因为final关键字修饰的类不能被继承，方法不能被重写，而abstract关键字修饰的类继承后，该类的方法需要重写，相互冲突。</li><li><code>static</code>关键字；因为static能被实例化可直接调用，而abstract不能被实例化，相互冲突。</li><li><code>private</code>关键字；因为private修饰的私有方法不能被继承，就不能重写，而<code>abstract</code>方法需要重写。</li></ol></li></ul><h3 id="17-枚举类（enum）"><a href="#17-枚举类（enum）" class="headerlink" title="17. 枚举类（enum）"></a>17. 枚举类（enum）</h3><ul><li>一个类中的对象 认为个数是有限且固定的 可以将每一个对象一一列举出来</li><li>创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式 Class Enum&lt;E extends Enum<E>&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到 protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。</li><li>我们自己定义的每一个enum类型 都会默认继承Enum 间接继承Object</li><li>Enum类型，有两个属性<ul><li>name—–&gt;枚举对象的名字，name()获取name属性</li><li>ordinal—&gt;枚举对象在类中罗列的顺序  类似index  也从0开始   ordinal()获取序号</li></ul></li><li>一些常用的方法<ul><li>valueOf()   通过给定的name获取对应的枚举对象</li><li>values()     获取全部的枚举对象  —&gt; 返回一个数组  Day[]</li><li>compareTo()   可以比较两个枚举对象   int</li><li>toString()      由于这个方法没有final修饰  可以覆盖(重写)</li></ul></li><li>switch内部判断枚举的应用</li><li>我们也可以在enum中描述自己的一些属性或方法<ul><li>必须在enum类中第一行 描述一下枚举的样子 最后需要分号结束;</li><li>可以定义自己的属性</li><li>类创建的过程中  帮我们创建枚举类型的对象</li><li>需要给枚举类型提供对应样子的构造方法  构造方法只能private修饰  可以重载</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Day</span>&#123;</span><br><span class="line">    <span class="comment">//描述了七个当前类的对象</span></span><br><span class="line">    monday(<span class="string">&quot;星期一&quot;</span>,<span class="number">1</span>),tuesday(<span class="string">&quot;星期二&quot;</span>,<span class="number">2</span>),wednesday,thursday,friday,saturday,sunday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Day</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Day</span><span class="params">(String  name,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.index=index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-内存机制问题"><a href="#18-内存机制问题" class="headerlink" title="18. 内存机制问题"></a>18. 内存机制问题</h3><ul><li>类创建在哪儿   对象创建在哪里   继承关系   静态成员   方法执行</li><li>栈内存—&gt;Person p &#x3D; new Person();—-&gt;堆内存    方法区—类模板<ul><li>栈内存—-变量空间,方法临时执行空间（从创建开始执行完毕,<strong>立即回收</strong>）</li><li>堆内存—-new申请对象空间（<strong>垃圾回收器GC</strong>,对象空间没有任何引用指向视为垃圾）</li><li>方法区—-常量  类模板  静态成员（有且只有一份,<strong>不回收</strong>）</li></ul></li><li>Runtime类(是单例模式)之中提供了几个管理内存的方法<ul><li>maxMemory</li><li>totalMemory</li><li>freeMemory</li><li>栈内存溢出错误StackOverflowError </li><li>堆内存溢出错误OutOfMemoryError</li></ul></li><li>Object类中有一个finalize方法  如果重写也能看见对象回收的效果</li><li>GC系统提供的一个线程    回收算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Java教程」语法基础</title>
      <link href="/2017/04/07/java-grammar.html"/>
      <url>/2017/04/07/java-grammar.html</url>
      
        <content type="html"><![CDATA[<p>这是<strong>Java教程</strong>的第一篇，梳理Java基础知识是学习其他专业知识的第一步阶梯；要想精通编程必须通过大量的编程训练，在实践中掌握编程知识，培养编程能力，并逐步理解和掌握程序设计的思想和方法。</p><span id="more"></span><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="1-1-两大类："><a href="#1-1-两大类：" class="headerlink" title="1.1 两大类："></a>1.1 两大类：</h4><ol><li>基本数据类型：<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>char</code>。</li><li>引用类型：数组，类（抽象类）<code>class</code>，接口<code>interface</code>，枚举<code>enum</code>，注解<code>@interface</code>。</li></ol><blockquote><p>注：单个字节表示<code>8</code>位二进制位，最左边表示符号位（<code>0</code>：正，<code>1</code>：负）。</p></blockquote><h4 id="1-2-整数类型（byte-short-int-long）"><a href="#1-2-整数类型（byte-short-int-long）" class="headerlink" title="1.2 整数类型（byte, short, int, long）"></a>1.2 整数类型（byte, short, int, long）</h4><ol><li><code>byte</code>： 1字节，范围<code>-2^7 ~ 2^7-1</code>，即<code>-128-127</code>。</li><li><code>short</code>: 2字节，范围<code>-2^15 ~ 2^15-1</code>，即<code>-32768 ~ 32767</code>。</li><li><code>int</code>: 4个字节，范围<code>-2^31 ~ 2^31-1</code>，即<code>正负21亿</code>之间。</li><li><code>long</code>： 8个字节，范围<code>-2^63 ~ 2^63-1</code>，比<code>int</code>更大。如果要表示<code>long</code>类型数值，需要<code>L</code>或<code>l</code>结尾。</li></ol><h4 id="1-3-浮点类型（float，double）"><a href="#1-3-浮点类型（float，double）" class="headerlink" title="1.3 浮点类型（float，double）"></a>1.3 浮点类型（float，double）</h4><ol><li><code>float</code>：4个字节，单精度浮点数，取到小数点后<code>7</code>位有效数字。如果表示<code>float</code>类型数值，需要<code>F</code>或<code>f</code>结尾。</li><li><code>double</code>：8个字节，双精度浮点数，取到小数点后<code>15</code>位有效数字。如果表示<code>double</code>类型数值，需要<code>D</code>或<code>d</code>结尾。</li></ol><blockquote><p>扩展：浮点运算有时会有误差，为了实现精确运算可使用<code>java.math.BigDecimal</code>类型加以描述。</p></blockquote><h4 id="1-5-字符类型（char）"><a href="#1-5-字符类型（char）" class="headerlink" title="1.5 字符类型（char）"></a>1.5 字符类型（char）</h4><ol><li><strong>char</strong>：2个字节，表示单个字符的数据类型。事实是一个16位无符号整数，值是对应字符的编码，如：<code>&#39;a&#39;</code>,<code>&#39;1&#39;</code>,<code>&#39;中&#39;</code> 等。</li></ol><ul><li>开发中很少用到char类型，而使用String类型描述的多个字符组成的字符串，使用双引号<code>&quot;&quot;</code>引起来。</li><li>需记住的ASII码字符：<code>&#39;a&#39;:97</code>，<code>&#39;A&#39;:65</code>，<code>&#39;0&#39;:48</code>，<code>空格:32</code>，<code>换行符:10</code></li><li>常用转义符(逃逸字符)：<code>\t</code>:制表符，<code>\n</code>:换行，<code>\&quot;</code>，<code>\&#39;</code>，<code>\\</code>:反斜杠本身，<code>\b</code>:回退一格，<code>\r</code>:回车</li><li>字符类型计算<ul><li>一个字符加一个数字，得到<code>Unicode</code>码表中那个数之后的字符</li><li>两个字符相减得到它们在表中的距离</li><li><code>char</code>也可以和<code>int</code>之间相互赋值</li></ul></li></ul><h3 id="2-变量与常量"><a href="#2-变量与常量" class="headerlink" title="2. 变量与常量"></a>2. 变量与常量</h3><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><ul><li>常量是一个值，在程序运行的过程中不能再次发生改变</li><li>基本类型的值都可以认为是常量：<code>4</code>,<code>3.4</code>,<code>&#39;a&#39;</code>,<code>true</code>；引用类型<code>String</code>类的值<code>&quot;abc&quot;</code>视为常量。</li><li>常量存储在常量缓冲区(常量池)中，有且只有一份,常量池中的值默认空间大小<code>int(32bit)</code>,<code>double(64bit)</code>。</li></ul><h4 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h4><ul><li>变量是在栈内存中开辟的一块内存空间，程序执行过程中可以改变；</li><li>变量空间在创建的时候（声明变量），必须指定数据类型，变量空间的名字</li><li>变量空间，里面只能存储一个内容（值&#x2F;引用）</li><li>空间内的类容的类型与定义时一致，内容可以改变</li><li>内存结构与执行过程：类的定义，编译，加载空间各个区，变量赋值</li></ul><h4 id="2-3-标识符（变量）命名规则"><a href="#2-3-标识符（变量）命名规则" class="headerlink" title="2.3 标识符（变量）命名规则"></a>2.3 标识符（变量）命名规则</h4><ol><li>必须字母，数字，下划线以及美元$等组成，且首位非数字。</li><li>不能使用<code>Java</code>语言中的关键字，如<code>class</code>，<code>static</code>，<code>void</code>，<code>int</code>等。</li><li>区分大小写，长度无限制，但不能过长，尽量见名知意。</li></ol><h4 id="2-3-命名的规约"><a href="#2-3-命名的规约" class="headerlink" title="2.3 命名的规约"></a>2.3 命名的规约</h4><ul><li>类名字：首字母大写，如果两个以上的单词，所有首字母都大写</li><li>变量名：首字母小写，如果两个以上的单词，之后的首字母大写</li><li>遵循驼峰式命名规约，所有名字都需要见名知义，为了增强程序的可读性</li></ul><h3 id="3-数据类型之间的转换"><a href="#3-数据类型之间的转换" class="headerlink" title="3. 数据类型之间的转换"></a>3. 数据类型之间的转换</h3><h4 id="3-1-基本数据类型之间转换"><a href="#3-1-基本数据类型之间转换" class="headerlink" title="3.1 基本数据类型之间转换"></a>3.1 基本数据类型之间转换</h4><ol><li>自动类型转换：从小类型到大类型自动转换</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte --&gt; short --&gt; int --&gt; long --&gt; float --&gt; double</span><br><span class="line">          char -----^</span><br></pre></td></tr></table></figure><ol start="2"><li>强制类型转换：需在被转换数据前加上类型，会造成精度损失或者溢出</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long big = 1024L\*1024\*1024;</span><br><span class="line">int i = (int)big;</span><br></pre></td></tr></table></figure><h4 id="3-2其他数据类型之间转换"><a href="#3-2其他数据类型之间转换" class="headerlink" title="3.2其他数据类型之间转换"></a>3.2其他数据类型之间转换</h4><ul><li>同种大类型之间才能发生转换<ul><li>基本–基本   可以直接转换(自动 强制)</li><li>引用–引用   可以直接转化(自动 强制 – 上转型 下转型)</li><li>基本–引用   不可以直接进行转化(间接-桥梁-包装类)</li></ul></li></ul><ul><li>小数据类型一致:整型–&gt;整型 &#x2F; 浮点–&gt;浮点<ul><li>比较内存空间的大小</li><li>大数据类型空间可以直接接受小数据类型的值(自动转换)</li><li>小数据类型空间不可以直接接受大数据类型的值(强制类型转换)</li><li>强制类型转换,写法好用,但是需要注意取值范围的问题,丢失一部分数据</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte a = 1;   int b = a;//自动直接转化就可以</span><br><span class="line">int a = 1;  byte b = (byte)a;//需要强制类型转换</span><br><span class="line">float x = 3.4F;   double y = x;//自动直接转化</span><br><span class="line">double x = 3.4; float y = (float)x;//强制转换</span><br></pre></td></tr></table></figure><ul><li>小数据类型不一致:整型–&gt;浮点<ul><li>比较精确程度</li><li>浮点型的精确程度更高</li><li>任何一个浮点型空间都可以直接接受一个整型的值</li><li>反之需要进行强制类型转换(强行将小数点之后的部分去掉,只保留整数)</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;  float b = a;//自动直接转化</span><br><span class="line">float a =1.0F;  int b = (int)a;//强制类型转换</span><br></pre></td></tr></table></figure><ul><li>整型–&gt;字符<ul><li>每一个字符都对应这一个<code>Unicode</code>码   a–97</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char x = &#x27;a&#x27;;  int y = x;//自动转化  y--97</span><br><span class="line">int x = 97; char y = (char)x;//强制的转化</span><br></pre></td></tr></table></figure><ul><li>布尔类型很特殊<ul><li>不能与其他基本类型之间发生转化</li></ul></li></ul><h3 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h3><ol><li>算术运算符： <code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code></li><li>关系运算符： <code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li><li>自增减运算符： <code>++</code>，<code>--</code></li><li>逻辑运算符： <code>&amp;&amp;</code>，<code>||</code>，<code>！</code>（短路特性：逻辑与<code>&amp;&amp;</code>运算，若第一个条件为假,跳过第二个条件；逻辑或<code>||</code>运算，若第一个条件为真，跳过第二个条件）</li><li>三目运算符： 条件 ? 表达式1 ： 表达式2</li><li>赋值运算符：<code>=</code>，<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>=</code></li></ol><h3 id="5-循环"><a href="#5-循环" class="headerlink" title="5. 循环"></a>5. 循环</h3><ol><li><code>while</code>循环和<code>for</code>循环完全可以互换。</li><li><code>while</code>循环主要用于明确循环条件，但不明确循环次数的场合</li><li><code>for</code>循环主要用于明确次数或范围的场合</li><li><code>while(true)</code> 等价于 <code>for(;;)</code>，表示无限循环。</li></ol><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h3><h4 id="6-1-一维数组"><a href="#6-1-一维数组" class="headerlink" title="6.1 一维数组"></a>6.1 一维数组</h4><ul><li><code>数组类型[] 数组名 = new 数据类型[长度]</code> ：动态方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组类型[] 数组名 = <span class="keyword">new</span> 数据类型[长度] <span class="comment">//动态方式</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组类型[] 数组名 = &#123;初始值<span class="number">1</span>, 初始值<span class="number">1</span>, 初始值<span class="number">1</span>, ...&#125; <span class="comment">//静态方式</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="comment">/*特殊方式：*/</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-2-二维数组"><a href="#6-2-二维数组" class="headerlink" title="6.2 二维数组"></a>6.2 二维数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组类型[][] 数组名 = <span class="keyword">new</span> 数据类型[行数][列数]</span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组类型[][] 数组名 = &#123;&#123;初始值<span class="number">1</span>, 初始值<span class="number">1</span>, 初始值<span class="number">1</span>&#125;,&#123;值<span class="number">2</span>,...&#125; ...&#125;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;, &#123;<span class="number">01</span>, <span class="number">5</span>, <span class="number">3</span>&#125;, &#123;<span class="number">8</span>, <span class="number">20</span>, <span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>二维数组<code>arr.length</code>表示行数，<code>arr[0].length</code>表示此行的长度</p></blockquote><h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h3><ul><li>函数是一块代码，接收零个或多个参数，做一件事情，并返回零个或一个值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=a; i&lt;=b; i++)&#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(a +<span class="string">&quot;到&quot;</span>+ b +<span class="string">&quot;的和是&quot;</span>+ sum);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的调用：<code>函数名(参数值)</code>; 即使没有参数也需要<code>()</code>,<code>()</code>起到了调用函数的作用，如果有参数，则需要给出正确的数量和顺序</li><li>函数的返回：<code>return</code>停止函数的执行，并返回一个值，可以再赋值给变量，传递给另一个函数，甚至可以丢弃，有时候要的是副作用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端开发 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlueLake博客主题的详细配置</title>
      <link href="/2016/12/29/bluelake.html"/>
      <url>/2016/12/29/bluelake.html</url>
      
        <content type="html"><![CDATA[<h3 id="2021年2月3日更新："><a href="#2021年2月3日更新：" class="headerlink" title="2021年2月3日更新："></a>2021年2月3日更新：</h3><p><a href="https://github.com/chaooo/hexo-theme-BlueLake">BlueLake主题</a>主题写了有些年头了，随着Hexo升级到5.X，BlueLake很多配置已经过时，在使用中难免出现问题。</p><p>所以，我利用工作之余抽了些时间进行了大改版，主题模板引擎由Jade(Pug)换成了EJS，以landscape为原型进行二次开发；保留BlueLake主题老版本的其他功能，如原生JS实现站内搜索功能，本地分享等；新添加了一些新的功能，如打赏模块，集成新的三方评论等等。</p><p>说了这么多不如你亲自体验来的直接，BlueLake主题地址：<a href="https://github.com/chaooo/hexo-theme-BlueLake%E3%80%82">https://github.com/chaooo/hexo-theme-BlueLake。</a></p><span id="more"></span><p>在阅读本文之前，假定您已经成功安装了<a href="https://hexo.io/zh-cn/">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p><img src="/2016/12/29/bluelake/BlueLake.jpg"></p><blockquote><p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为**<code>根_config.yml</code><strong>；另一份位于主题目录下（themes&#x2F;主题名&#x2F;_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为</strong><code>主题_config.yml</code>**。</p></blockquote><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>您可以直接到<a href="https://github.com/chaooo/hexo-theme-BlueLake">BlueLake发布页</a>下载，然后解压拷贝到<code>themes</code>目录下，修改配置即可。<br>不过我还是推荐使用<code>GIT</code>来checkout代码，之后也可以通过<code>git pull</code>来快速更新。</p><h4 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chaooo/hexo-theme-BlueLake.git themes/bluelake</span><br></pre></td></tr></table></figure><h4 id="1-2-安装主题插件"><a href="#1-2-安装主题插件" class="headerlink" title="1.2 安装主题插件"></a>1.2 安装主题插件</h4><p>在根目录下打开终端窗口：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-jade --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h4 id="1-3-启用主题"><a href="#1-3-启用主题" class="headerlink" title="1.3 启用主题"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>bluelake</code>(先确认主题文件夹名称是否为bluelake)。</p><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">bluelake</span></span><br></pre></td></tr></table></figure><h4 id="1-4-验证"><a href="#1-4-验证" class="headerlink" title="1.4 验证"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code>http://localhost:4000</code>，检查站点是否正确运行。</p><h4 id="1-5-更新主题"><a href="#1-5-更新主题" class="headerlink" title="1.5 更新主题"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/bluelake</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><h4 id="2-1-配置网站头部显示文字"><a href="#2-1-配置网站头部显示文字" class="headerlink" title="2.1 配置网站头部显示文字"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：</p><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span>     <span class="comment"># 标题，如：秋过冬漫长</span></span><br><span class="line"><span class="attr">subtitle:</span>  <span class="comment"># 副标题，如：没有比脚更长的路，走过去，前面是个天！</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment"># 网站关键字，如：key, key1, key2, key3</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span></span><br></pre></td></tr></table></figure><ul><li><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；</li><li><code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；</li><li><code>keywords</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；</li><li><code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</li></ul><h4 id="2-2-设置语言"><a href="#2-2-设置语言" class="headerlink" title="2.2 设置语言"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：</p><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure><h4 id="2-3-设置菜单"><a href="#2-3-设置菜单" class="headerlink" title="2.3 设置菜单"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：</p><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml">themes/bluelake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">archive</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">archives/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># - page: about</span></span><br><span class="line">  <span class="comment">#   directory: about/</span></span><br><span class="line">  <span class="comment">#   icon: fa-user</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">page:</span> <span class="string">rss</span></span><br><span class="line">    <span class="attr">directory:</span> <span class="string">atom.xml</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fa-rss</span></span><br></pre></td></tr></table></figure><p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。</p><h4 id="2-4-添加about页"><a href="#2-4-添加about页" class="headerlink" title="2.4 添加about页"></a>2.4 添加about页</h4><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">&#x27;about&#x27;</span></span><br></pre></td></tr></table></figure><p>打开<code>主题_config.yml</code>，补全about页面的详细信息：</p><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml">themes/bluelake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">about:</span></span><br><span class="line">  <span class="attr">photo_url:</span> <span class="comment"># 头像的链接地址 e.g. http://cdn.itdn.top/blog/themeauthor.jpg</span></span><br><span class="line">  <span class="attr">items:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">email</span> <span class="comment"># 个人邮箱</span></span><br><span class="line">    <span class="attr">url:</span> <span class="comment">## Your email with mailto: e.g.  mailto:zhenggchaoo@gmail.com</span></span><br><span class="line">    <span class="attr">title:</span> <span class="comment">## Your email e.g.  zhenggchaoo@gmail.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">github</span> <span class="comment"># github</span></span><br><span class="line">    <span class="attr">url:</span> <span class="comment">## Your github&#x27;url e.g.  https://github.com/chaooo</span></span><br><span class="line">    <span class="attr">title:</span> <span class="comment">## Your github&#x27;name e.g.  chaooo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">weibo</span> <span class="comment"># 微博</span></span><br><span class="line">    <span class="attr">url:</span> <span class="comment">## Your weibo&#x27;s url e.g.  http://weibo.com/zhengchaooo</span></span><br><span class="line">    <span class="attr">title:</span> <span class="comment">## Your weibo&#x27;s name e.g.  秋过冬漫长</span></span><br></pre></td></tr></table></figure><p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p><h4 id="2-5-添加本地搜索"><a href="#2-5-添加本地搜索" class="headerlink" title="2.5 添加本地搜索"></a>2.5 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href="https://github.com/alexbruno/hexo-generator-json-content">hexo-generator-json-content</a>来创建JSON数据文件：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure><p>然后在<code>根_config.yml</code>添加配置：</p><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">pages:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">text:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">raw:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">slug:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">updated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">link:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">excerpt:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最后在<code>主题_config.yml</code>添加配置：</p><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml">themes/bluelake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h4 id="2-6-首页添加文章置顶"><a href="#2-6-首页添加文章置顶" class="headerlink" title="2.6 首页添加文章置顶"></a>2.6 首页添加文章置顶</h4><p>在根目录下打开命令行窗口安装：</p><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的Front-matter中加上top: true即可。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: BlueLake博客主题的详细配置</span><br><span class="line">tags: [hexo,BlueLake]</span><br><span class="line">categories: Hexo博客</span><br><span class="line"><span class="section">top: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="3-集成第三方服务"><a href="#3-集成第三方服务" class="headerlink" title="3.集成第三方服务"></a>3.集成第三方服务</h3><h4 id="3-1-添加评论"><a href="#3-1-添加评论" class="headerlink" title="3.1 添加评论"></a>3.1 添加评论</h4><p>目前主题集成多种第三方评论，比如基于Github Issue的<a href="https://gitalk.github.io/">GITALK</a>），<a href="https://valine.js.org/">Valine</a>评论，<a href="http://changyan.kuaizhan.com/">畅言评论</a>，<a href="https://disqus.com/">Disqus评论</a>、<a href="https://livere.com/">来必力评论</a>、<a href="http://www.uyan.cc/">友言评论</a>、<a href="https://gentie.163.com/info.html">网易云跟帖评论</a>等。</p><p> 配置<code>主题_config.yml</code>：</p><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml">themes/bluelake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitalk comment</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span> <span class="comment">## Your GitHub ID, e.g. username</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment">## The repository to store your comments, make sure you&#x27;re the repo&#x27;s owner, e.g. gitalk.github.io</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="comment">## GitHub client ID, e.g. 75752dafe7907a897619</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="comment">## GitHub client secret, e.g. ec2fb9054972c891289640354993b662f4cccc50</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="comment">## Github repo owner and collaborators, only these guys can initialize github issues.</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">&#x27;zh-CN&#x27;</span> <span class="comment">## Language</span></span><br><span class="line">  <span class="attr">pagerDirection:</span> <span class="string">last</span> <span class="comment"># Comment sorting direction, available values are last and first.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine comment. https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># if you want use valine,please set this value is true</span></span><br><span class="line">  <span class="attr">appId:</span> <span class="comment"># leancloud application app id</span></span><br><span class="line">  <span class="attr">appKey:</span> <span class="comment"># leancloud application app key</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># valine mail notify (true/false) https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># valine verify code (true/false)</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># i18n: zh-cn/en</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Changyan comment. 畅言</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="comment">## changyan appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment">## changyan appkey</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Other comments</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">disqus:</span> <span class="comment">## disqus_shortname</span></span><br><span class="line">  <span class="attr">livere:</span> <span class="comment">## 来必力(data-uid)</span></span><br><span class="line">  <span class="attr">uyan:</span> <span class="comment">## 友言(uid)</span></span><br><span class="line">  <span class="attr">cloudTie:</span> <span class="comment">## 网易云跟帖(productKey)</span></span><br></pre></td></tr></table></figure><h4 id="3-2-站点统计"><a href="#3-2-站点统计" class="headerlink" title="3.2 站点统计"></a>3.2 站点统计</h4><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml">themes/bluelake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span> <span class="literal">true</span>  <span class="comment"># 卜算子阅读次数统计</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="comment"># 百度统计</span></span><br><span class="line"><span class="attr">google_analytics:</span> <span class="comment"># 谷歌统计</span></span><br><span class="line"><span class="attr">gauges_analytics:</span> <span class="comment"># Gauges</span></span><br></pre></td></tr></table></figure><h5 id="3-2-1-卜算子阅读次数统计"><a href="#3-2-1-卜算子阅读次数统计" class="headerlink" title="3.2.1 卜算子阅读次数统计"></a>3.2.1 卜算子阅读次数统计</h5><p>若busuanzi设置为true将计算文章的阅读量，及网站的访问量与访客数，并显示在文章标题下和网站底部。</p><h5 id="3-2-2-百度统计"><a href="#3-2-2-百度统计" class="headerlink" title="3.2.2 百度统计"></a>3.2.2 百度统计</h5><p>登录百度统计，定位到站点的代码获取页面。复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：<code>8006843039519956000</code>)</p><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml">themes/bluelake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidu_analytics:</span> <span class="number">8006843039519956000</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： baidu_analytics不是你的百度id或者百度统计id，如若使用其他统计，配置方法与百度统计类似。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> BlueLake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义HEXO站内搜索Javascript+json</title>
      <link href="/2016/11/09/json-search.html"/>
      <url>/2016/11/09/json-search.html</url>
      
        <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>目前很多<a href="https://hexo.io/">Hexo</a>博客都用的Swiftype和Algolia等第三方搜索服务。其实针对无数据库的情况下，Hexo本身也提供了两个插件来生成数据文件作为数据源：<br>    <a href="https://github.com/PaicHyperionDev/hexo-generator-search">hexo-generator-search</a>生成<code>xml</code>格式的数据文件。<br>    <a href="https://github.com/alexbruno/hexo-generator-json-content">hexo-generator-json-content</a> 生成<code>json</code>格式的数据文件。<br>今天的主角是<a href="https://github.com/alexbruno/hexo-generator-json-content">hexo-generator-json-content</a>，对于 Javascript语言来说还是解析 json 更方便，如果需要用 xml 做数据文件也可以使用已有的atom.xml。</p><span id="more"></span><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure><p>然后执行<code>hexo generate</code>时会自动生成<code>content.json</code>文件，若使用默认设置，生成的数据结构如下 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">meta<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    title<span class="punctuation">:</span> hexo.config.title<span class="punctuation">,</span></span><br><span class="line">    subtitle<span class="punctuation">:</span> hexo.config.subtitle<span class="punctuation">,</span></span><br><span class="line">    description<span class="punctuation">:</span> hexo.config.description<span class="punctuation">,</span></span><br><span class="line">    author<span class="punctuation">:</span> hexo.config.author<span class="punctuation">,</span></span><br><span class="line">    url<span class="punctuation">:</span> hexo.config.url</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">pages<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="comment">//-&gt; all pages</span></span><br><span class="line">    title<span class="punctuation">:</span> page.title<span class="punctuation">,</span></span><br><span class="line">    slug<span class="punctuation">:</span> page.slug<span class="punctuation">,</span></span><br><span class="line">    date<span class="punctuation">:</span> page.date<span class="punctuation">,</span></span><br><span class="line">    updated<span class="punctuation">:</span> page.updated<span class="punctuation">,</span></span><br><span class="line">    comments<span class="punctuation">:</span> page.comments<span class="punctuation">,</span></span><br><span class="line">    permalink<span class="punctuation">:</span> page.permalink<span class="punctuation">,</span></span><br><span class="line">    path<span class="punctuation">:</span> page.path<span class="punctuation">,</span></span><br><span class="line">    excerpt<span class="punctuation">:</span> page.excerpt<span class="punctuation">,</span> <span class="comment">//-&gt; only text ;)</span></span><br><span class="line">    keywords<span class="punctuation">:</span> <span class="keyword">null</span> <span class="comment">//-&gt; it needs settings</span></span><br><span class="line">    text<span class="punctuation">:</span> page.content<span class="punctuation">,</span> <span class="comment">//-&gt; only text minified ;)</span></span><br><span class="line">    raw<span class="punctuation">:</span> page.raw<span class="punctuation">,</span> <span class="comment">//-&gt; original MD content</span></span><br><span class="line">    content<span class="punctuation">:</span> page.content <span class="comment">//-&gt; final HTML content</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">posts<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="comment">//-&gt; only published posts</span></span><br><span class="line">    title<span class="punctuation">:</span> post.title<span class="punctuation">,</span></span><br><span class="line">    slug<span class="punctuation">:</span> post.slug<span class="punctuation">,</span></span><br><span class="line">    date<span class="punctuation">:</span> post.date<span class="punctuation">,</span></span><br><span class="line">    updated<span class="punctuation">:</span> post.updated<span class="punctuation">,</span></span><br><span class="line">    comments<span class="punctuation">:</span> post.comments<span class="punctuation">,</span></span><br><span class="line">    permalink<span class="punctuation">:</span> post.permalink<span class="punctuation">,</span></span><br><span class="line">    path<span class="punctuation">:</span> post.path<span class="punctuation">,</span></span><br><span class="line">    excerpt<span class="punctuation">:</span> post.excerpt<span class="punctuation">,</span> <span class="comment">//-&gt; only text ;)</span></span><br><span class="line">    keywords<span class="punctuation">:</span> <span class="keyword">null</span> <span class="comment">//-&gt; it needs settings</span></span><br><span class="line">    text<span class="punctuation">:</span> post.content<span class="punctuation">,</span> <span class="comment">//-&gt; only text minified ;)</span></span><br><span class="line">    raw<span class="punctuation">:</span> post.raw<span class="punctuation">,</span> <span class="comment">//-&gt; original MD content</span></span><br><span class="line">    content<span class="punctuation">:</span> post.content<span class="punctuation">,</span> <span class="comment">//-&gt; final HTML content</span></span><br><span class="line">    categories<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        name<span class="punctuation">:</span> category.name<span class="punctuation">,</span></span><br><span class="line">        slug<span class="punctuation">:</span> category.slug<span class="punctuation">,</span></span><br><span class="line">        permalink<span class="punctuation">:</span> category.permalink</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    tags<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">        name<span class="punctuation">:</span> tag.name<span class="punctuation">,</span></span><br><span class="line">        slug<span class="punctuation">:</span> tag.slug<span class="punctuation">,</span></span><br><span class="line">        permalink<span class="punctuation">:</span> tag.permalink</span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>hexo-generator-json-content默认生成的json数据内容非常全，默认配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">keywords:</span> <span class="literal">false</span> <span class="comment"># (english, spanish, polish, german, french, italian, dutch, russian, portuguese, swedish)</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">slug:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">updated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">link:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">excerpt:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">keywords:</span> <span class="literal">true</span> <span class="comment"># but only if root keywords option language was set</span></span><br><span class="line">    <span class="attr">text:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">raw:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">slug:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">updated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">path:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">link:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">excerpt:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">keywords:</span> <span class="literal">true</span> <span class="comment"># but only if root keywords option language was set</span></span><br><span class="line">    <span class="attr">text:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">raw:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>因为默认生成了很多我们不需要的数据，所以我们要对其进行配置让它只生成我们想要的内容,在<code>hexo/_config.yml</code>中加入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line">  <span class="attr">meta:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">pages:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="literal">true</span> <span class="comment">#文章标题</span></span><br><span class="line">    <span class="attr">date:</span> <span class="literal">true</span> <span class="comment">#发表日期</span></span><br><span class="line">    <span class="attr">path:</span> <span class="literal">true</span> <span class="comment">#路径</span></span><br><span class="line">    <span class="attr">text:</span> <span class="literal">true</span> <span class="comment">#文本字段</span></span><br><span class="line">    <span class="attr">raw:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">content:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">slug:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">updated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">link:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">excerpt:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment">#标签</span></span><br></pre></td></tr></table></figure><p>这样，就只生成每篇文章的标题，日期，路径，标签和文本字段，同时也减小了文件的大小。<br>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义HEXO站内搜索Javascript+json&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2016-11-09T01:24:56.000Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2016/11/09/自定义HEXO站内搜索Javascript-json.html&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;目前很多Hexo博客都用的Swiftype和Algolia等第三......#这里显示整篇文章的内容&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;javascript,hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;slug&quot;</span><span class="punctuation">:</span> <span class="string">&quot;javascript-hexo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;permalink&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://chaoo.oschina.io/tags/javascript-hexo/&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-JavaScript实现代码"><a href="#3-JavaScript实现代码" class="headerlink" title="3.JavaScript实现代码"></a>3.JavaScript实现代码</h3><p>接下来就是用JS实现查询方法并把结果渲染到页面。</p><h4 id="3-1-xhr加载数据"><a href="#3-1-xhr加载数据" class="headerlink" title="3.1 xhr加载数据"></a>3.1 xhr加载数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchData;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">loadData</span>(<span class="params">success</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!searchData) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/content.json&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">        xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> res = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">response</span> || <span class="variable language_">this</span>.<span class="property">responseText</span>);</span><br><span class="line">                searchData = res <span class="keyword">instanceof</span> <span class="title class_">Array</span> ? res : res.<span class="property">posts</span>;</span><br><span class="line">                <span class="title function_">success</span>(searchData);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.<span class="title function_">send</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">success</span>(searchData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-匹配文章内容返回结果"><a href="#3-2-匹配文章内容返回结果" class="headerlink" title="3.2 匹配文章内容返回结果"></a>3.2 匹配文章内容返回结果</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">matcher</span>(<span class="params">post, regExp</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配优先级：title &gt; tags &gt; text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">regtest</span>(post.<span class="property">title</span>, regExp) || post.<span class="property">tags</span>.<span class="title function_">some</span>(<span class="keyword">function</span>(<span class="params">tag</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">regtest</span>(tag.<span class="property">name</span>, regExp);</span><br><span class="line">    &#125;) || <span class="title function_">regtest</span>(post.<span class="property">text</span>, regExp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">regtest</span>(<span class="params">raw, regExp</span>) &#123;</span><br><span class="line">    regExp.<span class="property">lastIndex</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> regExp.<span class="title function_">test</span>(raw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-结果渲染到页面"><a href="#3-3-结果渲染到页面" class="headerlink" title="3.3 结果渲染到页面"></a>3.3 结果渲染到页面</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">length</span>) &#123;</span><br><span class="line">        html = data.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">tpl</span>(searchTpl, &#123;</span><br><span class="line">                <span class="attr">title</span>: post.<span class="property">title</span>,</span><br><span class="line">                <span class="attr">path</span>: post.<span class="property">path</span>,</span><br><span class="line">                <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(post.<span class="property">date</span>).<span class="title function_">toLocaleDateString</span>(),</span><br><span class="line">                <span class="attr">tags</span>: post.<span class="property">tags</span>.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">tag</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&#x27;&lt;span&gt;&#x27;</span> + tag.<span class="property">name</span> + <span class="string">&#x27;&lt;/span&gt;&#x27;</span>;</span><br><span class="line">                &#125;).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-查询匹配"><a href="#3-3-查询匹配" class="headerlink" title="3.3 查询匹配"></a>3.3 查询匹配</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">search</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="comment">// 关键字 =&gt; 正则，空格隔开的看作多个关键字</span></span><br><span class="line">    <span class="comment">// a b c =&gt; /a|b|c/gmi</span></span><br><span class="line">    <span class="keyword">var</span> regExp = <span class="keyword">new</span> <span class="title class_">RegExp</span>(key.<span class="title function_">replace</span>(<span class="regexp">/[ ]/g</span>, <span class="string">&#x27;|&#x27;</span>), <span class="string">&#x27;gmi&#x27;</span>);</span><br><span class="line">    <span class="title function_">loadData</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = data.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">post</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">matcher</span>(post, regExp);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">render</span>(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> BlueLake </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的Web包管理器-Bower</title>
      <link href="/2016/08/12/bower.html"/>
      <url>/2016/08/12/bower.html</url>
      
        <content type="html"><![CDATA[<p>Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。</p><span id="more"></span> <h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在安装<a href="https://bower.io/">bower</a>之前，必须确认你已经安装了<a href="http://nodejs.org/">Node.js</a>和<a href="http://git-scm.com/">Git</a>。</p><h3 id="1-安装Bower"><a href="#1-安装Bower" class="headerlink" title="1.安装Bower"></a>1.安装Bower</h3><p>使用npm，打开终端，键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g bower   <span class="comment">#全局安装bower</span></span><br></pre></td></tr></table></figure><p>移步<a href="https://github.com/bower/bower/wiki/Troubleshooting">这里</a>查看不同平台上安装的问题。</p><h3 id="2-使用Bower"><a href="#2-使用Bower" class="headerlink" title="2.使用Bower"></a>2.使用Bower</h3><p>使用help命令查看帮助。   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bower <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">    bower &lt;<span class="built_in">command</span>&gt; [&lt;args&gt;] [&lt;options&gt;]</span><br><span class="line">Commands:</span><br><span class="line">    cache                   Manage bower cache</span><br><span class="line">    <span class="built_in">help</span>                    Display <span class="built_in">help</span> information about Bower</span><br><span class="line">    home                    Opens a package homepage into your favorite browser</span><br><span class="line">    info                    Info of a particular package</span><br><span class="line">    init                    Interactively create a bower.json file</span><br><span class="line">    install                 Install a package locally</span><br><span class="line">    <span class="built_in">link</span>                    Symlink a package folder</span><br><span class="line">    list                    List <span class="built_in">local</span> packages - and possible updates</span><br><span class="line">    login                   Authenticate with GitHub and store credentials</span><br><span class="line">    lookup                  Look up a package URL by name</span><br><span class="line">    prune                   Removes <span class="built_in">local</span> extraneous packages</span><br><span class="line">    register                Register a package</span><br><span class="line">    search                  Search <span class="keyword">for</span> a package by name</span><br><span class="line">    update                  Update a <span class="built_in">local</span> package</span><br><span class="line">    uninstall               Remove a <span class="built_in">local</span> package</span><br><span class="line">    unregister              Remove a package from the registry</span><br><span class="line">    version                 Bump a package version</span><br><span class="line">Options:</span><br><span class="line">    -f, --force             Makes various commands more forceful</span><br><span class="line">    -j, --json              Output consumable JSON</span><br><span class="line">    -l, --loglevel          What level of logs to report</span><br><span class="line">    -o, --offline           Do not hit the network</span><br><span class="line">    -q, --quiet             Only output important information</span><br><span class="line">    -s, --silent            Do not output anything, besides errors</span><br><span class="line">    -V, --verbose           Makes output more verbose</span><br><span class="line">    --allow-root            Allows running commands as root</span><br><span class="line">    -v, --version           Output Bower version</span><br><span class="line">    --no-color              Disable colors</span><br><span class="line">See <span class="string">&#x27;bower help &lt;command&gt;&#x27;</span> <span class="keyword">for</span> more information on a specific <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure><h3 id="3-安装包到本地"><a href="#3-安装包到本地" class="headerlink" title="3.安装包到本地"></a>3.安装包到本地</h3><p>通过命令bower install安装软件包默认到bower_components&#x2F;目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower install &lt;package&gt;    <span class="comment">#package为包名</span></span><br></pre></td></tr></table></figure><p>想要下载的包可以是GitHub上的短链接（如jquery&#x2F;jquery）、.git 、一个URL或者其它.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bower install  <span class="comment"># 通过 bower.json 文件安装</span></span><br><span class="line">bower install jquery   <span class="comment"># 通过在github上注册的包名安装</span></span><br><span class="line">bower install desandro/masonry   <span class="comment"># GitHub短链接</span></span><br><span class="line">bower install git://github.com/user/package.git   <span class="comment"># Github上的 .git</span></span><br><span class="line">bower install http://example.com/script.js   <span class="comment"># URL</span></span><br></pre></td></tr></table></figure><p>安装选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-F, --force-latest: Force latest version on conflict</span><br><span class="line">-p, --production: Do not install project devDependencies</span><br><span class="line">-S, --save: Save installed packages into the project’s bower.json dependencies</span><br><span class="line">-D, --save-dev: Save installed packages into the project’s bower.json devDependencies</span><br><span class="line">-E, --save-exact: Configure installed packages with an exact version rather than semver</span><br></pre></td></tr></table></figure><h3 id="4-用bower-json文件来管理依赖"><a href="#4-用bower-json文件来管理依赖" class="headerlink" title="4.用bower.json文件来管理依赖"></a>4.用bower.json文件来管理依赖</h3><p>发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行<code>bower install</code>就可根据bower.json来安装依赖的包。<br>在项目中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower init</span><br></pre></td></tr></table></figure><p>会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.<br>如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上<code>--save</code>即可。</p><h3 id="5-使用下载好的包"><a href="#5-使用下载好的包" class="headerlink" title="5.使用下载好的包"></a>5.使用下载好的包</h3><p>对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;bower_components/bootstrap/dist/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;bower_components/jquery/dist/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-更新包"><a href="#6-更新包" class="headerlink" title="6.更新包"></a>6.更新包</h3><p>若下载的包升级了，只需执行<code>update</code>命令即可更新，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower update jquery</span><br></pre></td></tr></table></figure><p>这样就可以自动升级到最新版的jquery了。<br>更新选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-F, --force-latest: Force latest version on conflict</span><br><span class="line">-p, --production: Do not install project devDependencies</span><br><span class="line">-S, --save: Update dependencies <span class="keyword">in</span> bower.json</span><br><span class="line">-D, --save-dev: Update devDependencies <span class="keyword">in</span> bower.json</span><br></pre></td></tr></table></figure><h3 id="7-搜索包"><a href="#7-搜索包" class="headerlink" title="7.搜索包"></a>7.搜索包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bower search               <span class="comment">#搜索所有包</span></span><br><span class="line">bower search &lt;packageName&gt; <span class="comment">#搜索指定名称的包</span></span><br></pre></td></tr></table></figure><p>或者可以在<a href="https://bower.io/search/">这里:https://bower.io/search/</a>搜索喜欢的包.</p><h3 id="8-卸载包"><a href="#8-卸载包" class="headerlink" title="8.卸载包"></a>8.卸载包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;]</span><br></pre></td></tr></table></figure><p>卸载选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-S, --save: Remove uninstalled packages from the project’s bower.json dependencies</span><br><span class="line">-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bower </tag>
            
            <tag> 环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo+github搭建静态博客</title>
      <link href="/2016/05/23/hexo-github.html"/>
      <url>/2016/05/23/hexo-github.html</url>
      
        <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在安装<a href="https://hexo.io/zh-cn/">hexo</a>之前，必须确认你已经安装了<a href="http://nodejs.org/">Node.js</a>和<a href="http://git-scm.com/">Git</a>。</p><span id="more"></span> <h4 id="1-创建GitHub仓库"><a href="#1-创建GitHub仓库" class="headerlink" title="1.创建GitHub仓库"></a>1.创建GitHub仓库</h4><p>注册<a href="https://github.com/">GitHub</a>账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：<a href="https://github.com/chaooo/chaooo.github.io">chaooo.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p><h4 id="2-配置Git"><a href="#2-配置Git" class="headerlink" title="2.配置Git"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;username&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h4 id="3-本地Git与GitHub建立联系"><a href="#3-本地Git与GitHub建立联系" class="headerlink" title="3.本地Git与GitHub建立联系"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al ~/.ssh</span><br></pre></td></tr></table></figure><p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;emailt@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>然后键入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent -s</span><br><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>如果出现这个错误:<code>Could not open a connection to your authentication agent</code>，则先执行如下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br></pre></td></tr></table></figure><p>再重新输入指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>你可能会看到有警告，没事，输入“yes”就好。</p><h4 id="4-初始化hexo文件夹"><a href="#4-初始化hexo文件夹" class="headerlink" title="4.初始化hexo文件夹"></a>4.初始化hexo文件夹</h4><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git</span><br><span class="line">$ <span class="built_in">mkdir</span> Hexo-admin</span><br></pre></td></tr></table></figure><h3 id="Hexo安装配置"><a href="#Hexo安装配置" class="headerlink" title="Hexo安装配置"></a>Hexo安装配置</h3><h4 id="1-Hexo初始化"><a href="#1-Hexo初始化" class="headerlink" title="1.Hexo初始化"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Hexo-admin</span><br></pre></td></tr></table></figure><p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>输入Ctrl+C停止服务。</p><h4 id="2-Hexo配置"><a href="#2-Hexo配置" class="headerlink" title="2.Hexo配置"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin&#x2F; 下的配置文件_config.yml找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: </span><br><span class="line">  repository:</span><br></pre></td></tr></table></figure><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/chaooo/chaooo.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h4 id="3-完成部署"><a href="#3-完成部署" class="headerlink" title="3.完成部署"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href="http://chaooo.github.io/">chaooo.github.io&#x2F;</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/chaooo/chaooo.github.io.git</span><br><span class="line">   7f3b50a..128a10d  HEAD -&gt; master</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br></pre></td></tr></table></figure><p>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p><h3 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h3><h4 id="1-写文章"><a href="#1-写文章" class="headerlink" title="1.写文章"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\source_posts\文章标题.md 。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] <span class="string">&quot;文章标题&quot;</span> <span class="comment">#新建文章</span></span><br></pre></td></tr></table></figure><p>然后用编辑器打开“文章标题.md”按照<a href="http://www.appinn.com/markdown/">Markdown语法</a>书写文章。<br> 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br> 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\scaffolds\post.md</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line"><span class="built_in">date</span>: &#123; &#123; <span class="built_in">date</span> &#125; &#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line"><span class="built_in">date</span>: &#123; &#123; <span class="built_in">date</span> &#125; &#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br><code>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</code></p><h4 id="2-提交"><a href="#2-提交" class="headerlink" title="2.提交"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;...&quot;</span></span><br><span class="line">$ git push origin develop</span><br></pre></td></tr></table></figure><p>然后才执行hexo generate -d发布网站到master分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate -d</span><br></pre></td></tr></table></figure><h4 id="3-本地仓库丢失"><a href="#3-本地仓库丢失" class="headerlink" title="3.本地仓库丢失"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p><h5 id="3-1拷贝仓库"><a href="#3-1拷贝仓库" class="headerlink" title="3.1拷贝仓库"></a>3.1拷贝仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b develop https://github.com/chaooo/chaooo.github.io.git </span><br></pre></td></tr></table></figure><h5 id="3-2配置Hexo"><a href="#3-2配置Hexo" class="headerlink" title="3.2配置Hexo"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ npm install hexo</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h5 id="小Tips-hexo-命令"><a href="#小Tips-hexo-命令" class="headerlink" title="小Tips:hexo 命令"></a>小Tips:hexo 命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br><span class="line">hexo deploy -g  <span class="comment">#生成加部署</span></span><br><span class="line">hexo server -g  <span class="comment">#生成加预览</span></span><br><span class="line"><span class="comment">#命令的简写</span></span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/05/06/hello-world.html"/>
      <url>/2016/05/06/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
