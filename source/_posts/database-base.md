---
title: 「数据库」数据库系统基础
date: 2018-08-22 20:20:19
tags: [数据库, 后端开发]
categories: 数据库
---

### 概述
1. 数据库 是 电子化信息的集合
  * 将信息规范化并使之电子化，形成电子信息'库'，以便利用计算机对这些信息进行快速有效的存储、检索、统计与管理。
2. 表(Table)：以按行按列形式组织及展现的数据
<!-- more -->
  * 数据库起源于规范化“表(Table)”的处理，Table中描述了一批相互有关联关系的数据-->关系
3. 数据库系统的构成（概念层次）:
  1. 数据库(DB):Database：相互之间有关联关系的数据的集合
  2. 数据库管理系统(DBMS):Database Management System
  3. 数据库应用(DBAP):Database Application
  4. 数据库管理员(DBA):Database Asministrator
  5. 计算机基本系统


### 1. 数据库管理系统(DBMS)
#### 1.1 从用户角度看DBMS(数据库管理系统)
1. 数据库定义：定义数据库中的Table的表名、标题(属性以及属性值的要求)等
  * DBMS提供了一套**数据定义语言(DDL**: Data Definition Language)给用户
  * 用户使用DDL描述其所要建立的表的格式
  * DBMS依照用户的定义，创建数据库及其中的表
2. 数据库操作：向数据库的Table中增加/删除/更新数据及对数据进行查询、检索、统计等
  * DBMS提供了一套**数据库操纵语言(DML**: Data Manipulation Language)给用户
  * 用户使用DML描述其所要进行的增、删、改、查等操作
  * DBMS依照用户的操作描述，实际执行这些操作
3. 数据库控制：控制数据库中数据的使用(哪些用户可以使用，哪些不可以)
  * DBMS提供了一套**数据控制语言(DCL**: Data Control Language)给用户
  * 用户使用DCL描述其对数据库所要实施的控制
  * DBMS依照用户描述，实际ijnx控制
4. 数据库维护：转储/恢复/重组/性能监测/分析...
  * DBMS提供了一系列程序(实用程序/例行程序)给用户
  * 在这些程序中提供了对数据库维护的各种功能
  * 用户使用这些程序进行各种数据库维护操作
  * (数据库维护的实用程序，一般由数据库管理员(DBA)来使用和掌握的)


#### 1.2 数据库语言 
* 使用者使用数据库语言，利用DBMS操纵数据库
* SQL语言：结构化的数据库语言
* 高级语言：一条数据库语言相当于高级语言的一个或多个循环程序，数据库语言可以嵌入到高级语言(宿主语言)中使用


#### 1.3 从系统实现角度看DBMS的功能
1. 数据库管理系统的实现：形式 --> 构造 --> 自动化
2. DBMS为完成DB管理，在后台运行着一系列程序...
  + **语言编译器**：将数据库语言书写的内容，翻译成BDMS可执行的命令。例如：DDL编译器，DML编译器，DCL编译器等
  + **查询优化**(执行引擎)与**查询实现**(基本命令的不同执行算法)：提高数据库检索速度的手段。例如贯穿于数据存取各个阶段的优化程序
  + **数据存取与索引**：提供数据在磁盘/磁带等上的搞笑存取手段。例如：存储管理器，缓冲区管理器，索引/文件和记录管理器等
  + **通信控制**：提供网络环境下数据库操作与数据传输的手段
  + **事务管理**：提供提高可靠性并避免并发操作错误的手段
  + **故障恢复**：使用数据库自动恢复到故障发生前正确状态的手段。例如备份、运行日志操控等实用程序
  + **安全性控制**：提供合法性检验，避免非授权非法用户访问数据库的手段
  + **完整性控制**：提供数据及数据操作正确性检查的手段
  + **数据字典管理**：管理用户已经定义的信息
  + **应用程序接口(API)**：提供应用程序使用DBMS特定功能的二首段
  + **数据库数据装载、重组等实用程序**
  + **数据库性能分析**：统计在运行过程中数据库的各种性能数据，便于优化运行

> 典型的数据库管理系统(DBMS)：Oracle、DB2(IBM)、Sybase、Microsoft SQL Server、Microsoft Access、PostgreSQL 


### 2. 数据库系统的标准结构
DBMS管理数据的三个层次：
1. External Level = User Level（外部级别 = 用户级别）
  * 某一用户能够看到与处理的数据,   全局数据中的某一部分
2. Conceptual Level = Logic level（概念级别 = 逻辑级别）
  * 从全局角度理解/管理的数据, 含相应的关联约束
3. Internal Level = Physical level（内部级别 = 物理级别）
  * 存储在介质上的数据，含存储路径、存储方式 、索引方式等


### 3. 三级模式两层映像
数据库的三级模式结构是指：数据库系统是由外模式、模式(概念模式)和内模式三级构成
* 应用--> 外模式(多个) --> 模式(一个) --> 内模式(一个) --> 数据库

#### 3.1 数据(视图)与模式(数据的结构)
+ 模式(Schema):对数据库中数据所进行的一种结构性的描述，所观察到数据的结构信息
+ 视图(View)/数据(Data)：某一种表现形式下表现出来的数据库中的数据

#### 3.2 三级模式(三级视图)
1. External Schema ----(External) View
  * 外模式：某一用户能够看到与处理的数据的结构描述
2. (Conceptual) Schema ---- Conceptual View
  * 模式(概念模式)：从全局角度理解/管理的数据的结构描述, 含相应的关联约束
  * 体现在数据之间的内在本质联系
3. Internal Schema ---- Internal  View
  * 内模式：存储在介质上的数据的结构描述，含存储路径、存储方式 、索引方式等

#### 3.3 两层映像
1. E-C Mapping：External Schema-Conceptual Schema Mapping 
  + 将外模式映射为概念模式，从而支持实现数据概念视图向外部视图的转换
  + 便于用户观察和使用
2. C-I Mapping：Conceptual Schema-Internal Schema Mapping 
  + 将概念模式映射为内模式，从而支持实现数据概念视图向内部视图的转换
  + 便于计算机进行存储和处理

#### 3.4 标准结构的两个独立性
1. 逻辑数据独立性
  + 当概念模式变化时，可以不改变外部模式(只需改变E-C Mapping)，从而无需改变应用程序
2. 物理数据独立性
  + 当内部模式变化时，可以不改变概念模式(只需改变C-I Mapping) ，从而不改变外部模式


### 4. 数据模型
1. 数据模型：模式 与 模式的结构
  - 规定模式统一描述方式的模型，包括：数据结构、操作和约束
  - 数据模型是对模式本身结构的抽象，模式是对数据本身结构形式的抽象
  - 比如：关系模型：所有模式都可为抽象表(Table)的形式[**数据结构**]，而每一个具体的模式都是拥有不同列名的具体的表。对这种表形式的数据有哪些[**操作**]和[**约束**]
2. 三大经典数据模型
  - 关系模型：**表**的形式组织数据
  - 层次模型：**树**的形式组织数据
  - 网状模型：**图**的形式组织数据


### 5. 关系模型
1. 形象地说，**一个关系(relation)就是一个Table**，关系模型就是处理Table的，它由三个部分组成：
  + 描述DB各种数据的基本结构形式(Table/Relation)
  + 描述Table与Table之间所可能发生的各种操作(关系运算)
  + 描述这些操作所应遵循的约束条件(完整性约束)
2. 关系模型的三个要素：
  + 基本结构：Relation/Table
  + 基本操作：Relation Operator
    - 基本的:(并, UNION)、(差, DIFFERENCE)、(广义积,PRODUCT)、(选择, SELECTION)、(投影, PROJECTION)。
    - 扩展的:(交, INTERSECTION)、(连接, JOIN)、(除, DIVISION)运算
  + 完整性约束：实体完整性、参照完整性和用户自定义的完整性
3. 表(Table)的基本构成要素
  + 列/字段/属性/数据项：列名，列值
  + 行/元组/记录
  + 标题/模式

#### 5.1 “表”的严格定义
* 域(Domain)：“列”的取值范围，一组值的集合，这组值具有相同的数据类型
* 笛卡尔积(Cartesian Product)：“元组”及所有可能组合成的元组
* 关系(Relation)：一组域D1,D2,…,Dn的笛卡尔积的子集，笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)

#### 5.2 关系模式与关系
* 同一关系模式下，可有很多的关系
* 关系模式是关系的结构, 关系是关系模式在某一时刻的数据
* 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的

#### 5.3 关系的特性
* 列是同质：即每一列中的分量来自同一域，是同一类型的数据
* 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。
* 列位置互换性：区分哪一列是靠列名
* 行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)
* 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分
* 理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。元组相同是指两个元组的每个分量(列值)都相同。
* 属性不可再分特性:又被称为关系第一范式

#### 5.4 关系的一些重要概念
1. 候选码(Candidate Key)/候选键
  - 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉
任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。
2. 主码(Primary Key)/主键
  - 当有多个候选码时，可以选定一个作为主码。DBMS以主码为主要线索管理关系中的各个元组
3. 主属性与非主属性
  - 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性
  - 最简单的，候选码只包含一个属性；
  - 极端的，所有属性构成这个关系的候选码，称为全码(All-Key)
4. 外码(Foreign Key)/外键
  - 关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。
  - 两个关系通常是靠外码连接起来的。


### 6. 关系模型中的完整性
#### 6.1 实体完整性
* 关系的主码中的属性值不能为空值；
* 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的。

#### 6.2 参照完整性
* 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk 值，或者为空值
* 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在

#### 6.3 用户自定义完整性
* 用户针对具体的应用环境定义的完整性约束条件

#### 6.4 DBMS对关系完整性的支持
* 实体完整性和参照完整性由DBMS系统自动支持
* DBMS系统通常提供了如下机制：
  1. 它使用户可以自行定义有关的完整性约束条件
  2. 当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性


### 7. 关系代数
#### 7.1 关系代数的特点
* 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积(广义积)、选择、投影和更名等基本操作
* 以及交、 连接和关系除等扩展操作，是一种集合思维的操作语言。
* 关系代数操作以一个或多个关系为输入，结果是一个新的关系。
* 用对关系的运算来表达查询，需要指明所用操作, 具有一定的过程性。
* 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础

#### 7.2 关系代数的约束
某些关系代数操作，如并、差、交等，需满足"并相容性"
* 并相容性：
  1. 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性
  2. 定义：关系R与关系S存在相容性，当且仅当：
    - (1) 关系R和关系S的属性数目必须相同；
    - (2) 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同
  + 示例：关系R：STUDENT(SID **char(10)**, Sname **char(8)**, Age **char(3)**)
  + 示例：关系S：TEACHER(TID **char(10)**, Tname **char(8)**, Age **char(3)**)


#### 7.3 关系代数的基本操作
1. 集合操作
  * 并（UNIO）：R∪S
  * 交（INTERSECTION）：R∩S
  * 差（DIFFERENCE）：R-S
  * 笛卡儿积（Cartesian PRODUCT）：R×S
2. 纯关系操作
  * 选择（SELECT）：σF(R)
  * 投影（PROJECT）：ΠA(R)
  * 连接（JOIN）：R⋈S
  * 除（DIVISION）：R÷S

##### 7.3.1 并(Union) 操作
* 定义：设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：**`R∪S`**, 它由 或者出现在关系R中，或者出现在S中的元组构成。
* 数学描述：`R∪S={t|t∈R∨t∈S}`，其中t是元组
* 并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。
* 汉语中的“或者…或者…”通常意义是并运算的要求。
* `R∪S` 与 `S∪R` 运算的结果是**同**一个关系

##### 7.3.2 差(Difference) 操作
* 定义：设关系R 和关系S是并相容的，则关系R与关系S的差运算结果也是一个关系，记作：**`R-S`**, 它由出现在关系R中但不出现在关系S中的元组构成。
* 数学描述：`R－S={t|t∈R∧t∉S}`，其中t是元组
* 汉语中的“是…但不含…”通常意义是差运算的要求。
* `R-S` 与 `S-R` 是**不同**的

##### 7.3.3  交（Intersection Referential integrity） 操作
* 定义：设关系R和关系S具有相同的目n，且相应的属性取自同一个域，则关系R与关系S的交由既属于R又属于S的元组组成。其结果关系仍为n目关系。
* 数学描述：`R∩S={t|t∈R∧t∈S}`，其中t是元组

##### 7.3.4 广义笛卡尔积(Extended cartesian product) 操作
* 定义：关系`R(<a1,a2, …,an>)`与关系`S(<b1,b2, …,bm >)`的广义笛卡尔积(简称广义积,或 积 或笛卡尔积)运算结果也是一个关系，记作：**`RxS`**；两个分别为n目和m目的关系R和S的广义笛卡尔积是一个(n+m)列的元组的集合，元组的前n列是关系R的一个元组，后m列是关系S的一个元组，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。
* 数学描述：`RxS = {<a1,a2,…,an,b1,b2,…,bm>|<a1,a2,…,an>∈R ∧ <b1,b2,…,bm>∈S}`
* `RxS=SxR`：RxS为R中的每一个元组都和S中的所有元组进行串接。`SxR`为S中的每一个元组都和R中的所有元组进行串接。结果是相同的。
* 两个关系R和S，它们的**属性个数**分别为n和m(R是n度关系，S是m度关系)则笛卡尔积R×S的属性个数=n+m。即元组的前n个分量是R中元组的分量，后m个分量是S中元组的分量(R×S是n+m度关系).
* 两个关系R和S，它们的**元组个数**分别为x和y(关系R的基数x,S的基数y),则笛卡尔积R×S的元组个数=x×y。(R×S的基数是x×y).

##### 7.3.5 选择(Select)
* 定义：给定一个关系R, 同时给定一个选择的条件condition(简记F), 选择运算结果也是一个关系，记作**`σF(R)`**, 它从关系R中选择出满足给定条件condition的元组构成。
* 数学描述：`σF(R) = {t|t∈R ∧ F(t)='真'}`,其中F表示选择条件，它是一个逻辑表达式，取逻辑值‘真’或‘假’。
* 选择操作从给定的关系中选出满足条件的行,条件的书写很重要，尤其是当不同运算符在一起时，要注意运算符的优先次序，优先次序自高至低为{ `括弧()；θ；¬；∧；∨` }

##### 7.3.6 投影(Project)
* 定义：给定一个关系R, 投影运算结果也是一个关系，记作**`A(R)`**, 它从关系R中选出属性包含在A中的列构成。
* 数学描述：`ΠA(R) = {t[A] | t∈R}`,其中A为R中的属性列
* 投影操作从给定关系中选出某些列组成新的关系, 而选择操作是从给定关系中选出某些行组成新的关系


#### 7.4 关系代数的扩展操作
##### 7.4.1 交(Intersection)
* **定义**：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，记作：**`R∩S`**, 它由同时出现在关系R和关系S中的元组构成。
* 数学描述：`R∩S = {t|t∈R ∧ t∈S}`，其中t是元组
* R∩S 和 S∩R 运算的结果是同一个关系
* 交运算可以通过差运算来实现：`R∩S = R-(R-S) = S-(S-R)`
* 汉语中的“既…又…”，“…, 并且…”通常意义是交运算的要求

##### 7.4.2 θ-连接(θ-Join, theta-Join)
* 投影与选择操作只是对单个关系(表)进行操作, 而实际应用中往往涉及多个表之间的操作, 这就需要θ-连接操作
* **定义**：给定关系R和关系S, R与S的连接运算结果也是一个关系，记作 **`R⋈S[AθB]`**：(括号内AθB是⋈的下标)，它由关系R和关系S的笛卡尔积中, 选取R中属性A与S中属性B之间满足 θ 条件的元组构成。
* 数学描述：`R⋈S[AθB] = σ t[A]θs[B] (R×S)`，σF(RxS)其中t是R中的元组，s是S中的元组
* 在实际应用中，θ-连接操作经常与投影Π、选择σ操作一起使用
* **特别注意**：当引入θ-连接操作后，DBMS可直接进行连接操作，而不必先形成笛卡尔积。

##### 7.4.3 等值连接(Equi-Join)
* **定义**：给定关系R和关系S, R与S的等值连接运算结果也是一个关系，记作**`R⋈S[A=B]`**：(括号内A=B是⋈的下标)，它由关系R和关系S的笛卡尔积中选取R中属性A与S中属性B上值相等的元组所构成。
* 数学描述：`R⋈S[A=B] = σ t[A]=s[B] (R×S)`
* 当θ-连接中运算符为“＝”时，就是等值连接，等值连接是θ-连接的一个特例；
* 广义积的元组组合并不是都有意义的，另广义积的元组组合数目也非常庞大，因此采用**θ-连接/等值连接**运算可大幅度降低中间结果的保存量，提高速度。

##### 7.4.4 自然连接(Natural-Join)
* 定义：给定关系R和关系S, R与S的自然连接运算结果也是一个关系，记作 ，它由关系R和关系S的笛卡尔积中选取相同属性组B上值相等的元组所构成。
* 数学描述：`R⋈S = σ t[B]=s[B] (R×S)`
* 自然连接是一种特殊的等值连接，要求关系R和关系S必须有相同的属性组B，R, S属性相同，值必须相等才能连接，要在结果中去掉重复的属性列

#### 7.5 关系代数的基本书写思路
1. 选出将用到的关系/表
2. 做"积"运算（可用连接运算替换）
3. 做选择运算保留所需的行/元组
4. 做投影运算保留所需的列/属性

- 基本思路： 检索是否涉及多个表，如不涉及，则可直接采用并、差、交、选择与投影，只要注意条件书写正确与否即可
- 如涉及多个表，则检查：
  * 能否使用自然连接，将多个表连接起来(多数情况是这样的)
  * 如不能，能否使用等值或不等值连接(θ-连接)
  * 还不能，则使用广义笛卡尔积，注意相关条件的书写
- 连接完后，可以继续使用选择、投影等运算，即所谓数据库的“选投联”操作


#### 7.6 关系代数之复杂扩展操作
##### 7.6.1 除(Division)
* 除法运算经常用于求解“查询… 全部的/所有的…”问题
* 前提条件：给定关系R(A1 ,A2 , … ,An)为n度关系，关系S(B1 ,B2 , … ,Bm)为m度关系 。如果可以进行关系R与关系S的除运算，当且仅当：属性集{ B1 ,B2 , … , Bm }是属性集{ A1 ,A2 , … ,An }的真子集，即m < n。
* 定义：关系R 和关系S的除运算结果也是一个关系，记作R÷S，分两部分来定义。
* 数学描述：
``` math
R÷S = {t|t∈Π[R-S](R) ∧ ∀u∈S(tu∈R) }
    = Π[R-S](R) - Π[R-S]((Π[R-S](R)×S)-R)
```
> 其中[R-S]为投影Π的下标(属性)

##### 7.6.2 外连接(Outer-Join)
* 定义：两个关系R与S进行连接时，如果关系R(或S)中的元组在S(或R)中找不到相匹配的元组，则为了避免该元组信息丢失，从而将该元组与S(或R)中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接(Outer Join)。
* 外连接 = 自然连接 (或θ连接) + 失配的元组(与全空元组形成的连接)
* 外连接的形式：左外连接、右外连接、全外连接
  - 左外连接 = 自然连接(或连接) + 左侧表中失配的元组
  - 右外连接 = 自然连接(或连接) + 右侧表中失配的元组
  - 全外连接 = 自然连接(或连接) + 两侧表中失配的元组
  - 左外连接(Left Outer Join)记为：⋊
  - 右外连接(Right Outer Join)记为：⋉
  - 全外连接(Full Outer Join)记为：⋊⋉


### 8. 关系演算
关系演算是**描述关系运算**的另一种思维方式，它是以数理逻辑中的谓词演算为基础的，SQL语言是继承了关系代数和关系演算各自的优点所形成的
* 按照谓词变量的不同，可分为关系元组演算和关系域演算
  1. 关系元组演算是以**元组变量**作为谓词变量的基本对象
  2. 关系域演算是以**域变量**作为谓词变量的基本对象

#### 8.1 关系元组演算
1. 关系元组演算公式：{ t | P(t) }
  - 表示：所有使谓词 P 为真的元组 t 的集合
  - t 是元组变量
  - t ∈ r 表示元组 t 在关系 r 中
  - t[A] 表示元组 t 的分量，即 t 在属性 A 上的值
  - P是与谓词逻辑相似的公式, P(t)表示以元组 t 为变量的公式
2. 关系元组演算公式的基本形式：{ t | P(t) }
3. P(t)可以是如下三种形式之一的原子公式：
  + t∈R：t 是关系 R 中的一个元组，例如： { t | t∈Student}
  + s[A] θ c：元组分量s[A]与常量 c 之间满足比较关系θ，θ:比较运算符<,<=,=,<>,>,>=
  + s[A] θ u[B]：s[A] 与 u[B] 为元组分量，A和B分别是某些关系的属性，他们之间满足比较关系θ，
4. P(t)可以由公式加运算符 ∧(与)、∨(或)、¬(非)递归地构造
  + 如果F是一个公式，则 ¬F 也是公式
  + 如果F1、F2是公式，则 F1∧F2, F1∨F2也是公式
5. P(t)运算符优先次序(括弧；θ；∃；∀；¬；∧；∨)示例
6. 构造P(t)还有两个运算符：∃(存在)、∀(任意)
  + 如果F是一个公式，则 ∃(t∈r)(F(t)) 也是公式
  + 如果F是一个公式，则 ∀(t∈r)(F(t)) 也是公式
  + 运算符∃和∀，又称为量词，前者称“**存在量词**”，后者称“**全称量词**”
  + 而被∃或∀限定的元组变量 t , 或者说，元组变量 t 前有存在量词或全称量词，则该变量被称为“**约束变量**”，否则被称为“**自由变量**”。
7. 元组演算的等价性变换
    + 符号`<=>`表示表示等价于,如：`¬(A>B) <=> A<=B  <=> A<B∨A=B`


#### 8.2 关系域演算
1. 关系域演算公式的基本形式：`{<x1,x2, …,xn> | P(x1,x2, …,xn)}`,其中 xi 代表域变量或常量, P为以xi为变量的公式。
2. 元组演算是以元组为变量，以元组为基本处理单位，先找到元组，然后再找到元组分量，进行谓词判断；
3. 域演算是以域变量为基本处理单位，先有域变量，然后再判断由这些域变量组成的元组是否存在或是否满足谓词判断。
4. 公式的运算符(∧(与)、∨(或)、¬(非)、∀(全称量词)和∃(存在量词))是相同的，只是其中的变量不同。
5. 元组演算和域演算可以等价互换。

##### 8.2.1 基于关系域演算的QBE语言
QBE: Query By Example，1975年由M. M. Zloof提出，1978年在IBM370上实现，是一种高度非过程化的查询语言，特别适合于终端用户的使用。
1. 特点：操作独特，基于屏幕表格的查询语言，不用书写复杂的公式，只需将条件填在表格中即可
2. QBE操作框架由四个部分构成
    + 关系名区：用于书写欲待查询的关系名
    + 属性名区：用于显示对应关系名区关系的所有属性名
    + 操作命令区：用于书写查询操作的命令
    + 查询条件区：用于书写查询条件
3. QBE的操作命令
    + Print 或 P.   ---- 显示输出操作
    + Delete或D.   ---- 删除操作
    + Insert或I.     ---- 插入操作
    + Update或U. ---- 更新操作
4. 构造查询的几个要素 
    + 示例元素: 即域变量， 一定要加下划线 
    + 示例元素是这个域中可能的一个值， 它不必是查询结果中的元素
    + 打印操作符P.: 指定查询结果所含属性列 
    + 查询条件: 不用加下划线
    + 可使用比较运算符＞， ≥，＜， ≤，＝和≠  其中＝可以省略
    + 排序要求 
        - 升序排序(AO.)，降序排序（DO.）,多列排序，用‚AO(i).‛ 或‚DO(i).‛ 表示 ，其中i为排序的优先级， i值越小，优先级越高

#### 8.3 安全性
关系运算的安全性：不产生无限关系和无穷验证的运算被称为是安全的
1. 关系代数是一种集合运算，是安全的
    + 集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。
2. 关系演算不一定是安全的
    + 如：{t|¬(R(t))}, {t R(t)∨t[2]>3}可能表示无限关系
3. 需要对关系演算施加约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。

##### 8.3.1 安全约束有限集合DOM
1. DOM(ψ)是一个有限集合，其中的每个符号要么是ψ中明显出现的符号，要么是出现在ψ中的某个关系R的某元组的分量。
2. DOM主要用于约束ψ中一些谓词的计算范围，它不必是最小集合。
3. 安全元组演算表达式，满足三个条件：
    + 只要t满足ψ，t的每个分量就是DOM(ψ)的一个成员。
        - { t|ψ(t) }中t的取值只能是DOM中的值，有限的。
    + 对于ψ中形如(∃u)(ω(u))的子表达式，若u满足ω,则u的每个分量都是DOM(ω)中的成员。
        - { t|ψ(t) }中的每个(∃u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为真的元素。而对于DOM以外的元素，已经明确其都不满足ω(u)，无需验证。
    + 对于ψ中形如(∀u)(ω(u))的子表达式，若u不满足ω,则u的每个分量都是DOM(ω)中的成员。
        - { t|ψ(t) }中的每个(∀u)(ω(u))子表达式，只需要验证DOM中的元素是否有使ω(u)为假的元素。而对于DOM以外的元素，已经明确其都满足ω(u)，无需验证。


#### 8.4 关于三种关系运算的一些观点
1. 关系运算有三种：关系代数、关系元组演算和关系域演算
2. 三种关系运算都是抽象的数学运算，体现了三种不同的思维
    + 关系代数---以集合为对象的操作思维，由集合到集合的变换
    + 元组演算---以元组为对象的操作思维，取出关系的每一个元组进行验证，有一个元组变量则可能需要一个循环，多个元组变量则需要多个循环
    + 域演算---以域变量为对象的操作思维，取出域的每一个变量进行验证看其是否满足条件
3. 三种运算之间是等价的
    + 关系代数 与 安全的元组演算表达式 与 安全的域演算表达式 是等
价的。即一种形式的表达式可以被等价地转换为另一种形式
4. 三种关系运算都可说是非过程性的
    + 相比之下：域演算的非过程性最好，元组演算次之，关系代数最差
5. 三种关系运算虽是抽象的，但却是衡量数据库语言完备性的基础
    + 一个数据库语言如果能够等价地实现这三种关系运算的操作，则说该语言是完备的
    + 目前多数数据库语言都能够实现这三种运算的操作，在此基础上还增加了许多其他的操作，如赋值操作、聚集操作等
6. 数据库语言可以基于这三种抽象运算来设计
    + 用“键盘符号”来替换抽象的数学符号
    + 用易于理解的符号组合来表达抽象的数学符号
    + 例如：ISBL语言---基于关系代数的数据库语言
    + 再例如：Ingres系统的QUEL语言
