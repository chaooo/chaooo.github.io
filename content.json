[{"title":"github博客迁移","date":"2016-08-17T03:14:25.000Z","path":"2016/08/17/github博客迁移.html","text":"由于github博客在国内访问非常慢而且经常不稳定，百度爬虫也无法抓取github博客内容，所以决定将博客迁移至码云。 1.迁移代码把代码从github迁移至码云（oschina）。首先，你要先在码云注册一个账号，和GitHub操作基本一样，这里不再赘述。码云的Pages服务基本和GitHub的一样，不过码云的Pages服务更灵活一些。在GitHub上，可以新建一个以用户名命名的仓库，将网站代码放在master分支下，即可自动部署到：http://用户名.github.io/，若其他命名的仓库则新建一个gh-pages的分支，网站代码放在gh-pages下，，即可自动部署到：http://用户名.github.io/仓库名/。对于码云，基本和GitHub一样，不过还需要手动开启Pages服务，而且其他仓库虽然默认在osc-pages下，但可自定到自己喜欢的分支上。代码迁移步骤如下： 1.1 新建码云项目以我自己的博客为例，项目地址：https://github.com/chaooo/chaooo.github.io.git。它在Github上的Pages地址是：http://chaooo.github.io如果想把它转移到码云Pages，只需要登录你的码云账户，点击右上角的+号，选择新建项目: 1.2 开启pages服务然后点击创建，项目会在后台自动导入，导入成功后，点击菜单栏的Pages,码云默认的Pages服务分支是osc-pages，但是你也已选择自己静态页面所在的分支，这里我的博客项目的静态页面分支是master，选择master并点击启动服务。至此，博客已经部署成功，访问提供的地址：http://chaoo.oschina.io即可查看到我的博客。 2.修改hexo配置打开博客根目录的_config.yml文件，找到：12345678910# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://chaooo.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 修改为(根据自己的仓库地址修改)：1234567891011121314# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#url: http://chaooo.github.iourl: http://chaoo.oschina.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:#- type: git# repository: https://github.com/chaooo/chaooo.github.io.git# branch: master- type: git repository: https://git.oschina.net/chaoo/chaoo.git branch: master 然后执行下面命令，以重新生成baidusitemap.xml。1hexo generate -d 3.验证网站百度搜索引擎入口：百度搜索引擎入口。先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的public/下面 。然后部署到服务器,输入地址：http://chaoo.oschina.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照百度的引导步骤就好)。 4.sitemap提交直接点击sitemap填写数据文件地址：http://chaoo.oschina.io/baidusitemap.xml,输入验证码提交。 自动推送自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout\\_partial\\after_footer.ejs中的最下面就行。代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 这样就可以等待百度收录了。","tags":[{"name":"github,hexo","slug":"github-hexo","permalink":"http://chaoo.oschina.io/tags/github-hexo/"}]},{"title":"好用的Web包管理器-Bower","date":"2016-08-12T07:32:41.000Z","path":"2016/08/12/Web包管理器-Bower.html","text":"Bower是twitter推出的客户端包管理工具，用于命令行操作包的搜索、下载、更新、卸载(如jQuery、Bootstrap、JavaScript、HTML、CSS之类的网络资源)。Bower对包结构没有强制规范，可以很方便获取各种Web模块文件，但bower本身不存储模块文件和模块版本信息，模块发布者通过register方式将模块可访问的公开的git地址记录在bower的数据库中，而所有版本都是通过代码库的tag来决定的。 开始之前在安装bower之前，必须确认你已经安装了Node.js和Git。 1.安装Bower使用npm，打开终端，键入：1npm install -g bower #全局安装bower 移步这里查看不同平台上安装的问题。 2.使用Bower使用help命令查看帮助。12345678910111213141516171819202122232425262728293031323334bower helpUsage: bower &lt;command&gt; [&lt;args&gt;] [&lt;options&gt;]Commands: cache Manage bower cache help Display help information about Bower home Opens a package homepage into your favorite browser info Info of a particular package init Interactively create a bower.json file install Install a package locally link Symlink a package folder list List local packages - and possible updates login Authenticate with GitHub and store credentials lookup Look up a package URL by name prune Removes local extraneous packages register Register a package search Search for a package by name update Update a local package uninstall Remove a local package unregister Remove a package from the registry version Bump a package versionOptions: -f, --force Makes various commands more forceful -j, --json Output consumable JSON -l, --loglevel What level of logs to report -o, --offline Do not hit the network -q, --quiet Only output important information -s, --silent Do not output anything, besides errors -V, --verbose Makes output more verbose --allow-root Allows running commands as root -v, --version Output Bower version --no-color Disable colorsSee 'bower help &lt;command&gt;' for more information on a specific command. 3.安装包到本地通过命令bower install安装软件包默认到bower_components/目录。1bower install &lt;package&gt; #package为包名 想要下载的包可以是GitHub上的短链接（如jquery/jquery）、.git 、一个URL或者其它.12345bower install # 通过 bower.json 文件安装bower install jquery # 通过在github上注册的包名安装bower install desandro/masonry # GitHub短链接bower install git://github.com/user/package.git # Github上的 .gitbower install http://example.com/script.js # URL 安装选项12345-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Save installed packages into the project’s bower.json dependencies-D, --save-dev: Save installed packages into the project’s bower.json devDependencies-E, --save-exact: Configure installed packages with an exact version rather than semver 4.用bower.json文件来管理依赖发布项目的时候没有必要把所有依赖的库发布上去，只需在根目录生成一个bower.json文件即可，别人使用时在根目录执行bower install就可根据bower.json来安装依赖的包。在项目中执行1bower init 会提示你输入一些基本信息，根据提示按回车或者空格即可，然后会生成一个bower.json文件，用来保存该项目的配置.如果想保存依赖信息(dependencies)到你的bower.json文件，安装包时，命令后面跟上--save即可。 5.使用下载好的包对于已经下载下来的包，默认在当前目录的bower_components文件夹。你可以直接在项目里引用。例如：12&lt;link rel=\"stylesheet\" href=\"bower_components/bootstrap/dist/css/bootstrap.min.css\"&gt;&lt;script type=\"text/javascript\" src=\"bower_components/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt; 6.更新包若下载的包升级了，只需执行update命令即可更新，例如：1bower update jquery 这样就可以自动升级到最新版的jquery了。更新选项1234-F, --force-latest: Force latest version on conflict-p, --production: Do not install project devDependencies-S, --save: Update dependencies in bower.json-D, --save-dev: Update devDependencies in bower.json 7.搜索包12bower search #搜索所有包bower search &lt;packageName&gt; #搜索指定名称的包 或者可以在这里:https://bower.io/search/搜索喜欢的包. 8.卸载包1bower uninstall &lt;name&gt; [&lt;name&gt; ..] [&lt;options&gt;] 卸载选项12-S, --save: Remove uninstalled packages from the project’s bower.json dependencies-D, --save-dev: Remove uninstalled packages from the project’s bower.json devDependencies","tags":[{"name":"bower","slug":"bower","permalink":"http://chaoo.oschina.io/tags/bower/"}]},{"title":"Node.js 多进程(17)","date":"2016-06-30T07:42:28.000Z","path":"2016/06/30/Node.js 多进程.html","text":"17、Node.js 多进程我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。Node 提供了 child_process 模块来创建子进程，方法有： exec - child_process.exec//使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。 spawn - child_process.spawn//使用指定的命令行参数创建新线程。 fork - child_process.fork//是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。 exec()方法child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。语法如下所示：1child_process.exec(command[, options], callback) 参数说明如下： command//字符串， 将要运行的命令，参数使用空格隔开 options//对象，可以是： /cwd ，字符串，子进程的当前工作目录 env，对象 环境变量键值对 encoding ，字符串，字符编码（默认： ‘utf8’） shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为/bin/sh， 在 Windows 中为cmd.exe， Shell 应当能识别 -c开关在 UNIX 中，或 /s /c 在 Windows 中。 在Windows 中，命令行解析应当能兼容cmd.exe） timeout，数字，超时时间（默认： 0） maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: 2001024） killSignal ，字符串，结束信号（默认：’SIGTERM’） uid，数字，设置用户进程的 ID gid，数字，设置进程组的 ID*/ callback//回调函数，包含三个参数error, stdout 和 stderr。 exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。 实例让我们创建两个 js 文件 support.js 和 master.js。12//support.js 文件代码： console.log(\"进程 \" + process.argv[2] + \" 执行。\" ); 1234567891011121314151617//master.js 文件代码： const fs = require('fs'); const child_process = require('child_process'); for (var i = 0; i &lt; 3; i++) &#123; var workerProcess = child_process.exec('node support.js' + i, function (error, stdout, stderr)&#123; if (error) &#123; console.log(error.stack); console.log('Error code: ' + error.code); console.log('Signal received: ' + error.signal); &#125; console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); &#125;); workerProcess.on('exit', function (code)&#123; console.log('子进程已退出，退出码 ' + code); &#125;); &#125;; //执行以上代码，结果如下所示：12345678910111213node master.js 子进程已退出，退出码 0stdout: 进程 1 执行。stderr: 子进程已退出，退出码 0stdout: 进程 0 执行。stderr: 子进程已退出，退出码 0stdout: 进程 2 执行。stderr: spawn() 方法child_process.spawn 使用指定的命令行参数创建新线程，语法格式如下：1child_process.spawn(command[, args][, options]) 参数说明如下： command //将要运行的命令 args // Array 字符串参数数组 options //Object /cwd String 子进程的当前工作目录 env Object 环境变量键值对 stdio Array|String 子进程的 stdio 配置 detached Boolean 这个子进程将会变成进程组的领导 uid Number 设置用户进程的 ID gid Number 设置进程组的 ID/spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。 实例让我们创建两个 js 文件 support.js 和 master.js。12//support.js 文件代码： console.log(\"进程 \" + process.argv[2] + \" 执行。\" ); 123456789101112131415//master.js 文件代码： const fs = require('fs'); const child_process = require('child_process'); for (var i = 0; i &lt; 3; i++) &#123; var workerProcess = child_process.spawn('node', ['support.js', i]); workerProcess.stdout.on('data', function (data)&#123; console.log('stdout: ' + data); &#125;); workerProcess.stderr.on('data', function (data)&#123; console.log('stderr: ' + data); &#125;); workerProcess.on('close', function (data)&#123; console.log('子进程已退出，退出码' + code); &#125;); &#125;; //执行以上代码，输出结果为：123456789node master.js stdout: 进程 0 执行。子进程已退出，退出码 0stdout: 进程 1 执行。子进程已退出，退出码 0stdout: 进程 2 执行。子进程已退出，退出码 0 fork 方法child_process.fork 是 spawn() 方法的特殊形式，用于创建进程，语法格式如下：1child_process.fork(modulePath[, args][, options]) 参数说明如下： modulePath//String，将要在子进程中运行的模块 args// Array 字符串参数数组 options//Object /cwd String 子进程的当前工作目录 env Object 环境变量键值对 execPath String 创建子进程的可执行文件 execArgv Array 子进程的可执行文件的字符串参数数组（默认： process.execArgv） silent Boolean 如果为true，子进程的stdin，stdout和stderr将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：false） uid Number 设置用户进程的 ID gid Number 设置进程组的 ID/返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。 实例让我们创建两个 js 文件 support.js 和 master.js。12//support.js文件，代码如下： console.log(\"进程\" + process.argv[2] + \"执行。\"); 123456789//master.js文件，代码如下： const fs = require('fs'); const child_process = require('child_process'); for (var i = 0; i &lt; 3; i++) &#123; var worker_process = child_process.fork(\"support.js\", [i]); worker_process.on('close', function (code)&#123; console.log('子进程已退出，退出码' + code); &#125;); &#125;; //执行以上代码，输出结果为：1234567node master.js 进程 0 执行。子进程已退出，退出码 0进程 1 执行。子进程已退出，退出码 0进程 2 执行。子进程已退出，退出码 0","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js RESTful API(16)","date":"2016-06-30T03:38:20.000Z","path":"2016/06/30/Node.js RESTful API.html","text":"16、Node.js RESTful API */REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。 表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。 HTTP 方法以下为 REST 基本架构的四个方法：1234GET - 用于获取数据。PUT - 用于添加数据。DELETE - 用于删除数据。POST - 用于更新或添加数据。 创建 RESTful首先，创建一个 json 数据资源文件 users.json，内容如下：1234567891011121314151617181920&#123; \"user1\" : &#123; \"name\" : \"mahesh\", \"password\" : \"password1\", \"profession\" : \"teacher\", \"id\": 1 &#125;, \"user2\" : &#123; \"name\" : \"suresh\", \"password\" : \"password2\", \"profession\" : \"librarian\", \"id\": 2 &#125;, \"user3\" : &#123; \"name\" : \"ramesh\", \"password\" : \"password3\", \"profession\" : \"clerk\", \"id\": 3 &#125;&#125; 基于以上数据，我们创建以下 RESTful API：12345序号 URI HTTP方法 发送内容 结果 1 listUsers GET 空 显示所有用户列表 2 addUser POST JSON 字符串 添加新用户 3 deleteUser DELETE JSON 字符串 删除用户 4 :id GET 空 显示用户详细信息 获取用户列表：listUsers创建 RESTful API listUsers，用于读取用户的信息列表， server.js 文件代码如下所示：1234567891011121314var express = require('express');var app = express();var fs = require('fs');app.get('./listUsers', function (req, res)&#123; fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; console.log(data); res.end(data); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/listUsers，结果如下所示：1234567891011121314151617181920&#123; \"user1\" : &#123; \"name\" : \"mahesh\", \"password\" : \"password1\", \"profession\" : \"teacher\", \"id\": 1 &#125;, \"user2\" : &#123; \"name\" : \"suresh\", \"password\" : \"password2\", \"profession\" : \"librarian\", \"id\": 2 &#125;, \"user3\" : &#123; \"name\" : \"ramesh\", \"password\" : \"password3\", \"profession\" : \"clerk\", \"id\": 3 &#125;&#125; 添加用户：addUser创建 RESTful API addUser， 用于添加新的用户数据，server.js 文件代码如下所示：1234567891011121314151617181920212223242526var express = require('express');var app = express();var fs = require('fs');//添加的新用户数据var user = &#123; \"user4\" : &#123; \"name\" : \"mohit\", \"password\" : \"password4\", \"profession\" : \"teacher\", \"id\": 4 &#125;&#125;;app.get('./addUser', function (req, res)&#123; //读取已存在的数据 fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; data = JSON.parse(data); data[\"user4\"] = user[\"user4\"]; console.log(data); res.end(JSON.stringify(data)); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/addUser，结果如下所示：123456789101112131415161718192021&#123; user1: &#123; name: 'mahesh', password: 'password1', profession: 'teacher', id: 1 &#125;, user2: &#123; name: 'suresh', password: 'password2', profession: 'librarian', id: 2 &#125;, user3: &#123; name: 'ramesh', password: 'password3', profession: 'clerk', id: 3 &#125;, user4: &#123; name: 'mohit', password: 'password4', profession: 'teacher', id: 4 &#125; &#125; 删除用户：deleteUser创建 RESTful API deleteUser， 用于删除指定用户的详细信息，以下实例中，用户 id 为 2，server.js 文件代码如下所示：1234567891011121314151617var express = require('express');var app = express();var fs = require('fs');app.get('./deleteUser', function (req, res)&#123; //读取已存在的数据 fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; data = JSON.parse(data); delete data[\"user\"+2]; console.log(data); res.end(JSON.stringify(data)); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/deleteUser，结果如下所示：1234567891011&#123; user1: &#123; name: 'mahesh', password: 'password1', profession: 'teacher', id: 1 &#125;, user3: &#123; name: 'ramesh', password: 'password3', profession: 'clerk', id: 3 &#125;,&#125; 显示用户详情：:id(用户id)创建 RESTful API :id（用户id）， 用于读取指定用户的详细信息，server.js 文件代码如下所示：1234567891011121314151617var express = require('express');var app = express();var fs = require('fs');app.get('./:id', function (req, res)&#123; //读取已存在的数据 fs.readFile(__dirname + \"/\" + \"users.Json\", 'utf8', function (err, data)&#123; data = JSON.parse(data); var user = data[\"user\" + req.params.id] console.log(user); res.end(JSON.stringify(user)); &#125;);&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)&#125;); 接下来执行以下命令：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/2，结果如下所示：123456&#123; \"name\":\"suresh\", \"password\":\"password2\", \"profession\":\"librarian\", \"id\":2&#125;","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js Express 框架(15)","date":"2016-06-30T01:38:20.000Z","path":"2016/06/30/Node.js Express 框架.html","text":"15、Node.js Express 框架Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性：1、可以设置中间件来响应 HTTP 请求。2、定义了路由表用于执行不同的 HTTP 请求动作。3、可以通过向模板传递参数来动态渲染 HTML 页面。 安装 Express安装 Express 并将其保存到依赖列表中：1npm install express --save 以上命令会将 Express 框架安装在当期目录的 node_modules 目录中， node_modules 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：123456//body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。//cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。//multer - node.js 中间件，用于处理 enctype=&quot;multipart/form-data&quot;（设置表单的MIME编码）的表单数据。 npm install body-parser --save npm install cookie-parser --save npm install multer --save 第一个 Express 框架实例接下来我们使用 Express 框架来输出 “Hello World”。以下实例中我们引入了 express 模块，并在客户端发起请求后，响应 “Hello World” 字符串。创建 express_demo.js 文件，代码如下所示：12345678910var express = require('express');var app = express();app.get('/', function (req,res)&#123; res.send('Hello World');&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;); 执行以上代码：12node express_demo.js应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081，结果如下所示：1Hello World 请求和响应Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 Request 对象request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：req.app：当callback为外部文件时，用req.app访问express的实例req.baseUrl：获取路由当前安装的URL路径req.body / req.cookies：获得「请求主体」/ Cookiesreq.fresh / req.stale：判断请求是否还「新鲜」req.hostname / req.ip：获取主机名和IP地址req.originalUrl：获取原始请求URLreq.params：获取路由的parametersreq.path：获取请求路径req.protocol：获取协议类型req.query：获取URL的查询参数串req.route：获取当前匹配的路由req.subdomains：获取子域名req.accpets（）：检查请求的Accept头的请求类型req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguagesreq.get（）：获取指定的HTTP请求头req.is（）：判断请求头Content-Type的MIME类型 Response 对象response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：res.app：同req.app一样res.append（）：追加指定HTTP头res.set（）在res.append（）后将重置之前设置的头res.cookie（name，value [，option]）：设置Cookieopition: domain / expires / httpOnly / maxAge / path / secure / signedres.clearCookie（）：清除Cookieres.download（）：传送指定路径的文件res.get（）：返回指定的HTTP头res.json（）：传送JSON响应res.jsonp（）：传送JSONP响应res.location（）：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect（）：设置响应的Location HTTP头，并且设置状态码302res.send（）：传送HTTP响应res.sendFile（path [，options] [，fn]）：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set（）：设置HTTP头，传入object可以一次设置多个头res.status（）：设置HTTP状态码res.type（）：设置Content-Type的MIME类型 路由我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。接下来我们扩展 Hello World，添加一些功能来处理更多类型的 HTTP 请求。创建 express_demo2.js 文件，代码如下所示：1234567891011121314151617181920212223242526272829303132var express = require('express');var app = express();//主页输出\"Hello World\"app.get('/', function (req, res)&#123; console.log(\"主页GET请求\"); res.send('Hello GET');&#125;);//POST请求app.post('/', function (req, res)&#123; console.log(\"主页 POST 请求\"); res.send('Hello POST');&#125;);// /del_user页面响应app.delete('/del_user', function (req, res)&#123; console.log(\"/del_user响应 DELETE 请求\"); res.send('删除页面');&#125;);// /list_user 页面 GET 请求app.get('/list_user', function (req, res)&#123; console.log(\"/list_user 页面 GET 请求\"); res.send('用户列表页面');&#125;);// 对页面 abcd, abxcd, ab123cd, 等响应GET请求app.get('/ab*cd', function (req, res)&#123; console.log(\"/ab*cd GET 请求\"); res.send('正则匹配')&#125;);var server = app.listen(8081,function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;); 执行以上代码：1234567891011 node express_demo2.js 应用实例，访问地址为 http://0.0.0.0:8081``` 接下来你可以尝试访问 http://127.0.0.1:8081 不同的地址，查看效果。 访问 http://127.0.0.1:8081/list_user 结果：用户列表页 访问 http://127.0.0.1:8081/abcd 结果：正则匹配 访问 http://127.0.0.1:8081/abcdefg 结果：Cannot GET/abcdefg 无法解析该地址#### 静态文件Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：``` javascript app.use(express.static(&apos;public&apos;));//public为放置静态文件的目录 我们可以到 public/images 目录下放些图片,如下所示：12345node_modulesserver.jspublic/public/imagespublic/images/logo.png 让我们再修改下 “Hello Word” 应用添加处理静态文件的功能。创建 express_demo3.js 文件，代码如下所示：1234567891011var express = require('express');var app = express();app.use(express.static('public'));app.get('/', function (req, res)&#123; res.send('Hello World');&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;) 执行以上代码：12node express_demo3.js 应用实例，访问地址为 http://0.0.0.0:8081 在浏览器中访问 http://127.0.0.1:8081/images/logo.png ,结果展示了图片。 GET 方法以下实例演示了在表单中通过 GET 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：index.htm 文件代码如下：123456789&lt;html&gt; &lt;body&gt; &lt;form action=\"http://127.0.0.1:8081/process_get\" method=\"GET\"&gt; First Name:&lt;input type=\"text\" name=\"first_name\"&gt;&lt;br&gt; Last Name: &lt;input type=\"text\" name=\"last_name\"&gt; &lt;input type=\"submit\" name=\"Submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; server.js文件：1234567891011121314151617181920var express = require('express');var app = express();app.use(express.static('public'));app.get('/index.htm', function (req, res)&#123; res.sendFile(__dirname + \"/\" + \"index.htm\");&#125;);app.get('/process_get', function (req, res)&#123; //输出JSON格式 response = &#123; first_name:req.query.first_name, last_name:req.query.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port); &#125;); 执行以上代码：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 浏览器访问 http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果： {&quot;first_name&quot;:&quot;aaa&quot;,&quot;last_name&quot;:&quot;bbb&quot;} POST 方法以下实例演示了在表单中通过 POST 方法提交两个参数，我们可以使用 server.js 文件内的 process_get 路由器来处理输入：index.htm 文件代码修改如下：123456789&lt;html&gt; &lt;body&gt; &lt;form action=\"http://127.0.0.1:8081/process_post\" method=\"POST\"&gt; First Name: &lt;input type=\"text\" name=\"first_name\"&gt;&lt;br&gt; Last Name: &lt;input type=\"text\" name=\"last_name\"&gt; &lt;input type=\"submit\" value=\"Submit\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; server.js 文件代码修改如下:1234567891011121314151617181920212223var express = require('express');var app = express();var bodyParser = require('body-parser');//创建application/x-www-form-urlencode编码解析var urlencodedParser = bodyParser.urlencoded(&#123;extended:false&#125;);app.use(express.static('public'));app.get('/index.htm', function (req, res) &#123; res.sendFile(__dirname + \"/\" + \"index.htm\");&#125;);app.post('/process_post', urlencodedParser, function (req, res)&#123; //输出 JSON 格式 response = &#123; first_name:req.body.first_name, last_name:req.body.last_name &#125;; console.log(response); res.end(JSON.stringify(response));&#125;);var server = app.listen(8081, function()&#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port); &#125;); 执行以上代码：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 浏览器访问 http://127.0.0.1:8081/index.htm,填写表单aaa,bbb，然后提交，结果： {&quot;first_name&quot;:&quot;aaa&quot;,&quot;last_name&quot;:&quot;bbb&quot;} 文件上传以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。index.htm 文件代码修改如下：12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;文件上传表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;文件上传：&lt;/h3&gt; 选择一个文件上传: &lt;br /&gt; &lt;form action=\"/file_upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"image\" size=\"50\" /&gt;&lt;br /&gt; &lt;input type=\"submit\" value=\"上传文件\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; server.js 文件代码修改如下:12345678910111213141516171819202122232425262728293031323334var express = require('express');var app = express();var fs = require(\"fs\");var bodyParser = require('body-parser');var multer = require('multer');app.use(express.static('public'));app.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(multer(&#123;dest:'/tmp/'&#125;).array('image'));app.get('/index.htm', function (req, res) &#123; res.sendFile(__dirname + \"/\" + \"index.htm\");&#125;);app.post('/file_upload', function (req, res) &#123; console.log(req.files[0]);//上传文件信息 var des_file = __dirname + \"/\" + req.files[0].originalname; fs.readFile(req. files[0].path, function (err, data) &#123; fs.writeFile(des_file, data, function (err) &#123; if (err) &#123; console.log(err); &#125; else&#123; response = &#123; message:'File uploaded successfully', filename:req.files[0].originalname &#125;; &#125;; console.log(response); res.end(JSON.stringify(response)); &#125;); &#125;);&#125;);var server = app.listen(8081,function() &#123; var host = server.address().address; var port = server.address().port; console.log(\"应用实例，访问地址为 http://%s:%s\", host, port);&#125;); 执行以上代码：12node server.js 应用实例，访问地址为 http://0.0.0.0:8081 浏览器访问 http://127.0.0.1:8081/index.htm,上传本地文件a.jpg，结果： {&quot;message&quot;:&quot;File uploaded successfully&quot;,&quot;filename&quot;:&quot;a.jpg&quot;} Cookie 管理我们可以使用中间件向 Node.js 服务器发送 cookie 信息，以下代码输出了客户端发送的 cookie 信息：express_cookie.js文件12345678var express = require('express');var cookieParser = require('cookie-parser');var app = express();app.use(cookieParser());app.get('/', function (req, res) &#123; console.log(\"Cookies: \", req.cookies);&#125;);app.listen(8081);","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"MongoDB学习笔记(2)","date":"2016-06-30T00:20:16.000Z","path":"2016/06/30/MongoDB学习笔记(2).html","text":"part2 CRUD操作(Creat,Read,Update,Delete)一、基础：1、document(文档) MongoDB把所有数据存放在类似于JSON数据结构的文档内：1&#123; \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.2\" &#125; 2、collection(集合) 集合是一组相关的文档，MongoDB存储所有的文档在集合里,他们拥有一套共享的通用索引。123&#123; \"item\": \"pencil\", \"qty\": 500, \"type\": \"no.1\" &#125;&#123; \"item\": \"pencil2\", \"qty\": 550, \"type\": \"no.2\" &#125;&#123; \"item\": \"pencil3\", \"qty\": 800, \"type\": \"no.3\" &#125; 3、database(数据库) MongoDB的默认数据库为”db”，该数据库存储在data目录中。一个mongodb中可以建立多个数据库。 二、数据库操作：连接及运行mongoDB“show dbs“命令可以显示所有的数据的列表“db“命令可以显示当前数据库对象或集合“use“命令可以连接到一个指定的数据库数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。 1.不能是空字符串（””)。 2.不得含有’ ‘（空格)、.、$、/、\\和\\0 (空宇符)。 3.应全部小写。 4.最多64字节。 1、创建数据库：use Database_Name1use test ##创建名为test的数据库 2、删除当前数据库：1db.dropDatabase() 三、文档操作（以 Collection_Name = col 为例）1、插入：12345678910db.col.insert(Document) ##插入一条或多组数据db.col.insertOne(Document) ##插入一条数据db.col.insertMany(Document) ##插入多条数据##例如： db.col.insertOne(&#123; \"item\": \"pencil\", \"type\": \"no.1\" &#125;) db.col.insertMany([ &#123; \"item\": \"dog\", \"type\": \"no.2\" &#125;, &#123; \"item\": \"apple\", \"type\": \"no.3\" &#125;, &#123; \"item\": \"orange\", \"type\": \"no.4\" &#125; ]) 2、删除：123456789db.col.remove(&#123;&#125;) ##删除所有数据db.col.remove(query &lt;,options&gt;) # query: 查询条件(数据索引或名字) # ptions:两个可选参数 # &#123;justOne: &lt;boolean&gt;, //默认false，删除所有匹配到的。 # writeConcern: &lt;document&gt;//抛出异常的级别。 # &#125;db.col.deleteOne(query &lt;,options&gt;) ##同上，无justOne参数，只删除第一条db.col.deleteMany(query &lt;,options&gt;) ##同上，无justOne参数，只删除多条 3、更新：123456789101112131415161718db.col.update(query, update &lt;,options&gt;) # query: 查询条件(数据索引或名字) # update: 更新的内容，语法：&#123;$set:query&#125; # options:三个可选参数 # &#123;upsert: &lt;boolean&gt;, //如果不存在update的记录，是否插入新数据，默认:false。 # multi: &lt;boolean&gt;, //只更新找到的第一条记录，默认是false,如果为true,多条记录全部更新。 # writeConcern: &lt;document&gt;//#抛出异常的级别。 # &#125;##例如： db.col.update( &#123;\"type\": \"no.1\"&#125;, &#123;$set: &#123;\"item\": \"human\"&#125;&#125;, &#123;upsert: true, multi: true&#125; )db.col.updateOne() ##同上，无multi参数，只更新第一条db.col.updateMany() ##同上，无multi参数db.col.replaceOne() ##同updateOnedb.col.save(document &lt;,writeConcern&gt;) ##通过传入的文档整个替换 insert 与 save的区别如果插入的数据的_id相同,save将会更新该文档,而insert将会报错 update常用操作符1234567891011$set ##当文档中包含该字段的时候,更新该字段,如果该文档中没有该字段,则为本文档添加一个字段.$unset ##删除文档中的一个字段.$rename ##重命名某个列$inc ##增长某个列$setOnInsert ##当upsert为true时,并且发生了insert操作时,可以补充的字段$push ##将一个数字存入一个数组,分为三种情况,如果该字段存在,则直接将数字存入数组.如果该字段不存在,创建字段并且将数字插入该数组.如果更新的字段不是数组,会报错的.$pushAll ##将多个数值一次存入数组.上面的push只能一个一个的存入$addToSet ##与$push功能相同将一个数字存入数组,不同的是如果数组中有这个数字,将不会插入,只会插入新的数据,同样也会有三种情况,与$push相同.$pop ##删除数组最后一个元素$pull ##删除数组中的指定的元素,如果删除的字段不是数组,会报错$pullAll ##删除数组中的多个值,跟pushAll与push的关系类似. 4、查询12345db.col.find(&#123;&#125;) ##查询所有文档db.col.find().pretty() ##以易读的方式来读取数据db.collection.find(query, projection) # query：查询条件(数据索引或名字) # projection：可选。指定返回的字段。 4.1、深入查询表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647db.col.find()##查询所有db.col.find(&#123;filed: value&#125;) ##等值查询db.col.find(&#123;filed: &#123;$ne: value&#125;&#125;) ##不等于 $nedb.col.find(&#123;filed: &#123;$nin: [value1, value2, ...]&#125;&#125;) ##不能包含给定的值 $nindb.col.find(&#123;filed: &#123;$all: [value1, value2, ...]&#125;&#125;) ##必须包含所有给定的值 $alldb.col.find(&#123;filed: &#123;$in: [value1, value2, ...]&#125;&#125;) ##只要包含一个或多个给定的值 $indb.col.find(&#123;filed: &#123;$exists:1&#125;&#125;) ##存在filed字段的db.col.find(&#123;filed: &#123;$exists:0&#125;&#125;) ##不存在filed字段的db.col.find(&#123;filed: &#123;$mod:[3,1]&#125;&#125;) ##模三余一，$mod(取模操作)db.col.find(&#123;$or: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;) ##或 $ordb.col.find(&#123;$nor: [&#123;filed1: vulue1&#125;, &#123;filed2: vulue2&#125;]&#125;)##排除 $nordb.col.find(&#123;filed: &#123;$size: 3&#125;&#125;) ##返回值得数组是给定的长度(3) $sizedb.col.find(&#123;$where: function()&#123;return ...&#125;&#125;) ##回调，隐式迭代，符合条件才返回db.col.find(&#123;$where: '...'&#125;&#125;) ##同上db.col.find(&#123;age: &#123;$lt: 5&#125;&#125;).limit(3) ##查询age的值小于5，限制3条 #范围查询： # $lt （小于） # $gt （大于） # $lte （小于等于） # $gte （大于等于） # limit（限制显示）db.col.find().skip(2).limit(3) ##跳过前两个文档查询后面三个 # skip(num):表示跳过前面num个文档db.col.find().sort(&#123;age: 1&#125;) ##查询后以age升序排列显示 # sort():排序，这里 1 代表升序, -1 代表降序.db.col.find(&#123;filed: /user.*/i&#125;) ##正则，查询filed以user开头不区分大小写（正则效率低）db.col.find(&#123;filed: &#123;$type: 1&#125;&#125;) ##查找filed为双精度的文档 # 根据数据类型查询 $type # |类型 |编号| # |双精度 |1 | # |字符串 |2 | # |对象 |3 | # |数组 |4 | # |二进制数据 |5 | # |对象ID |7 | # |布尔值 |8 | # |日期 |9 | # |空 |10 | # |正则表达式 |11 | # |JavaScript |13 | # |符号 |14 | # |JavaScript(带范围)|15 | # |32位整数 |16 | # |时间戳 |17 | # |64位整数 |18 | # |最小键 |255 | # |最大键 |127 | 4.2、group分组查询group做的聚合有些复杂。先选定分组所依据的键，此后MongoDB就会将集合依据选定键值的不同分成若干组。然后可以通过聚合每一组内的文档，产生一个结果文档。12345group(&#123; key:&#123;字段:1&#125;, initial:&#123;变量:初始值&#125;, $reduce:function(doc,prev)&#123;函数代码&#125;&#125;) 其中key下的字段代表,需要按哪个字段分组.initial下的变量表示这一个分组中会使用的变量,并且给一个初始值.可以在后面的$reduce函数中使用.$reduce的两个参数,分别代表当前的文档和上个文档执行完函数后的结果. 栗子：如下我们按年龄分组,同级不同年龄的用户的多少:123456789101112131415161718192021222324252627282930313233db.user.find() &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 &#125;db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;count:0&#125;, $reduce:function(doc,prev)&#123; prev.count++ &#125;&#125;); [ &#123;\"age\": 0, \"count\": 1&#125;, &#123;\"age\": 1, \"count\": 3&#125;, &#123;\"age\": 2, \"count\": 2&#125; ]db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;users:[]&#125;, reduce:function(doc,prev)&#123; prev.users.push(doc.name) &#125;&#125;); [ &#123;\"age\": 0, \"users\": [\"user0\"]&#125;, &#123;\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]&#125;, &#123;\"age\": 2, \"users\": [\"user2\", \"user5\"]&#125; ] 另外本函数还有两个可选参数 condition 和 finalizecondition就是分组的条件筛选类似mysql中的having123456789101112db.user.group(&#123; key:&#123;age:1&#125;, initial:&#123;users:[]&#125;, $reduce:function(doc,prev)&#123; prev.users.push(doc.name) &#125;, condition:&#123;age:&#123;$gt:0&#125;&#125;&#125;) ##筛选出age大于0的:[ &#123;\"age\": 1, \"users\": [\"user1\", \"user3\", \"user4\"]&#125;, &#123;\"age\": 2, \"users\": [\"user2\", \"user5\"]&#125;] 4.3、count统计12db.goods.count() ##统计该集合总数db.goods.count(&#123;cat_id: 3&#125;) ##统计cat_id=3的总数 4.4、distinct排重12345678910db.user.find() &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b2\"), \"name\" : \"user0\", \"age\" : 0 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b3\"), \"name\" : \"user1\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b4\"), \"name\" : \"user2\", \"age\" : 2 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b5\"), \"name\" : \"user3\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b6\"), \"name\" : \"user4\", \"age\" : 1 &#125; &#123; \"_id\" : ObjectId(\"5198c286c686eb50e2c843b7\"), \"name\" : \"user5\", \"age\" : 2 &#125; db.user.distinct(\"age\") ## 特殊,传入的参数直接是字符串,而不是对象; [0, 1, 2] 4.5、子文档查询$elemMatchelemMatch投影操作符将限制查询返回的数组字段的内容只包含匹配elemMatch条件的数组元素。注意：(1)数组中元素是内嵌文档。(2)如果多个元素匹配$elemMatch条件，操作符返回数组中第一个匹配条件的元素。假设集合school有如下数据：1234567891011121314151617181920212223242526272829303132&#123; _id: 1, zipcode: 63109, students: [ &#123; name: \"john\", school: 102, age: 10 &#125;, &#123; name: \"jess\", school: 102, age: 11 &#125;, &#123; name: \"jeff\", school: 108, age: 15 &#125; ]&#125;&#123; _id: 2, zipcode: 63110, students: [ &#123; name: \"ajax\", school: 100, age: 7 &#125;, &#123; name: \"achilles\", school: 100, age: 8 &#125;, ]&#125;&#123; _id: 3, zipcode: 63109, students: [ &#123; name: \"ajax\", school: 100, age: 7 &#125;, &#123; name: \"achilles\", school: 100, age: 8 &#125;, ]&#125;&#123; _id: 4, zipcode: 63109, students: [ &#123; name: \"barney\", school: 102, age: 7 &#125;, ]&#125; 下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102）的元素。12345db.school.find(&#123;zipcode: 63109 &#125;,&#123; students: &#123; $elemMatch: &#123; school: 102 &#125; &#125; &#125; );&#123;\"_id\": 1, \"students\": [&#123;\"name\":\"john\", \"school\":102, \"age\":10&#125;]&#125;&#123;\"_id\": 3&#125;&#123;\"_id\": 4, \"students\": [&#123;\"name\":\"barney\", \"school\":102, \"age\":7&#125;]&#125; 查询结果说明：_id为1的文档，students数组包含多个元素中存在school键且值为102的元素，$elemMatch只返回一个匹配条件的元素。_id为3的文档，因为students数组中元素无法匹配$elemMatch条件，所以查询结果不包含”students”字段。 $elemMatch可以指定多个字段的限定条件，下面的操作将查询邮政编码键值是63109的所有文档。 $elemMatch操作符将返回 students数组中的第一个匹配条件（内嵌文档的school键且值为102且age键值大于10）的元素。12345db.school.find( &#123; zipcode: 63109 &#125;,&#123; students: &#123; $elemMatch: &#123; school: 102, age: &#123; $gt: 10&#125; &#125; &#125; &#125; ); &#123;\"_id\": 1, \"students\": [&#123;\"name\":\"jess\", \"school\":102, \"age\":11&#125;]&#125; &#123;\"_id\": 3&#125; &#123;\"_id\": 4&#125;","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://chaoo.oschina.io/tags/mongodb/"}]},{"title":"Node.js Web 模块(14)","date":"2016-06-29T12:51:36.000Z","path":"2016/06/29/Node.js Web模块.html","text":"14、Node.js Web 模块使用 Node 创建 Web 服务器Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：1var http = require('http'); 以下是演示一个最基本的 HTTP 服务器架构(使用8081端口)，创建 server.js 文件，代码如下所示：123456789101112131415161718192021222324252627var http = require('http');var fs = require('fs');var url = require('url');//创建服务器http.createServer(function(request,response)&#123; //解析请求，包括文件名 var pathname = url.parse(request.url).pathname; //输出请求文件名 console.log(\"Request for \" + pathname + \" received.\"); //从文件系统中读取请求的文件内容 fs.readFile(pathname.substr(1), function (err, data)&#123; if (err) &#123; console.log(err); //HTTP 状态码：404：NOT FOUND //Content Type：text/plain response.writeHead(404, &#123;'Content-Type': 'text/html'&#125;); &#125; else&#123; //HTTP 状态码：200：OK //Content Type：text/plain response.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); //响应文件内容 response.write(data.toString()); &#125;; //发送响应数据 response.end(); &#125;);&#125;).listen(8081); 控制台会输出以下信息1console.log('Server running at http://127.0.0.1:8081/'); 接下来我们在该目录下创建一个 index.htm 文件，代码如下：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello World!&lt;/body&gt;&lt;/html&gt; 执行 server.js 文件：12node server.jsServer running at http://127.0.0.1:8081/ 使用 Node 创建 Web 客户端Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：12345678910111213141516171819202122var http = require('http');//用于请求选项var optionss = &#123; host:'localhost', port:'8081' path:'/index.htm'&#125;;//处理响应的回调函数var callback = function(response)&#123; //不断更新数据 var body = ''; response.on('data', function(data)&#123; body += data; &#125;); response.on('end', function()&#123; //数据接收完成 console.log(body); &#125;);&#125;//向服务器端发送请求var req = http.request(options, callback);req.end(); 新开一个终端，执行 client.js 文件，输出结果如下：1node client.js 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Sample Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 执行 server.js 的控制台输出信息如下：12Server running at http://127.0.0.1:8081/Request for /index.htm received. # 客户端请求信息","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js JXcore 打包(18)","date":"2016-06-29T12:14:59.000Z","path":"2016/06/29/Node.js JXcore打包.html","text":"18、Node.js JXcore 打包JXcore 是一个支持多线程的 Node.js 发行版本，基本不需要对你现有的代码做任何改动就可以直接线程安全地以多线程运行。但我们这篇文章主要是要教大家介绍 JXcore 的打包功能。 JXcore 安装下载 JXcore 安装包，并解压，在解压的的目录下提供了 jx 二进制文件命令，接下来我们主要使用这个命令。步骤1、下载 1、下载 JXcore 安装包 http://jxcore.com/downloads/，你需要根据你自己的系统环境来下载安装包。 2、Linux/OSX 下载安装命令，直接下载解压包下的 jx 二进制文件拷贝到 /usr/bin 目录下：123wget https://s3.amazonaws.com/nodejx/jx_rh64.zipunzip jx_rh64.zipcp jx_rh64/jx /usr/bin 将 /usr/bin 添加到 PATH 路径中：1export PATH=$PATH:/usr/bin 以上步骤如果操作正确，使用以下命令，会输出版本号信息：12jx --versionv0.10.32 包代码例如，我们的 Node.js 项目包含以下几个文件，其中 index.js 是主文件：123456drwxr-xr-x 2 root root 4096 Nov 13 12:42 images-rwxr-xr-x 1 root root 30457 Mar 6 12:19 index.htm-rwxr-xr-x 1 root root 30452 Mar 1 12:54 index.jsdrwxr-xr-x 23 root root 4096 Jan 15 03:48 node_modulesdrwxr-xr-x 2 root root 4096 Mar 21 06:10 scriptsdrwxr-xr-x 2 root root 4096 Feb 15 11:56 style 接下来我们使用 jx 命令打包以上项目，并指定 index.js 为 Node.js 项目的主文件：1jx package index.js index 以上命令执行成功，会生成以下两个文件： index.jxp //这是一个中间件文件，包含了需要编译的完整项目信息。 index.jx //这是一个完整包信息的二进制文件，可运行在客户端上。 载入 JX 文件我们使用 jx 命令打包项目：1node index.js command_line_arguments 使用 JXcore 编译后，我们可以使用以下命令来执行生成的 jx 二进制文件：1jx index.jx command_line_arguments 更多 JXcore 功能特性你可以参考官网：http://jxcore.com/","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js 工具模块(13)","date":"2016-06-29T10:38:26.000Z","path":"2016/06/29/Node.js 工具模块.html","text":"13、Node.js 工具模块Node.js OS 模块Node.js os 模块提供了一些基本的系统操作函数。我们可以通过以下方式引入该模块：1var os = require(\"os\"); 方法：1 os.tmpdir()//返回操作系统的默认临时文件夹。2 os.endianness()//返回 CPU 的字节序，可能的是 “BE” 或 “LE”。3 os.hostname()//返回操作系统的主机名。4 os.type()//返回操作系统名5 os.platform()//返回操作系统名6 os.arch()//返回操作系统 CPU 架构，可能的值有 “x64”、”arm” 和 “ia32”。7 os.release()//返回操作系统的发行版本。8 os.uptime()//返回操作系统运行的时间，以秒为单位。9 os.loadavg()//返回一个包含 1、5、15 分钟平均负载的数组。10 os.totalmem()//返回系统内存总量，单位为字节。11 os.freemem()//返回操作系统空闲内存量，单位是字节。12 os.cpus()//返回一个对象数组，包含所安装的每个 CPU/内核的信息：型号、速度（单位 MHz）、时间（一个包含 user、nice、sys、idle 和 irq 所使用 CPU/内核毫秒数的对象）。13 os.networkInterfaces()//获得网络接口列表。 属性：os.EOL//定义了操作系统的行尾符的常量。实例创建 main.js 文件，代码如下所示：123456var os = require(\"os\");console.log('endianness : ' + os.endianness());// CPU 的字节序console.log('type : ' + os.type());// 操作系统名console.log('platform : ' + os.platform());// 操作系统名console.log('total memory : ' + os.totalmem() + \" bytes.\");// 系统内存总量console.log('free memory : ' + os.freemem() + \" bytes.\");// 操作系统空闲内存量 代码执行结果如下：123456node main.js endianness : LEtype : Linuxplatform : linuxtotal memory : 25103400960 bytes.free memory : 20676710400 bytes. Node.js Path 模块Node.js path 模块提供了一些用于处理文件路径的小工具，我们可以通过以下方式引入该模块：1var path = require(\"path\"); 方法1 path.normalize(p)//规范化路径，注意’..’ 和 ‘.’。2 path.join([path1][, path2][, ...])//用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\\”。3 path.resolve([from ...], to)//将 to 参数解析为绝对路径。4 path.isAbsolute(path)//判断参数 path 是否是绝对路径。5 path.relative(from, to)//用于将相对路径转为绝对路径。6 path.dirname(p)//返回路径中代表文件夹的部分，同 Unix 的dirname 命令类似。7 path.basename(p[, ext])//返回路径中的最后一部分。同 Unix 命令 bashname 类似。8 path.extname(p)//返回路径中文件的后缀名，即路径中最后一个’.’之后的部分。如果一个路径中并不包含’.’或该路径只包含一个’.’ 且这个’.’为路径的第一个字符，则此命令返回空字符串。9 path.parse(pathString)//返回路径字符串的对象。10 path.format(pathObject)//从对象中返回路径字符串，和 path.parse 相反。 属性1 path.sep//平台的文件路径分隔符，’\\‘ 或 ‘/‘。2 path.delimiter//平台的分隔符, ; or ‘:’.3 path.posix//提供上述 path 的方法，不过总是以 posix 兼容的方式交互。4 path.win32//提供上述 path 的方法，不过总是以 win32 兼容的方式交互。 实例创建 main.js 文件，代码如下所示：123456789var path = require(\"path\");// 格式化路径console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));// 连接路径console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));// 转换为绝对路径console.log('resolve : ' + path.resolve('main.js'));// 路径中文件的后缀名console.log('ext name : ' + path.extname('main.js')); 代码执行结果如下：12345node main.js normalization : /test/test1/2slashes/1slashjoint path : /test/test1/2slashes/1slashresolve : /web/com/1427176256_27423/main.jsext name : .js Node.js Net 模块Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块：1var net = require(\"net\") 方法：1 net.createServer([options][, connectionListener])//创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。2 net.connect(options[, connectionListener])//返回一个新的 ‘net.Socket’，并连接到指定的地址和端口。当 socket 建立的时候，将会触发 ‘connect’ 事件。3 net.createConnection(options[, connectionListener])//创建一个到端口 port 和 主机 host的 TCP 连接。 host 默认为 ‘localhost’。4 net.connect(port[, host][, connectListener])//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。5 net.createConnection(port[, host][, connectListener])//创建一个端口为 port 和主机为 host的 TCP 连接 。host 默认为 ‘localhost’。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。6 net.connect(path[, connectListener])//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件上。返回 ‘net.Socket’。7 net.createConnection(path[, connectListener])//创建连接到 path 的 unix socket 。参数 connectListener 将会作为监听器添加到 ‘connect’ 事件。返回 ‘net.Socket’。8 net.isIP(input)//检测输入的是否为 IP 地址。 IPV4 返回 4， IPV6 返回 6，其他情况返回 0。9 net.isIPv4(input)//如果输入的地址为 IPV4， 返回 true，否则返回 false。10 net.isIPv6(input)//如果输入的地址为 IPV6， 返回 true，否则返回 false。 net.Servernet.Server通常用于创建一个 TCP 或本地服务器。 net.Server方法：1 server.listen(port[, host][, backlog][, callback])//监听指定端口 port 和 主机 host ac连接。 默认情况下 host 接受任何 IPv4 地址(INADDR_ANY)的直接连接。端口 port 为 0 时，则会分配一个随机端口。2 server.listen(path[, callback])//通过指定 path 的连接，启动一个本地 socket 服务器。3 server.listen(handle[, callback])//通过指定句柄连接。4 server.listen(options[, callback])//options 的属性：端口 port, 主机 host, 和 backlog, 以及可选参数 callback 函数, 他们在一起调用server.listen(port, [host], [backlog], [callback])。还有，参数 path 可以用来指定 UNIX socket。5 server.close([callback])//服务器停止接收新的连接，保持现有连接。这是异步函数，当所有连接结束的时候服务器会关闭，并会触发 ‘close’ 事件。6 server.address()//操作系统返回绑定的地址，协议族名和服务器端口。7 server.unref()//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。8 server.ref()//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。9 server.getConnections(callback)//异步获取服务器当前活跃连接的数量。当 socket 发送给子进程后才有效；回调函数有 2 个参数 err 和 count。 net.Server事件：1 listening//当服务器调用 server.listen 绑定后会触发。2 connection//当新连接创建后会被触发。socket 是 net.Socket实例。3 close//服务器关闭时会触发。注意，如果存在连接，这个事件不会被触发直到所有的连接关闭。4 error//发生错误时触发。’close’ 事件将被下列事件直接调用。 net.Socketnet.Socket 对象是 TCP 或 UNIX Socket 的抽象。net.Socket 实例实现了一个双工流接口。 他们可以在用户创建客户端(使用 connect())时使用, 或者由 Node 创建它们，并通过 connection 服务器事件传递给用户。 net.Socket事件：1 lookup//在解析域名后，但在连接前，触发这个事件。对 UNIX sokcet 不适用。2 connect//成功建立 socket 连接时触发。3 data//当接收到数据时触发。4 end//当 socket 另一端发送 FIN 包时，触发该事件。5 timeout//当 socket 空闲超时时触发，仅是表明 socket 已经空闲。用户必须手动关闭连接。6 drain//当写缓存为空得时候触发。可用来控制上传。7 error//错误发生时触发。8 close//当 socket 完全关闭时触发。参数 had_error 是布尔值，它表示是否因为传输错误导致 socket 关闭。 net.Socket属性：1 socket.bufferSize//该属性显示了要写入缓冲区的字节数。2 socket.remoteAddress//远程的 IP 地址字符串，例如：’74.125.127.100’ or ‘2001:4860:a005::68’。3 socket.remoteFamily//远程IP协议族字符串，比如 ‘IPv4’ or ‘IPv6’。4 socket.remotePort//远程端口，数字表示，例如：80 or 21。5 socket.localAddress//网络连接绑定的本地接口 远程客户端正在连接的本地 IP 地址，字符串表示。例如，如果你在监听’0.0.0.0’而客户端连接在’192.168.1.1’，这个值就会是 ‘192.168.1.1’。6 socket.localPort//本地端口地址，数字表示。例如：80 or 21。7 socket.bytesRead//接收到得字节数。8 socket.bytesWritten//发送的字节数。 net.Socket方法：1 new net.Socket([options])//构造一个新的 socket 对象。2 socket.connect(port[, host][, connectListener])//指定端口 port 和 主机 host，创建 socket 连接 。参数 host 默认为 localhost。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。3 socket.connect(path[, connectListener])//打开指定路径的 unix socket。通常情况不需要使用 net.createConnection 打开 socket。只有你实现了自己的 socket 时才会用到。4 socket.setEncoding([encoding])//设置编码5 socket.write(data[, encoding][, callback])//在 socket 上发送数据。第二个参数指定了字符串的编码，默认是 UTF8 编码。6 socket.end([data][, encoding])//半关闭 socket。例如，它发送一个 FIN 包。可能服务器仍在发送数据。7 socket.destroy()//确保没有 I/O 活动在这个套接字上。只有在错误发生情况下才需要。（处理错误等等）。8 socket.pause()//暂停读取数据。就是说，不会再触发 data 事件。对于控制上传非常有用。9 socket.resume()//调用 pause() 后想恢复读取数据。10 socket.setTimeout(timeout[, callback])//socket 闲置时间超过 timeout 毫秒后 ，将 socket 设置为超时。11 socket.setNoDelay([noDelay])//禁用纳格（Nagle）算法。默认情况下 TCP 连接使用纳格算法，在发送前他们会缓冲数据。将 noDelay 设置为 true 将会在调用 socket.write() 时立即发送数据。noDelay 默认值为 true。12 socket.setKeepAlive([enable][, initialDelay])//禁用/启用长连接功能，并在发送第一个在闲置 socket 上的长连接 probe 之前，可选地设定初始延时。默认为 false。 设定 initialDelay （毫秒），来设定收到的最后一个数据包和第一个长连接probe之间的延时。将 initialDelay 设为0，将会保留默认（或者之前）的值。默认值为0.13 socket.address()//操作系统返回绑定的地址，协议族名和服务器端口。返回的对象有 3 个属性，比如{ port: 12346, family: ‘IPv4’, address: ‘127.0.0.1’ }。14 socket.unref()//如果这是事件系统中唯一一个活动的服务器，调用 unref 将允许程序退出。如果服务器已被 unref，则再次调用 unref 并不会产生影响。15 socket.ref()//与 unref 相反，如果这是唯一的服务器，在之前被 unref 了的服务器上调用 ref 将不会让程序退出（默认行为）。如果服务器已经被 ref，则再次调用 ref 并不会产生影响。 实例创建 server.js 文件，代码如下所示：123456789101112var net = require('net');var server = net.createServer(function(connection)&#123; console.log('client connected'); connection.on('end', function()&#123; console.log('客户端关闭连接'); &#125;); connection.write('Hello World!\\r\\n'); connection.pipe(connection);&#125;);server.listen(8080,function()&#123; console.log('server is listening');&#125;); 执行以上服务端代码：12node server.jsserver is listening # 服务已创建并监听8080端口 新开一个窗口，创建client.js文件，代码如下：1234567891011var net = require('net');var client = net.connect(&#123;port: 8080&#125;,function()&#123; console.log('连接服务器！');&#125;);client.on('data', function(data)&#123; console.log(data.toString()); client.end();&#125;);client.on('end',function()&#123; console.log('断开与服务器的连接');&#125;); 执行以上客户端的代码：123连接服务器！Hello World!断开与服务器的连接 Node.js DNS 模块Node.js DNS 模块用于解析域名。引入 DNS 模块语法格式如下：1var dns = require(\"dns\") 方法：1 dns.lookup(hostname[, options], callback)//将域名（比如 ‘runoob.com’）解析为第一条找到的记录 A （IPV4）或 AAAA(IPV6)。参数 options可以是一个对象或整数。如果没有提供 options，IP v4 和 v6 地址都可以。如果 options 是整数，则必须是 4 或 6。2 dns.lookupService(address, port, callback)//使用 getnameinfo 解析传入的地址和端口为域名和服务。3 dns.resolve(hostname[, rrtype], callback)//将一个域名（如 ‘runoob.com’）解析为一个 rrtype 指定记录类型的数组。4 dns.resolve4(hostname, callback)//和 dns.resolve() 类似, 仅能查询 IPv4 (A 记录）。 addresses IPv4 地址数组 (比如，[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]）。5 dns.resolve6(hostname, callback)//和 dns.resolve4() 类似， 仅能查询 IPv6( AAAA 查询）6 dns.resolveMx(hostname, callback)//和 dns.resolve() 类似, 仅能查询邮件交换(MX 记录)。7 dns.resolveTxt(hostname, callback)//和 dns.resolve() 类似, 仅能进行文本查询 (TXT 记录）。 addresses 是 2-d 文本记录数组。(比如，[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]）。 每个子数组包含一条记录的 TXT 块。根据使用情况可以连接在一起，也可单独使用。8 dns.resolveSrv(hostname, callback)//和 dns.resolve() 类似, 仅能进行服务记录查询 (SRV 记录）。 addresses 是 hostname可用的 SRV 记录数组。 SRV 记录属性有优先级（priority），权重（weight）, 端口（port）, 和名字（name） (比如，[{‘priority’: 10, ‘weight’: 5, ‘port’: 21223, ‘name’: ‘service.example.com’}, …]）。9 dns.resolveSoa(hostname, callback)//和 dns.resolve() 类似, 仅能查询权威记录(SOA 记录）。10 dns.resolveNs(hostname, callback)//和 dns.resolve() 类似, 仅能进行域名服务器记录查询(NS 记录）。 addresses 是域名服务器记录数组（hostname 可以使用） (比如, [‘ns1.example.com’, ‘ns2.example.com’]）。11 dns.resolveCname(hostname, callback)//和 dns.resolve() 类似, 仅能进行别名记录查询 (CNAME记录)。addresses 是对 hostname 可用的别名记录数组 (比如，, [‘bar.example.com’]）。12 dns.reverse(ip, callback)//反向解析 IP 地址，指向该 IP 地址的域名数组。13 dns.getServers()//返回一个用于当前解析的 IP 地址数组的字符串。14 dns.setServers(servers)//指定一组 IP 地址作为解析服务器。 rrtypesdns.resolve()方法中有效的rrtypes值：123456789&apos;A&apos; IPV4 地址, 默认&apos;AAAA&apos; IPV6 地址&apos;MX&apos; 邮件交换记录&apos;TXT&apos; text 记录&apos;SRV&apos; SRV 记录&apos;PTR&apos; 用来反向 IP 查找&apos;NS&apos; 域名服务器记录&apos;CNAME&apos; 别名记录&apos;SOA&apos; 授权记录的初始值 错误码每次 DNS 查询都可能返回以下错误码:123456789101112131415161718192021222324dns.NODATA: 无数据响应。dns.FORMERR: 查询格式错误。dns.SERVFAIL: 常规失败。dns.NOTFOUND: 没有找到域名。dns.NOTIMP: 未实现请求的操作。dns.REFUSED: 拒绝查询。dns.BADQUERY: 查询格式错误。dns.BADNAME: 域名格式错误。dns.BADFAMILY: 地址协议不支持。dns.BADRESP: 回复格式错误。dns.CONNREFUSED: 无法连接到 DNS 服务器。dns.TIMEOUT: 连接 DNS 服务器超时。dns.EOF: 文件末端。dns.FILE: 读文件错误。dns.NOMEM: 内存溢出。dns.DESTRUCTION: 通道被摧毁。dns.BADSTR: 字符串格式错误。dns.BADFLAGS: 非法标识符。dns.NONAME: 所给主机不是数字。dns.BADHINTS: 非法HINTS标识符。dns.NOTINITIALIZED: c c-ares 库尚未初始化。dns.LOADIPHLPAPI: 加载 iphlpapi.dll 出错。dns.ADDRGETNETWORKPARAMS: 无法找到 GetNetworkParams 函数。dns.CANCELLED: 取消 DNS 查询。 实例创建 main.js 文件，代码如下所示：12345678910var dns = require('dns');dns.lookup('www.github.com',function onLookup(err, address, family)&#123; console.log('ip 地址：', address); dns.reverse(address, function(err, hostname)&#123; if (err) &#123; console.log(err.stack); &#125; console.log('反向解析' + address + ':' + JSON.stringify(hostname)); &#125;);&#125;); 执行以上代码，结果如下所示：12address: 192.30.252.130reverse for 192.30.252.130: [&quot;github.com&quot;] Node.js Domain 模块Node.js Domain(域) 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的异常。引入 Domain 模块 语法格式如下：1var domain = require(\"domain\") domain模块，把处理多个不同的IO的操作作为一个组。注册事件和回调到domain，当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不导致程序错误立即推出，与process.on(‘uncaughtException’)不同。Domain 模块可分为隐式绑定和显式绑定：1、隐式绑定: 把在domain上下文中定义的变量，自动绑定到domain对象2、显式绑定: 把不是在domain上下文中定义的变量，以代码的方式绑定到domain对象 方法：1 domain.run(function)//在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。2 domain.add(emitter)//显式的增加事件3 domain.remove(emitter)//删除事件。4 domain.bind(callback)//返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数被时，所有被抛出的错误都会被导向到这个域的 error 事件。5 domain.intercept(callback)//和 domain.bind(callback) 类似。除了捕捉被抛出的错误外，它还会拦截 Error 对象作为参数传递到这个函数。6 domain.enter()//进入一个异步调用的上下文，绑定到domain。7 domain.exit()//退出当前的domain，切换到不同的链的异步调用的上下文中。对应domain.enter()。8 domain.dispose()//释放一个domain对象，让node进程回收这部分资源。9 domain.create()//返回一个domain对象。 事件：1 domain.menbers//已加入domain对象的域定时器和事件发射器的数组。 实例创建 main.js 文件，代码如下所示：123456789101112131415161718192021222324252627var EventEmitter = require(\"events\").EventEmitter;var domain = require(\"domain\");var emitter1 = new EventEmitter();// 创建域var domain1 = domain.create();domain1.on('error', function(err)&#123; console.log(\"domain1 处理这个错误 (\"+err.message+\")\");&#125;);// 显式绑定domain1.add(emitter1);emitter1.on('error',function(err)&#123; console.log(\"监听器处理此错误 (\"+err.message+\")\");&#125;);emitter1.emit('error',new Error('通过监听器来处理'));emitter1.removeAllListeners('error');emitter1.emit('error',new Error('通过 domain1 处理'));var domain2 = domain.create();domain2.on('error', function(err)&#123; console.log(\"domain2 处理这个错误 (\"+err.message+\")\");&#125;);// 隐式绑定domain2.run(function()&#123; var emitter2 = new EventEmitter(); emitter2.emit('error',new Error('通过 domain2 处理')); &#125;);domain1.remove(emitter1);emitter1.emit('error', new Error('转换为异常，系统将崩溃!')); 执行以上代码，结果如下所示:123456789101112131415监听器处理此错误 (通过监听器来处理)domain1 处理这个错误 (通过 domain1 处理)domain2 处理这个错误 (通过 domain2 处理)events.js:72 throw er; // Unhandled &apos;error&apos; event ^Error: 转换为异常，系统将崩溃! at Object.&lt;anonymous&gt; (/www/node/main.js:40:24) at Module._compile (module.js:456:26) at Object.Module._extensions..js (module.js:474:10) at Module.load (module.js:356:32) at Function.Module._load (module.js:312:12) at Function.Module.runMain (module.js:497:10) at startup (node.js:119:16) at node.js:929:3","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js GET/POST请求(12)","date":"2016-06-29T07:38:20.000Z","path":"2016/06/29/Node.js GET POST请求.html","text":"12、Node.js GET/POST请求获取GET请求内容由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js中url模块中的parse函数提供了这个功能。1234567var http = require('http');var url = require('url');var util = require('util');http.createServer(function(req, res)&#123; res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(3000); 在浏览器中访问http://localhost:3000/user?name=w3c&amp;email=w3c@w3cschool.cc 然后查看返回结果:12345678910111213Url &#123; protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: '?name=w3c&amp;email=w3c@w3cschool.cc', query: &#123; name: 'w3c', email: 'w3c@w3cschool.cc' &#125;, pathname: '/user', path: '/user?name=w3c&amp;email=w3c@w3cschool.cc', href: '/user?name=w3c&amp;email=w3c@w3cschool.cc' &#125; 获取POST请求内容POST请求的内容全部的都在请求体中，http.ServerRequest并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所有node.js默认是不会解析请求体的， 当你需要的时候，需要手动来做。12345678910111213var http = require('http');var querystring = require('querystring');var util = require('util');http.createServer(function(req, res)&#123; var post = '';//定义了一个post变量，用于暂存请求体的信息 req.on('data',function(chunk)&#123;//通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中 post += chunk; &#125;); req.on('end',function()&#123;//在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。 post = querystring.parse(post); res.end(util.inspect(post)); &#125;);&#125;).listen(3000);","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js 文件系统(11)","date":"2016-06-29T05:35:20.000Z","path":"2016/06/29/Node.js 文件系统.html","text":"11、Node.js 文件系统Node.js 提供一组类似 UNIX（POSIX）标准的文件操作API。 Node 导入文件系统模块(fs)语法如下所示：1234var fs = require(\"fs\");//读取文件内容fs.readFile(filename, [options], callback)//异步读取文件内容。fs.readFileSync(filename, [options])//同步读取文件内容。 建议大家是用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。 打开文件fs.open(path, flags, [mode], callback)//异步打开文件。 path-文件路径；flag-文件打开行为；mode-设置文件模式(默认:0666-可读可写)；callback - 回调函数，带有两个参数如：callback(err, fd)。flags参数描述：1 r //以读取模式打开文件。如果文件不存在抛出异常。2 r+ //以读写模式打开文件。如果文件不存在抛出异常。3 rs //以同步的方式读取文件。4 rs+ //以同步的方式读取和写入文件。5 w //以写入模式打开文件，如果文件不存在则创建。6 wx //类似 ‘w’，但是如果文件路径存在，则文件写入失败。7 w+ //以读写模式打开文件，如果文件不存在则创建。8 wx+ //类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。9 a //以追加模式打开文件，如果文件不存在则创建。10 ax //类似 ‘a’， 但是如果文件路径存在，则文件追加失败。11 a+ //以读取追加模式打开文件，如果文件不存在则创建。12 ax+ //类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 读取文件信息fs.stat(path, callback)//通过异步模式获取文件信息. path - 文件路径。callback - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。stats类中方法有：1 stats.isFile()//如果是文件返回 true，否则返回 false。2 stats.isDirectory()//如果是目录返回 true，否则返回 false。3 stats.isBlockDevice()//如果是块设备返回 true，否则返回 false。4 stats.isCharacterDevice()//如果是字符设备返回 true，否则返回 false。5 stats.isSymbolicLink()//如果是软链接返回 true，否则返回 false。6 stats.isFIFO()//如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。7 stats.isSocket()//如果是 Socket 返回 true，否则返回 false。 写入文件fs.writeFile(filename, data, [options], callback)//异步写入文件 path-文件路径；data-要写入的数据，可以是String或Buffer(流)对象；options-该参数是一个对象，包含{encoding,mode,flag}默认utf8 ,0666,’w’；callback-回调函数，只包含错误信息参数(err),在写入失败是返回。 读取文件fs.read(fd, buffer, offset, length, position, callback)//异步模式下使用文件描述符来读取文件。 fd-通过fs.open()方法返回文件描述符；buffer-数据写入的缓冲区；offset-缓冲区写入的写入偏移量；length-要从文件中读取的字节数；position-文件读取的起始位置，值为null则会从当前文件指针位置读取；callback-回调函数，有三个参数err错误信息,bytesRead字节数,buffer缓冲区对象. 关闭文件fs.close(fd, callback)//异步模式下关闭文件,该方法使用了文件描述符来读取文件。 fd - 通过 fs.open() 方法返回的文件描述符; callback - 回调函数，没有参数。 截取文件fs.ftruncate(fd, len, callback)//异步模式下截取文件,该方法使用了文件描述符来读取文件。 fd - 通过 fs.open() 方法返回的文件描述符; len - 文件内容截取的长度; callback - 回调函数，没有参数。 删除文件fs.unlink(path, callback) path - 文件路径; callback - 回调函数，没有参数。 创建目录fs.mkdir(path[, mode], callback) path - 文件路径; mode - 设置目录权限，默认为 0777; callback - 回调函数，没有参数。 读取目录fs.readdir(path, callback) path - 文件路径; callback - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。 文件模块方法参考手册1 fs.rename(oldPath, newPath, callback)//异步 rename().回调函数没有参数，但可能抛出异常。2 fs.ftruncate(fd, len, callback)//异步 ftruncate().回调函数没有参数，但可能抛出异常。3 fs.ftruncateSync(fd, len)//同步 ftruncate()4 fs.truncate(path, len, callback)//异步 truncate().回调函数没有参数，但可能抛出异常。5 fs.truncateSync(path, len)//同步 truncate()6 fs.chown(path, uid, gid, callback)//异步 chown().回调函数没有参数，但可能抛出异常。7 fs.chownSync(path, uid, gid)//同步 chown()8 fs.fchown(fd, uid, gid, callback)//异步 fchown().回调函数没有参数，但可能抛出异常。9 fs.fchownSync(fd, uid, gid)//同步 fchown()10 fs.lchown(path, uid, gid, callback)//异步 lchown().回调函数没有参数，但可能抛出异常。11 fs.lchownSync(path, uid, gid)//同步 lchown()12 fs.chmod(path, mode, callback)//异步 chmod().回调函数没有参数，但可能抛出异常。13 fs.chmodSync(path, mode)//同步 chmod().14 fs.fchmod(fd, mode, callback)//异步 fchmod().回调函数没有参数，但可能抛出异常。15 fs.fchmodSync(fd, mode)//同步 fchmod().16 fs.lchmod(path, mode, callback)//异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.17 fs.lchmodSync(path, mode)//同步 lchmod().18 fs.stat(path, callback)//异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。19 fs.lstat(path, callback)//异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。20 fs.fstat(fd, callback)//异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。21 fs.statSync(path)//同步 stat(). 返回 fs.Stats 的实例。22 fs.lstatSync(path)//同步 lstat(). 返回 fs.Stats 的实例。23 fs.fstatSync(fd)//同步 fstat(). 返回 fs.Stats 的实例。24 fs.link(srcpath, dstpath, callback)//异步 link().回调函数没有参数，但可能抛出异常。25 fs.linkSync(srcpath, dstpath)//同步 link().26 fs.symlink(srcpath, dstpath[, type], callback)//异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。27 fs.symlinkSync(srcpath, dstpath[, type])//同步 symlink().28 fs.readlink(path, callback)//异步 readlink(). 回调函数有两个参数 err, linkString。29 fs.realpath(path[, cache], callback)//异步 realpath(). 回调函数有两个参数 err, resolvedPath。30 fs.realpathSync(path[, cache])//同步 realpath()。返回绝对路径。31 fs.unlink(path, callback)//异步 unlink().回调函数没有参数，但可能抛出异常。32 fs.unlinkSync(path)//同步 unlink().33 fs.rmdir(path, callback)//异步 rmdir().回调函数没有参数，但可能抛出异常。34 fs.rmdirSync(path)//同步 rmdir().35 fs.mkdir(path[, mode], callback)//S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 mode defaults to 0777.36 fs.mkdirSync(path[, mode])//同步 mkdir().37 fs.readdir(path, callback)//异步 readdir(3). 读取目录的内容。38 fs.readdirSync(path)//同步 readdir().返回文件数组列表。39 fs.close(fd, callback)//异步 close().回调函数没有参数，但可能抛出异常。40 fs.closeSync(fd)//同步 close().41 fs.open(path, flags[, mode], callback)//异步打开文件。42 fs.openSync(path, flags[, mode])//同步 version of fs.open().43 fs.utimes(path, atime, mtime, callback) 44fs.utimesSync(path, atime, mtime)//修改文件时间戳，文件通过指定的文件路径。 45fs.futimes(fd, atime, mtime, callback)46 fs.futimesSync(fd, atime, mtime)//修改文件时间戳，通过文件描述符指定。47 fs.fsync(fd, callback)//异步 fsync.回调函数没有参数，但可能抛出异常。48 fs.fsyncSync(fd)//同步 fsync.49 fs.write(fd, buffer, offset, length[, position], callback)//将缓冲区内容写入到通过文件描述符指定的文件。50 fs.write(fd, data[, position[, encoding]], callback)//通过文件描述符 fd 写入文件内容。51 fs.writeSync(fd, buffer, offset, length[, position])//同步版的 fs.write()。52 fs.writeSync(fd, data[, position[, encoding]])//同步版的 fs.write().53 fs.read(fd, buffer, offset, length, position, callback)//通过文件描述符 fd 读取文件内容。54 fs.readSync(fd, buffer, offset, length, position)//同步版的 fs.read.55 fs.readFile(filename[, options], callback)//异步读取文件内容。56 fs.readFileSync(filename[, options]) 57fs.writeFile(filename, data[, options], callback)异步写入文件内容。 58fs.writeFileSync(filename, data[, options])//同步版的 fs.writeFile。 59fs.appendFile(filename, data[, options], callback)//异步追加文件内容。 60fs.appendFileSync(filename, data[, options])//The 同步 version of fs.appendFile. 61fs.watchFile(filename[, options], listener)//查看文件的修改。 62fs.unwatchFile(filename[, listener])//停止查看 filename 的修改。 63fs.watch(filename[, options][, listener])//查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。 64fs.exists(path, callback)//检测给定的路径是否存在。 65fs.existsSync(path)//同步版的 fs.exists. 66fs.access(path[, mode], callback)//测试指定路径用户权限。 67fs.accessSync(path[, mode])//同步版的 fs.access。 68fs.createReadStream(path[, options])//返回ReadStream 对象。 69fs.createWriteStream(path[, options])//返回 WriteStream 对象。 70fs.symlink(srcpath, dstpath[, type], callback)`//异步 symlink().回调函数没有参数，但可能抛出异常。","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"MongoDB学习笔记","date":"2016-06-29T02:22:14.000Z","path":"2016/06/29/MongoDB学习笔记(1).html","text":"part1 安装配置一、安装：在mongodb官网下载对应自己电脑系统的安装包，地址为： http://www.mongodb.org/downloads。1、以Windows64bit为例，下载.msi文件双击安装。2、安装过程中，点击 “Custom(自定义)” 按钮来设置安装目录(D:\\MongoDB\\bin)。3、创建数据目录(D:\\MongoDB\\data\\db),MongoDB默认数据目录\\data\\db。4、连接数据库(命令行win+r cmd,到D:\\MongoDB\\bin目录下，执行代码：mongod –dbpath D:\\MongoDB\\data\\db)123D:cd D:\\MongoDB\\binmongod --dbpath D:\\MongoDB\\data\\db 5、启动 MongoDB JavaScript 工具(D:\\MongoDB\\bin目录下,打开mongo,会看到：)12MongoDB shell version: 3.2.4 //mongodb版本connecting to: test //默认shell连接的是本机localhost 上面的test库 此时就可以操作数据库了。 二、将MongoDB服务器作为Windows服务运行1、在D:\\MongoDB目录下创建mongodb.config,写入如下：12345## 数据库文件目录dbpath=D:/MongoDB/data## 日志目录logpath=D:/MongoDB/log/mongo.logdiaglog=3 2、常规命令(cmd管理员):123D:cd D:\\MongoDB\\binmongod --config D:\\MongoDB\\mongodb.config 3、若常规方式失败，则sc方式(cmd管理员)：123D:cd D:\\MongoDB\\binsc create mongodb binPath= &quot;D:\\MongoDB\\bin\\mongod.exe --service --config=D:\\mongoDB\\mongodb.config&quot; 访问地址：localhost:27017测试是否启动成功","tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://chaoo.oschina.io/tags/mongodb/"}]},{"title":"sublime text3个人习惯配置","date":"2016-06-29T01:41:48.000Z","path":"2016/06/29/sublime-text3个人习惯配置-C.html","text":"1、安装分别在官网下载并安装 nodejs 和 sublime text3。 2、sublime text3注册： 点击菜单【help】－&gt;【Enter License】，粘贴下面注册码(亲测v3103可用 ):12345678910111213—– BEGIN LICENSE —–Ryan ClarkSingle User LicenseEA7E-8124792158A7DE B690A7A3 8EC04710 006A5EEB34E77CA3 9C82C81F 0DB6371B 79704E6F93F36655 B031503A 03257CCC 01B20F60D304FA8D B1B4F0AF 8A76C7BA 0FA94D5556D46BCE 5237A341 CD837F30 4D60772D349B1179 A996F826 90CDB73C 24D41245FD032C30 AD5E7241 4EAA66ED 167D91FB55896B16 EA125C81 F550AF6B A6820916—— END LICENSE —— 3、安装package control组件，用于管理所有插件按ctrl + ~调出控制台(或点击菜单栏的【View】-&gt;【Show Console】)，在Console窗口中输入以下代码，按回车键：1import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 等待安装完毕，重启Sublime Text3。按快捷键：Ctrl+Shift+P，调出界面，在其中输入：install，第一个选项即是Package Control： 4、用Package Control安装插件按快捷键：Ctrl+Shift+P，调出界面，按照个人习惯安装插件（以下是我使用的插件）Material ThemeEmmetCSS FormatCSScombjsFormatAutoFileNameAutoprefixerDoc BlockrSublimeLinterSublimeLinter-jshintSublimeLinter-csslintColor HighlighterBracketHighlighter 5、配置nodejs方法1(1)下载sublime Text的nodejs插件(2)下载后解压:直接改名为nodejs 放到 Preferences–&gt;浏览程序包Browse Packages所在的文件夹(3)修改配置:打开Nodejs文件夹，找到文件“Nodejs.sublime-build”， 拖拽到sublime，显示：12345678910111213141516171819&#123; \"cmd\": [\"node\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.js\", \"shell\":true, \"encoding\": \"cp1252\", \"windows\": &#123; \"cmd\": [\"taskkill /F /IM node.exe &amp; node\", \"$file\"] &#125;, \"linux\": &#123; \"cmd\": [\"killall node; node\", \"$file\"] &#125;, \"osx\": &#123; \"cmd\": [\"killall node; node $file\"] &#125;&#125; (4)修改为：1234567891011121314151617181920&#123; \"cmd\": [\"node\", \"$file\"], \"file_regex\": \"^[ ]*File \\\"(...*?)\\\", line ([0-9]*)\", \"selector\": \"source.js\", \"shell\":true, \"encoding\": \"utf-8\", \"windows\": &#123; \"cmd\": [\"taskkill /F /IM node.exe\", \"\"], \"cmd\": [\"node\", \"$file\"] &#125;, \"linux\": &#123; \"cmd\": [\"killall node; node\", \"$file\"] &#125;, \"osx\": &#123; \"cmd\": [\"killall node; node $file\"] &#125;&#125; (5)完成:随便写一段nodejs代码，ctrl+B运行(6)注意：在手动解压sublime Text插件后，需要在preference-&gt;package settings-&gt;package control的user setting下添加installed packages中的“Nodejs”，不然重启sublime Text 会被删除Nodejs插件。 方法2首先需要先安装nodejs。(1)运行Sublime,菜单上找到Tools —&gt; Build System —&gt; new Build System(2)输入：{ “cmd”: [“node”, “$file”], “file_regex”: “^[ ]File \\”(…?)\\”, line ([0-9]*)”, “selector”: “source.js”, “shell”:true, “encoding”: “utf-8”, “windows”: { “cmd”: [“taskkill /F /IM node.exe”, “”], “cmd”: [“node”, “$file”] }}(3)保存文件为NodeJs.sublime-build(4)菜单上找到Tools —&gt; Build System —&gt;选择 NodeJs(5)安装sublime插件 JavaScript &amp; NodeJs Snippets(6)新建test.js文件，输入 console.log(‘Hello Node.js’); 按快捷键 Ctrl + B 运行，成功输出","tags":[{"name":"sublime","slug":"sublime","permalink":"http://chaoo.oschina.io/tags/sublime/"}]},{"title":"Node.js常用工具(10)","date":"2016-06-29T00:10:03.000Z","path":"2016/06/29/Node.js 常用工具.html","text":"10、Node.js 常用工具util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。 util.inheritsutil.inherits(constructor, superConstructor)//是一个实现对象间原型继承 的函数。JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。在这里我们只介绍util.inherits 的用法，示例如下：12345678910111213141516171819202122var util = require('util');function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello ' + this.name); &#125;;&#125; Base.prototype.showName = function()&#123; console.log(this.name);&#125;;function Sub() &#123; this.name = 'sub';&#125;util.inherits(Sub, Base);var objBase = new Base();objBase.showName();objBase.sayHello();console.log(objBase);var objSub = new Sub();objSub.showName();console.log(objSub); 我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：12345base Hello base &#123; name: &apos;base&apos;, base: 1991, sayHello: [Function] &#125; sub &#123; name: &apos;sub&apos; &#125; 注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出. util.inspectutil.inspect(object,[showHidden],[depth],[colors])//是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。-showHidden//是一个可选参数，如果值为 true，将会输出更多隐藏信息。-depth//表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。-colors//如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。12345678910111213141516171819202122var util = require('util');function Person()&#123; this.name = 'byvoid'; this.toString = function()&#123; return this.name; &#125;;&#125;var obj = new Person();console.log(util.inspect(obj));console.log(util.inspect(obj,true));//运行结果是： Person &#123; name: 'byvoid', toString: [Function] &#125;Person &#123; name: 'byvoid', toString: &#123; [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125; util.isArrayutil.isArray(object)//如果给定的参数 “object” 是一个数组返回true，否则返回false。1234var util = require('util');util.isArray([]);// trueutil.isArray(new Array);// trueutil.isArray(&#123;&#125;);// false util.isRegExputil.isRegExp(object)//如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。1234var util = require('util');util.isRegExp(/some regexp/);// trueutil.isRegExp(new RegExp('another regexp'));// trueutil.isRegExp(&#123;&#125;);// false util.isDateutil.isDate(object)// 如果给定的参数 “object” 是一个日期返回true，否则返回false。1234var util = require('util');util.isDate(new Date());// trueutil.isDate(Date());// false (without 'new' returns a String)util.isDate(&#123;&#125;);// false util.isErrorutil.isError(object)// 如果给定的参数 “object” 是一个错误对象返回true，否则返回false。1234var util = require('util');util.isError(new Error());// trueutil.isError(new TypeError());// trueutil.isError(&#123; name: 'Error', message: 'an error occurred' &#125;);// false","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js 全局对象(9)","date":"2016-06-28T12:42:07.000Z","path":"2016/06/28/Node.js 全局对象.html","text":"9、Node.js 全局对象在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global本身以外）都是 global 对象的属性。 在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。 全局对象与全局变量global 全局对象最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量： -在最外层定义的变量； -全局对象的属性； -隐式定义的变量（未定义直接赋值的变量）。当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。 __filename__filename表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。实例：创建main.js：输出全局变量 __filename 的值1console.log( __filename ); 执行 main.js 文件:12node main.js/web/com/runoob/nodejs/main.js __dirname__dirname 表示当前执行脚本所在的目录。实例：创建main.js：输出全局变量 __dirname 的值1console.log( __dirname ); 执行 main.js 文件:12node main.js/web/com/runoob/nodejs setTimeout(cb, ms)setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout()只执行一次指定函数。返回一个代表定时器的句柄值。实例:创建文件 main.js:12345function printHello()&#123; console.log(\"Hello, World!\");&#125;//两秒后执行以上函数setTimeout(printHello, 2000); //执行 main.js 文件:12node main.jsHello, World! clearTimeout(t)clearTimeout(t) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的计算器。实例:创建文件 main.js:1234567function printHello()&#123; console.log(\"Hello, World!\");&#125;//两秒后执行以上函数var t = setTimeout(printHello, 2000);//清除定时器clearTimeout(t) 执行 main.js 文件:1node main.js setInterval(cb, ms), clearInterval(t)setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。实例:创建文件 main.js:12345function printHello()&#123; console.log(\"Hello, World!\");&#125;//两秒后执行以上函数setInterval(printHello, 2000); 执行 main.js 文件:12node main.jsHello, World! Hello, World! Hello, World …… 以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮. consoleconsole 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。console方法：-console.log([data], [...])//向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。-console.info([data], [...])//P该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。-console.error([data], [...])//输出错误消息的。控制台在出现错误时会显示是红色的叉子。-console.warn([data], [...])//输出警告消息。控制台出现有黄色的惊叹号。-console.dir(obj, [options])//用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。-console.time(label)//输出时间，表示计时开始。-console.timeEnd(label)//结束时间，表示计时结束。-console.trace(message, [...])//当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。-console.assert(value, [message], [...])//用于判断某个表达式或变量是否为真，接手两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 processprocess 是一个全局变量，即 global 对象的属性。它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。 process 对象的一些最常用的成员方法:-exit//当进程准备退出时触发。-beforeExit//当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。-uncaughtException//当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。-Signal 事件//当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。-退出状态码：1,2,3,4,5,6,7,8,9,10,12,&gt;128 Process属性：-stdout//标准输出流。-stderr//标准错误流-stdin//标准输入流。-argv//argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。-execPath//返回执行当前脚本的 Node 二进制文件的绝对路径。-execArgv//返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。-env//返回一个对象，成员为当前 shell 的环境变量-exitCode//进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。-version//Node 的版本，比如v0.10.18。-versions//一个属性，包含了 node 的版本和依赖.-config//一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。-pid//当前进程的进程号。-title//进程名，默认值为”node”，可以自定义该值。-arch//当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。-platform//运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’-mainModule//require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。 方法参考手册:-abort()//这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。-chdir(directory)//改变当前工作进程的目录，如果操作失败抛出异常。-cwd()//返回当前进程的工作目录-exit([code])//使用指定的 code 结束进程。如果忽略，将会使用 code 0。-getgid()//获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-setgid(id)//设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。//注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-getuid()//获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-setuid(id)//设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。//注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-getgroups()//返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-setgroups(groups)//设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-initgroups(user, extra_group)//读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。-kill(pid, [signal])//发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。-memoryUsage()//返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。-nextTick(callback)//一旦当前事件循环结束，调用回到函数。-umask([mask])//设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。-uptime()//返回 Node 已经运行的秒数。-hrtime()//返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js 路由(9)","date":"2016-06-28T10:55:08.000Z","path":"2016/06/28/Node.js 路由.html","text":"8、Node.js 路由我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码。因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。12345678910111213 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)[\"foo\"] | | querystring(string)[\"hello\"] 当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：1234567891011121314var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \"received.\"); response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 现在我们可以来编写路由了，建立一个名为router.js的文件:1234function route(pathname)&#123; console.log(\"About to route a request for \" + pathname);&#125;exports.route = route; 在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来(我们将使用依赖注入的方式较松散地添加路由模块)。首先，我们来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去：123456789101112131415var http = require(\"http\");var url = require(\"url\");function start() &#123; function onRequest(request, response) &#123; var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \"received.\"); route(pathname);//路由函数 response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end(); &#125; http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");&#125;exports.start = start; 同时，我们会相应扩展index.js，使得路由函数可以被注入到服务器中：123var server = require(\"./server\");var router = require(\"./router\");server.start(router.route); 现在启动应用（node index.js），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：1234node index.jsRequest for /foo received.About to route a request for /foo//以上输出已经去掉了比较烦人的`/favicon.ico`请求相关的部分。","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js函数(7)","date":"2016-06-28T07:20:07.000Z","path":"2016/06/28/Node.js函数.html","text":"7、Node.js函数Node.js中函数的使用与Javascript类似:1234567function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里返回的不是 say 的返回值，而是 say 本身！ 这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。 当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。 匿名函数我们可以把一个函数作为变量传递。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：1234function execute(someFunction, value)&#123; someFunction(value);&#125;execute(function(word)&#123;console.log(word)&#125;, \"Hello\"); 我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。 用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。 函数传递是如何让HTTP服务器工作的123456var http = require(\"http\");http.createServer(function(request,response)&#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888);","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js模块系统(6)","date":"2016-06-28T03:32:07.000Z","path":"2016/06/28/Node.js模块系统.html","text":"6、Node.js模块系统Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。实例：12345678910111213141516//hello.jsfunction Hello()&#123; var name; this.setName = function(thyName)&#123; name = thyName; &#125;; this.sayHello = function()&#123; console.log('Hello '+ name); &#125;;&#125;;module.exports = Hello;//main.jsvar Hello = require('./hello');hello = new Hello();hello.setName('BYVoid');hello.sayHello(); 服务端的模块放在哪里我们已经在代码中使用了模块了。像这样：123var http = require(\"http\");...http.createServer(...); Node.js中自带了一个叫做”http”的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。Node.js 的 require方法中的文件查找策略如下：1234567891011121314开始require--&gt; if (在文件模块缓存区中) &#123; 返回exports. &#125; else&#123; if (是原生模块) &#123; if (在原生模块缓存区中) &#123; 返回exports. &#125; else&#123; 加载原生模块--&gt;缓存原生模块--&gt;返回exports. &#125;; &#125; else&#123; 查找文件模块--&gt;根据扩展名载入文件模块--&gt;缓存文件模块--&gt;返回exports. &#125;; &#125;; 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载 */原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(&quot;http&quot;)都不会从这些文件中加载，而是从原生模块中加载。原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载 */当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。require方法接受以下几种参数的传递: http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js Stream流(5)","date":"2016-06-28T01:50:03.000Z","path":"2016/06/28/Node.js Stream流.html","text":"5、Node.js Stream(流)Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。Stream有四种流类型： Readable //可读操作。 Writable //可写操作。 Duplex //可读写操作。 Transform//操作被写入数据，然后读出数据。所有的Stream对象都是EventEmitter的实例。常用事件： data //当有数据可读时触发。 end //没有更多数据可读时触发。 error //在接收和写入过程中发生错误时触发。 finish//所有数据已被写入到底层系统时触发。 从流中读取数据实例创建input.txt文件，内容自定。创建main.js文件：1234567891011121314151617var fs = require(\"fs\");var data = '';//创建可读流var readerStream = fs.createReadStream('input.txt');//设置编码为 utf8。readerStream.setEncoding('UTF8');//处理流事件--&gt;data,end,and errrorreaderStream.on('data',function(chunk)&#123; data += chunk;&#125;);readerStream.on('end',function()&#123; console.log(data);&#125;);readerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); 写入流实例创建main.js文件：12345678910111213141516var fs = require(\"fs\");var data = '我是被写入的数据';//创建一个可以写入的流，写入到output.txt中var writerStream = fs.createWriteStream('output.txt');//使用utf8编码写入数据writerStream.write(data,'UTF8');//标记文件末尾writerStream.end();//处理流事件--&gt;finish, errrorreaderStream.on('finish',function()&#123; console.log(\"写入完成。\");&#125;);readerStream.on('error',function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); #### 管道流实例创建input.txt文件，内容自定。创建main.js文件：12345678var fs = require(\"fs\");//创建一个可读流var readerStream = fs.createReadStream('input.txt');//创建一个可写流var writerStream = fs.createWriteStream('output.txt');//管道读写操作，读取input.txt内容，并写入到output.txt文件中。readerStream.pipe(writerStream);console.log(\"程序执行完毕\"); #### 链式流实例创建compress.js文件：123456789101112var fs = require(\"fs\");var zlib = require('zlib');//压缩input.txt文件为input.txt.gzfs.createReadStream('input.txt').pipe(zlib.createGzip()).pipe(fs.createWriteStream('input.txt.gz'));console.log(\"文件压缩完成。\");//执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。接下来，让我们来解压该文件//创建 decompress.js 文件:var fs = require(\"fs\");var zlib = require('zlib');//解压input.txt.gz文件为input.txtfs.createReadStream('input.txt.gz').pipe(zlib.createGunzip()).pipe(fs.createWriteStream('input.txt'));console.log(\"文件解压完成。\");","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js Buffer缓冲区(4)","date":"2016-06-27T07:54:06.000Z","path":"2016/06/27/Node.js Buffer.html","text":"4、Node.js Buffer(缓冲区)JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 创建Buffer类123var buf = new Buffer(10);//创建长度为10字节的Buffer实例var buf = new Buffer([10, 20, 30, 40, 50]);//通过给定的数组创建Buffer实例var buf = new Buffer(\"www.runoob.com\", \"utf-8\");//通过一个字符串来创建Buffer实例 写入缓冲区1buf.write(string, [offset], [length], [encoding]); 参数： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为0. length - 写入的字节数，默认为buffer.length encoding - 使用的编码。默认‘utf-8’返回值：返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 从缓冲区读取数据1buf.toString([encoding], [start], [end]); 参数： encoding - 使用的编码。默认‘utf-8’. start - 指定开始读取的索引位置，默认为0. end - 结束位置，默认缓冲区末尾。返回值：解码缓冲区数据并使用指定的编码返回字符串。 将 Buffer 转换为 JSON 对象1buf.toJSON(); 返回值：返回JSON对象。 缓冲区合并1Buffer.concat(list, [totalLength]); 参数： list - 用于合并的Buffer对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。返回值：返回一个多个成员合并的新 Buffer 对象。 缓冲区比较1buf.compare(otherBuffer); 返回值：返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 拷贝缓冲区1buf.copy(targetBuffer,[targetStart],[sourceStart],[sourceEnd]); 参数： targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length返回值：无。 缓冲区剪裁1buf.slice([start],[end]); 参数： start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length返回值：返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 缓冲区长度1buf.length; 返回值：返回Buffer对象所占据的内存长度。 Node.js Buffer 模块常用的方法 new Buffer(size);//分配一个新的 size 大小单位为8位字节的 buffer。 注意, size 必须小于 kMaxLength，否则，将会抛出异常 RangeError。 new Buffer(buffer);//拷贝参数 buffer 的数据到 Buffer 实例。 new Buffer(str, [encoding]);//分配一个新的 buffer ，其中包含着传入的 str 字符串。 encoding 编码方式默认为 ‘utf8’。 buf.length;//返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。 buf.toString([encoding], [start], [end]);//根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。 buf.toJSON();//将 Buffer 实例转换为 JSON 对象。 buf[index];//获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。 buf.equals(otherBuffer);//比较两个缓冲区是否相等，如果是返回 true，否则返回 false。 buf.compare(otherBuffer);//比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd]);//buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。 buf.slice([start, [end]]);//剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。 buf.fill(value, [offset], [end]);//使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。 buf.write(string, [offset], [length], [encoding]);//根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。 buf.writeUIntLE(value, offset, byteLength, [noAssert]);//将value 写入到 buffer 里， 它由offset 和 byteLength 决定。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。/ 下同。/ buf.writeUIntBE(value, offset, byteLength, [noAssert]); buf.writeUInt8(value, offset, [noAssert]); buf.writeUInt16LE(value, offset, [noAssert]); buf.writeUInt16BE(value, offset, [noAssert]); buf.writeUInt32LE(value, offset, [noAssert]); buf.writeUInt32BE(value, offset, [noAssert]); buf.writeIntLE(value, offset, byteLength, [noAssert]); buf.writeIntBE(value, offset, byteLength, [noAssert]); buf.writeInt8(value, offset, [noAssert]); buf.writeInt16LE(value, offset, [noAssert]); buf.writeInt16BE(value, offset, [noAssert]); buf.writeInt32LE(value, offset, [noAssert]); buf.writeInt32BE(value, offset, [noAssert]); buf.writeFloatLE(value, offset, [noAssert]); buf.writeFloatBE(value, offset, [noAssert]); buf.writeDoubleLE(value, offset, [noAssert]); buf.writeDoubleBE(value, offset, [noAssert]); buf.readUInt8(offset, [noAssert]);//读取。 buf.readUInt16LE(offset, [noAssert]); buf.readUInt16BE(offset, [noAssert]); buf.readUInt32LE(offset, [noAssert]); buf.readUInt32BE(offset, [noAssert]); buf.readUIntLE(offset, byteLength, [noAssert]); buf.readUIntBE(offset, byteLength, [noAssert]); buf.readIntLE(offset, byteLength, [noAssert]); buf.readIntBE(offset, byteLength, [noAssert]); buf.readInt8(offset, [noAssert]); buf.readInt16LE(offset, [noAssert]); buf.readInt16BE(offset, [noAssert]); buf.readInt32LE(offset, [noAssert]); buf.readInt32BE(offset, [noAssert]); buf.readFloatLE(offset, [noAssert]); buf.readFloatBE(offset, [noAssert]); buf.readDoubleLE(offset, [noAssert]); buf.readDoubleBE(offset, [noAssert]);","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js EventEmitter类(3)","date":"2016-06-27T05:02:05.000Z","path":"2016/06/27/Node.js EventEmitter类.html","text":"3、Node.js EventEmitter 类Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。Node.js里面的许多对象都会分发事件：一个net.Server 对象会在每次有新连接时分发一个事件， 一个fs.readStream对象会在文件被打开的时候发出一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。你可以通过require(&quot;events&quot;);来访问该模块:123var events = require('events');//创建eventEmitter对象var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 &#39;error&#39; 事件。当添加新的监听器时，&#39;newListener&#39; 事件会触发，当监听器被移除时，&#39;removeListener&#39; 事件被触发。实例：123456789//event.js 文件var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event',function() &#123; console.log('some_event事件触发')；&#125;);setTimeout(function() &#123; event.emit('some_event');&#125;, 1000); 运行这段代码，1 秒后控制台输出了 some_event 事件触发。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器执行结果如下:12node event.js some_event 事件触发 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。12345678910//event.js 文件var events = require('events')var emitter = new events.EventEmitter(); emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener1', arg1, arg2); &#125;); emitter.on('someEvent', function(arg1, arg2) &#123; console.log('listener2', arg1, arg2); &#125;); emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。执行结果如下:123node event.js listener1 arg1 参数 arg2 参数listener2 arg1 参数 arg2 参数 方法1、addListener(event, listener)//为指定事件添加一个监听器到监听数组的尾部2、on(event, listener)//为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数:123server.on('connection',function (stream) &#123; console.log('someone connected!');&#125;); 3、once(event, listener)//为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。123server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); 4、removeListener(event, listener)//移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。123456var callback = function(stream) &#123; console.log('someone connected!');&#125;;server.on('connection', callback);// ...server.removeListener('connection', callback); 5、removeAllListeners([event])//移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。6、setMaxListeners(n)//默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。7、listeners(event)//返回指定事件的监听器数组8、emit(event, [arg1], [arg2], [...])//按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法1、listenerCount(emitter, event)//返回指定事件的监听器数量。 事件1、newListener //该事件再添加新监听器时被触发 event - 字符串，事件名称 listener - 处理事件函数2、removeListener//从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。 event - 字符串，事件名称 listener - 处理事件函数实例：通过 connection（连接）事件演示了 EventEmitter 类的应用123456789101112131415161718192021222324252627// 创建main.js文件：var events = require('events');var eventEmitter = new events.EventEmitter();// 监听器 #1var listener1 = function listener1() &#123; console.log('监听器 listener1 执行。');&#125;// 监听器 #2var listener2 = function listener2() &#123; console.log('监听器 listener2 执行。');&#125;// 绑定connection事件，处理函数为listener1eventEmitter.addListener('connection',listener1);// 绑定connection事件，处理函数为listener2eventEmitter.on('connection',listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \"个监听器连接事件\");//处理connection事件eventEmitter.emit('connection');//移除监绑定的listener1函数eventEmitter.removeListener('connection',listener1);console.log(\"listener1不再受监听。\");//触发连接事件eventEmitter.emit('connection');eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \"个监听器连接事件\");console.log(\"程序执行完毕。\"); //执行结果：12345678node main.js2个监听器连接事件监听器 listener1 执行。监听器 listener2 执行。listener1不再受监听。监听器 listener2 执行。1个监听器连接事件程序执行完毕。 error事件EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter的子类。原因有两点： -首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发射应该是一个对象的方法。 -其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"NodeJs学习笔记(2)","date":"2016-06-27T04:55:00.000Z","path":"2016/06/27/Node.js 事件循环.html","text":"2、Node.js 事件循环Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：12345678910111213141516171819//引入events模块var events = require('events');//创建eventEmitter对象var eventEmitter = new events.EventEmitter();//创建时间处理程序var connectHander = function connected() &#123; console.log('连接成功。'); //触发data_received事件 eventEmitter.emit('data_received');&#125;//绑定connection事件处理程序eventEmitter.on('connection', connectHandler);//使用匿名函数绑定data_received事件eventEmitter.on('data_received', function()&#123; console.log('数据接收成功。');&#125;);//触发connection事件eventEmitter.emit('connection');console.log(\"程序执行完毕。\"); node应用程序如何工作创建一个input.txt文件，内容如下：1Hello World; 创建main.js文件，代码如下：12345678var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) &#123; if (err) &#123; console.log(err.stack); &#125; console.log(data.toString());&#125;);console.log(\"程序执行完毕\"); 以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。执行以上代码，执行结果如下：1Hello World; 接下来我们删除 input.txt 文件，执行结果如下所示：12程序执行完毕Error: ENOENT, open &apos;input.txt&apos;","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Node.js创建第一个应用(1)","date":"2016-06-27T03:55:07.000Z","path":"2016/06/27/Node.js创建第一个应用.html","text":"1、Node.js创建第一个应用1.1、创建服务器使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。实例如下，在项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：1234567891011var http = require(\"http\");//引入require模块http.createServer(function(require, response)&#123; //发送 HTTP 头部 //HTTP 状态值：200：OK //内容类型：text/plain response.writeHead(200, &#123;'Content-Type':'text/plain'&#125;); //发送响应数据：“Hello World” response.end('Hello World\\n');&#125;).listen(8888);//终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 使用 node 命令执行以上的代码：12node server.jsServer running at http://127.0.0.1:8888/ 接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 “Hello World” 的网页。","tags":[{"name":"node","slug":"node","permalink":"http://chaoo.oschina.io/tags/node/"}]},{"title":"Hexo博客优化——站内搜索、版权、IE8兼容","date":"2016-05-25T02:03:15.000Z","path":"2016/05/25/Hexo博客优化--站内搜索、版权、IE8兼容.html","text":"1.添加Hexo的swiftype站内搜索先去swiftype官网注册一个账号,然后根据指引建立好自己网站对应的索引。步骤： Create an engine—&gt; Create a search engine &gt;(standard web crawler)—&gt; WEBSITE URL下填写你的网站地址：如：http://chaooo.github.io—&gt; ENGINE NAME自己取一个名字：如：chaooo—&gt; 然后他开始抓取你网站的数据。—&gt; 完成后，可以点击Content去看看抓了些什么数据，然后可以自己删除不想要的数据。（可选）—&gt; 点击Install Search复制里面的代码： 然后在themes\\landscape\\layout\\_partial\\after-footer.ejs在最后加上刚复制的代码：12345678&lt;script type=\"text/javascript\"&gt; (function(w,d,t,u,n,s,e)&#123;w['SwiftypeObject']=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st'); _st('install','Hvy4-e-Ew4x8PR6Let84','2.0.0');&lt;/script&gt; 在themes\\landscape\\_config.yml末尾添加如下代码：12swift_search: enable: true 然后到themes\\landscape\\layout\\_partial\\header.ejs中找到：&lt;div id=&quot;search-form-wrap&quot;&gt;...&lt;/div&gt;刪除里面的內容，插入如下代码：123456&lt;div id=\"search-form-wrap\"&gt; &lt;form action=\"\" method=\"get\" accept-charset=\"UTF-8\" class=\"search-form\"&gt; &lt;input autocapitalize=\"off\" autocorrect=\"off\" autocomplete=\"off\" name=\"q\" results=\"0\" id=\"search\" maxlength=\"20\" placeholder=\"Search\" style=\"border:none;background:none;width:161px;height:30px;line-height:30px;padding:0px 11px 0px 28px;\" class=\"st-default-search-input search-form-input\" type=\"text\"&gt; &lt;button type=\"submit\" class=\"search-form-submit\"&gt;&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 然后到themes\\landscape\\source\\css\\_partial\\header.styl找到#search-form-wrap对其样式微调，大概在118行，修改后的值：1234567891011121314151617#search-form-wrap position: absolute top: 14px width: 200px height: 30px right: 35px opacity: 0 visibility: hidden transition: 0.2s ease-out transform: scale(.5) translate(94px, 0) &amp;.on opacity: 1 visibility: visible transform: scale(1) translate(0, 0) @media mq-mobile width: 80% right: -80% 然后到themes\\landscape\\source\\css\\_partial\\header.styl找到.nav-icon，大概在81行，在其后面添加(z-index: 1)：1234567891011.nav-icon @extend $nav-link font-family: font-icon text-align: center font-size: font-size width: font-size height: font-size padding: 20px 15px position: relative cursor: pointer z-index: 1 注意：在使用中我发现swiftype搜索框在IE和火狐浏览器根本不能唤醒搜狗输入法的中文输入，必须要先输入一个英文字母才能输入中文，我在swiftype官网测试的swiftype搜索框也一样。（我分别测试了Chrome–v49，Firefox Developer Edition–v47，IE11/IE10/IE9,结果只有Chrome能唤起搜狗中文。） 2. 页尾版权信息修改在themes\\landscape\\layout\\_partial\\footer.ejs中，第6行开始，修改其为居中对齐，添加网站地图、订阅、联系博主链接：12345&lt;div id=\"footer-info\" class=\"inner\" style=\"text-align:center;\"&gt; Copyright &amp;copy; &lt;%= date(new Date(), 'YYYY') %&gt; &lt;%= config.author || config.title %&gt;&lt;br&gt; &lt;%= __('powered_by') %&gt; &lt;a href=\"http://hexo.io/\" target=\"_blank\"&gt;Hexo&lt;/a&gt;&lt;br&gt; &lt;a href=\"/baidusitemap.xml\"&gt;网站地图&lt;/a&gt;&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp;&lt;a href=\"/atom.xml\"&gt;订阅本站&lt;/a&gt;&amp;nbsp; &amp;nbsp;|&amp;nbsp; &amp;nbsp;&lt;a href=\"mailto:zhenggchaoo@gmail.com\" target=\"_blank\"&gt;联系博主&lt;/a&gt; &lt;/div&gt; 3. 对于低版本IE布局微调3.1 加入低版本IE浏览器提醒Hexo主题大多都只完美支持IE9及以上版本的浏览器，低版本IE会影响网站体验，所以要提示浏览者及时更换现代浏览器，在themes\\landscape\\layout\\_partial\\header.ejs中找到&lt;div id=&quot;header-outer&quot; class=&quot;outer&quot;&gt;&lt;/div&gt;以其为父元素添加：1234567891011121314151617&lt;!--[if lt IE 9]&gt; &lt;style&gt; .hid-ltIE9&#123;position:absolute;bottom:0;z-index:999;width:100%;line-height:46px;color:#7b1a00;font-size:14px;text-align:center;background:#fff3c8;border-radius:4px;border:1px solid #;text-shadow:0 1px #fff;-webkit-box-shadow:0 -1px 4px #ccc inset;box-shadow:0 -1px 4px #ccc inset;border:1px solid #ccc;&#125; .hid-ltIE9 a&#123;color:#258fb8;text-decoration:none;&#125; .hid-ltIE9 a:hover&#123;text-decoration:underline;&#125; .hid-exclamation-triangle,.hid-chrome,.hid-firefox&#123;font:normal normal normal 14px/1 FontAwesome;display:inline-block;width:30px;height:30px;font-size:14px;text-align:center;&#125; .hid-exclamation-triangle:before&#123;content:\"\\f071\";&#125; .hid-chrome:before&#123;content:\"\\f268\";&#125; .hid-firefox:before&#123;content:\"\\f269\";&#125; &lt;/style&gt; &lt;p class=\"hid-ltIE9\"&gt; &lt;i class=\"hid-exclamation-triangle\" aria-hidden=\"true\"&gt;&lt;/i&gt;重要提示：您当前使用的浏览器版本过低，可能存在安全风险！想要更好的体验，建议升级浏览器： &lt;a href=\"https://www.google.cn/intl/zh-CN/chrome/browser/desktop/\" title=\"谷歌Chrome浏览器\"&gt;&lt;i class=\"hid-chrome\" aria-hidden=\"true\"&gt;&lt;/i&gt; Chrome&lt;/a&gt;、 &lt;a href=\"http://www.firefox.com.cn/download/\"title=\"火狐Firefox浏览器\"&gt;&lt;i class=\"hid-firefox\" aria-hidden=\"true\"&gt;&lt;/i&gt;Firefox&lt;/a&gt; &lt;/p&gt;&lt;![endif]--&gt; 这样，现代浏览器都不会解析这段代码，直到IE8及其版本的浏览器才会显示。 3.2 (对于旧IE)header与footer布局微调发现博客在IE8及其版本的浏览器显示很多样式都乱掉了，特别是头部header，毕竟还有不少人用的低版本浏览器，平常工作中也要求做到兼容到IE8，所以这里只做稍微调。在themes\\landscape\\layout\\_partial\\header.ejs中，把&lt;header id=&quot;header&quot;&gt;&lt;/div&gt;用下面的代码包起来：12345&lt;!--[if lt IE 9]&gt;&lt;div id=\"header\"&gt;&lt;![endif]--&gt;&lt;header id=\"header\"&gt; //....其他代码&lt;/header&gt;&lt;!--[if lt IE 9]&gt;&lt;/div&gt;&lt;![endif]--&gt; 在themes\\landscape\\layout\\_partial\\footer.ejs中，把&lt;header id=&quot;footer&quot;&gt;&lt;/div&gt;用下面的代码包起来：12345&lt;!--[if lt IE 9]&gt;&lt;div id=\"footer\"&gt;&lt;![endif]--&gt;&lt;footer id=\"footer\"&gt; //....其他代码&lt;/footer&gt;&lt;!--[if lt IE 9]&gt;&lt;/div&gt;&lt;![endif]--&gt; 虽然这样调整并不高明，但能使其在IE8下显示效果大体上还能接受。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaoo.oschina.io/tags/hexo/"}]},{"title":"Hexo博客优化——库、字体、收录、统计","date":"2016-05-24T03:22:56.000Z","path":"2016/05/24/Hexo博客优化--库、字体、收录、统计.html","text":"1. jQuery 库的优化landscape默认是使用Google jQuery 库，但在国内速度不是很理想，这里把它换成新浪的，在themes\\landscape\\layout\\_partial\\after-footer.ejs17行：1&lt;script src=\"//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js\"&gt;&lt;/script&gt; 替换为如下代码：12345678&lt;script src=\"http://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;//&lt;![CDATA[if (typeof jQuery == 'undefined') &#123; document.write(unescape(\"%3Cscript src='/js/jquery-2.0.3.min.js' type='text/javascript'%3E%3C/script%3E\"));&#125;// ]]&gt;&lt;/script&gt; 这里不但将 Google 的 jQuery 替换成了 SAE 的，随后还进行了一个判断，如果获取新浪的 jQuery 失败，则使用本网站自己的 jQuery。为了让这段代码有效，我们要去 jQuery 官方下载合适版本的 jQuery 并将其放到 themes/landscape/source/js/目录下，命名为 jquery-2.0.3.min.js。还有一点需要特别注意，那就是 jQuery 这个文件在 hexo 生成博客时会被解析，因此一定要将 jQuery 文件开头处的 //@ sourceMappingURL=jquery-2.0.3.min.map 这一行代码删去，否则会导致博客无法生成。 2. 字体优化2.1跨平台字体优化为了能在各个平台上都显示令人满意的字体，我们要修改CSS文件中的字体设置，列出多个备选的字体，操作系统会依次尝试，使用系统中已安装的字体。我们要修改的是themes/landscape/source/css/_variables.styl这一文件，将其中第22行:1font-sans = \"Helvetica Neue\", Helvetica, Arial, sans-serif 改成如下内容：1font-sans = Tahoma, \"Helvetica Neue\", Helvetica, \"Hiragino Sans GB\", \"Microsoft YaHei Light\", \"Microsoft YaHei\", \"Source Han Sans CN\", \"WenQuanYi Micro Hei\", Arial, sans-serif 其中海维提卡（Helvetica）、Arial是英文字体，前者一般存在于苹果电脑和移动设备上，后者一般存在于Windows系统中。冬青黑体（Hiragino Sans GB）、思源黑体（Source Han Sans CN）、文泉驿米黑（WenQuanYi Micro Hei）是中文字体，冬青黑体从OS X 10.6开始集成在苹果系统中，文泉驿米黑在Linux的各大发行版中均较为常见，而思源黑体是近期Google和Adobe合作推出的一款开源字体，很多电脑上也安装了这一字体。这样一来，在绝大部分操作系统中就可以显示美观的字体了。 2.2代码等宽字体优化Hexo默认的等宽字体是Google的Source Code Pro，这里把它换成360的，在themes/landscape/layout\\_partial\\head.ejs 第31行:1&lt;link href=\"//fonts.googleapis.com/css?family=Source+Code+Pro\" rel=\"stylesheet\" type=\"text/css\"&gt; 改成如下内容：1&lt;link href=\"http://fonts.useso.com/css?family=Source+Code+Pro\" rel=\"stylesheet\" type=\"text/css\"&gt; 3. hexo提交搜索引擎（百度+谷歌）3.1 确认博客是否被收录在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有，用你的域名替代我的http:chaooo.github.io1site:chaooo.github.io 3.2 验证网站两个搜索引擎入口：Google搜索引擎提交入口、百度搜索引擎入口。不管谷歌还是百度都要先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的source/下面 。然后部署到服务器,输入地址：http://chaooo.github.io/google4cc3eef6ff5975bf.html和http://chaooo.github.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照谷歌或百度的引导步骤就好)。注意：若出现验证失败，则是因为hexo编译文件时，会给下载的HTML文件中添加其他的内容，导致验证失败。则需要在Github里手动修改验证HTML文件，或者不编译。我的做法是，删除根目录source/下面刚拷贝的两个文件，和编译后生成的public/下的两个同名文件（若细心会注意到source/和public/下的两个同名文件大小不一样）。然后重新执行：1hexo generate -d 现在重新验证就通过了。 3.3 安装 RSS(订阅) 和 sitemap(网站地图) 插件123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 修改 hexo_config.yml 站点配置，添加：1234567891011121314151617#ExtensionsPlugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 部署后,访问 chaooo.github.io/sitemap.xml 和 chaooo.github.io/baidusitemap.xml,就能看到有内容且第一行为:该 XML 文件并未包含任何关联的样式信息。文档树显示如下。,就说明成功了。RSS 也差不多，访问 chaooo.github.io/atom.xml ，能看到订阅信息。注意：把chaooo.github.io换成你自己的个人域名（订阅是顺带安装的，也可以后在安装）。 3.4 让谷歌收录我们的博客谷歌操作比较简单，就是向Google站长工具提交sitemap。登录Google账号，添加了站点验证通过后，选择站点，之后在抓取——站点地图中就能看到添加/测试站点地图,然后输入sitemap.xml点击提交。 3.5 让百度收录我们的博客正常情况，是要等百度爬虫来爬到你的网站，才会被收录。但是github屏蔽了百度爬虫目前，所以我们要主动出击，我们自己把网站提交给百度。这就要使用到百度站长平台。1.进入站点管理，找到网页抓取——链接提交——详情点进去。一般主动提交比手动提交效果好，这里介绍主动提交的两种简单的方法 3.5.1 sitemap提交直接点击sitemap填写数据文件地址：chaooo.github.io/baidusitemap.xml,输入验证码提交。 3.5.2 自动推送自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout\\_partial\\after_footer.ejs中的最下面就行。代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 百度链接提交主动推送后不收录的原因 4. 开启谷歌统计(google analysis)先到google analysis注册服务，注册时，需要正确填写 网站的URL。注册成功后，会得到一个跟踪ID，以及一段跟踪代码。12345678910// 跟踪 ID// UA-58387143-1&lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()&#123; (i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) &#125;)(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-58387143-1', 'auto'); ga('send', 'pageview');&lt;/script&gt; 到\\themes\\landscape\\layout\\_config.yml中,将google analysis打开：123google_analytics: enable: true id: UA-58387143-1 #刚注册获取的ID 如果设置不起作用，检查在themes\\pacman\\layout\\_partial\\下有没有google_analytics.ejs ，有的话就在\\themes\\landscape\\layout\\_partial\\head.ejs的&lt;/head&gt;之前，添加下面代码试试：1&lt;%- partial('google_analytics') %&gt; 若themes\\pacman\\layout\\_partial\\不存在google_analytics.ejs 文件，就手动创建：123456789101112&lt;% if (theme.google_analytics)&#123; %&gt;&lt;!-- Google Analytics --&gt;&lt;script type=\"text/javascript\"&gt;(function(i,s,o,g,r,a,m)&#123;i['GoogleAnalyticsObject']=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)&#125;)(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', '&lt;%= theme.google_analytics %&gt;', 'auto');ga('send', 'pageview');&lt;/script&gt;&lt;!-- End Google Analytics --&gt;&lt;% &#125; %&gt; 最笨的方法就是删除google_analytics.ejs和刚在_config.yml配置google analysis的几行代码，直接从注册来的代码拷贝到\\themes\\landscape\\layout\\_partial\\head.ejs的&lt;/head&gt;之前。 5. 文章永久链接默认文章链结是以: http://chaooo.github.io/2016/05/24/文章标题/ 的格式，末尾没有.html结尾，有点动态页面的感觉，好像对搜索引擎不太友好，于是可以修改根目录下的 _config.yml 文件里:1permalink: :year/:month/:day/:title/ 改为：1permalink: :year/:month/:day/:title.html 最后浏览器访问就是http://chaooo.github.io/2016/05/24/文章标题.html 的格式了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaoo.oschina.io/tags/hexo/"}]},{"title":"Hexo博客优化——主题、分享、评论、微博秀","date":"2016-05-23T06:30:13.000Z","path":"2016/05/23/Hexo博客优化--主题、分享、评论、微博秀.html","text":"继上一篇Hexo3.2+GitHub搭建静态博客。 1.主题Hexo提供了很多主题，具体可参见Themes|Hexo，这里我选择默认主题landscape(此主题默认已安装)。 1.1安装主题将Git Shell切换到根目录，执行下列命令，将主题下载到themes/spfk目录下：1$ git clone https://github.com/hexojs/hexo-theme-landscape.git themes/landscape 获取landscape主题的最新版本：12$ cd themes/landscape$ git pull 修改在根目录下_config.yml 配置：1theme: landscape 2.修改添加分享链接2.1原生分享的修改在themes\\landscape\\source\\js\\script.js中，57行 &lt;div class=&quot;article-share-links&quot;&gt;下面的四个链接就是 Facebook 等社交网站的分享链接。将其替换或添加如下代码，即可实现分享到国内社交网站：1234'&lt;a href=\"http://service.weibo.com/share/share.php?&amp;title=好东西就要一起分享&amp;language=zh_cn&amp;url=' + encodedUrl + '\" class=\"article-share-sina\" target=\"_blank\" title=\"微博\"&gt;&lt;/a&gt;','&lt;a href=\"http://share.renren.com/share/buttonshare.do?link=' + encodedUrl + '\" class=\"article-share-renren\" target=\"_blank\" title=\"人人\"&gt;&lt;/a&gt;','&lt;a href=\"http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=' + encodedUrl + '\" class=\"article-share-qq\" target=\"_blank\" title=\"QQ空间\"&gt;&lt;/a&gt;','&lt;a href=\"http://qr.liantu.com/api.php?text=' + encodedUrl + '\" class=\"article-share-wechat\" target=\"_blank\" title=\"微信\"&gt;&lt;/a&gt;', 同时，还需要替换图标。本主题使用 Font Awesome 来显示图标，但内置的 Font Awesome 版本较旧，无法显示 QQ、微信等图标，所以，需要下载最新版 Font Awesome，替换掉 themes\\landscape\\source\\css\\fonts中相关文件，并在themes\\landscape\\source\\css\\_variables.styl中27行的 font-icon-version 修改为最新的 Font Awesome 版本号。 然后，在 themes\\landscape\\source\\css\\_partial\\article.styl 中，找到四段以 .article-share-***开头的代码（273行起），添加如下内容：12345678910111213141516171819202122232425262728293031.article-share-sina @extend $article-share-link &amp;:before content: \"\\f18a\" &amp;:hover background: color-sina text-shadow: 0 1px darken(color-sina, 20%).article-share-qq @extend $article-share-link &amp;:before content: \"\\f1d6\" &amp;:hover background: color-qq text-shadow: 0 1px darken(color-qq, 20%).article-share-renren @extend $article-share-link &amp;:before content: \"\\f18b\" &amp;:hover background: color-renren text-shadow: 0 1px darken(color-renren, 20%).article-share-wechat @extend $article-share-link &amp;:before content: \"\\f1d7\" &amp;:hover background: color-wechat text-shadow: 0 1px darken(color-wechat, 20%) 最后，找到 themes\\landscape\\source\\css\\_variables.styl 中 Colors 部分（16行），最后四行分别为社交网站图标的背景色，可根据这些网站的主题色修改。1234color-sina = #ff8140color-qq = #ffcc33color-renren = #227dc5color-wechat = #44b549 2.2加入百度分享首先在_config.yml中增加bdshare_shortname: 你站点的short_name，这里的short_name也就是你的二级域名。1bdshare_shortname: http://chaooo.github.io/ 在百度分享获取代码后，代码可分为两部分。在themes\\landscape\\layout\\_partial\\article.ejs中第26行插入第一段代码并添加判断条件，若当前页为文章展开页则显示百度分享框，若是缩略则采用原生分享链接，避免百度分享框获取的 URL 错误：12345678&lt;% if ((page.layout == 'post'|| page.layout == 'page'))&#123; %&gt;&lt;div class=\"bdsharebuttonbox\"&gt;&lt;span style=\"float:left;line-height:16px;height:16px;margin: 6px 6px 6px 0;\"&gt;分享到：&lt;/span&gt;&lt;a title=\"分享到新浪微博\" href=\"#\" class=\"bds_tsina\" data-cmd=\"tsina\"&gt;&lt;/a&gt;&lt;a title=\"分享到QQ空间\" href=\"#\" class=\"bds_qzone\" data-cmd=\"qzone\"&gt;&lt;/a&gt;&lt;a title=\"分享到微信\" href=\"#\" class=\"bds_weixin\" data-cmd=\"weixin\"&gt;&lt;/a&gt;&lt;a title=\"分享到人人网\" href=\"#\" class=\"bds_renren\" data-cmd=\"renren\"&gt;&lt;/a&gt;&lt;a title=\"分享到Facebook\" href=\"#\" class=\"bds_fbook\" data-cmd=\"fbook\"&gt;&lt;/a&gt;&lt;a title=\"分享到一键分享\" href=\"#\" class=\"bds_mshare\" data-cmd=\"mshare\"&gt;&lt;/a&gt;&lt;a href=\"#\" class=\"bds_more\" data-cmd=\"more\"&gt;&lt;/a&gt;&lt;/div&gt;&lt;% &#125; else &#123; %&gt;&lt;a data-url=\"&lt;%- post.permalink %&gt;\" data-id=\"&lt;%= post._id %&gt;\" class=\"article-share-link\"&gt;&lt;%= __('share') %&gt;&lt;/a&gt;&lt;% &#125; %&gt;&lt;!-- Baidu Share Start --&gt;&lt;script&gt;window._bd_share_config=&#123;\"common\":&#123;\"bdSnsKey\":&#123;&#125;,\"bdText\":\"好东西就要一起分享~\",\"bdMini\":\"2\",\"bdMiniList\":[\"mshare\",\"qzone\",\"tsina\",\"weixin\",\"sqq\",\"douban\",\"tqq\",\"renren\",\"kaixin001\",\"tqf\",\"linkedin\",\"ty\",\"fbook\",\"twi\",\"copy\",\"print\"],\"bdPic\":\"\",\"bdStyle\":\"1\",\"bdSize\":\"16\"&#125;,\"share\":&#123;&#125;,\"image\":&#123;\"viewList\":[\"mshare\",\"weixin\",\"qzone\",\"tsina\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"&#125;,\"selectShare\":&#123;\"bdContainerClass\":null,\"bdSelectMiniList\":[\"mshare\",\"weixin\",\"qzone\",\"tsina\"]&#125;&#125;;with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];&lt;/script&gt;&lt;!-- Baidu Share End --&gt; 3.加入多说评论首先在_config.yml中增加duoshuo_shortname: 你站点的short_name，这里的short_name也就是你的二级域名。1duoshuo_shortname: http://chaooo.github.io/ 如果使用的是默认的landscape主题只需要修改themes\\landscape\\layout\\_partial\\article.ejs中的disqus评论：1234567&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt; &lt;section id=\"comments\"&gt; &lt;div id=\"disqus_thread\"&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"//disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% &#125; %&gt; 改为多说评论：1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;&lt;section id=\"comments\"&gt;&lt;!-- 多说评论框 start --&gt; &lt;div class=\"ds-thread\" data-thread-key=\"&lt;%= post.path %&gt;\" data-title=\"&lt;%= post.title %&gt;\" data-url=\"&lt;%= post.url %&gt;\"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=\"text/javascript\"&gt;var duoshuoQuery = &#123;short_name:\"chaooo\"&#125;; (function() &#123; var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt;&lt;/section&gt;&lt;% &#125; %&gt; 如果是其他主题，也只需要修改主题\\layout_partial\\comment.ejs注意多说的Thread Key一定不要改变，Thread Key相当于是识别码；如果改变了的话，评论清空。 4. 侧栏微博秀登录新浪微博开放平台来获取微博秀的代码，将其样式调整与主题一致，关掉各种边框和标题栏。然后新建themes/landscape/layout/_widget/weibo.ejs这个文件，将刚刚获取到的代码添加到这个文件中。最后编辑themes/landscape/_config.yml，在widgets:标签后面的适当位置添加- weibo。这样微博秀应该就可以显示在你的博客上了。123456&lt;div class=\"widget-wrap\"&gt; &lt;h3 class=\"widget-title\"&gt;微博&lt;/h3&gt; &lt;div class=\"widget\" style=\"padding: 0\"&gt; &lt;iframe width=\"100%\" height=\"400\" class=\"share_self\" frameborder=\"0\" scrolling=\"no\" src=\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=2&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,dddddd,555555,837f86,cccccc&amp;dpc=1\"&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt; 其中，&lt;iframe...&gt;&lt;/iframe&gt;为获取微博秀的代码。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaoo.oschina.io/tags/hexo/"}]},{"title":"Hexo3.2+GitHub搭建静态博客","date":"2016-05-23T03:16:51.000Z","path":"2016/05/23/Hexo3-2-github搭建静态博客.html","text":"开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：chaooo.github.io，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：12$ git config --global user.name \"username\"$ git config --global user.email \"email@example.com\" 3.本地Git与GitHub建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好：1$ ssh-keygen -t rsa -C \"emailt@example.com\" 然后键入以下指令：12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：1$ ssh-agent bash 再重新输入指令：1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：1$ clip &lt; ~/.ssh/id_rsa.pub 在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令：1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;12$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git$ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹1$ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装:1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令：123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：chaooo.github.io/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：123To https://github.com/chaooo/chaooo.github.io.git 7f3b50a..128a10d HEAD -&gt; masterINFO Deploy done: git 当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。1$ hexo new [layout] \"文章标题\" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout， 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。123$ git add .$ git commit -m \"...\"$ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。1$ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库1$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 小Tips:hexo 命令1234567891011121314hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaoo.oschina.io/tags/hexo/"}]},{"title":"Hello World","date":"2015-12-31T15:59:59.000Z","path":"2015/12/31/hello-world.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://chaoo.oschina.io/tags/hexo/"}]}]